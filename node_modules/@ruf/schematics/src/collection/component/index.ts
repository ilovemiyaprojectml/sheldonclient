import { Schema } from './schema';
import { strings } from '@angular-devkit/core';
import { getWorkspace } from '@schematics/angular/utility/config';
import { parseName } from '@schematics/angular/utility/parse-name';
import { EOL } from 'os';
import { Tree, Rule, SchematicsException, SchematicContext, externalSchematic, chain, apply, url, template, move, branchAndMerge, mergeWith } from '@angular-devkit/schematics';

/*
Invocation with module value. The module has to exist.
$ ng g c mymod/mycomp --project app2 -m mymod

Invocation with module value in a app/lib inside a directory. The module has to exist.
$ ng g c mymod/mycomp --project mybu-app1 -m mymod
*/

interface NormalizedSchema extends Schema {
  // for invocation with --directory (such as ng g app app1 --directory mybu), it will be apps/mybu/app1
  // for invocation without --directory, it will be apps/app1
  path: string; // path into the lib or app where the component will be generated, for example - /libs/mybu/lib1/src/lib
  // for invocation like ng g app app1 --directory mybu, appProjectName will be 'mybu-app1' and that's the project name in angular.json
  isApplication: boolean; // 'app' or 'lib'
  sourceRoot: string; // project source root
  baseName: string; // name of the component, user may pass in something like 'mymod/UserList' for nested components, the value of this attribute will be 'UserList'
  dasherizedBaseName: string; // dasherized baseName of the component for example UseeList will be user-list
  dasherizedFullName: string; // for user-provided value like mymod/UserList, value will be mymod/user-list. Need for adding relative imports in the scss files
  projectBaseName: string; // for app wih root value (in angular.json) 'apps/app1/', this will be app1 and for libraries 'libs/lib1' it will be lib1
  dasherizedModuleName: string; // needed for flat component structure within a module
}

export default function (schema: Schema): Rule {
  return (host: Tree, context: SchematicContext) => {
    // For a typical invocation, schema looks like following
    // { project: 'app1', name: 'mymod/modComp2', flat: false, theme: false }
    // options look like this -
    // { project: 'mybu-lib1', theme: true, name: 'mymod/SomeList', '--': [ '--module', 'mymod' ], flat: false, path: '/libs/mybu/lib1/src/lib/mymod', isApplication: false, sourceRoot: 'libs/mybu/lib1/src', baseName: 'SomeList', dasherizedBaseName: 'some-list', dasherizedFullName: 'mymod/some-list', projectBaseName: 'lib1' }
    if (!schema.project) {
      throw new SchematicsException('Option (project) is required.');
    }

    const options = normalizeOptions(host, schema);

    const rules = [
      externalSchematic('@schematics/angular', 'component', {
        ...schema,
        styleext: 'scss'
      })
    ];

    if (options.theme) { // add the theme related rules in the chain
      // copy theme file
      const templateSource = apply(url('./files'), [
        template({
          ...strings,
          'if-flat': (s: string) => options.flat ? '' : s,
          ...options,
          name: options.dasherizedBaseName
        }),
        move(options.path),
      ]);

      rules.push(branchAndMerge(chain([mergeWith(templateSource)])));
      rules.push(prefixThemeScss(options));
      rules.push(updateMainThemeScss(options));
    }

    return chain(rules)(host, context);
  };

}

function normalizeOptions(host: Tree, schema: Schema): NormalizedSchema {
  const workspace = getWorkspace(host); // get the configuration from angular.json
  const project = workspace.projects[schema.project];
  const appOrLib = project.projectType === 'application' ? 'app' : 'lib';
  // parsedPath will be like - { name: 'UserList', path: '/libs/mybu/lib1/src/lib' }
  const parsedPath = parseName(`/${project.sourceRoot}/${appOrLib}`, schema.name);
  // get the project root
  let root = project.root.endsWith('/') ? project.root.slice(0, -1) : project.root;
  let projectBaseName = root.substring(root.lastIndexOf('/') + 1);

  return {
    ...schema,
    path: parsedPath.path,
    isApplication: project.projectType === 'application',
    sourceRoot: project.sourceRoot || '',
    baseName: parsedPath.name,
    dasherizedBaseName: strings.dasherize(parsedPath.name),
    dasherizedFullName: strings.dasherize(schema.name),
    projectBaseName,
    dasherizedModuleName: strings.dasherize(schema.module || '')
  };
}

function prefixThemeScss(options: NormalizedSchema): Rule {
  return (host: Tree) => {
    const compThemeFilePath = options.flat ? `${options.path}` : `${options.path}/${options.dasherizedBaseName}`;
    const oldCompThemeFile = `${compThemeFilePath}/${options.dasherizedBaseName}.theme.scss`;
    const newCompThemeFile = `${compThemeFilePath}/_${options.dasherizedBaseName}.theme.scss`;
    if (host.exists(oldCompThemeFile)) {
      host.rename(oldCompThemeFile, newCompThemeFile);
    }
    return host;
  }
}

function updateMainThemeScss(options: NormalizedSchema): Rule {
  return (host: Tree) => {
    const mainScssFilePath = options.isApplication ? `${options.sourceRoot}/_all-theme.scss` : `${options.sourceRoot}/lib/_${options.projectBaseName}-theme.scss`;
    const mainScssBuffer = host.read(mainScssFilePath);

    if (mainScssBuffer) {
      const lines = mainScssBuffer.toString('utf-8').split(EOL);
      // if --flat is passed, don't add component directory name to the path. But if module is passed, the path will have module directory name
      let compDirName;
      if (options.flat && options.module) { // flat structure requested, but module is present, add dasherized module dir to the path
        compDirName = `${options.dasherizedModuleName}/`;
      } else if (options.flat) {
        compDirName = '';
      } else {
        compDirName = `${options.dasherizedFullName}/`;
      }
      // const compDirName = options.flat && !options.module ? '' : `${options.dasherizedFullName}/`;
      const importStr = options.isApplication ? `@import './app/${compDirName}_${options.dasherizedBaseName}.theme.scss';` :
        `@import './${compDirName}_${options.dasherizedBaseName}.theme.scss';`
      lines.splice(lines.findIndex(line => line.includes('//@@IMPORT')), 0, importStr);

      // find the comment //@@include and add the following include statement before it
      lines.splice(lines.findIndex(line => line.includes('//@@INCLUDE')), 0, `  @include ${options.dasherizedBaseName}-theme($theme);`);

      // find the comment //@@TYPOGRAPHY and add the following include statement before it
      lines.splice(lines.findIndex(line => line.includes('//@@TYPOGRAPHY')), 0, `  @include ${options.dasherizedBaseName}-typography($config);`);

      // re-write the file
      host.overwrite(mainScssFilePath, lines.join(EOL));
    }
    return host;
  }
}
