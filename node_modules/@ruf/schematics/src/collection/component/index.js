"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const config_1 = require("@schematics/angular/utility/config");
const parse_name_1 = require("@schematics/angular/utility/parse-name");
const os_1 = require("os");
const schematics_1 = require("@angular-devkit/schematics");
function default_1(schema) {
    return (host, context) => {
        // For a typical invocation, schema looks like following
        // { project: 'app1', name: 'mymod/modComp2', flat: false, theme: false }
        // options look like this -
        // { project: 'mybu-lib1', theme: true, name: 'mymod/SomeList', '--': [ '--module', 'mymod' ], flat: false, path: '/libs/mybu/lib1/src/lib/mymod', isApplication: false, sourceRoot: 'libs/mybu/lib1/src', baseName: 'SomeList', dasherizedBaseName: 'some-list', dasherizedFullName: 'mymod/some-list', projectBaseName: 'lib1' }
        if (!schema.project) {
            throw new schematics_1.SchematicsException('Option (project) is required.');
        }
        const options = normalizeOptions(host, schema);
        const rules = [
            schematics_1.externalSchematic('@schematics/angular', 'component', Object.assign({}, schema, { styleext: 'scss' }))
        ];
        if (options.theme) { // add the theme related rules in the chain
            // copy theme file
            const templateSource = schematics_1.apply(schematics_1.url('./files'), [
                schematics_1.template(Object.assign({}, core_1.strings, { 'if-flat': (s) => options.flat ? '' : s }, options, { name: options.dasherizedBaseName })),
                schematics_1.move(options.path),
            ]);
            rules.push(schematics_1.branchAndMerge(schematics_1.chain([schematics_1.mergeWith(templateSource)])));
            rules.push(prefixThemeScss(options));
            rules.push(updateMainThemeScss(options));
        }
        return schematics_1.chain(rules)(host, context);
    };
}
exports.default = default_1;
function normalizeOptions(host, schema) {
    const workspace = config_1.getWorkspace(host); // get the configuration from angular.json
    const project = workspace.projects[schema.project];
    const appOrLib = project.projectType === 'application' ? 'app' : 'lib';
    // parsedPath will be like - { name: 'UserList', path: '/libs/mybu/lib1/src/lib' }
    const parsedPath = parse_name_1.parseName(`/${project.sourceRoot}/${appOrLib}`, schema.name);
    // get the project root
    let root = project.root.endsWith('/') ? project.root.slice(0, -1) : project.root;
    let projectBaseName = root.substring(root.lastIndexOf('/') + 1);
    return Object.assign({}, schema, { path: parsedPath.path, isApplication: project.projectType === 'application', sourceRoot: project.sourceRoot || '', baseName: parsedPath.name, dasherizedBaseName: core_1.strings.dasherize(parsedPath.name), dasherizedFullName: core_1.strings.dasherize(schema.name), projectBaseName, dasherizedModuleName: core_1.strings.dasherize(schema.module || '') });
}
function prefixThemeScss(options) {
    return (host) => {
        const compThemeFilePath = options.flat ? `${options.path}` : `${options.path}/${options.dasherizedBaseName}`;
        const oldCompThemeFile = `${compThemeFilePath}/${options.dasherizedBaseName}.theme.scss`;
        const newCompThemeFile = `${compThemeFilePath}/_${options.dasherizedBaseName}.theme.scss`;
        if (host.exists(oldCompThemeFile)) {
            host.rename(oldCompThemeFile, newCompThemeFile);
        }
        return host;
    };
}
function updateMainThemeScss(options) {
    return (host) => {
        const mainScssFilePath = options.isApplication ? `${options.sourceRoot}/_all-theme.scss` : `${options.sourceRoot}/lib/_${options.projectBaseName}-theme.scss`;
        const mainScssBuffer = host.read(mainScssFilePath);
        if (mainScssBuffer) {
            const lines = mainScssBuffer.toString('utf-8').split(os_1.EOL);
            // if --flat is passed, don't add component directory name to the path. But if module is passed, the path will have module directory name
            let compDirName;
            if (options.flat && options.module) { // flat structure requested, but module is present, add dasherized module dir to the path
                compDirName = `${options.dasherizedModuleName}/`;
            }
            else if (options.flat) {
                compDirName = '';
            }
            else {
                compDirName = `${options.dasherizedFullName}/`;
            }
            // const compDirName = options.flat && !options.module ? '' : `${options.dasherizedFullName}/`;
            const importStr = options.isApplication ? `@import './app/${compDirName}_${options.dasherizedBaseName}.theme.scss';` :
                `@import './${compDirName}_${options.dasherizedBaseName}.theme.scss';`;
            lines.splice(lines.findIndex(line => line.includes('//@@IMPORT')), 0, importStr);
            // find the comment //@@include and add the following include statement before it
            lines.splice(lines.findIndex(line => line.includes('//@@INCLUDE')), 0, `  @include ${options.dasherizedBaseName}-theme($theme);`);
            // find the comment //@@TYPOGRAPHY and add the following include statement before it
            lines.splice(lines.findIndex(line => line.includes('//@@TYPOGRAPHY')), 0, `  @include ${options.dasherizedBaseName}-typography($config);`);
            // re-write the file
            host.overwrite(mainScssFilePath, lines.join(os_1.EOL));
        }
        return host;
    };
}
//# sourceMappingURL=index.js.map