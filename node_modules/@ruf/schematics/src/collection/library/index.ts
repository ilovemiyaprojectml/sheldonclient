import { Schema } from "./schema";
import { Rule, apply, url, template, chain, externalSchematic, branchAndMerge, mergeWith, Tree, SchematicContext } from "@angular-devkit/schematics";
import { toFileName } from "@nrwl/workspace/src/utils/name-utils";
import { getNpmScope } from "@nrwl/workspace/src/utils/cli-config-utils";
import { readJsonInTree } from "@nrwl/workspace/src/utils/ast-utils";
import { serializeJson } from "@nrwl/workspace/src/utils/fileutils";

interface NormalizedSchema extends Schema {
  // for invocation like ng g lib lib1 --directory mybu the value will be 'libs/mybu/lib1' and without directory - 'libs/lib1'
  projectRoot: string;
  // for invocation like ng g app app1 --directory mybu, appProjectName will be 'mybu-app1' and that's the project name in angular.json
  projectName: string;
  // for invocation like ng g lib lib1 --directory mybu the value will be 'mybu/lib1' and without directory - 'lib1'
  projectDirectory: string;
}

export default function (schema: Schema): Rule {
  return (host: Tree, context: SchematicContext) => {
    // for an invocation like ng g lib lib1 --directory mybu
    // schema = { publishable: true, directory: 'mybu', name: 'lib1', prefix: undefined}
    // options = { publishable: true, directory: 'mybu', name: 'lib1', prefix: 'micro',projectName: 'mybu-lib1', projectRoot: 'libs/mybu/lib1', projectDirectory: 'mybu/lib1' }
    const options = normalizeOptions(host, schema);

    // copy welcome component and routing module
    const templateSource = apply(url('./files'), [
      template({
        tmpl: '',
        name: options.name,
        directory: options.directory
      })
    ]);

    return chain([
      externalSchematic('@nrwl/schematics', 'lib', {
        ...schema,
        framework: 'angular'
      }),
      branchAndMerge(chain([mergeWith(templateSource)])),
      prefixThemeScss(options),
      addBuildScriptToWsPkg(options)
    ])(host, context);
  };
}

function normalizeOptions(host: Tree, options: Schema): NormalizedSchema {
  const projectDirectory = options.directory
    ? `${toFileName(options.directory)}/${toFileName(options.name)}`
    : toFileName(options.name);
  const projectRoot = `libs/${projectDirectory}`;
  const projectName = projectDirectory.replace(new RegExp('/', 'g'), '-');

  const defaultPrefix = getNpmScope(host);
  return {
    ...options,
    prefix: options.prefix ? options.prefix : defaultPrefix,
    projectName,
    projectRoot,
    projectDirectory
  };
}

function addBuildScriptToWsPkg(options: NormalizedSchema): Rule {
  return (host: Tree) => {
    // read workspace package.json and add the following scripts to the scripts section
    // "pkg:${projectName}": "ng-packagr -p libs/${name}/package.json"
    // "postpkg:${projectName}": "ruf-wrench bundle-scss --projectRoot=${options.projectRoot} --projectName={options.projectName} --libName=${options.name}"
    if (options.publishable) {
      const pkg = readJsonInTree(host, 'package.json');
      pkg.scripts[`pkg:${options.projectName}`] = `ng build --project ${options.projectName}`;
      pkg.scripts[`postpkg:${options.projectName}`] = `./node_modules/.bin/ruf-wrench bundle-scss --projectRoot=${options.projectRoot} --projectName=${options.projectName} --libName=${options.name}`;
      host.overwrite('package.json', serializeJson(pkg));
    }
    return host;
  }
}

function prefixThemeScss(options: NormalizedSchema): Rule {
  return (host: Tree) => {
    const name = options.name;
    host.rename(`${options.projectRoot}/src/lib/${name}-theme.scss`, `${options.projectRoot}/src/lib/_${name}-theme.scss`);
    return host;
  }
}
