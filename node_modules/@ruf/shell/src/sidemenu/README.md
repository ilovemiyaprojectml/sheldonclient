# Sidemenu

The RUF Sidemenu component can be used to display menu items vertically on either side of a content area.
It renders multiple menu items and allows the user to select one.

[]()                 | []()
-------------------- | --------------------
Selector             | ruf-sidemenu
Class Name           | RufSidemenuComponent
Module name          | RufSidemenuModule
Presentational       | Yes
FIS UX Guidelines    | [Side Main Menu](https://ux.fisglobal.com/ux/menutouch.html#/sidemainmenu)
Dependencies         | RufMenubarComponent

## Appearance and Behavior

The component is a container for clickable menu items. Each item can be selected on click and become activated. 
An activated item will have an "ink bar" to visually identify the activated state of that item. 

Clicking on an item (selecting) doesn't necessarily activate the item. The activation of the item can be controlled externally using the selectedPath property binding.

### Styling

This component extends the RufMenubarComponent so refer to it for additional styling rules not covered here.

You can declaratively define the inkbar color using the activatedColor input. 

Variable                             | Default           | Description
------------------------------------ | ----------------- | -----------
$ruf-sidemenu-min-width              | ruf-to-rem($ruf-vunit * 100px) | The minimum width of the sidemenu.
$ruf-sidemenu-max-width              | ruf-to-rem($ruf-vunit * 250px) | The maximum width of the sidemenu.
$ruf-sidemenu-item-min-height        | ruf-to-rem($ruf-vunit * 45px)  | The minimum height each menu item should take.

**IMPORTANT:**
The foreground and background colors are, by default, inherited from the parent. This make the sidemenu reusable in different scenarios where a vertical menu is needed. For example, we are reusing it inside the megamenu component. However, to be used as the application's sidemenu as defined in the FIS UX Guidelines, you should use the `ruf-background-primary-dark` and `ruf-icon-primary-light` classes on the element containing the `ruf-sidemenu`. 


###  Detection of Light/Dark background
Sidemenu does not add any background or foreground color. It inherits it from the parent. However, the container holding sidemenu can have a lighter or darker background irrespective of whether the overall application uses `light` or `dark` theme.
In order for the side menu to apply proper hover, text colors, a `light` attribute should be added to `ruf-sidemenu` tag in component template.
The presence of `light` background suggests that this component has a dark background and lighter hover colors should be used. Similarly, if `light` attribute is not present on element, it assumes that background color is light.

This is just a css selector. It does not add any functionality.

```html
<ruf-sidemenu class="ruf-background-primary-dark" rufId [selectedPath]="selectedPath" 
(select)="openbasic($event.path)" light>
  <a rufId rufSidemenuItem path="demo/item1">Item 1</a>
  <a rufId rufSidemenuItem path="demo/item2">Item 2</a>
</ruf-sidemenu>
```

### Responsiveness

Use the layout directives to control the responsive aspects of your application.
If given a maximum height and the number of menu items is too big to be displayed, a scroll bar will appear next to the menu items.

## Accessibility

This component assigns a role attribute of `menubar` to the ruf-sidemenu element and a role of `menuitem` to each
of the items to communicate the presence and purpose of the sidemenu to screen reader users.
Focus management for sidemenu is handled in such a way that the tab sequence includes one stop for the sidemenu, and arrow
keys move focus among the items in the sidemenu.

See [ARIA Guidelines](https://www.w3.org/WAI/GL/wiki/Using_ARIA_menus) for menus 

### Keyboard interaction
* When sidemenu receives focus, focus is set on the first item that is not disabled.

* For a sidemenu (the default):
  * `Up arrow` moves focus to the previous item
  * `Down arrow` moves focus to the next item
* `ruf-sidemenu` element has role menubar

### Sidemenu Items

All sidemenu items will have `rufSidemenuItem` component applied on them.

```html
<ruf-sidemenu rufId [selectedPath]="selectedPath" (select)="openbasic($event.path)" class="ruf-background-primary-dark ruf-icon-primary-light">
  <a rufId rufSidemenuItem path="demo/toolbar"><ruf-labeled-icon fontIcon="fis-icon-dashboard">Toolbar</ruf-labeled-icon></a>
  <a rufId rufSidemenuItem path="demo/icon"><ruf-labeled-icon fontIcon="fis-icon-table">Icon</ruf-labeled-icon></a>
</ruf-sidemenu>
```
In the above example, `rufSidemenuItem` component is applied on all anchor tags of sidemenu.

### Sidemenu Items having child Items

In case, when the focus is on an item (parent) having child items, user can Expand/Collapse the parent item by pressing ENTER/SPACE
key to OPEN/CLOSE the child menu. Once the child menu is visible, the first child item will automatically get the focus.

* Use UP/DOWN ARROW keys to navigate through the child items.
* Use ENTER/SPACE keys to select a child item.
* Use ESCAPE key to close the child menu. On closing the child menu, the focus will automatically shift to the respective
  parent item. Now, user can navigate through the Main menu items using UP/DOWN ARROW keys.

Note: The selected path will not change on closing of the child menu until user selects some other item of the sidemenu.

```html
<ruf-sidemenu rufId [selectedPath]="selectedPath" (select)="openbasic($event.path)" class="ruf-background-primary-dark ruf-icon-primary-light">
  <ng-container *ngFor="let item of [1,2,3]">
    <a rufId rufToggleChevron rufSidemenuItem #trigger="rufToggle" path="demo/basic-item{{item}}"><ruf-labeled-icon fontIcon="fis-icon-folder">
        Item {{item}}</ruf-labeled-icon></a>
    <ruf-sidemenu-children [visible]="trigger.value" [menuTrigger]="trigger">
      <a rufId rufSidemenuItem path="demo/basic-item{{item}}/child1">Child 1</a>
      <a rufId rufSidemenuItem path="demo/basic-item{{item}}/child2">Child 2</a>
      <a rufId rufSidemenuItem path="demo/basic-item{{item}}/child3">Child 3</a>
    </ruf-sidemenu-children>
  </ng-container>
  <a rufId rufSidemenuItem path="demo/toolbar"><ruf-labeled-icon fontIcon="fis-icon-dashboard">Toolbar</ruf-labeled-icon></a>
  <a rufId rufSidemenuItem path="demo/icon"><ruf-labeled-icon fontIcon="fis-icon-table">Icon</ruf-labeled-icon></a>
</ruf-sidemenu>
```
In the above example, the main menu items are Item 1, Item 2, Item 3, Toolbar and Icon. Also, Item 1, Item 2 and Item 3
have 3 child items Child 1, Child 2 and Child 3 each.

## Inputs

### selectedPath

Type: string

Optional. Use this property to control the item that should be activated. 

A path is simply an identifier for an item. Each menu item will use a "startsWith" matching strategy to determine if it is active or not.
This means that if you have an item with a path of users and on with 'users/me' and provide a selectedPath of 'users/me', both items will be activated.

Note: changing this property does not fire a select event.  

### activeColor

Type: string

Optional. You can provide the color to be used to identify activated items. 
Use one of the theme color names: primary, accent (default), emphasis.  

### inkbarPosition

Type: string

Optional. Can be either start (default) or end. 
In the sidemenu, start will display the inkbar to the left of the menu item that is selected.

## Outputs

### select

A MenuItem event is fired on clicking an item in the menu. The event has the following properties:

| Property       | Type   | Description |
| -------------- | ------ | ------------|
| path           | string | Path associated to the menu item clicked. |
| data           | any    | Any value given to the item's data input property. |

Example:

```html
<ruf-menubar (select)="doSomething($event)"></ruf-menubar>
<ruf-menubar (select)="selectedPath = $event.path"></ruf-menubar>
```

## Methods

### select

* Signature: select(path: string, data?: any)
* Return type: void

Programmatically select an item with a given path (and optional data) and emit MenuItemSelectEvent event. 

### activate

* Signature: activate(path: string)
* Return type: void

Activates a path. No select event gets emitted. 

## Body

The body should contain RufSidemenuItemComponent and RufSidemenuChildrenComponent elements. 

# RufSidemenuItemComponent

This component identifies a menu items.

[]()                 | []()
-------------------- | --------------------
Selector             | ruf-sidemenu-item, [rufSidemenuItem]
Class                | RufSidemenuItemComponent
Presentational       | Yes 

## Inputs

### path

* Type: string

A string identifying the item. You will generally want these to be unique within a sidemenu.

If no path is provided, the item will not be activable.

### data

* Type: any

Optional. A data item to be associated to the item. This data item will be part of the sidemenu's select event.

### selectable

* Type: boolean
* Default: true 

Identifies the item as being selectable or not. If not selectable, clicking on the item will not fire a select event.
This can be useful if you want to define your own click event on the item.

Note: the item can still be activated using the sidemenu's selectedPath property.

## Example

```html
<a rufSidemenuItem path="accounts/manage">
  <ruf-labeled-icon fontIcon="fis-icon-folder">Manage Accounts</ruf-labeled-icon>
</a>
<a rufSidemenuItem path="profile">User profile</a>
```

# RufSidemenuChildrenComponent

This component can be used to wrap RufSidemenuItemComponent to make them appear as children of the previous menu item. It also provides a `visible` property that controls the visibility of the children and performs a slide in/out transition. 

[]()                 | []()
-------------------- | --------------------
Selector             | ruf-sidemenu-children, [rufSidemenuChildren]
Class                | RufSidemenuChildrenComponent
Presentational       | Yes 

## Inputs

### visible

Type: boolean
Default: true

Controls whether the children are visible or not. A slide in/out animation is used to transition between both states.

### menuTrigger

Type: RufToggleDirective

The element that triggers this menu. This is an optional input. If provided, the `SideMenuChildrenComponent` passes focus
to the `menuTrigger` element when its visibility is changed to `hidden' e.g., when `ESC` key is pressed.

## Example

Angular provides a `ng-container` element that allows grouping elements without actually outputting the ng-container element to the DOM. This can be useful to repeat a group of elements like below.

```html
<ruf-sidemenu [selectedPath]="selectedPath" (select)="openbasic($event.path)">
  <ng-container *ngFor="let item of [1,2,3]">
    <a rufToggleChevron rufSidemenuItem #trigger="rufToggle" path="demo/basic-item{{item}}">Item {{item}}</a>
    <ruf-sidemenu-children [visible]="trigger.value">
      <a rufSidemenuItem path="demo/basic-item{{item}}/child1">Child 1</a>
      <a rufSidemenuItem path="demo/basic-item{{item}}/child2">Child 2</a>
      <a rufSidemenuItem path="demo/basic-item{{item}}/child3">Child 3</a>
    </ruf-sidemenu-children>
  </ng-container>
</ruf-sidemenu>
```

The above piece of code adds another level of hierarchy to the side menu.
Using `ruf-toggle` in combination with the visible property of `ruf-sidemenu-children` adds the ability to expand and collapse children.
