# Router

RUF provides some additions to the Angular Router to support different use cases. The use of these additions is optional and only needed if you want the behavior they provide. 

## MDI Strategy

Here, MDI stands for "Multi-Document Interface" and it refers to the behavior RUF Classic had which was to let users navigate from one view to the other while preserving the state of the views. This makes it possible for the user to, for example, edit a form in view A switch to view B and go back to view A to continue editing where he/she left off.

The Angular router by default creates new component instances every time a route is visited. In this use case, it is important that, while navigating from one route to another, the state of the previous route is saved so that data is not lost.
The `RufMDIStrategy` helps in preserving the state.

To achieve this, we had to extend the Angular Router outlet and provide a custom RouteReuseStrategy we called RufMDIStrategy. Both ruf-router-outlet and RufMDIStrategy work hand in hand to provide this functionality and need to be used together. 

We had to extend the outlet because of [this](https://github.com/angular/angular/issues/13869) bug in the Angular Router. When this bug is resolved, we may deprecate the custom outlet.

## RufRouterOutlet

This directive is a placeholder used by Angular to dynamically add content based on the current router state. It extends the Angular [router-outlet](https://angular.io/api/router/RouterOutlet).
It saves component state in a service when routes are detached (when user navigates to a different route) along with complete route path. This reference is later used by the custom strategy to restore state.

[]()                 | []()
-------------------- | --------------------
Selector             | ruf-router-outlet
Class name           | RufRouterOutletDirective
Module name          | RufRouterModule

## RufRouteReuseStrategy

This is an abstract class which extends Angular's [RouteReuseStrategy](https://angular.io/api/router/RouteReuseStrategy) and declares a `destroy` method that should be implemented by custom strategy sub-class.

## RufMDIStrategy

Implements `RufRouteReuseStrategy`.

This is a custom RUF strategy which tells Angular Router how the routes should be reused. It stores every path and its component reference with the current state when the route is detached. When a new route is activated, it first checks if it was previously visited and retrieves the component instance - and its state - in that case.

### Destroy Method

The `RufMDIStrategy` stores component instances so that they are not re-instantiated when the route is re-visited. This means that the component is not destroyed when routes are switched.

However, there will be instances in the application, when the route should be destroyed completely e.g., after closing a tab that contains a particular view. For such scenarios, `RufMDIStrategy` provides a `destroy` method which removes route component references from store and destroys the component completely.

The container component that is attached to a route should call the `RufMDIStrategy.destroy` method.

#### Usage

Component for which you want to call destroy method.

```ts
import { RouteReuseStrategy } from '@angular/router';
import { RufRouterModule, RufRouterUtilService, RufMDIStrategy} from '@ruf/shell';

@Component({
  selector: 'app-nav',
  templateUrl: './nav-list.component.html'
})
export class NavListComponent {
  constructor(@Inject(RouteReuseStrategy) private routeReuseStrategy) {}

  // function that is called when a navigation tab is closed.
  onClose() {
   /**
   * path - the complete navigation route (including parent route name).
   * e.g: if location url for a route is 
   * https://infinitydev.sungard.com/RUF/ruf-nb/ruf/shell/router/mdi-strategy 
   * for which you want to destroy the component, 'path' should be /ruf/shell/router/mdi-strategy.
   */
    this.routeReuseStrategy.destroy(path);
  }
}

```

### Important Notes

1. The component state is stored in memory and you should be careful of the amount of components stored. This strategy by default applies to all the routes and hence states of all routes are stored. If you wish to store state only for certain routes, you should override the `shouldDetach` method.
E.g.,
```ts
export class CustomMDIStrategy extends RufMDIStrategy {

  constructor(private util: RufRouterUtilService) {
    super(util);
  }

  /**
   * Decides when the route should be stored
   * @param route the route that the user is currently on
   * @returns boolean indicating whether the route should or should not be stored
   */
  shouldDetach(route: ActivatedRouteSnapshot): boolean {
    const path = this.util.getLeafNodePath(route);
    let urlExp = new RegExp('^\/mdi\/');
    if (urlExp.test(path)) { // store routes with '/mdi/' in the path
      return true;
    }
    return false;
  }
}
```
Use `CustomMDIStrategy` instead of `RufMDIStrategy` while configuring ngModule.

2. Preserving state in RUF is different from how RUF Classic did it (hide and show the content in DOM). In Angular, state cannot be preserved and restored from the DOM because the elements are destroyed upon navigation. It is good practice to not rely on the DOM to store state (element.dataset for example) as you will be losing that information when you navigate away. 

## Usage

### Module

Configure the strategy in the root module.

```ts
import { RouteReuseStrategy } from '@angular/router';
import { RufRouterModule, RufRouterUtilService, RufMDIStrategy} from '@ruf/shell';

@NgModule({
  imports: [ RufRouterModule.forRoot() ],
  providers: [
    {
      provide: RouteReuseStrategy, 
      useFactory: getMDIStrategy, 
      deps: [RufRouterUtilService]
    }
  ]
})
export class AppModule {
}

export function getMDIStrategy(util: RufRouterUtilService) {
  return new RufMDIStrategy(util);
}
```

### Router Component

Use `ruf-router-outlet` where you would normally use `router-outlet`.

```html
<ruf-router-outlet></ruf-router-outlet>
```
