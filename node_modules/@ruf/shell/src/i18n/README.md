# I18n

An I18n module that sets locale for application, publishes `localeChange` event and can be used to format date/currency fields, translate strings using locale.

[]()                 | []()
-------------------- | --------------------
Module             	 | RufI18nModule
Presentational       | No

## Exported classes
This module exports date and currency pipes and I18n service

### rufDatePipe
Formats date as per locale. Subscribes to `localeChange` event.

[]()                 | []()
-------------------- | --------------------
name             	   | rufDate
pure       			     | false

Example

```html
<p>Today is {{ today | rufDate }}</p>
```

### rufCurrencyPipe
Formats currency as per locale. Subscribes to `localeChange` event.

[]()                 | []()
-------------------- | --------------------
name             	   | rufCurrency
pure       		       | false

Example

```html
<p>Value: {{ price | rufCurrency }}</p>
```

### I18n Service
Service for setting and getting current locale.

Methods

[]()                 | []()
-------------------- | --------------------
setLocale            | sets the argument as current locale and publishes `localeChange` event
getLocale			       | returns current locale. Defaults to 'en'

Events

[]()                 | []()
-------------------- | --------------------
localeChange         | Fired when locale is changed through setLocale method

# String Translations

## Shell Components
There are some components in shell like `ruf-statusbar` that need internationalization for some of the texts they use.
RUF has a `@Injectable()` class called `RufShellIntl` which contains default values for such messages.
Localization of these messages can be achieved by providing your own implementation of `RufShellIntl` and adding it in your application's root module providers.

```ts
import { RufUtilsModule, RufShellIntl } from '@ruf/shell';
@NgModule({
  imports: [RufUtilsModule],
  providers: [
    {provide: RufShellIntl, useClass: MyAppIntl},
  ],
})
export class AppModule {}
```

```ts
export class MyAppIntl {
  statusbar = {
      aria: { closeIconLabel: 'Localized Close Label' }
    };
}
```
Another way of achieving localization is through attributes provided to each of these components. Attribute values take precedence over `RufShellIntl` provider. 

```html
<ruf-statusbar >...</ruf-statusbar> <!-- 'Localized Close Label' is used as ARIA label for 'Close' icon. -->
<ruf-statusbar [closeAriaLabel]="'Click to close Status bar'">...</ruf-statusbar> <!-- 'Click to close Status bar' is used. -->
```

## String Translation in Applications

There are multiple ways to achieve i18n for angular applications. This section explains how and when to use them.
RUF does not provide any API/component/pipe for string translations. This is something the end applications need to take care of.

### Build time message bundle

Angular CLI provides commands that make it possible to translate text in component templates at build time. In this approach, 
you can add `i18n` attribute to template tags that is recognized by ng CLI. It then generates a random key (or uses value of `i18n` attribute as a key)
with value as text between the tag.

Angular CLI generates automatic bundles by reading all the i18n values from your components.

E.g., If your component template has 
```html
<h1 i18n="@@welcomeText">Welcome!</h1>
```

The bundle generated using `ng xi18n` will have `welcomeText` matched to 'Welcome!' value. This will by default be generated for `en-US` locale.

For other locales, use the `--locale` parameter and then edit the values to use this new locale.
```bash
ng xi18n --locale fr
```
It can be used both in AoT as well as JIT compilation mode.
More information can be found [here](https://angular.io/guide/i18n#!#merge).

#### Who should use this?
This is useful for applications where dynamic generation of message bundle is not needed. e.g., message bundles for all the possible locales can be generated 
at build time.

#### Pros
1. Support for pluralization, gender selection etc. in the translation. e.g,
2. Highest runtime performance
3. Easy merging with AOT compiler
4. Auto generation of message bundle using Angular CLI
5. Call `ng serve` with different locales to run different instances 
6. supports multiple translation formats

#### Cons
1. Not convenient for dynamic changes to locale or translation values.
2. Needs different deployments for different locales.
3. It can be hard to maintain in more complicated cases e.g., the application lets users change
 locale or translations at runtime, locale is determined by the information of logged in user etc.
  In such cases, you need to maintain locales and customer variations and build/deploy customer
  specific app.

### Using I18n Object

Create an `@Injectable()` class that contains labels used by components that require internationalization.
This class can detect locale changes and use a store or http service or have any other kind of logic to fetch translations.

**I18n Class**
```ts

@Injectable()
export class AppIntl {
  /**
   * Stream that emits whenever the labels here are changed. Use this to notify
   * components if the labels have changed after initialization.
   */
  changes: Subject<void> = new Subject<void>();

  // You can use ngrx store or a service to fetch data from server instead of hard-coded values.
  label = 'This is a label';
 
}
```

**Component** 
```ts
export class AppComponent implements OnDestroy {
  private _intlChanges: Subscription;
  
  get label() {
    return this._intl.label;
  }
  ...
  constructor(private _intl: AppIntl, changeDetectorRef: ChangeDetectorRef) {
    this._intlChanges = _intl.changes.subscribe(() => changeDetectorRef.markForCheck());
  }
  
  ngOnDestroy() {
    this._intlChanges.unsubscribe();
  }
}
```

This approach can be used by libraries too. Since it is an injectable, applications using this library can provide their own implementation.

```ts
import { LibModule, LibIntl } from 'lib';
@NgModule({
  imports: [LibModule],
  providers: [
    {provide: LibIntl, useClass: MyAppIntl},
  ],
})
export class AppModule {}
```

```ts
import { RufShellIntl } from '@ruf/shell';
export class MyAppIntl extends RufShellIntl{
  // override values here
}
```

### Attributes

Libraries can use this approach of adding attributes to components where i18n is required.
```ts
@Component({
  selector: 'lib-cmp'
})
export class LibComponent {
	@Input() label;
}
```

**Usage** 
```html
<lib-cmp [label]="'Some other label'"></lib-cmp>
```

This approach can be combined with the `Using I18n Object` mentioned above. In that case, component can have an attribute or use `LibIntl` class if attribute is not provided.

This is the default approach used by RUF components e.g. `ruf-dynamic-menubar`.

```ts
export class LibComponent implements ngDestroy {
  private _intlChanges: Subscription;
	private _label: string;

  @Input()
  get label() {
    return this._label || this._intl.label;
  }

  set label(label:string) {
    this._label = label;
  }
  
	constructor(private _intl: AppIntl, changeDetectorRef: ChangeDetectorRef) {
    this._intlChanges = _intl.changes.subscribe(() => {
      changeDetectorRef.markForCheck();
    });
	}

  ngOnDestroy() {
    this._intlChanges.unsubscribe();
  }
}
```

**Usage** 

1. Attribute is used and takes precedence.
```html
<lib-cmp [label]="'Some other label'"></lib-cmp>  //displays 'Some other label'
```
2. Attribute is not provided. By default use value from Injector class
```html
<lib-cmp></lib-cmp>  //displays default label value from `LibIntl` class
```

### Using ngx-translate

The RUF Demo application uses this approach to demonstrate string translations. With this approach, bundle can be created on server and used on client side. 
Runtime changes to locale or translated values can be detected.
More information can be found at [ngx translate site](https://github.com/ngx-translate/core).

Applications that have complex logic for generating message bundle, e.g., if the values are stored in database, can change at runtime, locale changes at runtime etc., should use this (or the `I18n Object`) approach.

## Future Considerations

Check if `LOCALE_ID` provider can use promise and `rufDatePipe` and `rufCurrencyPipe` can be used with minimum changes.
