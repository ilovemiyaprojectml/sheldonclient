/*!
FIS Responsive UI Framework: @ruf/shell
Version: 6.0.0

© 2018
Fidelity National Information Services, Inc. and/or its subsidiaries - All Rights Reserved worldwide.
This document is protected under the trade secret and copyright laws as the property of Fidelity National Information Services, Inc. and/or its subsidiaries.
Copying, reproduction or distribution should be limited and only to employees with a “need to know” to do their job. Any disclosure of this document to third parties is strictly prohibited.
*/

/*!
FIS Responsive UI Framework: @ruf/shell
Version: undefined

© 2018
Fidelity National Information Services, Inc. and/or its subsidiaries - All Rights Reserved worldwide.
This document is protected under the trade secret and copyright laws as the property of Fidelity National Information Services, Inc. and/or its subsidiaries.
Copying, reproduction or distribution should be limited and only to employees with a “need to know” to do their job. Any disclosure of this document to third parties is strictly prohibited.
*/

import { InjectionToken, Injectable, Directive, ElementRef, NgModule, Renderer2, Input, ContentChildren, QueryList, HostListener, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, isDevMode, ContentChild, HostBinding, SimpleChange, Self, Optional, EventEmitter, ViewChildren, Output, TemplateRef, forwardRef, ViewChild, Inject, ViewContainerRef, Pipe, LOCALE_ID, Attribute, ComponentFactoryResolver } from '@angular/core';
import { __decorate, __metadata, __param } from 'tslib';
import { Subject, Subscription, BehaviorSubject, from, merge, of, Observable } from 'rxjs';
import { CommonModule, DOCUMENT, CurrencyPipe, DatePipe } from '@angular/common';
import { FocusKeyManager, ListKeyManager } from '@angular/cdk/a11y';
import { HOME, END, ENTER, SPACE, ESCAPE } from '@angular/cdk/keycodes';
import { MatButtonModule, MatButton } from '@angular/material/button';
import { MatDialogModule } from '@angular/material/dialog';
import { MatIcon, MatIconModule } from '@angular/material/icon';
import { MatTabsModule } from '@angular/material/tabs';
import { takeUntil, distinctUntilChanged, debounceTime, switchMap, startWith, withLatestFrom, map } from 'rxjs/operators';
import { MatMenuTrigger, MatMenuModule } from '@angular/material/menu';
import { CdkOverlayOrigin, OverlayModule, Overlay } from '@angular/cdk/overlay';
import { MediaObserver, FlexLayoutModule, BaseDirective, MediaMonitor, StyleUtils } from '@angular/flex-layout';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { RouterOutlet, PRIMARY_OUTLET, ChildrenOutletContexts, RouteReuseStrategy } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { TemplatePortal } from '@angular/cdk/portal';
import { MatButtonToggle, MatButtonToggleModule } from '@angular/material/button-toggle';

const versionString = '4.7.0-beta8-SNAPSHOT';

function infoToken() {
    return new InjectionToken('RUF_INFO');
}
const RUF_INFO = infoToken;
const info = {
    version: versionString,
    get copyright() {
        return '© ' + new Date().getFullYear() + ' FIS';
    }
};
console.log('RUF ' + info.version);
console.log(info.copyright);

function _window() {
    // return the global native browser window object
    return window;
}
let RufWindowRef = class RufWindowRef {
    get nativeWindow() {
        return _window();
    }
};
RufWindowRef = __decorate([
    Injectable()
], RufWindowRef);

/**
 * Labels used by all shell components that require internationalization.
 * These components also have individual attributes for these labels.
 * Users can either provide attributes
 * e.g., `closeIconTitle` can be provided by users for title of modal dialog close button.
 * <button mat-icon-button mat-dialog-close [title]="closeIconTitle">
 * </button>
 * or
 * Provide an instance of this class which overrides `closeIconTitle`.
 * */
let RufShellIntl = class RufShellIntl {
    /**
     * Labels used by all shell components that require internationalization.
     * These components also have individual attributes for these labels.
     * Users can either provide attributes
     * e.g., `closeIconTitle` can be provided by users for title of modal dialog close button.
     * <button mat-icon-button mat-dialog-close [title]="closeIconTitle">
     * </button>
     * or
     * Provide an instance of this class which overrides `closeIconTitle`.
     * */
    constructor() {
        /**
         * Stream that emits whenever the labels here are changed. Use this to notify
         * components if the labels have changed after initialization.
         */
        this.changes = new Subject();
        this.dynamicmenubar = {
            aria: { closeIconLabel: 'Close' }
        };
        this.dialog = { closeIconTitle: 'Close' };
        this.banner = {
            altText: 'logo',
            aria: {
                label: 'Banner',
                labelledBy: null
            }
        };
        this.toolbar = {
            aria: { label: 'Toolbar' }
        };
        this.statusbar = {
            aria: { closeIconLabel: 'Close', expandIconLabel: 'Expand' }
        };
        this.ellipsis = {
            label: '...Read More',
            aria: { label: 'Read More' }
        };
        this.megamenu = {
            placeholder: 'Search',
            aria: { clearSearchLabel: 'Clear search' }
        };
        this.megamenusearch = {
            placeholder: 'Search',
            aria: { clearSearchLabel: 'Clear search' }
        };
        this.card = {
            aria: {
                expandLabel: 'Expand',
                collapseLabel: 'Collapse'
            }
        };
        this.fileupload = {
            aria: {
                label: 'Choose File'
            },
            label: 'Choose File',
            placeholder: 'No file chosen',
            fileNameLabel: 'File Name',
            sizeLabel: 'Size',
            progressLabel: 'Progress'
        };
        this.sidepanel = {
            aria: {
                pinLabel: 'Pin',
                unpinLabel: 'Unpin'
            }
        };
    }
};
RufShellIntl = __decorate([
    Injectable()
], RufShellIntl);

/**
 * This attribute directive should be placed on any element that needs to get focus on keyboard navigation
 */
let RufFocusableDirective = class RufFocusableDirective {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
    focus() {
        this._elementRef.nativeElement.focus();
    }
    get disabled() {
        return this._elementRef.nativeElement.disabled;
    }
};
RufFocusableDirective = __decorate([
    Directive({
        selector: '[rufFocusable], [ruf-focusable]' // tslint:disable-line
    }),
    __metadata("design:paramtypes", [ElementRef])
], RufFocusableDirective);

const ɵ0 = info;
let RufUtilsModule = class RufUtilsModule {
};
RufUtilsModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [
            RufFocusableDirective
        ],
        exports: [
            RufFocusableDirective
        ],
        providers: [RufWindowRef, RufShellIntl, { provide: RUF_INFO, useValue: ɵ0 }]
    })
], RufUtilsModule);

/**The MIT License

Copyright (c) 2017 Google, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
class RufKeyCodes {
}
RufKeyCodes.ENTER = 13;
RufKeyCodes.ESCAPE = 27;
RufKeyCodes.SPACE = 32;
RufKeyCodes.LEFT_ARROW = 37;
RufKeyCodes.UP_ARROW = 38;
RufKeyCodes.RIGHT_ARROW = 39;
RufKeyCodes.DOWN_ARROW = 40;
class RufKeyboardNavigation {
    constructor() {
        this._direction = 'row';
    }
    // To receive select notifications, subscribe to this function
    init(container, items) {
        this._container = container;
        this._items = items;
        this._FocusKeyManager = new FocusKeyManager(items).withWrap();
        this._ListKeyManager = new ListKeyManager(items);
        if (items.length > 0) {
            this.setActiveItemWithoutFocus(0);
            this._ListKeyManager.setActiveItem.call(this._FocusKeyManager, 0);
        }
        this._subscription = new Subject();
        return this._subscription;
    }
    setActiveItem(index) {
        this._FocusKeyManager.setActiveItem(index);
    }
    setActiveItemWithoutFocus(index) {
        this._ListKeyManager.setActiveItem.call(this._FocusKeyManager, index);
    }
    navigate(event) {
        switch (event.keyCode) {
            case RufKeyCodes.ESCAPE:
                this._container.nativeElement.focus();
                break;
            case RufKeyCodes.LEFT_ARROW:
            case RufKeyCodes.UP_ARROW:
                this._FocusKeyManager.setPreviousItemActive();
                // prevent scrollbar catching the event
                this.preventEventPropagation(event);
                break;
            case RufKeyCodes.RIGHT_ARROW:
            case RufKeyCodes.DOWN_ARROW:
                this._FocusKeyManager.setNextItemActive();
                // prevent scrollbar catching the event
                this.preventEventPropagation(event);
                break;
            case RufKeyCodes.SPACE:
            case RufKeyCodes.ENTER:
                this.selectFocusedItem();
                // prevent scrollbar catching the event
                this.preventEventPropagation(event);
                break;
            case HOME:
                this._FocusKeyManager.setFirstItemActive();
                // prevent scrollbar catching the event
                this.preventEventPropagation(event);
                break;
            case END:
                this._FocusKeyManager.setLastItemActive();
                // prevent scrollbar catching the event
                this.preventEventPropagation(event);
                break;
            default:
                this._FocusKeyManager.onKeydown(event);
                break;
        }
    }
    preventEventPropagation(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    onKeyDown(event) {
        if (this._items.length === 0) {
            return;
        }
        this.navigate(event);
    }
    addTabIndex(focusableItems) {
        focusableItems.forEach((child, index) => {
            if (index === 0) {
                child._elementRef.nativeElement.setAttribute('tabindex', 0);
            }
            else {
                child._elementRef.nativeElement.setAttribute('tabindex', -1);
            }
        });
    }
    selectFocusedItem() {
        if (this._FocusKeyManager.activeItem) {
            this._subscription.next(this._FocusKeyManager.activeItem);
        }
    }
    focus(path) {
        if (!this._items || this._items.length === 0) {
            return;
        }
        const item = this._items.find(f => f.path === path);
        const index = this._items.toArray().indexOf(item);
        this._FocusKeyManager.setActiveItem(index);
    }
    isActive() {
        return this._FocusKeyManager.activeItem !== undefined;
    }
    setDirection(direction) {
        if (direction === 'column') {
            this._direction = direction;
        }
    }
}

// tslint doesn't see the selector is kebab-case here
/* tslint:disable:directive-selector-name */
let RufToolbarFillerDirective = class RufToolbarFillerDirective {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        renderer.setStyle(el.nativeElement, 'flex', '1 1 auto');
    }
};
RufToolbarFillerDirective = __decorate([
    Directive({ selector: '[rufToolbarFiller]' }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], RufToolbarFillerDirective);

/**
 * @license
 * The MIT License

 * Copyright (c) 2010-2019 Google LLC. http://angular.io/license

 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
 * files (the "Software"), * to deal in the Software without restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
 * is furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
function rufMixinColor(base, defaultColor) {
    return class extends base {
        constructor(...args) {
            super(...args);
            // Set the default color that can be specified from the mixin.
            this.color = defaultColor;
        }
        get color() {
            return this._color;
        }
        set color(value) {
            const colorPalette = value || defaultColor;
            if (colorPalette !== this._color) {
                if (this._color) {
                    this._elementRef.nativeElement.classList.remove(`ruf-${this._color}`);
                }
                if (colorPalette) {
                    this._elementRef.nativeElement.classList.add(`ruf-${colorPalette}`);
                }
                this._color = colorPalette;
            }
        }
    };
}
class RufElementRefBase {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
}
const RufMixinBase = rufMixinColor(RufElementRefBase);

let RufToolbarRowDirective = class RufToolbarRowDirective {
};
RufToolbarRowDirective = __decorate([
    Directive({
        selector: 'ruf-toolbar-row' // tslint:disable-line
    })
], RufToolbarRowDirective);
let RufToolbarComponent = class RufToolbarComponent extends RufMixinBase {
    constructor(_elementRef, _intl, changeDetectorRef) {
        super(_elementRef);
        this._elementRef = _elementRef;
        this._intl = _intl;
        this.children = [];
        this._intlChanges = _intl.changes.subscribe(() => {
            changeDetectorRef.markForCheck();
        });
    }
    /* tslint:disable:no-input-rename */
    set ariaLabel(label) {
        this._ariaLabel = label;
    }
    get ariaLabel() {
        return this._ariaLabel || this._intl.toolbar.aria.label;
    }
    ngAfterContentInit() {
        this._keyboardNav = new RufKeyboardNavigation();
        this._keyboardNav.init(this._elementRef, this.toolbarItems);
        this._keyboardNav.addTabIndex(this.toolbarItems);
    }
    onKey(event) {
        switch (event.keyCode) {
            case RufKeyCodes.SPACE:
            case RufKeyCodes.ENTER:
                event.stopPropagation();
                break;
            default:
                this._keyboardNav.onKeyDown(event);
        }
    }
    ngOnDestroy() {
        this._intlChanges.unsubscribe();
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufToolbarComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufToolbarComponent.prototype, "ariaLabel", null);
__decorate([
    ContentChildren(RufFocusableDirective, { descendants: true }),
    __metadata("design:type", QueryList)
], RufToolbarComponent.prototype, "toolbarItems", void 0);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], RufToolbarComponent.prototype, "onKey", null);
RufToolbarComponent = __decorate([
    Component({
        selector: 'ruf-toolbar',
        template: "<div class=\"ruf-toolbar-rows\" rufId=\"toolbar\" >\n  <ruf-toolbar-row  class=\"ruf-toolbar-first-row\" rufId=\"toolbar_row\" role=\"toolbar\" [attr.aria-label]=\"ariaLabel\">\n    <ng-content></ng-content>\n  </ruf-toolbar-row>\n  <ng-content select=\"ruf-toolbar-row\"></ng-content>\n</div>\n",
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: ["ruf-toolbar{display:block;flex-shrink:0;min-height:inherit;overflow:hidden}ruf-toolbar .mat-select{padding-top:0}.ruf-toolbar-separator{border-left-style:solid;border-left-width:1px;display:inline-block;height:1.4375rem;margin:0 .625rem;vertical-align:middle;word-wrap:nowrap}.ruf-toolbar-rows{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;min-height:inherit}ruf-toolbar-row{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;min-height:inherit}ruf-toolbar-row>*{margin-left:.625rem}ruf-toolbar-row>:nth-last-child(1){margin-left:.625rem;margin-right:.625rem}ruf-toolbar-row>:nth-last-child(1).ruf-square{margin-right:0}ruf-toolbar-row>:only-child{border:0}"]
    }),
    __metadata("design:paramtypes", [ElementRef,
        RufShellIntl,
        ChangeDetectorRef])
], RufToolbarComponent);

let RufUniqueIdDirective = class RufUniqueIdDirective {
    constructor(el) {
        this.el = el;
    }
    ngOnInit() {
        if (isDevMode()) {
            const currentElement = this.el.nativeElement;
            if (!currentElement.id) {
                currentElement.id = this.rufId ? this.getUniqueId(this.rufId) : this.generateID();
            }
        }
    }
    /**
     * Walks up the tree, picking up uids as it goes
     * @param node
     * @returns parent ID
     */
    getParentID(node) {
        let tempParentId = '';
        if (node.attributes && node.attributes.id) {
            return node.attributes.id.value;
        }
        if (node.parentNode) {
            tempParentId = this.getParentID(node.parentNode);
        }
        return tempParentId;
    }
    /**
     * Generates an idempotent id on the element this directive is attached to
     * Based on the name and attributes (but ignores the angular temp name that can be different each run)
     * @returns string
     */
    generateID() {
        const nel = this.el.nativeElement;
        const parentID = this.getParentID(nel);
        let tempUid = parentID === '' ? nel.tagName.toLowerCase() : parentID + '_' + nel.nodeName.toLowerCase();
        tempUid = this.getUniqueId(tempUid);
        return tempUid;
    }
    /**
     * Check for unique id in DOM
     * @returns string
     */
    getUniqueId(tempId) {
        let count = 0;
        const genId = tempId + '_';
        tempId = genId + count;
        while (document.getElementById(tempId) !== null) {
            count++;
            tempId = genId + count;
        }
        return tempId;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], RufUniqueIdDirective.prototype, "rufId", void 0);
RufUniqueIdDirective = __decorate([
    Directive({
        selector: '[rufId]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], RufUniqueIdDirective);

let RufUniqueIdModule = class RufUniqueIdModule {
};
RufUniqueIdModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [RufUniqueIdDirective],
        exports: [RufUniqueIdDirective]
    })
], RufUniqueIdModule);

let RufToolbarModule = class RufToolbarModule {
};
RufToolbarModule = __decorate([
    NgModule({
        imports: [CommonModule, RufUniqueIdModule, RufUtilsModule],
        declarations: [RufToolbarComponent, RufToolbarFillerDirective, RufToolbarRowDirective],
        exports: [RufToolbarComponent, RufToolbarFillerDirective, RufToolbarRowDirective]
    })
], RufToolbarModule);

let RufBannerRowDirective = class RufBannerRowDirective {
};
RufBannerRowDirective = __decorate([
    Directive({
        selector: 'ruf-banner-row' // tslint:disable-line
    })
], RufBannerRowDirective);
let RufBannerControlsDirective = class RufBannerControlsDirective {
};
RufBannerControlsDirective = __decorate([
    Directive({
        selector: '[rufBannerControls]' // tslint:disable-line
    })
], RufBannerControlsDirective);
let RufBannerBrandComponent = class RufBannerBrandComponent {
    constructor(_intl, changeDetectorRef) {
        this._intl = _intl;
        this.logoClass = 'fis-logo';
        this.showLogo = true;
        this._intlChanges = _intl.changes.subscribe(() => changeDetectorRef.markForCheck());
    }
    get altText() {
        return this._altText || this._intl.banner.altText;
    }
    set altText(value) {
        this._altText = value;
    }
    get ariaLabel() {
        return this._ariaLabel || this._intl.banner.aria.label;
    }
    set ariaLabel(value) {
        this._ariaLabel = value;
    }
    get ariaLabelledby() {
        return this._ariaLabelledby || this._intl.banner.aria.labelledBy;
    }
    set ariaLabelledby(value) {
        this._ariaLabel = value;
    }
    ngOnDestroy() {
        this._intlChanges.unsubscribe();
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], RufBannerBrandComponent.prototype, "logoUrl", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RufBannerBrandComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufBannerBrandComponent.prototype, "logoClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufBannerBrandComponent.prototype, "showLogo", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufBannerBrandComponent.prototype, "altText", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufBannerBrandComponent.prototype, "ariaLabel", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufBannerBrandComponent.prototype, "ariaLabelledby", null);
RufBannerBrandComponent = __decorate([
    Component({
        selector: 'ruf-banner-brand',
        template: `
    <div rufId [class]="'ruf-banner-brand-logo ' + (!logoUrl && logoClass)" *ngIf="showLogo" >
      <span hidden="true" aria-hidden="false" [attr.aria-label]="ariaLabel"
      [attr.aria-labelledby]="ariaLabelledby">{{ariaLabel}}</span>
      <img rufId *ngIf="logoUrl" [src]="logoUrl" [attr.alt]="altText">
    </div>
    <div rufId class="ruf-toolbar-separator" *ngIf="title && showLogo"></div>
    <h1 *ngIf="title" class="ruf-banner-brand-title">{{title}}</h1>
  `,
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [RufShellIntl, ChangeDetectorRef])
], RufBannerBrandComponent);
let RufBannerComponent = class RufBannerComponent {
    constructor() { }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], RufBannerComponent.prototype, "color", void 0);
__decorate([
    ContentChild(RufBannerControlsDirective, { static: false }),
    __metadata("design:type", RufBannerControlsDirective)
], RufBannerComponent.prototype, "controls", void 0);
RufBannerComponent = __decorate([
    Component({
        selector: 'ruf-banner',
        template: "<header class=\"ruf-banner-header\" role=\"banner\">\n  <ruf-toolbar [color]=\"color\" class=\"ruf-banner-toolbar\" rufId=\"banner_toolbar\">\n    <ng-content></ng-content>\n    <div *ngIf=\"controls\" class=\"ruf-banner-filler\"></div>\n    <ng-content select=\"[rufBannerControls]\"></ng-content>\n    <ng-content select=\"ruf-banner-row\" ngProjectAs=\"ruf-toolbar-row\"></ng-content>\n  </ruf-toolbar>\n</header>\n",
        encapsulation: ViewEncapsulation.None,
        styles: ["ruf-banner{display:block;flex-shrink:0;min-height:3rem;overflow:hidden;z-index:100}.ruf-banner-toolbar{height:inherit}.ruf-banner-toolbar ruf-banner-row,.ruf-banner-toolbar ruf-toolbar-row{margin:0 auto;padding:0;width:100%}.ruf-banner-header{min-height:inherit}ruf-banner-brand{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;height:3rem}ruf-banner-brand .ruf-toolbar-separator{display:none}.ruf-banner-filler{-webkit-box-flex:1;flex:1 1 auto}.ruf-banner-brand-logo{line-height:0}.ruf-banner-brand-logo.fis-logo{background-size:4.375rem;height:2.375rem;max-width:4.375rem;width:4.375rem}.ruf-banner-brand-title{display:none;white-space:nowrap}@media (min-width:960px){.ruf-banner-brand-title,ruf-banner-brand .ruf-toolbar-separator{display:block}}"]
    }),
    __metadata("design:paramtypes", [])
], RufBannerComponent);

let RufBannerModule = class RufBannerModule {
};
RufBannerModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            RufToolbarModule,
            RufUniqueIdModule,
            RufUtilsModule
        ],
        declarations: [
            RufBannerComponent,
            RufBannerRowDirective,
            RufBannerBrandComponent,
            RufBannerControlsDirective
        ],
        exports: [
            RufBannerComponent,
            RufBannerRowDirective,
            RufBannerBrandComponent,
            RufBannerControlsDirective
        ]
    })
], RufBannerModule);

let RufDialogHeaderDirective = class RufDialogHeaderDirective {
};
RufDialogHeaderDirective = __decorate([
    Directive({
        selector: 'ruf-dialog-header' // tslint:disable-line
    })
], RufDialogHeaderDirective);
let RufDialogContentDirective = class RufDialogContentDirective {
};
RufDialogContentDirective = __decorate([
    Directive({
        selector: 'ruf-dialog-content' // tslint:disable-line
    })
], RufDialogContentDirective);
let RufDialogFooterDirective = class RufDialogFooterDirective {
};
RufDialogFooterDirective = __decorate([
    Directive({
        selector: 'ruf-dialog-footer' // tslint:disable-line
    })
], RufDialogFooterDirective);
let RufDialogPanelComponent = class RufDialogPanelComponent {
    constructor(_intl, changeDetectorRef) {
        this._intl = _intl;
        this.tabindex = 0;
        this.separator = false;
        this._intlChanges = _intl.changes.subscribe(() => changeDetectorRef.markForCheck());
    }
    get closeIconTitle() {
        return this._closeIconTitle || this._intl.dialog.closeIconTitle;
    }
    set closeIconTitle(value) {
        this._closeIconTitle = value;
    }
    ngOnDestroy() {
        this._intlChanges.unsubscribe();
    }
};
__decorate([
    ContentChild(RufDialogFooterDirective, { static: false }),
    __metadata("design:type", RufDialogFooterDirective)
], RufDialogPanelComponent.prototype, "footer", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Object)
], RufDialogPanelComponent.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufDialogPanelComponent.prototype, "separator", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufDialogPanelComponent.prototype, "closeIconTitle", null);
RufDialogPanelComponent = __decorate([
    Component({
        selector: 'ruf-dialog-panel',
        template: "<div class=\"ruf-dialog-panel\" rufId=\"dialog_panel\" [ngClass]=\"{'ruf-dialog-separator-enabled': separator}\">\n  <div #title mat-dialog-title class=\"ruf-dialog-header\" rufId=\"dialog_header\">\n    <div class=\"ruf-dialog-header-bar\">\n      <ng-content select=\"ruf-dialog-header\"></ng-content>\n      <span class=\"ruf-dialog-header-filler\"></span>\n      <button type=\"button\" mat-icon-button fisStyle mat-dialog-close rufId=\"dialog_close_icon\" [title]=\"closeIconTitle\">\n        <mat-icon fisIcon=\"close\" rufIconStyle=\"sm\" alt=\"fis-close-icon\"></mat-icon>\n      </button>\n    </div>\n    <hr *ngIf=\"title.children.length > 0 && separator\" class=\"ruf-dialog-separator\">\n  </div>\n  <div mat-dialog-content class=\"ruf-dialog-content\" rufId=\"dialog_content\">\n    <ng-content select=\"ruf-dialog-content\"></ng-content>\n  </div>\n  <div #actions mat-dialog-actions class=\"ruf-dialog-footer\" [class.ruf-footer-empty]=\"!footer\" rufId=\"dialog_footer\">\n    <hr *ngIf=\"actions.children.length > 0  && separator\" class=\"ruf-dialog-separator\">\n    <ng-content select=\"ruf-dialog-footer\"></ng-content>\n  </div>\n  <ng-content></ng-content>\n</div>\n",
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [".ruf-dialog-header{margin-bottom:1.125rem;min-height:2.25rem;position:relative}.ruf-dialog-header .ruf-dialog-header-bar{display:block}.ruf-dialog-header .ruf-dialog-header-bar ruf-dialog-header{display:block;padding-right:.9375rem;width:90%}.ruf-dialog-header .ruf-dialog-header-bar .mat-icon-button{position:absolute;right:0;top:-.1875rem}.mat-dialog-container,.ruf-dialog-panel{padding:1.25rem}mat-dialog-container.mat-dialog-container{border-radius:4px}mat-dialog-container.mat-dialog-container .ruf-dialog-panel{margin:-1.25rem}mat-dialog-container.mat-dialog-container .ruf-dialog-panel .ruf-dialog-footer{display:block;margin-bottom:.625rem;margin-top:1.25rem;min-height:2.625rem;padding:0}mat-dialog-container.mat-dialog-container .ruf-dialog-panel .ruf-dialog-footer ruf-dialog-footer{display:block;padding-top:.5rem}mat-dialog-container.mat-dialog-container .ruf-dialog-panel .ruf-dialog-footer.ruf-footer-empty{display:none}mat-dialog-container.mat-dialog-container .ruf-dialog-separator{margin-left:-1.25rem;margin-right:-1.25rem}mat-dialog-container.mat-dialog-container .ruf-dialog-content{margin:-1.25rem;padding:.625rem 1.25rem}.ruf-dialog-separator{border-style:solid}.ruf-dialog-footer>.ruf-dialog-separator{margin-bottom:0;margin-top:.5rem}mat-dialog-container.mat-dialog-container .ruf-dialog-separator-enabled .ruf-dialog-header{min-height:2.9375rem}mat-dialog-container.mat-dialog-container .ruf-dialog-separator-enabled.ruf-dialog-panel .ruf-dialog-footer{min-height:3.3125rem}mat-dialog-container.mat-dialog-container .ruf-dialog-separator-enabled.ruf-dialog-panel .ruf-dialog-footer ruf-dialog-footer{padding-top:1.125rem}mat-dialog-container.mat-dialog-container .ruf-dialog-separator-enabled .ruf-dialog-content{padding:1.25rem}"]
    }),
    __metadata("design:paramtypes", [RufShellIntl, ChangeDetectorRef])
], RufDialogPanelComponent);

let RufIconDirective = class RufIconDirective {
    constructor(matIcon) {
        this.matIcon = matIcon;
        this.icon = '';
    }
    set fisIcon(val) {
        this.icon = val || '';
    }
    set rufIcon(val) {
        this.icon = val || '';
    }
    ngOnChanges(changes) {
        // the matIcon is intentionally left unchanged if fisIcon or rufIcon is set to empty:
        // it is assumed that fontSet and fontIcon are changed appropriately.
        if (this.matIcon &&
            ((changes.fisIcon && changes.fisIcon.currentValue) ||
                (changes.rufIcon && changes.rufIcon.currentValue))) {
            const currentIcon = changes.fisIcon ? changes.fisIcon.currentValue : changes.rufIcon.currentValue;
            this.matIcon.fontSet = 'fisfont';
            this.matIcon.fontIcon = 'fis-icon-' + currentIcon;
            const chg = new SimpleChange('', this.matIcon.fontIcon, true);
            this.matIcon.ngOnChanges({ fontIcon: chg });
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufIconDirective.prototype, "fisIcon", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufIconDirective.prototype, "rufIcon", null);
RufIconDirective = __decorate([
    Directive({ selector: '[fisIcon], [rufIcon]' }),
    __param(0, Self()),
    __param(0, Optional()),
    __metadata("design:paramtypes", [MatIcon])
], RufIconDirective);

/* tslint:disable:max-line-length */
const RUF_ICON_STYLE_VALUES = ['rotate-90', 'rotate-180', 'rotate-270', 'flip-horizontal', 'flip-vertical', 'spin', 'pulse', 'xs', 'sm', 'md', 'lg', 'xl'];
let RufIconStyleDirective = class RufIconStyleDirective {
    constructor(renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.classPrefix = 'fis-icon-';
    }
    ngOnChanges(changes) {
        if (changes.rufIconStyle) {
            const previous = this._validateValue(changes.rufIconStyle.previousValue);
            const current = this._validateValue(changes.rufIconStyle.currentValue);
            this.renderer.removeClass(this.elementRef.nativeElement, this.classPrefix + previous);
            this.renderer.addClass(this.elementRef.nativeElement, this.classPrefix + current);
        }
    }
    _validateValue(val) {
        if (RUF_ICON_STYLE_VALUES.indexOf(val) !== -1) {
            return val;
        }
        return 'md';
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], RufIconStyleDirective.prototype, "rufIconStyle", void 0);
RufIconStyleDirective = __decorate([
    Directive({
        selector: '[rufIconStyle]',
        exportAs: 'rufIconStyle'
    }),
    __metadata("design:paramtypes", [Renderer2, ElementRef])
], RufIconStyleDirective);

let RufIconModule = class RufIconModule {
};
RufIconModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [RufIconDirective, RufIconStyleDirective],
        exports: [RufIconDirective, RufIconStyleDirective, MatIconModule]
    })
], RufIconModule);

let RufDialogPanelModule = class RufDialogPanelModule {
};
RufDialogPanelModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            MatIconModule,
            MatButtonModule,
            MatDialogModule,
            RufUniqueIdModule,
            RufIconModule,
            RufUtilsModule
        ],
        declarations: [RufDialogPanelComponent, RufDialogHeaderDirective, RufDialogContentDirective, RufDialogFooterDirective],
        exports: [RufDialogPanelComponent, RufDialogHeaderDirective, RufDialogContentDirective, RufDialogFooterDirective]
    })
], RufDialogPanelModule);

var RufDynamicNavType;
(function (RufDynamicNavType) {
    RufDynamicNavType["Nav"] = "nav";
    RufDynamicNavType["Tabs"] = "tabs";
})(RufDynamicNavType || (RufDynamicNavType = {}));
let RufDynamicMenubarComponent = class RufDynamicMenubarComponent extends RufMixinBase {
    constructor(_elementRef, _renderer, _intl, changeDetectorRef) {
        super(_elementRef);
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._intl = _intl;
        this._isMenuItemClosed = false;
        this.items = [];
        this.tabLabels = [];
        this.tabSubscription = Subscription.EMPTY;
        this.selectedIndex = 0;
        this.focusedIndex = 0;
        this.closedItemIndexLessThanSelectedIndex = false;
        this.select = new EventEmitter();
        /* tslint:disable:no-output-rename */
        this.closeEmitter = new EventEmitter();
        this._intlChanges = _intl.changes.subscribe(() => changeDetectorRef.markForCheck());
        this.type = RufDynamicNavType.Nav;
    }
    get closeAriaLabel() {
        return this._closeAriaLabel || this._intl.dynamicmenubar.aria.closeIconLabel;
    }
    set closeAriaLabel(value) {
        this._closeAriaLabel = value;
    }
    get type() {
        return this._type;
    }
    set type(value) {
        this._renderer.removeClass(this._elementRef.nativeElement, `ruf-dynamic-${this._type}`);
        this._type = value || RufDynamicNavType.Nav;
        this._renderer.addClass(this._elementRef.nativeElement, `ruf-dynamic-${this._type}`);
    }
    ngOnInit() {
        // remove the body element from matTabGroup since we are never going to need it.
        const matTabGroupElem = this._elementRef.nativeElement.children[0];
        matTabGroupElem.removeChild(matTabGroupElem.children[1]);
    }
    ngAfterViewInit() {
        this.tabLabels = this.menuLabels.toArray();
        this.tabSubscription = this.menuLabels.changes.subscribe((value) => {
            this.tabLabels = value.toArray();
        });
    }
    ngOnChanges(changes) {
        if (changes.items && this.selectedIndex > -1 && this.items[this.selectedIndex]) {
            // adding a setTimeout to delay the emil call in order to avoid ExpressionChangedAfterItHasBeenCheckedError
            // need to see if there is a better solution for this
            // https://stackoverflow.com/questions/44070732/angular-4-expressionchangedafterithasbeencheckederror-expression-has-changed
            const indexToSet = this.closedItemIndexLessThanSelectedIndex ? this.selectedIndex - 1 : this.selectedIndex;
            setTimeout(() => {
                this.onSelect({ index: indexToSet });
            });
            this.closedItemIndexLessThanSelectedIndex = false;
        }
    }
    set selectedPath(path) {
        if (this.selectedPath === path) {
            return;
        }
        this._selectedPath = path;
        // Check if selectedPath match with any first level items
        let selected = path ? this.items.filter(item => this.matches(path, item)) : null;
        // If selectedPath matches with first level items, first matched item will be selected (and select event emitter will be emitted).
        if (selected && selected.length > 0) {
            if (this.selectedIndex === this.items.indexOf(selected[0])) {
                setTimeout(() => this.onSelect({ index: this.selectedIndex }));
            }
            else {
                this.selectedIndex = this.items.indexOf(selected[0]);
            }
            return;
        }
        else {
            // If selectedPath does not match with any first level item, check if matches with children of each first level item
            for (const item of this.items) {
                if (item.children && item.children.length > 0) {
                    selected = path ? item.children.filter(citem => this.matches(path, citem)) : null;
                    if (selected && selected.length > 0) {
                        // If selectedPath match with child menu, set selectedIndex to Parent and selectedPath to child menu
                        this.onChildSelect(selected[0], item);
                        return;
                    }
                }
            }
        }
        // If selectedPath does not match with first level items as well as child menu,
        // select first item.
        // FIXME: The `ngOnChange` event should take care of this. Currently it only checks for `items` changes.
        setTimeout(() => this.onSelect({ index: 0 }));
    }
    get selectedPath() {
        return this._selectedPath;
    }
    isChild(parent, childPath) {
        if (!childPath || parent.path === childPath) {
            return false;
        }
        const selected = parent.children.filter(citem => this.matches(childPath, citem));
        if (selected && selected.length > 0) {
            return true;
        }
        return false;
    }
    onSelect($event) {
        if (this.items.length > 0) {
            this.selectedIndex = $event.index;
            let selectedItem = this.items[$event.index];
            // SDHTML-18280, SDHTML-18231
            // Focus on the next element after menuitem is closed.
            // We dont need to handle focus on click and enter because focus for those events will be handled by mat-tabs.
            if (this._isMenuItemClosed) {
                this.focusTabOnIndex(this.selectedIndex);
                this._isMenuItemClosed = false;
            }
            // This condition added to avoid select emitter for parent item on selecting child item
            if (selectedItem.children && selectedItem.children.length > 0) {
                if (this.isChild(selectedItem, this._selectedPath)) {
                    return;
                }
                else {
                    selectedItem = selectedItem.children[0];
                }
            }
            this._selectedPath = selectedItem.path;
            this.select.emit(selectedItem);
        }
    }
    onFocusChange($event) {
        this.focusedIndex = $event.index;
    }
    OnSelectFocusedIndex(event) {
        this.tabLabels[this.focusedIndex].handleKeydown(event);
    }
    onChildMenuToggle(event) {
        if (!event) {
            // this.selectedIndex is used to ensure that it gives focus to parent element
            // when child is selected using mouse click.
            this.focusTabOnIndex(this.selectedIndex);
        }
    }
    onChildSelect($event, item) {
        this.selectedIndex = this.items.indexOf(item);
        this._selectedPath = $event.path;
        this.select.emit($event);
    }
    matches(path, item) {
        if (path && item.path) {
            if (path === item.path) {
                return true;
            }
        }
        return false;
    }
    close(item) {
        // check if the index of the item being closed is smaller than the item that is currently selected
        // if it is, and if the user actually closes the tab - we'll have to set the selectedIndex to selectedIndex - 1
        // otherwise the selectedItem will change
        // See https://etojira.fnfis.com/browse/SDHTML-16688 for details
        this.closedItemIndexLessThanSelectedIndex = false;
        if (this.items.indexOf(item) < this.selectedIndex) {
            this.closedItemIndexLessThanSelectedIndex = true;
        }
        this._isMenuItemClosed = true;
        this.closeEmitter.emit(item);
    }
    focusTabOnIndex(index) {
        this._elementRef.nativeElement.getElementsByClassName('mat-tab-label')[index].focus();
    }
    _handleKeydown(event, item) {
        switch (event.keyCode) {
            case ENTER:
            case SPACE:
                this.close(item);
                event.stopPropagation();
                break;
            case ESCAPE:
                this.focusTabOnIndex(this.focusedIndex);
                event.stopPropagation();
                break;
            default:
        }
    }
    ngOnDestroy() {
        this._intlChanges.unsubscribe();
        this.tabSubscription.unsubscribe();
    }
};
__decorate([
    Input(),
    __metadata("design:type", Array)
], RufDynamicMenubarComponent.prototype, "items", void 0);
__decorate([
    ViewChildren('menuLabel'),
    __metadata("design:type", QueryList)
], RufDynamicMenubarComponent.prototype, "menuLabels", void 0);
__decorate([
    Input('activeColor'),
    __metadata("design:type", Object)
], RufDynamicMenubarComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufDynamicMenubarComponent.prototype, "closeAriaLabel", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufDynamicMenubarComponent.prototype, "type", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], RufDynamicMenubarComponent.prototype, "select", void 0);
__decorate([
    Output('close'),
    __metadata("design:type", Object)
], RufDynamicMenubarComponent.prototype, "closeEmitter", void 0);
__decorate([
    ContentChild(TemplateRef, { static: false }),
    __metadata("design:type", Object)
], RufDynamicMenubarComponent.prototype, "navActions", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufDynamicMenubarComponent.prototype, "selectedPath", null);
RufDynamicMenubarComponent = __decorate([
    Component({
        selector: 'ruf-dynamic-menubar',
        template: "<mat-tab-group rufId [selectedIndex]=\"selectedIndex\" (selectedTabChange)=\"onSelect($event)\" (focusChange)=\"onFocusChange($event)\" (keydown.enter)=\"OnSelectFocusedIndex($event)\" (keydown.space)=\"OnSelectFocusedIndex($event)\">\n  <mat-tab rufId *ngFor=\"let item of items;let currentIndex=index\">\n    <ng-template matTabLabel>\n      <ruf-menu-label #menuLabel rufId [label]=\"item.label\" [icon]=\"item.icon\" [children]=\"item.children\"\n                      (select)=\"onChildSelect($event, item)\"\n                      (toggle)=\"onChildMenuToggle($event)\"\n                      [selectedPath]=\"selectedPath\">\n        <ng-template [ngTemplateOutlet]=\"navActions\" [ngTemplateOutletContext]=\"{item: item}\">\n        </ng-template>\n        <button type=\"button\" mat-icon-button rufId=\"dynamic_menubar_close_icon\" fisStyle class=\"ruf-close\" [attr.tabindex]=\"focusedIndex === currentIndex ? 0 : -1\" *ngIf=\"item.closeable === true\" (keydown)=\"_handleKeydown($event, item)\" (click)=\"close(item)\" role=\"button\" [attr.aria-label]=\"closeAriaLabel\">\n          <mat-icon fisIcon=\"close\" class=\"fis-icon-xs\"></mat-icon>\n        </button>\n      </ruf-menu-label>\n    </ng-template>\n  </mat-tab>\n</mat-tab-group>\n\n",
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: ["ruf-dynamic-menubar{-webkit-box-flex:1;flex-grow:1;overflow:hidden}ruf-dynamic-menubar.ruf-dynamic-menubar-flex-height .mat-tab-labels>.mat-tab-label{height:inherit}ruf-dynamic-menubar .mat-tab-labels>.mat-tab-label{height:2.75rem;min-width:48px;padding-left:.9375rem;padding-right:.9375rem}ruf-dynamic-menubar .mat-tab-header{border:0}ruf-dynamic-menubar .ruf-menu-label-trigger{margin-left:-.9375rem;margin-right:-.9375rem}ruf-menu-label .ruf-close.mat-icon-button[fisStyle]{margin-left:.3125rem;padding:1px 3px;-webkit-transition:text-shadow .1s ease-in,color .1s ease-in;transition:text-shadow .1s ease-in,color .1s ease-in}ruf-menu-label .ruf-close.mat-icon-button[fisStyle]:hover{text-shadow:1px 0 0}"]
    }),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        RufShellIntl,
        ChangeDetectorRef])
], RufDynamicMenubarComponent);

let RufLabeledIconComponent = class RufLabeledIconComponent {
    constructor() {
        this.fontSet = 'fisfont';
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufLabeledIconComponent.prototype, "fontSet", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RufLabeledIconComponent.prototype, "fontIcon", void 0);
RufLabeledIconComponent = __decorate([
    Component({
        selector: 'ruf-labeled-icon',
        template: "<mat-icon [fontSet]=\"fontSet\" [fontIcon]=\"fontIcon\" [class.ruf-no-text]=\"ref.childNodes.length == 0\" [class.ruf-no-icon]=\"!fontIcon\" rufId></mat-icon>\n<span #ref rufId><ng-content></ng-content></span>\n\n",
        encapsulation: ViewEncapsulation.None,
        styles: ["ruf-labeled-icon{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;min-height:24px;overflow:hidden;white-space:nowrap}ruf-labeled-icon>span{-webkit-box-flex:1;flex:1;flex-basis:auto;margin-left:.625rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}ruf-labeled-icon>mat-icon.ruf-no-text+span{margin-left:0}ruf-labeled-icon>mat-icon.ruf-no-icon{display:none}ruf-labeled-icon>mat-icon.ruf-no-icon+span{margin-left:0}"]
    })
], RufLabeledIconComponent);

let RufLabeledIconModule = class RufLabeledIconModule {
};
RufLabeledIconModule = __decorate([
    NgModule({
        imports: [CommonModule, MatIconModule, RufUniqueIdModule],
        declarations: [RufLabeledIconComponent],
        exports: [RufLabeledIconComponent]
    })
], RufLabeledIconModule);

let RufMenubarComponent = class RufMenubarComponent extends RufMixinBase {
    constructor(_elementRef, _renderer) {
        super(_elementRef);
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._selectedPathSubject = new BehaviorSubject(this._selectedPath);
        this._selectedPath$ = from(this._selectedPathSubject);
        this._activatedPathSubject = new Subject();
        this._activatedPath$ = from(this._activatedPathSubject);
        // if true, selecting automatically activates the item
        this.autoActivate = true;
        this.direction = 'row';
        /* tslint:disable:no-output-rename */
        // Renaming output to avoid duplicate `select` identifiers
        this.selectEmitter = new EventEmitter();
    }
    ngAfterViewInit() {
        this.addNewKeyboardNav();
        setTimeout(() => this.addTabIndex());
    }
    ngAfterContentInit() {
        this.menuItems.changes.subscribe(() => {
            this.addNewKeyboardNav();
            if (this._keyboardNav) {
                this._keyboardNav.setActiveItemWithoutFocus(this.selectedIndex(this.selectedPath));
            }
        });
    }
    addNewKeyboardNav() {
        this._keyboardNav = new RufKeyboardNavigation();
        this._keyboardNav.setDirection(this.direction);
        this._keyboardNav.init(this._elementRef, this.menuItems).subscribe(item => this.select(item.path, item.data));
    }
    setActiveItem(path) {
        this._keyboardNav.setActiveItemWithoutFocus(this.selectedIndex(path));
        // if path is null, set tabindex to 0 for first menuitem
        if (!path) {
            this.addTabIndex();
        }
    }
    firstChild() {
        return this.menuItems ? this.menuItems.toArray()[0] : null;
    }
    addTabIndex() {
        if (this.firstChild()) {
            this.firstChild().tabindex = 0;
        }
    }
    selectedIndex(path) {
        let index = 0;
        if (path && this.menuItems) {
            index = this.menuItems.toArray().findIndex(menuItem => {
                return menuItem.matches(path);
            });
        }
        return index;
    }
    select(path, data, event) {
        if (!path) {
            this._selectedPath = null;
            return;
        }
        this.selectEmitter.emit({
            path: path,
            data: data,
            event: event
        });
        if (this.autoActivate) {
            this.activate(path);
        }
        this._keyboardNav.focus(path);
        this._activatedPathSubject.next(path);
    }
    activate(path) {
        this._selectedPath = path;
        this._selectedPathSubject.next(path);
    }
    // Selection of an item is driven by this input if it is used.
    // Otherwise, the select method (which is invoked on click of an item) changes the selectedPath automatically.
    // If this property setter is invoked, it turns off automatic selection.
    // Normally, this should only happen when a selectedPath property binding is used.
    set selectedPath(path) {
        this.autoActivate = false;
        this.activate(path);
    }
    get selectedPath() {
        return this._selectedPath;
    }
    get selectedPath$() {
        return this._selectedPath$;
    }
    get activatedPath$() {
        return this._activatedPath$;
    }
    set inkbarPosition(position) {
        this._updateInkbarPosition(position === 'start' ? position : 'end');
    }
    get inkbarPosition() {
        return this._inkbarPosition;
    }
    getLayoutClass() {
        return {
            'ruf-menubar-layout': true,
            'ruf-layout-row': this.direction !== 'column',
            'ruf-layout-column': this.direction === 'column',
            'ruf-layout-row-xs': this.directionXs === 'row',
            'ruf-layout-column-xs': this.directionXs === 'column',
            'ruf-layout-row-sm': this.directionSm === 'row',
            'ruf-layout-column-sm': this.directionSm === 'column',
            'ruf-layout-row-md': this.directionMd === 'row',
            'ruf-layout-column-md': this.directionMd === 'column',
            'ruf-layout-row-lg': this.directionLg === 'row',
            'ruf-layout-column-lg': this.directionLg === 'column',
            'ruf-layout-row-xl': this.directionXl === 'row',
            'ruf-layout-column-xl': this.directionXl === 'column',
            'ruf-layout-row-gt-xs': this.directionGtXs === 'row',
            'ruf-layout-column-gt-xs': this.directionGtXs === 'column',
            'ruf-layout-row-gt-sm': this.directionGtSm === 'row',
            'ruf-layout-column-gt-sm': this.directionGtSm === 'column',
            'ruf-layout-row-gt-md': this.directionGtMd === 'row',
            'ruf-layout-column-gt-md': this.directionGtMd === 'column',
            'ruf-layout-row-gt-lg': this.directionGtLg === 'row',
            'ruf-layout-column-gt-lg': this.directionGtLg === 'column',
            'ruf-layout-row-lt-sm': this.directionLtSm === 'row',
            'ruf-layout-column-lt-sm': this.directionLtSm === 'column',
            'ruf-layout-row-lt-md': this.directionLtMd === 'row',
            'ruf-layout-column-lt-md': this.directionLtMd === 'column',
            'ruf-layout-row-lt-lg': this.directionLtLg === 'row',
            'ruf-layout-column-lt-lg': this.directionLtLg === 'column',
            'ruf-layout-row-lt-xl': this.directionLtXl === 'row',
            'ruf-layout-column-lt-xl': this.directionLtXl === 'column'
        };
    }
    _updateInkbarPosition(position) {
        this._renderer.removeClass(this._elementRef.nativeElement, `ruf-menubar-inkbar-${this._inkbarPosition}`);
        this._renderer.addClass(this._elementRef.nativeElement, `ruf-menubar-inkbar-${position}`);
        this._inkbarPosition = position;
    }
    onKey(event) {
        if (this._keyboardNav && this._keyboardNav.isActive()) {
            this._keyboardNav.onKeyDown(event);
        }
    }
};
__decorate([
    Input('activeColor'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "direction", void 0);
__decorate([
    Input('direction.xs'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "directionXs", void 0);
__decorate([
    Input('direction.sm'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "directionSm", void 0);
__decorate([
    Input('direction.md'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "directionMd", void 0);
__decorate([
    Input('direction.lg'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "directionLg", void 0);
__decorate([
    Input('direction.xl'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "directionXl", void 0);
__decorate([
    Input('direction.gt-xs'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "directionGtXs", void 0);
__decorate([
    Input('direction.gt-sm'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "directionGtSm", void 0);
__decorate([
    Input('direction.gt-md'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "directionGtMd", void 0);
__decorate([
    Input('direction.gt-lg'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "directionGtLg", void 0);
__decorate([
    Input('direction.lt-sm'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "directionLtSm", void 0);
__decorate([
    Input('direction.lt-md'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "directionLtMd", void 0);
__decorate([
    Input('direction.lt-lg'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "directionLtLg", void 0);
__decorate([
    Input('direction.lt-xl'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "directionLtXl", void 0);
__decorate([
    Output('select'),
    __metadata("design:type", Object)
], RufMenubarComponent.prototype, "selectEmitter", void 0);
__decorate([
    ContentChildren(forwardRef(() => RufMenubarItemComponent)),
    __metadata("design:type", QueryList)
], RufMenubarComponent.prototype, "menuItems", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufMenubarComponent.prototype, "selectedPath", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufMenubarComponent.prototype, "inkbarPosition", null);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], RufMenubarComponent.prototype, "onKey", null);
RufMenubarComponent = __decorate([
    Component({
        selector: 'ruf-menubar',
        template: "<div [ngClass]=\"getLayoutClass()\" role=\"menubar\">\n  <ng-content></ng-content>\n</div>\n",
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: ["ruf-menubar{-ms-grid-row-align:stretch;align-self:stretch;display:block}.ruf-menubar-layout{-webkit-box-align:stretch;align-items:stretch;height:100%}.ruf-menu-item{-webkit-box-align:center;align-items:center;border-color:transparent;cursor:pointer;display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1 auto;-webkit-transition:background-color .2s;transition:background-color .2s}.ruf-menu-item:focus{outline:0}.ruf-layout-row{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-menubar-layout.ruf-layout-column{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-menubar-layout.ruf-layout-column>ul{padding-left:0}.ruf-menubar-layout.ruf-layout-column .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}@media (min-width:0) and (max-width:599px){.ruf-layout-row-xs{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-xs>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-xs .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-xs{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-xs>ul{padding-left:0}.ruf-layout-column-xs .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:600px) and (max-width:959px){.ruf-layout-row-sm{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-sm>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-sm .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-sm{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-sm>ul{padding-left:0}.ruf-layout-column-sm .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:960px) and (max-width:1279px){.ruf-layout-row-md{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-md>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-md .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-md{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-md>ul{padding-left:0}.ruf-layout-column-md .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1280px) and (max-width:1919px){.ruf-layout-row-lg{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-lg>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-lg .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-lg{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-lg>ul{padding-left:0}.ruf-layout-column-lg .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1920px){.ruf-layout-row-xl{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-xl>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-xl .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-xl{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-xl>ul{padding-left:0}.ruf-layout-column-xl .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:600px){.ruf-layout-row-gt-xs{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-xs>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-xs .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-xs{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-xs>ul{padding-left:0}.ruf-layout-column-gt-xs .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:960px){.ruf-layout-row-gt-sm{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-sm>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-sm .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-sm{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-sm>ul{padding-left:0}.ruf-layout-column-gt-sm .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1280px){.ruf-layout-row-gt-md{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-md>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-md .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-md{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-md>ul{padding-left:0}.ruf-layout-column-gt-md .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1920px){.ruf-layout-row-gt-lg{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-lg>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-lg .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-lg{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-lg>ul{padding-left:0}.ruf-layout-column-gt-lg .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}"]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], RufMenubarComponent);

let RufMenubarItemComponent = class RufMenubarItemComponent {
    // this can probably only be achieved in nav-menubar
    // @HostBinding('attr.aria-haspopup') hasPopup = true;
    constructor(menubar, _elementRef) {
        this.menubar = menubar;
        this._elementRef = _elementRef;
        this.unsubscribe = new Subject();
        this.selectable = true;
        this.menuitem = true;
        this.role = 'menuitem';
        this.tabindex = -1;
        this.active = false;
    }
    ngAfterContentInit() {
        this.menubar.selectedPath$.pipe(takeUntil(this.unsubscribe), distinctUntilChanged())
            .subscribe((path) => {
            this.active = this.matches(path);
            setTimeout(() => {
                this.tabindex = this.active ? 0 : -1;
                this.menubar.setActiveItem(path);
            });
        });
        this.menubar.activatedPath$.pipe(takeUntil(this.unsubscribe), distinctUntilChanged())
            .subscribe((path) => {
            const match = this.matches(path);
            setTimeout(() => this.tabindex = match ? 0 : -1);
        });
    }
    ngOnDestroy() {
        this.unsubscribe.next();
        this.unsubscribe.complete();
    }
    onClick(event) {
        if (!event.cancelBubble) {
            if (this.selectable) {
                this.menubar.select(this.path, this.data, event);
            }
            else {
                // still change activated state since user clicked on the item
                this.menubar.activate(this.path);
            }
        }
    }
    focus() {
        if (this._elementRef) {
            this._elementRef.nativeElement.focus();
        }
    }
    matches(selectedPath) {
        if (selectedPath && this.path) {
            const pattern = new RegExp('^((\/)?' + this.path + ')(\/.*)?$'); // use word boundary to exact match
            if (selectedPath === this.path || pattern.test(selectedPath)) { // match with current menuitem and with parent menuitem
                return true;
            }
        }
        return false;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], RufMenubarItemComponent.prototype, "path", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufMenubarItemComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufMenubarItemComponent.prototype, "selectable", void 0);
__decorate([
    HostBinding('class.ruf-menu-item'),
    __metadata("design:type", Object)
], RufMenubarItemComponent.prototype, "menuitem", void 0);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", Object)
], RufMenubarItemComponent.prototype, "role", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Object)
], RufMenubarItemComponent.prototype, "tabindex", void 0);
__decorate([
    HostBinding('class.ruf-menubar-item-active'),
    __metadata("design:type", Object)
], RufMenubarItemComponent.prototype, "active", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], RufMenubarItemComponent.prototype, "onClick", null);
RufMenubarItemComponent = __decorate([
    Component({
        selector: 'ruf-menubar-item, [rufMenubarItem]',
        template: `
      <ng-content></ng-content>
  `,
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [RufMenubarComponent, ElementRef])
], RufMenubarItemComponent);

let RufMenubarModule = class RufMenubarModule {
};
RufMenubarModule = __decorate([
    NgModule({
        imports: [CommonModule, RufUniqueIdModule],
        providers: [RufKeyboardNavigation],
        declarations: [RufMenubarComponent, RufMenubarItemComponent],
        exports: [RufMenubarComponent, RufMenubarItemComponent]
    })
], RufMenubarModule);

let RufMenuLabelComponent = class RufMenuLabelComponent {
    constructor() {
        this.label = '';
        this.icon = '';
        // on child menu toggle
        this.toggle = new EventEmitter();
        this.select = new EventEmitter();
        this.rowLayout = true; // tells the internal labeled-icon that it is in a row.
    }
    handleClick(event) {
        // labels with children will not propagate the click event by default
        if (this.children && this.children.length > 0) {
            event.preventDefault();
            event.stopPropagation();
        }
    }
    hasPopup() {
        return this.children ? this.children.length > 0 : false;
    }
    onClose() {
        this.toggle.emit(false);
    }
    handleKeydown(event) {
        if (!this.children || this.children.length === 0) {
            return;
        }
        switch (event.keyCode) {
            case SPACE:
            case ENTER:
                this.trigger.openMenu();
                if (this.trigger.menu) {
                    // This is needed for dynamic menubar since it uses setTimeout for selecting a tab.
                    // This should be removed when we refactor dynamic menubar.
                    setTimeout(() => {
                        this.trigger.menu.focusFirstItem();
                    });
                }
                event.preventDefault();
                event.stopPropagation();
                this.toggle.emit(true);
                break;
            case ESCAPE:
                this.trigger.closeMenu();
                this.toggle.emit(false);
                event.stopPropagation();
                break;
            default:
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufMenuLabelComponent.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufMenuLabelComponent.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], RufMenuLabelComponent.prototype, "children", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], RufMenuLabelComponent.prototype, "toggle", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], RufMenuLabelComponent.prototype, "select", void 0);
__decorate([
    HostBinding('class.ruf-layout-row'),
    __metadata("design:type", Object)
], RufMenuLabelComponent.prototype, "rowLayout", void 0);
__decorate([
    ViewChild(MatMenuTrigger, { static: false }),
    __metadata("design:type", MatMenuTrigger)
], RufMenuLabelComponent.prototype, "trigger", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RufMenuLabelComponent.prototype, "selectedPath", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], RufMenuLabelComponent.prototype, "handleClick", null);
RufMenuLabelComponent = __decorate([
    Component({
        selector: 'ruf-menu-label',
        template: "<div class=\"ruf-menu-label-wrap\" rufId>\n  <!-- ideally, Angular would support putting matMenuTriggerFor on the host -->\n  <div class=\"ruf-menu-label-trigger\" *ngIf=\"children && children.length > 0\" [matMenuTriggerFor]=\"menu\" (menuClosed)=\"toggle.emit(false)\" (menuOpened)=\"toggle.emit(true)\"></div>\n  <ruf-labeled-icon fontSet=\"fisfont\" [fontIcon]=\"icon\" rufId>\n    <span class=\"ruf-menu-label-container\">\n      {{ label }}\n      <mat-icon class=\"ruf-menu-label-chevron\" aria-hidden=\"true\" rufId=\"menu_label_link\" *ngIf=\"children && children.length > 0\" fisIcon=\"arrow-down\"></mat-icon>\n    </span>\n\n    <span (click)=\"$event.stopPropagation()\" rufId=\"menu_label_content\">\n      <ng-content></ng-content>\n    </span>\n  </ruf-labeled-icon>\n</div>\n\n<mat-menu class=\"ruf-cust-menu\" rufId=\"menu\" #menu=\"matMenu\" yPosition=\"below\" [overlapTrigger]=\"false\">\n  <button type=\"button\" rufId=\"menu_button\" *ngFor=\"let child of children\" mat-menu-item (click)=\"select.emit(child)\"\n          [class.ruf-menu-selected]=\"selectedPath && child.path === selectedPath\"\n          [attr.aria-selected]=\"selectedPath && child.path === selectedPath\">\n    <mat-icon rufId=\"menu_icon\" *ngIf=\"child.icon\" fontSet=\"fisfont\" [fontIcon]=\"child.icon\"></mat-icon>\n    <span>{{ child.label }}</span>\n  </button>\n</mat-menu>\n",
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: ["ruf-menu-label{display:block!important;min-width:100%}ruf-menu-label ruf-labeled-icon{-webkit-box-pack:center;justify-content:center;width:100%}ruf-menu-label ruf-labeled-icon>span{-webkit-box-flex:0;flex:0 1 auto}.ruf-menu-label-wrap{position:relative}.ruf-menu-label-trigger{bottom:0;left:0;position:absolute;right:0;top:0}.ruf-menu-label-chevron{color:currentColor;margin-left:5px}.ruf-menu-label-container{-webkit-box-align:center;align-items:center;display:-webkit-inline-box;display:inline-flex}.ruf-cust-menu .mat-menu-content{border-style:solid;border-width:0 1px 1px;min-width:7.5rem;padding-bottom:0;padding-top:0}.ruf-cust-menu .mat-menu-content .mat-menu-item{height:2.75rem;line-height:2.75rem}.ruf-cust-menu .mat-menu-content .ruf-menu-selected{text-decoration:underline}"]
    })
], RufMenuLabelComponent);

/**
 * Throws an exception for the case when dropdown trigger doesn't have a valid ruf-dropdown-panel instance
 * @docs-private
 */
function throwTargetMissingError() {
    throw Error(`rufTrigger: must pass in RufTriggerTarget instance.
    Example:
    <button [rufTrigger]="menuLabel">Open menu</button>
    <ruf-menu-label #menuLabel ...></ruf-menu-label>
    `);
}

let RufTriggerDirective = class RufTriggerDirective extends CdkOverlayOrigin {
    constructor(elRef, renderer) {
        super(elRef);
        this.elRef = elRef;
        this.renderer = renderer;
        this.subscription = Subscription.EMPTY;
    }
    ngAfterViewInit() {
        this._checkTarget();
        if (this.target.hasPopup()) {
            this.renderer.setAttribute(this.elRef.nativeElement, 'aria-haspopup', 'true');
            this.renderer.setAttribute(this.elRef.nativeElement, 'aria-expanded', 'false');
        }
        else {
            this.renderer.removeAttribute(this.elRef.nativeElement, 'aria-haspopup');
            this.renderer.removeAttribute(this.elRef.nativeElement, 'aria-expanded');
        }
        if (this.subscription === Subscription.EMPTY) {
            this.subscription = this.target.toggle.subscribe((opened) => {
                this.renderer.setAttribute(this.elRef.nativeElement, 'aria-expanded', opened ? 'true' : 'false');
                if (!opened) {
                    this.elRef.nativeElement.focus();
                }
            });
        }
    }
    handleClickEvent(event) {
        this.target.handleClick(event);
    }
    handleKeydownEvent(event) {
        this.target.handleKeydown(event);
    }
    _checkTarget() {
        if (!this.target) {
            throwTargetMissingError();
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
};
__decorate([
    Input('rufTrigger'),
    __metadata("design:type", Object)
], RufTriggerDirective.prototype, "target", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], RufTriggerDirective.prototype, "handleClickEvent", null);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], RufTriggerDirective.prototype, "handleKeydownEvent", null);
RufTriggerDirective = __decorate([
    Directive({
        selector: '[rufTrigger]',
        exportAs: 'rufTrigger'
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], RufTriggerDirective);

let RufTriggerModule = class RufTriggerModule {
};
RufTriggerModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [RufTriggerDirective],
        exports: [RufTriggerDirective]
    })
], RufTriggerModule);

let RufMenuLabelModule = class RufMenuLabelModule {
};
RufMenuLabelModule = __decorate([
    NgModule({
        imports: [CommonModule,
            MatMenuModule,
            MatIconModule,
            RufLabeledIconModule,
            RufUniqueIdModule,
            RufIconModule,
            RufTriggerModule
        ],
        declarations: [RufMenuLabelComponent],
        exports: [RufMenuLabelComponent]
    })
], RufMenuLabelModule);

let RufDynamicMenubarModule = class RufDynamicMenubarModule {
};
RufDynamicMenubarModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            MatTabsModule,
            MatButtonModule,
            RufLabeledIconModule,
            RufMenubarModule,
            RufMenuLabelModule,
            RufUniqueIdModule,
            RufUtilsModule,
            RufIconModule,
            RufTriggerModule
        ],
        declarations: [RufDynamicMenubarComponent],
        exports: [RufDynamicMenubarComponent]
    })
], RufDynamicMenubarModule);

let RufDynamicSideMenuComponent = class RufDynamicSideMenuComponent {
    constructor(document, _renderer, _mediaObserver, _elementRef) {
        this.document = document;
        this._renderer = _renderer;
        this._mediaObserver = _mediaObserver;
        this._elementRef = _elementRef;
        this.items = [];
        this._inkbarPosition = this._inkbarPosition || 'start';
        this.multi = true;
        this._select = new EventEmitter();
        // @HostBinding('class.ruf-dynamic-sidemenu-minimized')
        this.minimized = false;
        this.minimizedXs = false;
        this.minimizedSm = false;
        this.minimizedMd = false;
        this.minimizedLg = false;
        this.minimizedXl = false;
        this.minimizedGtXs = false;
        this.minimizedGtSm = false;
        this.minimizedGtMd = false;
        this.minimizedGtLg = false;
    }
    isMinimized() {
        return [
            this.minimized,
            this.minimizedXs && this._mediaObserver.isActive('xs'),
            this.minimizedSm && this._mediaObserver.isActive('sm'),
            this.minimizedMd && this._mediaObserver.isActive('md'),
            this.minimizedLg && this._mediaObserver.isActive('lg'),
            this.minimizedXl && this._mediaObserver.isActive('xl'),
            this.minimizedGtXs && this._mediaObserver.isActive('gt-xs'),
            this.minimizedGtSm && this._mediaObserver.isActive('gt-sm'),
            this.minimizedGtMd && this._mediaObserver.isActive('gt-md'),
            this.minimizedGtLg && this._mediaObserver.isActive('gt-lg')
        ].some(x => x === true);
    }
    onSelect($event) {
        if (!($event.data && $event.data.children)) {
            this._selectedPath = $event.path;
            this._select.emit($event.data);
        }
        else if ($event && $event.event) {
            $event.event.preventDefault();
            $event.event.stopPropagation();
        }
    }
    getRufId(item) {
        return 'dynamic_sidemenu_' + item.label.toLowerCase().replace(/ /g, '_');
    }
    closeMenu() {
        this.menuTrigger.closeMenu();
    }
    setPopupData(event, data) {
        this.sideMenuPopupData = data;
        event.currentTarget.classList.add('ruf-active');
        // focus on the first menu item
        setTimeout(() => {
            const cdkOverlayClass = `.ruf-sidemenu-popup-backdrop + .cdk-overlay-connected-position-bounding-box`;
            const cdkOverlayElement = this.document.querySelector(cdkOverlayClass);
            if (cdkOverlayElement) {
                // set left position for cdkOverlay based on the position of menuitem.
                // so we need to get left and width value from BoundingClientRect;
                const rufMenuItem = this._elementRef.nativeElement.querySelector('.ruf-menu-item');
                const rufMenuItemClientTect = rufMenuItem.getBoundingClientRect();
                cdkOverlayElement.style.left = rufMenuItemClientTect.left + rufMenuItemClientTect.width + 'px';
                const firstMenuItem = this.document.querySelector(`${cdkOverlayClass} .ruf-menu-item`);
                if (firstMenuItem) {
                    firstMenuItem.focus();
                }
            }
        });
    }
    onPopupClose() {
        // remove active class when popop is closed
        const currentActiveItem = this._elementRef.nativeElement.querySelector('.ruf-menu-item.ruf-active');
        if (currentActiveItem) {
            currentActiveItem.focus();
            this._renderer.removeClass(currentActiveItem, 'ruf-active');
        }
    }
    keyHandler(event) {
        switch (event.keyCode) {
            case ENTER:
            case SPACE:
                event.currentTarget.click();
                break;
            default:
        }
    }
    getOverlayClasses() {
        const colorClass = this._activeColor ? `ruf-${this._activeColor}` : ``;
        return `${this.popupBackgroundClass} ${colorClass} ruf-menubar-inkbar-${this._inkbarPosition}`;
    }
    toggleChildItems(currentTrigger) {
        if (this.multi === false) {
            this._triggers.toArray()
                .filter((element) => element.value === true && element !== currentTrigger)
                .forEach((element) => {
                element.value = false;
            });
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", Array)
], RufDynamicSideMenuComponent.prototype, "items", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RufDynamicSideMenuComponent.prototype, "popupBackgroundClass", void 0);
__decorate([
    ViewChild(MatMenuTrigger, { static: false }),
    __metadata("design:type", MatMenuTrigger)
], RufDynamicSideMenuComponent.prototype, "menuTrigger", void 0);
__decorate([
    ViewChild('menuTrigger', { static: false }),
    __metadata("design:type", ElementRef)
], RufDynamicSideMenuComponent.prototype, "trigger", void 0);
__decorate([
    Input('selectedPath'),
    __metadata("design:type", String)
], RufDynamicSideMenuComponent.prototype, "_selectedPath", void 0);
__decorate([
    Input('activeColor'),
    __metadata("design:type", String)
], RufDynamicSideMenuComponent.prototype, "_activeColor", void 0);
__decorate([
    Input('inkbarPosition'),
    __metadata("design:type", Object)
], RufDynamicSideMenuComponent.prototype, "_inkbarPosition", void 0);
__decorate([
    Input('multi'),
    __metadata("design:type", Object)
], RufDynamicSideMenuComponent.prototype, "multi", void 0);
__decorate([
    Output('select'),
    __metadata("design:type", Object)
], RufDynamicSideMenuComponent.prototype, "_select", void 0);
__decorate([
    ViewChildren('trigger'),
    __metadata("design:type", QueryList)
], RufDynamicSideMenuComponent.prototype, "_triggers", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufDynamicSideMenuComponent.prototype, "minimized", void 0);
__decorate([
    Input('minimized.xs'),
    __metadata("design:type", Object)
], RufDynamicSideMenuComponent.prototype, "minimizedXs", void 0);
__decorate([
    Input('minimized.sm'),
    __metadata("design:type", Object)
], RufDynamicSideMenuComponent.prototype, "minimizedSm", void 0);
__decorate([
    Input('minimized.md'),
    __metadata("design:type", Object)
], RufDynamicSideMenuComponent.prototype, "minimizedMd", void 0);
__decorate([
    Input('minimized.lg'),
    __metadata("design:type", Object)
], RufDynamicSideMenuComponent.prototype, "minimizedLg", void 0);
__decorate([
    Input('minimized.xl'),
    __metadata("design:type", Object)
], RufDynamicSideMenuComponent.prototype, "minimizedXl", void 0);
__decorate([
    Input('minimized.gt-xs'),
    __metadata("design:type", Object)
], RufDynamicSideMenuComponent.prototype, "minimizedGtXs", void 0);
__decorate([
    Input('minimized.gt-sm'),
    __metadata("design:type", Object)
], RufDynamicSideMenuComponent.prototype, "minimizedGtSm", void 0);
__decorate([
    Input('minimized.gt-md'),
    __metadata("design:type", Object)
], RufDynamicSideMenuComponent.prototype, "minimizedGtMd", void 0);
__decorate([
    Input('minimized.gt-lg'),
    __metadata("design:type", Object)
], RufDynamicSideMenuComponent.prototype, "minimizedGtLg", void 0);
RufDynamicSideMenuComponent = __decorate([
    Component({
        selector: 'ruf-dynamic-sidemenu',
        template: "<ruf-sidemenu rufId=\"dynamic_sidemenu\" [activeColor]=\"_activeColor\"\n   [inkbarPosition]=\"_inkbarPosition\"\n   [selectedPath]=\"_selectedPath\"\n   [ngClass]=\"{'ruf-dynamic-sidemenu-minimized': isMinimized()}\"\n   (select)=\"onSelect($event)\">\n\n  <ng-container *ngFor=\"let item of items\">\n    <a [rufId]=\"getRufId(item)\" [data]=\"item\" *ngIf=\"!item.children || item.children.length === 0 \" [path]=\"item.path\"\n      rufSidemenuItem>\n      <mat-icon *ngIf=\"isMinimized()\" [fontIcon]=\"item.icon\"></mat-icon>\n      <ruf-labeled-icon *ngIf=\"!isMinimized()\" [fontIcon]=\"item.icon\" [ngClass]=\"{'sidemenu-item-with-no-icon': !item.icon}\">{{item.label}}\n      </ruf-labeled-icon>\n    </a>\n    <ng-container *ngIf=\"item.children && item.children.length > 0\">\n      <ng-container *ngIf=\"!isMinimized(); else minimizedTemplate\">\n        <a [rufId]=\"getRufId(item)\" [data]=\"item\" [path]=\"item.path\" rufSidemenuItem rufToggleChevron\n         #trigger=\"rufToggle\" (toggleChange)=\"toggleChildItems(trigger)\">\n          <ruf-labeled-icon [fontIcon]=\"item.icon\" [ngClass]=\"{'sidemenu-item-with-no-icon': !item.icon}\">{{item.label}}\n          </ruf-labeled-icon>\n        </a>\n        <ruf-sidemenu-children [rufId]=\"getRufId(item)+'_children'\" [visible]=\"trigger.value\"\n          [menuTrigger]=\"trigger\">\n          <a rufId *ngFor=\"let child of item.children\" [data]=\"child\" [path]=\"child.path\" rufSidemenuItem>\n            <ruf-labeled-icon [fontIcon]=\"child.icon\" [ngClass]=\"{'sidemenu-item-with-no-icon': !child.icon}\">{{child.label}}\n            </ruf-labeled-icon>\n          </a>\n        </ruf-sidemenu-children>\n      </ng-container>\n\n      <ng-template #minimizedTemplate>\n        <a [rufId]=\"getRufId(item)\"\n           [data]=\"item\"\n           [path]=\"item.path\"\n           rufSidemenuItem\n           #menuTrigger\n           [matMenuTriggerFor]=\"sideMenuPopup\"\n           (click)=\"setPopupData($event, item)\"\n           (keydown)=\"keyHandler($event)\">\n          <mat-icon [fontIcon]=\"item.icon\"></mat-icon>\n          <mat-icon fisIcon=\"arrow-down\" rufIconStyle=\"xs\" class=\"ruf-expand-sidemenu-popup-icon\"></mat-icon>\n      </a>\n      </ng-template>\n    </ng-container>\n\n  </ng-container>\n\n  <mat-menu #sideMenuPopup=\"matMenu\" overlapTrigger=\"true\" [class]=\"getOverlayClasses()\" (closed)=\"onPopupClose()\"\n    backdropClass=\"ruf-sidemenu-popup-backdrop\">\n    <ruf-sidemenu-children *ngIf=\"sideMenuPopupData\" rufId=\"ruf-sidemenu-children-items-popup\">\n      <p class=\"ruf-side-menu-popup-title\">{{sideMenuPopupData?.label}}</p>\n      <a rufId *ngFor=\"let child of sideMenuPopupData?.children\" [data]=\"child\" [path]=\"child.path\" (keydown.enter)=\"closeMenu()\"\n        rufSidemenuItem>\n        <span>{{child.label}}</span>\n    </a>\n    </ruf-sidemenu-children>\n  </mat-menu>\n</ruf-sidemenu>\n",
        encapsulation: ViewEncapsulation.None,
        styles: ["ruf-dynamic-sidemenu .sidemenu-item-with-no-icon .mat-icon{visibility:hidden;width:0}ruf-dynamic-sidemenu .sidemenu-item-with-no-icon span{margin-left:0}ruf-dynamic-sidemenu ruf-labeled-icon{white-space:normal}ruf-dynamic-sidemenu ruf-sidemenu.ruf-dynamic-sidemenu-minimized{box-shadow:none;min-width:auto}ruf-dynamic-sidemenu ruf-sidemenu.ruf-dynamic-sidemenu-minimized .ruf-menubar-layout.ruf-layout-column .ruf-menu-item{padding-right:0}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel{border-radius:0;box-shadow:none}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel.ruf-menubar-inkbar-start .ruf-menu-item{border-left-width:.25rem;border-left-style:solid}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel.ruf-menubar-inkbar-end .ruf-menu-item{border-right-width:.25rem;border-right-style:solid}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-menu-item{padding-left:.9375rem;padding-right:.9375rem}.ruf-expand-sidemenu-popup-icon{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex}.ruf-side-menu-popup-title{padding-left:1.1875rem}"]
    }),
    __param(0, Inject(DOCUMENT)),
    __metadata("design:paramtypes", [Object, Renderer2,
        MediaObserver,
        ElementRef])
], RufDynamicSideMenuComponent);

/**
 * Directive that can be applied on any element, and that toggles an attribute that can be used by the underlying element as need be.
 */
let RufToggleDirective = class RufToggleDirective extends CdkOverlayOrigin {
    constructor(elRef) {
        super(elRef);
        this.elRef = elRef;
        // boolean property that gets toggled when the underlying element is clicked
        // tslint:disable-next-line:no-input-rename
        this.value = false;
        this.chevron = false;
        this.arrow = false;
        this.toggleChange = new EventEmitter();
        this.toggle = true;
    }
    get active() {
        return this.value;
    }
    set rufToggle(val) {
        this.value = val || false;
    }
    set rufToggleChevron(val) {
        this.arrow = false;
        this.chevron = true;
        this.value = val || false;
    }
    set rufToggleArrow(val) {
        this.arrow = true;
        this.chevron = false;
        this.value = val || false;
    }
    get normal() {
        return !this.chevron && !this.arrow;
    }
    // select should focus the element and toggle value
    select(event) {
        this.elRef.nativeElement.focus();
        this.toggleValue(event);
    }
    toggleValue(event) {
        event.stopPropagation();
        event.preventDefault();
        // For Safari browser, event.stopPropagation() is not setting the value of
        // event.cancelBubble as true. So, we need to explicitly set it.
        event.cancelBubble = true;
        this.value = !this.value;
        this.toggleChange.emit({ trigger: this.elRef, value: this.value, event: event });
    }
    onClick(event) {
        this.toggleValue(event);
    }
    onKey(event) {
        switch (event.keyCode) {
            case ENTER:
            case SPACE:
                this.toggleValue(event);
                break;
            default:
        }
    }
};
__decorate([
    HostBinding('class.ruf-toggle-active'),
    __metadata("design:type", Object)
], RufToggleDirective.prototype, "value", void 0);
__decorate([
    HostBinding('class.ruf-toggle-chevron'),
    __metadata("design:type", Object)
], RufToggleDirective.prototype, "chevron", void 0);
__decorate([
    HostBinding('class.ruf-toggle-arrow'),
    __metadata("design:type", Object)
], RufToggleDirective.prototype, "arrow", void 0);
__decorate([
    HostBinding('class.ruf-active'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], RufToggleDirective.prototype, "active", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], RufToggleDirective.prototype, "rufToggle", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], RufToggleDirective.prototype, "rufToggleChevron", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], RufToggleDirective.prototype, "rufToggleArrow", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], RufToggleDirective.prototype, "toggleChange", void 0);
__decorate([
    HostBinding('class.ruf-toggle'),
    __metadata("design:type", Object)
], RufToggleDirective.prototype, "toggle", void 0);
__decorate([
    HostBinding('class.ruf-toggle-normal'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], RufToggleDirective.prototype, "normal", null);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], RufToggleDirective.prototype, "onClick", null);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], RufToggleDirective.prototype, "onKey", null);
RufToggleDirective = __decorate([
    Directive({
        selector: '[rufToggle], [rufToggleChevron], [rufToggleArrow]',
        exportAs: 'rufToggle'
    }),
    __metadata("design:paramtypes", [ElementRef])
], RufToggleDirective);

let RufToggleModule = class RufToggleModule {
};
RufToggleModule = __decorate([
    NgModule({
        imports: [CommonModule, OverlayModule],
        declarations: [RufToggleDirective],
        exports: [RufToggleDirective]
    })
], RufToggleModule);

let RufSidemenuItemComponent = class RufSidemenuItemComponent extends RufMenubarItemComponent {
    constructor(menubar, _elementRef) {
        super(menubar);
        this.menubar = menubar;
        this._elementRef = _elementRef;
    }
};
RufSidemenuItemComponent = __decorate([
    Component({
        selector: 'ruf-sidemenu-item, [rufSidemenuItem]',
        template: `
      <ng-content></ng-content>
  `,
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __param(0, Inject(forwardRef(() => RufSidemenuComponent))),
    __metadata("design:paramtypes", [RufSidemenuComponent,
        ElementRef])
], RufSidemenuItemComponent);

let RufSidemenuComponent = class RufSidemenuComponent extends RufMenubarComponent {
    constructor(_elementRef, _renderer) {
        super(_elementRef, _renderer);
        this.direction = 'column';
        this.inkbarPosition = 'start';
        this.orientation = 'vertical';
    }
};
__decorate([
    HostBinding('attr.aria-orientation'),
    __metadata("design:type", Object)
], RufSidemenuComponent.prototype, "orientation", void 0);
__decorate([
    ContentChildren(forwardRef(() => RufSidemenuItemComponent)),
    __metadata("design:type", QueryList)
], RufSidemenuComponent.prototype, "menuItems", void 0);
RufSidemenuComponent = __decorate([
    Component({
        selector: 'ruf-sidemenu',
        template: "<div [ngClass]=\"getLayoutClass()\" role=\"menubar\">\n  <ng-content></ng-content>\n</div>\n",
        encapsulation: ViewEncapsulation.None,
        providers: [RufMenubarComponent],
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: ["ruf-menubar{-ms-grid-row-align:stretch;align-self:stretch;display:block}.ruf-menubar-layout{-webkit-box-align:stretch;align-items:stretch;height:100%}.ruf-menu-item{-webkit-box-align:center;align-items:center;border-color:transparent;cursor:pointer;display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1 auto;-webkit-transition:background-color .2s;transition:background-color .2s}.ruf-menu-item:focus{outline:0}.ruf-layout-row{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-menubar-layout.ruf-layout-column{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-menubar-layout.ruf-layout-column>ul{padding-left:0}.ruf-menubar-layout.ruf-layout-column .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}@media (min-width:0) and (max-width:599px){.ruf-layout-row-xs{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-xs>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-xs .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-xs{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-xs>ul{padding-left:0}.ruf-layout-column-xs .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:600px) and (max-width:959px){.ruf-layout-row-sm{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-sm>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-sm .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-sm{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-sm>ul{padding-left:0}.ruf-layout-column-sm .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:960px) and (max-width:1279px){.ruf-layout-row-md{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-md>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-md .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-md{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-md>ul{padding-left:0}.ruf-layout-column-md .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1280px) and (max-width:1919px){.ruf-layout-row-lg{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-lg>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-lg .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-lg{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-lg>ul{padding-left:0}.ruf-layout-column-lg .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1920px){.ruf-layout-row-xl{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-xl>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-xl .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-xl{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-xl>ul{padding-left:0}.ruf-layout-column-xl .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:600px){.ruf-layout-row-gt-xs{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-xs>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-xs .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-xs{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-xs>ul{padding-left:0}.ruf-layout-column-gt-xs .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:960px){.ruf-layout-row-gt-sm{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-sm>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-sm .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-sm{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-sm>ul{padding-left:0}.ruf-layout-column-gt-sm .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1280px){.ruf-layout-row-gt-md{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-md>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-md .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-md{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-md>ul{padding-left:0}.ruf-layout-column-gt-md .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1920px){.ruf-layout-row-gt-lg{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-lg>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-lg .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-lg{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-lg>ul{padding-left:0}.ruf-layout-column-gt-lg .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel,ruf-sidemenu{display:block;max-width:15.625rem;min-width:6.25rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel>nav,ruf-sidemenu>nav{overflow-y:auto}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-menu-item,ruf-sidemenu .ruf-menu-item{-webkit-box-flex:0;flex:0 1 0;min-height:3.125rem;-webkit-transition:background-color .2s;transition:background-color .2s}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel.ruf-menubar-inkbar-start .ruf-menubar-layout.ruf-layout-column .ruf-menu-item,ruf-sidemenu.ruf-menubar-inkbar-start .ruf-menubar-layout.ruf-layout-column .ruf-menu-item{border-left-width:.25rem}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel.ruf-menubar-inkbar-end .ruf-menubar-layout.ruf-layout-column .ruf-menu-item,ruf-sidemenu.ruf-menubar-inkbar-end .ruf-menubar-layout.ruf-layout-column .ruf-menu-item{border-right-width:.25rem}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-sidemenu-children,ruf-sidemenu .ruf-sidemenu-children{overflow:hidden}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-sidemenu-children .ruf-menu-item,ruf-sidemenu .ruf-sidemenu-children .ruf-menu-item{height:1.875rem;min-height:1.875rem}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-sidemenu-children .ruf-menu-item:active,.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-sidemenu-children .ruf-menu-item:focus,.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-sidemenu-children .ruf-menu-item:hover,ruf-sidemenu .ruf-sidemenu-children .ruf-menu-item:active,ruf-sidemenu .ruf-sidemenu-children .ruf-menu-item:focus,ruf-sidemenu .ruf-sidemenu-children .ruf-menu-item:hover{text-decoration:underline}"]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], RufSidemenuComponent);

/**
 * description
 */
let RufSidemenuChildrenComponent = class RufSidemenuChildrenComponent {
    constructor(_elementRef, sidemenuComp) {
        this._elementRef = _elementRef;
        this.sidemenuComp = sidemenuComp;
        this.visible = true;
        this.sidemenuChildren = true;
    }
    ngOnChanges(changes) {
        if (changes.visible) {
            this.visibleState = changes.visible.currentValue;
        }
    }
    ngAfterContentInit() {
        if (this.childItems && this.childItems.length > 0) {
            this._keyboardSideNav = new RufKeyboardNavigation();
            this._keyboardSideNav.init(this._elementRef, this.childItems).subscribe(path => {
                this.sidemenuComp.select(path.path, path.data);
            });
        }
    }
    setActiveItem(event) {
        // set active item when parent is clicked
        if (event.toState) {
            this._keyboardSideNav.setActiveItem(0);
        }
    }
    onKey(event) {
        switch (event.keyCode) {
            case RufKeyCodes.ESCAPE:
                if (this.menuTrigger) {
                    this.menuTrigger.select(event);
                }
                break;
            default:
                if (this._keyboardSideNav && this._keyboardSideNav.isActive()) {
                    this._keyboardSideNav.onKeyDown(event);
                }
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufSidemenuChildrenComponent.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", RufToggleDirective)
], RufSidemenuChildrenComponent.prototype, "menuTrigger", void 0);
__decorate([
    HostBinding('class.ruf-sidemenu-children'),
    __metadata("design:type", Object)
], RufSidemenuChildrenComponent.prototype, "sidemenuChildren", void 0);
__decorate([
    HostBinding('@visible'),
    __metadata("design:type", Boolean)
], RufSidemenuChildrenComponent.prototype, "visibleState", void 0);
__decorate([
    ContentChildren(forwardRef(() => RufSidemenuItemComponent)),
    __metadata("design:type", QueryList)
], RufSidemenuChildrenComponent.prototype, "childItems", void 0);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], RufSidemenuChildrenComponent.prototype, "onKey", null);
RufSidemenuChildrenComponent = __decorate([
    Component({
        selector: `[rufSidemenuChildren], ruf-sidemenu-children`,
        exportAs: 'rufSidemenuChildren',
        template: `<div (@visible.done)="setActiveItem($event)" [@visible]="visible"><ng-content></ng-content></div>`,
        encapsulation: ViewEncapsulation.None,
        animations: [
            trigger('visible', [
                state('0', style({
                    height: 0
                })),
                state('1', style({
                    height: '*'
                })),
                transition('0 => 1', animate('300ms ease-in-out')),
                transition('1 => 0', animate('300ms ease-in-out'))
            ])
        ]
    }),
    __metadata("design:paramtypes", [ElementRef, RufSidemenuComponent])
], RufSidemenuChildrenComponent);

let RufSidemenuModule = class RufSidemenuModule {
};
RufSidemenuModule = __decorate([
    NgModule({
        imports: [CommonModule, RufMenubarModule, RufToggleModule],
        declarations: [RufSidemenuComponent, RufSidemenuItemComponent, RufSidemenuChildrenComponent],
        exports: [RufSidemenuComponent, RufSidemenuItemComponent, RufSidemenuChildrenComponent]
    })
], RufSidemenuModule);

let RufDynamicSideMenuModule = class RufDynamicSideMenuModule {
};
RufDynamicSideMenuModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            RufUtilsModule,
            RufUniqueIdModule,
            RufToggleModule,
            RufLabeledIconModule,
            RufSidemenuModule,
            RufIconModule,
            FlexLayoutModule,
            MatMenuModule
        ],
        declarations: [RufDynamicSideMenuComponent],
        exports: [RufDynamicSideMenuComponent]
    })
], RufDynamicSideMenuModule);

let RufFooterControlsDirective = class RufFooterControlsDirective {
};
RufFooterControlsDirective = __decorate([
    Directive({
        selector: '[rufFooterControls]'
    })
], RufFooterControlsDirective);
let RufFooterComponent = class RufFooterComponent {
    constructor() {
        this.role = 'contentinfo';
    }
    ngOnInit() { }
};
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", Object)
], RufFooterComponent.prototype, "role", void 0);
__decorate([
    ContentChild(RufFooterControlsDirective, { static: false }),
    __metadata("design:type", RufFooterControlsDirective)
], RufFooterComponent.prototype, "controls", void 0);
RufFooterComponent = __decorate([
    Component({
        selector: 'ruf-footer',
        template: "<ruf-toolbar class=\"ruf-footer-toolbar\" rufId=\"footer_toolbar\">\n  <ng-content></ng-content>\n  <div rufToolbarFiller *ngIf=\"controls\" class=\"ruf-footer-filler\"></div>\n  <ng-content select=\"[rufFooterControls]\"></ng-content>\n</ruf-toolbar>\n",
        encapsulation: ViewEncapsulation.None,
        styles: ["ruf-footer{border-top-style:solid;border-top-width:1px;display:block;flex-shrink:0;min-height:2.5rem;overflow:hidden}.ruf-footer-toolbar{height:2.5rem;margin:0 auto;padding:0 .625rem;width:100%}.ruf-footer-filler{-webkit-box-flex:1;flex:1 1 auto}"]
    }),
    __metadata("design:paramtypes", [])
], RufFooterComponent);

let RufFooterModule = class RufFooterModule {
};
RufFooterModule = __decorate([
    NgModule({
        imports: [CommonModule, RufToolbarModule, RufUniqueIdModule],
        declarations: [RufFooterComponent, RufFooterControlsDirective],
        exports: [RufFooterComponent, RufFooterControlsDirective]
    })
], RufFooterModule);

let RufIconButtonDirective = class RufIconButtonDirective {
    constructor(_matButton) {
        this._active = false;
        this._dark = false;
        this._activeClass = 'activeClass';
        this.fontSet = 'fisfont';
        // can be used in a container that supports the ruf-square class
        this.square = true;
        this.darkClass = this._dark;
        this.activeClass = false;
        this.primaryClass = false;
        this.transition = 'background-color 1s ease';
        this.tabindex = 0;
        if (_matButton) {
            _matButton.disableRipple = true;
        }
    }
    set activeColor(color) {
        if (color === 'primary') {
            this._activeClass = 'primaryClass';
        }
    }
    set active(isActive) {
        this._active = !!isActive;
        this[this._activeClass] = this._active;
    }
    get active() {
        return this._active;
    }
    set dark(isActive) {
        this._dark = isActive;
        this.darkClass = isActive === '' || isActive;
    }
    get dark() {
        return this._dark;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufIconButtonDirective.prototype, "fontSet", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RufIconButtonDirective.prototype, "fontIcon", void 0);
__decorate([
    HostBinding('class.ruf-square'),
    __metadata("design:type", Object)
], RufIconButtonDirective.prototype, "square", void 0);
__decorate([
    HostBinding('class.ruf-background-dark'),
    __metadata("design:type", Object)
], RufIconButtonDirective.prototype, "darkClass", void 0);
__decorate([
    HostBinding('class.ruf-background-darker'),
    __metadata("design:type", Object)
], RufIconButtonDirective.prototype, "activeClass", void 0);
__decorate([
    HostBinding('class.ruf-background-primary-dark'),
    __metadata("design:type", Object)
], RufIconButtonDirective.prototype, "primaryClass", void 0);
__decorate([
    HostBinding('style.transition'),
    __metadata("design:type", Object)
], RufIconButtonDirective.prototype, "transition", void 0);
__decorate([
    HostBinding('attr.tabindex'),
    __metadata("design:type", Object)
], RufIconButtonDirective.prototype, "tabindex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], RufIconButtonDirective.prototype, "activeColor", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], RufIconButtonDirective.prototype, "active", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], RufIconButtonDirective.prototype, "dark", null);
RufIconButtonDirective = __decorate([
    Directive({
        selector: '[rufIconButton]',
        exportAs: 'rufIconButton'
    }),
    __param(0, Self()),
    __param(0, Optional()),
    __metadata("design:paramtypes", [MatButton])
], RufIconButtonDirective);

let RufIconButtonModule = class RufIconButtonModule {
};
RufIconButtonModule = __decorate([
    NgModule({
        imports: [CommonModule, MatButtonModule],
        declarations: [RufIconButtonDirective],
        exports: [RufIconButtonDirective]
    })
], RufIconButtonModule);

const FALSY = ['false', false, 0];
let RufIfDirective = class RufIfDirective extends BaseDirective {
    constructor(templateRef, viewContainer, monitor, elRef, styleUtils, changeDetectorRef) {
        super(monitor, elRef, styleUtils);
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.elRef = elRef;
        this.styleUtils = styleUtils;
        this.changeDetectorRef = changeDetectorRef;
        this.isAlreadyInserted = false;
    }
    set rufIfXs(val) {
        this._cacheInput('rufIfXs', val);
    }
    set rufIfGtXs(val) {
        this._cacheInput('rufIfGtXs', val);
    }
    set rufIfSm(val) {
        this._cacheInput('rufIfSm', val);
    }
    set rufIfGtSm(val) {
        this._cacheInput('rufIfGtSm', val);
    }
    set rufIfMd(val) {
        this._cacheInput('rufIfMd', val);
    }
    set rufIfGtMd(val) {
        this._cacheInput('rufIfGtMd', val);
    }
    set rufIfLg(val) {
        this._cacheInput('rufIfLg', val);
    }
    set rufIfGtLg(val) {
        this._cacheInput('rufIfGtLg', val);
    }
    set rufIfXl(val) {
        this._cacheInput('rufIfXl', val);
    }
    _getDisplayStyle() {
        // this is not used for rufIf, only prevents error from being throw as BaseDirective invokes it
        return 'block';
    }
    ngOnChanges(changes) {
        if (changes['rufIf'] != null || this._mqActivation) {
            this._updateWithValue();
        }
    }
    ngOnInit() {
        this._listenForMediaQueryChanges('rufIf', false, (changes) => {
            this._updateWithValue(changes.value);
            this.changeDetectorRef.markForCheck();
        });
        this._updateWithValue();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    _updateWithValue(value) {
        value = value || this._getDefaultVal('rufIf', false);
        if (this._mqActivation) {
            value = this._mqActivation.activatedInput;
        }
        const shouldShow = this._validateTruthy(value);
        this._update(shouldShow);
    }
    // Insert or remove the template
    _update(value) {
        if (value && !this.isAlreadyInserted) {
            this.viewContainer.createEmbeddedView(this.templateRef);
            this.isAlreadyInserted = true;
        }
        else if (!value && this.isAlreadyInserted) {
            this.viewContainer.clear();
            this.isAlreadyInserted = false;
        }
    }
    _validateTruthy(value) {
        return FALSY.indexOf(value) === -1;
    }
};
__decorate([
    Input('rufIfXs'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], RufIfDirective.prototype, "rufIfXs", null);
__decorate([
    Input('rufIfGtXs'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], RufIfDirective.prototype, "rufIfGtXs", null);
__decorate([
    Input('rufIfSm'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], RufIfDirective.prototype, "rufIfSm", null);
__decorate([
    Input('rufIfGtSm'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], RufIfDirective.prototype, "rufIfGtSm", null);
__decorate([
    Input('rufIfMd'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], RufIfDirective.prototype, "rufIfMd", null);
__decorate([
    Input('rufIfGtMd'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], RufIfDirective.prototype, "rufIfGtMd", null);
__decorate([
    Input('rufIfLg'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], RufIfDirective.prototype, "rufIfLg", null);
__decorate([
    Input('rufIfGtLg'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], RufIfDirective.prototype, "rufIfGtLg", null);
__decorate([
    Input('rufIfXl'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], RufIfDirective.prototype, "rufIfXl", null);
RufIfDirective = __decorate([
    Directive({
        selector: `
    [rufIfXs],
    [rufIfGtXs],
    [rufIfSm],
    [rufIfGtSm],
    [rufIfMd],
    [rufIfGtMd],
    [rufIfLg],
    [rufIfGtLg],
    [rufIfXl]
  `
    }),
    __metadata("design:paramtypes", [TemplateRef,
        ViewContainerRef,
        MediaMonitor,
        ElementRef,
        StyleUtils,
        ChangeDetectorRef])
], RufIfDirective);

const RUF_PADDING_VALUES = ['none', 'auto', 'small', 'medium', 'large'];
let RufPaddingDirective = class RufPaddingDirective {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.classPrefix = 'ruf-padding';
        this._positions = {
            rufPadding: ['-'],
            rufPaddingVertical: ['-top-', '-bottom-'],
            rufPaddingHorizontal: ['-left-', '-right-'],
            rufPaddingTop: ['-top-'],
            rufPaddingRight: ['-right-'],
            rufPaddingBottom: ['-bottom-'],
            rufPaddingLeft: ['-left-']
        };
        this.rufPadding = '';
        this.rufPaddingVertical = '';
        this.rufPaddingHorizontal = '';
        this.rufPaddingTop = '';
        this.rufPaddingRight = '';
        this.rufPaddingBottom = '';
        this.rufPaddingLeft = '';
        this.padding = true;
    }
    ngOnChanges(changes) {
        Object.keys(changes).forEach(key => {
            this.update(key, changes[key]);
        });
    }
    update(key, change) {
        const previous = this._validateValue(change.previousValue);
        const current = this._validateValue(change.currentValue);
        const positions = this._positions[key];
        positions.forEach(pos => {
            // remove
            this.renderer.removeClass(this.el.nativeElement, this.classPrefix + pos + previous);
            // add
            this.renderer.addClass(this.el.nativeElement, this.classPrefix + pos + current);
        });
    }
    _validateValue(val) {
        if (RUF_PADDING_VALUES.indexOf(val) !== -1) {
            return val;
        }
        return 'medium';
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufPaddingDirective.prototype, "rufPadding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufPaddingDirective.prototype, "rufPaddingVertical", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufPaddingDirective.prototype, "rufPaddingHorizontal", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufPaddingDirective.prototype, "rufPaddingTop", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufPaddingDirective.prototype, "rufPaddingRight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufPaddingDirective.prototype, "rufPaddingBottom", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufPaddingDirective.prototype, "rufPaddingLeft", void 0);
__decorate([
    HostBinding('class.ruf-padding'),
    __metadata("design:type", Object)
], RufPaddingDirective.prototype, "padding", void 0);
RufPaddingDirective = __decorate([
    Directive({
        selector: `
    [rufPadding],
    [rufPaddingVertical],
    [rufPaddingHorizontal],
    [rufPaddingTop],
    [rufPaddingRight],
    [rufPaddingBottom],
    [rufPaddingLeft]
  `,
        exportAs: 'rufPadding'
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], RufPaddingDirective);

const RUF_MARGIN_VALUES = ['none', 'auto', 'small', 'medium', 'large'];
let RufMarginDirective = class RufMarginDirective {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.classPrefix = 'ruf-margin';
        this._positions = {
            rufMargin: ['-'],
            rufMarginVertical: ['-top-', '-bottom-'],
            rufMarginHorizontal: ['-left-', '-right-'],
            rufMarginTop: ['-top-'],
            rufMarginRight: ['-right-'],
            rufMarginBottom: ['-bottom-'],
            rufMarginLeft: ['-left-']
        };
        this.rufMargin = '';
        this.rufMarginVertical = '';
        this.rufMarginHorizontal = '';
        this.rufMarginTop = '';
        this.rufMarginRight = '';
        this.rufMarginBottom = '';
        this.rufMarginLeft = '';
        this.margin = true;
    }
    ngOnChanges(changes) {
        Object.keys(changes).forEach(key => {
            this.update(key, changes[key]);
        });
    }
    update(key, change) {
        const previous = this._validateValue(change.previousValue);
        const current = this._validateValue(change.currentValue);
        const positions = this._positions[key];
        positions.forEach(pos => {
            // remove
            this.renderer.removeClass(this.el.nativeElement, this.classPrefix + pos + previous);
            // add
            this.renderer.addClass(this.el.nativeElement, this.classPrefix + pos + current);
        });
    }
    _validateValue(val) {
        if (RUF_MARGIN_VALUES.indexOf(val) !== -1) {
            return val;
        }
        return 'medium';
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufMarginDirective.prototype, "rufMargin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufMarginDirective.prototype, "rufMarginVertical", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufMarginDirective.prototype, "rufMarginHorizontal", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufMarginDirective.prototype, "rufMarginTop", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufMarginDirective.prototype, "rufMarginRight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufMarginDirective.prototype, "rufMarginBottom", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufMarginDirective.prototype, "rufMarginLeft", void 0);
__decorate([
    HostBinding('class.ruf-margin'),
    __metadata("design:type", Object)
], RufMarginDirective.prototype, "margin", void 0);
RufMarginDirective = __decorate([
    Directive({
        selector: `
    [rufMargin],
    [rufMarginVertical],
    [rufMarginHorizontal],
    [rufMarginTop],
    [rufMarginRight],
    [rufMarginBottom],
    [rufMarginLeft]
  `,
        exportAs: 'rufMargin'
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], RufMarginDirective);

let RufLayoutModule = class RufLayoutModule {
};
RufLayoutModule = __decorate([
    NgModule({
        imports: [CommonModule, FlexLayoutModule],
        declarations: [RufMarginDirective, RufPaddingDirective, RufIfDirective],
        exports: [RufMarginDirective, RufPaddingDirective, RufIfDirective, FlexLayoutModule]
    })
], RufLayoutModule);

let RufPageHeaderRowDirective = class RufPageHeaderRowDirective {
};
RufPageHeaderRowDirective = __decorate([
    Directive({
        selector: 'ruf-page-header-row' // tslint:disable-line
    })
], RufPageHeaderRowDirective);
let RufPageHeaderIconComponent = class RufPageHeaderIconComponent {
};
RufPageHeaderIconComponent = __decorate([
    Component({
        selector: 'ruf-page-header-icon',
        encapsulation: ViewEncapsulation.None,
        template: `
    <div><ng-content></ng-content></div>
  `
    })
], RufPageHeaderIconComponent);
let RufPageHeaderTitleComponent = class RufPageHeaderTitleComponent {
};
RufPageHeaderTitleComponent = __decorate([
    Component({
        selector: 'ruf-page-header-title',
        encapsulation: ViewEncapsulation.None,
        template: `
    <ng-content></ng-content>
  `
    })
], RufPageHeaderTitleComponent);
let RufPageHeaderDescriptionComponent = class RufPageHeaderDescriptionComponent {
};
RufPageHeaderDescriptionComponent = __decorate([
    Component({
        selector: 'ruf-page-header-description',
        encapsulation: ViewEncapsulation.None,
        template: `
    <ng-content></ng-content>
  `
    })
], RufPageHeaderDescriptionComponent);
let RufPageHeaderComponent = class RufPageHeaderComponent {
    constructor() { }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], RufPageHeaderComponent.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RufPageHeaderComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RufPageHeaderComponent.prototype, "description", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RufPageHeaderComponent.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RufPageHeaderComponent.prototype, "color", void 0);
RufPageHeaderComponent = __decorate([
    Component({
        selector: 'ruf-page-header',
        template: "<ruf-toolbar [color]=\"color\" rufId=\"pageheader_toolbar\" class=\"ruf-pageheader-toolbar\" >\n  <ruf-page-header-icon rufId=\"pageheader_icon\" *ngIf=\"icon\" class=\"ruf-page-header-text-icon\">{{icon}}</ruf-page-header-icon>\n  <ng-content select=\"ruf-page-header-icon\"></ng-content>\n  <div class=\"ruf-page-header-title-area\">\n    <ruf-page-header-title *ngIf=\"title\" rufId=\"pageheader_title\">{{title}}</ruf-page-header-title>\n    <ng-content rufId=\"pageheader_title_tag\" select=\"ruf-page-header-title\"></ng-content>\n    <ruf-page-header-description rufId=\"pageheader_description\" *ngIf=\"description\">{{description}}</ruf-page-header-description>\n    <ng-content rufId=\"pageheader_title_tag\" select=\"ruf-page-header-description\"></ng-content>\n  </div>\n  <div rufToolbarFiller></div>\n  <ng-content></ng-content>\n  <ng-content select=\"ruf-page-header-row\" ngProjectAs=\"ruf-toolbar-row\"></ng-content>\n</ruf-toolbar>\n",
        encapsulation: ViewEncapsulation.None,
        styles: ["ruf-page-header{display:block;min-height:2.375rem;width:100%}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows>.ruf-toolbar-first-row{-webkit-box-align:end;align-items:flex-end;padding:.625rem 0}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows .ruf-page-header-title-area{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;-webkit-box-pack:center;justify-content:center;min-height:2.5rem}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows .ruf-page-header-metric,ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows ruf-page-header-title{margin:0;text-transform:capitalize}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows .ruf-page-header-metric-description,ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows ruf-page-header-description{text-transform:initial}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows>ruf-page-header-row,ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows>ruf-toolbar-row{margin:0 auto;padding:0;width:100%}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows ruf-page-header-icon{border-radius:50%;flex-shrink:0;height:2.5rem;overflow:hidden;text-align:center;width:2.5rem}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows ruf-page-header-icon>div{font-size:1.875rem;line-height:2.625rem}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows ruf-page-header-icon.ruf-page-header-text-icon>div{font-size:1.125rem;line-height:2.5rem;text-transform:lowercase}"]
    }),
    __metadata("design:paramtypes", [])
], RufPageHeaderComponent);

let RufPageHeaderModule = class RufPageHeaderModule {
};
RufPageHeaderModule = __decorate([
    NgModule({
        imports: [CommonModule, RufToolbarModule, RufUniqueIdModule],
        declarations: [
            RufPageHeaderComponent,
            RufPageHeaderTitleComponent,
            RufPageHeaderDescriptionComponent,
            RufPageHeaderIconComponent,
            RufPageHeaderRowDirective
        ],
        exports: [
            RufPageHeaderComponent,
            RufPageHeaderTitleComponent,
            RufPageHeaderDescriptionComponent,
            RufPageHeaderIconComponent,
            RufPageHeaderRowDirective
        ]
    })
], RufPageHeaderModule);

let RufAppCanvasComponent = class RufAppCanvasComponent {
};
RufAppCanvasComponent = __decorate([
    Component({
        selector: 'ruf-app-canvas',
        template: "<ng-content></ng-content>",
        encapsulation: ViewEncapsulation.None,
        styles: ["ruf-app-canvas{display:block;height:100%;padding:0 0 30px;width:100%}"]
    })
], RufAppCanvasComponent);

let RufAppCanvasModule = class RufAppCanvasModule {
};
RufAppCanvasModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [RufAppCanvasComponent],
        exports: [RufAppCanvasComponent]
    })
], RufAppCanvasModule);

let RufLocaleService = class RufLocaleService {
    constructor() {
        this._locale = 'en';
        this._localeSubject = new BehaviorSubject(this._locale);
        this._locale$ = from(this._localeSubject);
    }
    set locale(locale) {
        this._locale = locale;
        this._localeSubject.next(locale);
    }
    get locale() {
        return this._locale;
    }
    get locale$() {
        return this._locale$;
    }
};
RufLocaleService = __decorate([
    Injectable()
], RufLocaleService);

let RufCurrencyPipe = class RufCurrencyPipe {
    constructor(localeService) {
        this.localeService = localeService;
        this.subscription = localeService.locale$.subscribe(data => {
            this.currencyPipe = new CurrencyPipe(data);
        });
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    transform(value, currencyCode, symbolDisplay, digits) {
        return this.currencyPipe.transform(value, currencyCode, symbolDisplay, digits);
    }
};
RufCurrencyPipe = __decorate([
    Pipe({
        name: 'rufCurrency',
        pure: false
    }),
    __metadata("design:paramtypes", [RufLocaleService])
], RufCurrencyPipe);

let RufDatePipe = class RufDatePipe {
    constructor(localeService) {
        this.localeService = localeService;
        this.subscription = localeService.locale$.subscribe(data => {
            this.datePipe = new DatePipe(data);
        });
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    transform(value, pattern) {
        return this.datePipe.transform(value, pattern);
    }
};
RufDatePipe = __decorate([
    Pipe({
        name: 'rufDate',
        pure: false
    }),
    __metadata("design:paramtypes", [RufLocaleService])
], RufDatePipe);

var RufI18nModule_1;
let RufI18nModule = RufI18nModule_1 = class RufI18nModule {
    static forRoot() {
        return {
            ngModule: RufI18nModule_1,
            providers: [{ provide: LOCALE_ID, useFactory: localeFactory, deps: [RufLocaleService] }, RufLocaleService]
        };
    }
};
RufI18nModule = RufI18nModule_1 = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [RufDatePipe, RufCurrencyPipe],
        exports: [RufDatePipe, RufCurrencyPipe]
    })
], RufI18nModule);
function localeFactory(localeService) {
    return localeService.locale;
}

let RufNavbarComponent = class RufNavbarComponent {
    constructor() {
        this.role = 'navigation';
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], RufNavbarComponent.prototype, "color", void 0);
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", Object)
], RufNavbarComponent.prototype, "role", void 0);
RufNavbarComponent = __decorate([
    Component({
        selector: 'ruf-navbar',
        template: "<ruf-toolbar [color]=\"color\" rufId=\"navbar_toolbar\">\n  <ng-content></ng-content>\n</ruf-toolbar>\n",
        encapsulation: ViewEncapsulation.None,
        styles: ["ruf-navbar{display:block;flex-shrink:0;min-height:2.8125rem;overflow:hidden}"]
    }),
    __metadata("design:paramtypes", [])
], RufNavbarComponent);

let RufNavbarModule = class RufNavbarModule {
};
RufNavbarModule = __decorate([
    NgModule({
        imports: [CommonModule, RufToolbarModule, RufUniqueIdModule],
        declarations: [RufNavbarComponent],
        exports: [RufNavbarComponent]
    })
], RufNavbarModule);

let RufMegamenuSearchComponent = class RufMegamenuSearchComponent {
    constructor(_intl, changeDetectorRef) {
        this._intl = _intl;
        this.filterValue = new EventEmitter();
        this.inputFocus = new EventEmitter();
        this._intlChanges = _intl.changes.subscribe(() => changeDetectorRef.markForCheck());
    }
    get placeholder() {
        return this._placeholder || this._intl.megamenusearch.placeholder;
    }
    set placeholder(value) {
        this._placeholder = value;
    }
    get clearSearchLabel() {
        return this._clearSearchLabel || this._intl.megamenusearch.aria.clearSearchLabel;
    }
    set clearSearchLabel(value) {
        this._clearSearchLabel = value;
    }
    clear($event) {
        this.filter.nativeElement.value = '';
        this.filterValue.emit('');
        $event.preventDefault();
        $event.stopPropagation();
    }
    handleKeyDown($event) {
        switch ($event.keyCode) {
            case RufKeyCodes.SPACE:
            case RufKeyCodes.ENTER:
                this.clear($event);
                break;
        }
    }
    ngOnDestroy() {
        this._intlChanges.unsubscribe();
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufMegamenuSearchComponent.prototype, "placeholder", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufMegamenuSearchComponent.prototype, "clearSearchLabel", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], RufMegamenuSearchComponent.prototype, "filterValue", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], RufMegamenuSearchComponent.prototype, "inputFocus", void 0);
__decorate([
    ViewChild('filter', { static: false }),
    __metadata("design:type", ElementRef)
], RufMegamenuSearchComponent.prototype, "filter", void 0);
RufMegamenuSearchComponent = __decorate([
    Component({
        selector: 'ruf-megamenu-search',
        template: "<div class=\"fis-search-input-container\" [class.ruf-focus]='inputFocusClass'>\n  <div class=\"fis-icon-search\"></div>\n  <input type=\"text\" #filter (focus)=\"inputFocus.emit(filter.value);inputFocusClass = true\" (keyup.enter)=\"filterValue.emit(filter.value)\"\n         (blur)=\"inputFocusClass = false;\"\n         (input)=\"filterValue.emit(filter.value)\" [placeholder]=\"placeholder\"\n         [attr.aria-label]=\"placeholder\">\n  <i class=\"fis-icon-close\" (click)=\"clear($event);inputFocusClass = true;filter.focus();\"\n       (keydown)=\"handleKeyDown($event)\"\n       (blur)=\"inputFocusClass = false;\"\n       [title]=\"clearSearchLabel\"\n       role=\"button\" [attr.aria-label]=\"clearSearchLabel\" tabindex=\"0\"></i>\n</div>\n",
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: ["ruf-megamenu-search{padding-right:0}ruf-megamenu-search input{background-color:transparent;border:0 solid;content:'\\E93E';height:40px;outline:0;width:100%}ruf-megamenu-search input[type=text]::-ms-clear{display:none}ruf-megamenu-search .fis-icon-search{font-size:22px;margin-left:5px;margin-top:10px}ruf-megamenu-search .fis-icon-close{-ms-grid-row-align:center;align-self:center;height:1em;margin-right:5px;position:relative}ruf-megamenu-search .fis-search-input-container{display:-webkit-box;display:flex}"]
    }),
    __metadata("design:paramtypes", [RufShellIntl, ChangeDetectorRef])
], RufMegamenuSearchComponent);

// the object we reduce into during search preparation
class RufCart {
}
let RufSearchService = class RufSearchService {
    constructor() {
        this.SPLITTER = String.fromCharCode(167);
    }
    recursiveReduce(items, context) {
        return items.reduce((cart, item) => {
            if (item.children && item.children.length > 0) {
                // this is a parent
                const newContext = context.concat([item.label]);
                const childCart = this.recursiveReduce(item.children, newContext);
                // we need to add a parent object with this objects children
                const parent = {
                    label: item.label,
                    path: item.path,
                    context: context.join(', '),
                    children: childCart.children,
                    searchKey: childCart.searchKeys.join(this.SPLITTER) // only searchkeys of non-parent nodes
                };
                // only add this parent, if it has children
                if (childCart.children && childCart.children.length > 0) {
                    cart.parents.push(parent);
                }
                // we get the parent nodes from the children of this item and only pass these up
                cart.parents = cart.parents.concat(childCart.parents); // the reduced items are basically pushed up to the highest level
                // we also append the childcart keys to the parent (for searching purposes)
                // This isn't necessary anymore as we only have one level cart.searchKeys = cart.searchKeys.concat(childCart.searchKeys);
            }
            else {
                // this is a child, so we add it to this carts children
                item.searchKey = item.label.toLowerCase(); // we make the search key lowercase here for all children
                cart.children.push(item);
                cart.searchKeys.push(item.searchKey);
            }
            return cart;
        }, {
            // start with an empty cart
            parents: [],
            children: [],
            searchKeys: []
        });
    }
    // prepares the search items
    prepareSearch(items) {
        // the goal is to recursively parse the tree structure for parents of children
        // children are nodes with no children, parents are nodes with children
        const preparedItems = this.recursiveReduce(items, []);
        // we return a function here that performs the search on the prepared items
        return term => {
            return this.performSearch(preparedItems.parents, term);
        };
    }
    // used to create a reduced version of what gets displayed, and also
    // detaches from the original object
    copySearchItem(item, newChildren) {
        return {
            label: item.label,
            path: item.path,
            context: item.context,
            children: newChildren
        };
    }
    // The search assumes that there each item in the array only has one level of children
    // this explicit structure is created in the prepare search
    performSearch(items, term) {
        const searchTerm = term.toLowerCase(); // lowercase search term vs lowercase search key
        // call the reduce to omit non matching items
        return items.reduce(
        // newItems is the returned value from the prev function call
        (newItems, item) => {
            // first we check if the parent item will be added (checking this here prevents unnecessary looping)
            if (item.searchKey && item.searchKey.indexOf(searchTerm) > -1) {
                // filter the children
                // (we know there are children as the searchkey collates only child keys)
                const reducedChildren = item.children.filter(child => {
                    return child.searchKey.indexOf(searchTerm) > -1;
                });
                // there will always be atleast one child that matches
                // (as have already we checked the collated search key)
                newItems.push(this.copySearchItem(item, reducedChildren));
            }
            return newItems;
        }, [] // initial empty array
        );
    }
};
RufSearchService = __decorate([
    Injectable()
], RufSearchService);

let RufMegamenuComponent = class RufMegamenuComponent {
    constructor(searchService, _intl, changeDetectorRef) {
        this.searchService = searchService;
        this._intl = _intl;
        this.items = [];
        this.select = new EventEmitter();
        // Subjects: denotes user interaction streams
        // search related properties
        this.searchTerms$ = new Subject(); // stream of search terms
        // sidemenu select event stream
        this.selectedSidemenuItems$ = new Subject(); // stream of selected items (same type has this.items)
        this.preparedSearchableItems = (term) => [];
        this._intlChanges = _intl.changes.subscribe(() => changeDetectorRef.markForCheck());
    }
    get searchPlaceholder() {
        return this._searchPlaceholder || this._intl.megamenu.placeholder;
    }
    set searchPlaceholder(value) {
        this._searchPlaceholder = value;
    }
    get clearSearchAriaLabel() {
        return this._clearSearchAriaLabel || this._intl.megamenu.aria.clearSearchLabel;
    }
    set clearSearchAriaLabel(value) {
        this._clearSearchAriaLabel = value;
    }
    ngOnInit() {
        // map search terms to a search results stream ready to be consumed by sitemap
        const searchResults$ = this.searchTerms$.pipe(distinctUntilChanged(), debounceTime(400), // don't search unless user stopped typing for 400ms
        switchMap(term => this.search(term)), // ignore already triggered searches.
        startWith([])); // start with empty results
        // map sidemenu select event to selected item's children array
        const selectedItemChildren$ = this.selectedSidemenuItems$.pipe(withLatestFrom(searchResults$), // combine each event with the latest of the searchResults$ stream
        map(([item, searchResults]) => {
            if (!item) {
                return searchResults || [];
            }
            // map to the selected item's children or an empty array.
            return item.data || [];
        }));
        // sitemap data stream is a merge of search results and selected item's children streams
        this.sitemapItems$ = merge(selectedItemChildren$, searchResults$);
    }
    ngOnChanges(changes) {
        // when any changes to the items occur, re-prepare the search
        if (changes.items && changes.items.currentValue) {
            this.preparedSearchableItems = this.searchService.prepareSearch(changes.items.currentValue);
        }
    }
    ngAfterViewInit() {
        // once the sidemenu is created (after view init), select first sidemenu item
        setTimeout(() => {
            if (this.items[0]) {
                this.sidemenu.select(this.items[0].path, this.items[0].children);
            }
        });
    }
    search(term) {
        let results = this.items;
        // if no prepared searchable data is available we just return everything
        if (this.preparedSearchableItems) {
            // now we process the searching of the data
            results = this.preparedSearchableItems(term);
        }
        if (!term || term === '') {
            results = [];
        }
        // return observable of results using same type has this.item
        return of(results);
    }
    ngOnDestroy() {
        this._intlChanges.unsubscribe();
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufMegamenuComponent.prototype, "searchPlaceholder", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufMegamenuComponent.prototype, "clearSearchAriaLabel", null);
__decorate([
    Input(),
    __metadata("design:type", Array)
], RufMegamenuComponent.prototype, "items", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], RufMegamenuComponent.prototype, "select", void 0);
__decorate([
    ViewChild('sidemenu', { static: true }),
    __metadata("design:type", RufSidemenuComponent)
], RufMegamenuComponent.prototype, "sidemenu", void 0);
RufMegamenuComponent = __decorate([
    Component({
        selector: 'ruf-megamenu',
        template: "<div class=\"ruf-sidemenu-container\">\n  <ruf-megamenu-search (filterValue)=\"searchTerms$.next($event)\" (inputFocus)=\"selectedSidemenuItems$.next()\" [placeholder]=\"searchPlaceholder\" [clearSearchLabel]=\"clearSearchAriaLabel\"></ruf-megamenu-search>\n  <ruf-sidemenu #sidemenu [selectedPath]=\"(selectedSidemenuItems$ | async)?.path\" (select)=\"selectedSidemenuItems$.next($event);\">\n    <ruf-sidemenu-item *ngFor=\"let item of items\" [path]=\"item.path\" [data]=\"item.children\">{{item.label}}</ruf-sidemenu-item>\n  </ruf-sidemenu>\n</div>\n<div class=\"ruf-sitemap-container\">\n  <ruf-sitemap [items]=\"sitemapItems$\" (select)=\"select.emit($event)\">\n  </ruf-sitemap>\n</div>\n",
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [RufSearchService],
        styles: ["ruf-megamenu{display:-webkit-box;display:flex;flex-shrink:0;overflow-x:auto;padding:20px 20px 20px 0;width:100%}ruf-megamenu .ruf-sidemenu-container{height:100%;max-width:200px;min-width:200px;overflow-x:hidden;overflow-y:auto}ruf-megamenu .ruf-sidemenu-container ruf-sidemenu{flex-shrink:0;min-width:200px}ruf-megamenu .fis-search-input-container,ruf-megamenu .ruf-focus{border-left-style:solid;border-left-width:2px}ruf-megamenu .ruf-sitemap-container{border-style:solid;border-width:20px;display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1 1 auto}ruf-megamenu .ruf-sidemenu-container::-webkit-scrollbar{width:.5em}ruf-megamenu ruf-sitemap{padding:18px}ruf-megamenu::-webkit-scrollbar{height:.5em}"]
    }),
    __metadata("design:paramtypes", [RufSearchService, RufShellIntl, ChangeDetectorRef])
], RufMegamenuComponent);

let RufSitemapComponent = class RufSitemapComponent {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this.role = 'menubar';
        this.select = new EventEmitter();
        this.direction = 'row';
    }
    ngAfterViewInit() {
        if (this.sitemapItems.length > 0) {
            this.addNewKeyboardNav();
        }
        this.sitemapItems.changes.subscribe(changes => {
            if (this.sitemapItems.length > 0) {
                this.addNewKeyboardNav();
            }
        });
    }
    addNewKeyboardNav() {
        this._keyboardNav = new RufKeyboardNavigation();
        this._keyboardNav.setDirection(this.direction);
        this._keyboardNav.init(this._elementRef, this.sitemapItems);
        this._keyboardNav.addTabIndex(this.sitemapItems);
    }
    // emit the currently selected
    selectItem(sitemapItem) {
        this.select.emit(sitemapItem);
    }
    onKey(event, item) {
        this._keyboardNav.onKeyDown(event);
        switch (event.keyCode) {
            case RufKeyCodes.ENTER:
            case RufKeyCodes.SPACE:
                this.selectItem(item);
                break;
        }
    }
    uniqueItem(index, item) {
        return item.path;
    }
};
__decorate([
    HostBinding('attr.role'),
    __metadata("design:type", Object)
], RufSitemapComponent.prototype, "role", void 0);
__decorate([
    Input(),
    __metadata("design:type", Observable)
], RufSitemapComponent.prototype, "items", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], RufSitemapComponent.prototype, "select", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufSitemapComponent.prototype, "direction", void 0);
__decorate([
    ViewChildren(RufFocusableDirective),
    __metadata("design:type", QueryList)
], RufSitemapComponent.prototype, "sitemapItems", void 0);
RufSitemapComponent = __decorate([
    Component({
        selector: 'ruf-sitemap',
        template: "<div class=\"ruf-sitemap-wrap\">\n  <div *ngFor=\"let parent of items | async; trackBy: uniqueItem \" class=\"ruf-sitemap-parent\">\n    <small *ngIf=\"parent.context\" class=\"ruf-sitemap-context\">{{parent.context}}\n      <span class=\"fis-icon-chevron-double\"></span>\n    </small>\n    <div class=\"ruf-title\">{{ parent.label }}</div><br>\n\n    <ul class=\"ruf-sitemap-children\">\n      <li *ngFor=\"let child of parent.children; trackBy: uniqueItem\" class=\"ruf-sitemap-child\">\n        <a (click)=\"selectItem(child);\" (keydown)=\"onKey($event, child)\" role=\"menuitem\" title=\"{{ child.label }}\" rufFocusable>{{ child.label }}</a>\n      </li>\n    </ul>\n  </div>\n</div>\n\n",
        encapsulation: ViewEncapsulation.None,
        providers: [],
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: ["ruf-sitemap{display:block;max-height:100%;overflow-y:auto;padding:20px;width:100%}ruf-sitemap .ruf-sitemap-wrap{display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1 1 auto;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-flow:row wrap}ruf-sitemap .fis-icon-chevron-double{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}ruf-sitemap .ruf-sitemap-context{display:block;padding-left:10px}ruf-sitemap .ruf-sitemap-parent{width:200px}ruf-sitemap .ruf-sitemap-parent .ruf-title{cursor:default;display:inline-block;padding:5px 10px;text-transform:uppercase;white-space:pre-wrap;word-wrap:break-word}ruf-sitemap .ruf-sitemap-parent ul{margin:4px 4px 16px 0;padding-left:25px}ruf-sitemap .ruf-sitemap-parent ul .ruf-title{list-style-type:none}ruf-sitemap .ruf-sitemap-parent ul li{padding:4px}ruf-sitemap .ruf-sitemap-parent ul li a{cursor:pointer}ruf-sitemap .ruf-sitemap-parent ul li a:hover{text-decoration:underline}ruf-sitemap::-webkit-scrollbar{width:.5em}ruf-sitemap::-webkit-scrollbar-button{height:.5em}"]
    }),
    __metadata("design:paramtypes", [ElementRef])
], RufSitemapComponent);

let RufSitemapModule = class RufSitemapModule {
};
RufSitemapModule = __decorate([
    NgModule({
        imports: [CommonModule, RufUtilsModule],
        declarations: [RufSitemapComponent],
        exports: [RufSitemapComponent]
    })
], RufSitemapModule);

let RufMegamenuModule = class RufMegamenuModule {
};
RufMegamenuModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            RufToolbarModule,
            RufSidemenuModule,
            RufSitemapModule,
            RufUtilsModule
        ],
        declarations: [
            RufMegamenuComponent,
            RufMegamenuSearchComponent
        ],
        exports: [
            RufMegamenuComponent
        ],
        providers: []
    })
], RufMegamenuModule);

class RufMDIStrategy {
    constructor(util) {
        this.util = util;
        this.handlers = {};
    }
    /**
     * Decides when the route should be stored
     * @param route the route that the user is currently on
     * @returns boolean indicating whether the route should or should not be stored
     */
    shouldDetach(route) {
        return true;
    }
    /**
     * Stores the complete route path and its component state (as ComponentRef) for later attachment
     * @param route This is stored for later comparison to requested routes, see `this.shouldAttach`
     * @param handle A DetachedRouteHandle which is later retrieved by this.retrieve to restore state
     */
    store(route, handle) {
        const path = this.util.getLeafNodePath(route);
        // path is '' when route has loadChildren.
        if (path) {
            if (route.component) {
                this.handlers[path] = handle;
            }
            // route does not have component. this means it is a parent route like ruf/shell/banner or ruf/shell/layout.
            // In this case, previously stored leaf node handler should be re-stored.
            if (!route.component && handle) {
                // This condition is when parent route is being stored but it's the child route whose reference needs to be stored instead.
                // In this case, retrieve the component ref from RufRouterUtilService and create a new DetachedRouteHandle.
                this.handlers[path] = {
                    componentRef: this.util.getComponentRef(path),
                    route: this.util.getLeafNode(handle['route'])
                };
            }
        }
    }
    /**
     * Determines whether there is a stored route and, if yes, should it be rendered in place of requested route
     * @param route The route the user requested
     * @returns boolean indicating whether or not to render the stored route
     */
    shouldAttach(route) {
        const path = this.util.getLeafNodePath(route);
        return !!route.routeConfig && !!this.handlers[path];
    }
    /**
     * Finds the locally stored instance of the requested route and returns it if it exists
     * @param route New route the user has requested
     * @returns DetachedRouteHandle object which can be used to render the component
     */
    retrieve(route) {
        if (!route.routeConfig) {
            return null;
        }
        if (route.routeConfig.loadChildren) {
            return null;
        }
        return this.handlers[this.util.fullPath(route)];
    }
    /**
     * Determines whether or not the current route should be reused
     * @param future The route the user is navigating to as triggered by the router
     * @param curr The route the user is currently on
     * @returns boolean indicating true if the user intends to leave the current route
     */
    shouldReuseRoute(future, curr) {
        return ((future.routeConfig === curr.routeConfig) &&
            (JSON.stringify(future.params) === JSON.stringify(curr.params)));
    }
    /**
     *  Remove component reference from handlers.
     *  Destroy the route component
     *  @param path The key against which DetachedRouteHandle with component reference is stored for detached route
     */
    destroy(path) {
        if (this.handlers[path] && this.util.getComponentRef(path)) {
            this.util.getComponentRef(path).destroy();
            delete this.handlers[path];
        }
    }
}

let RufRouterUtilService = class RufRouterUtilService {
    constructor() {
        this._routeComp = {};
    }
    set lastActivatedPath(path) {
        this._lastActivatedPath = path;
    }
    get lastActivatedPath() {
        return this._lastActivatedPath;
    }
    set lastActivatedOutlet(outlet) {
        this._lastActivatedOutlet = outlet;
    }
    get lastActivatedOutlet() {
        return this._lastActivatedOutlet;
    }
    setComponentRef(path, componentRef) {
        this._routeComp[path] = componentRef;
    }
    getComponentRef(path) {
        return this._routeComp[path];
    }
    fullPath(snapshot) {
        let path = '';
        const rootElems = snapshot.pathFromRoot;
        rootElems.forEach(function (child) {
            const urlArray = child.url;
            urlArray.forEach(function (url) {
                path += `/${url.path}`;
            });
        });
        return path;
    }
    getLeafNodePath(route) {
        let path;
        // if (!route.routeConfig.loadChildren) {
        // If !route.component, this is a parent route. Return path of the leaf node in this case.
        if (!route.component) {
            const leafNode = this.getLeafNode(route);
            path = this.fullPath(leafNode);
        }
        else {
            path = this.fullPath(route);
        }
        // }
        return path;
    }
    getLeafNode(route) {
        if (!route.children || route.children.length === 0) {
            return route;
        }
        return this.getLeafNode(route.firstChild || route.children[0]);
    }
};
RufRouterUtilService = __decorate([
    Injectable()
], RufRouterUtilService);

let RufRouterOutletDirective = class RufRouterOutletDirective extends RouterOutlet {
    constructor(rufParentContexts, rufLocation, rufResolver, rufName, rufChangeDetector, util) {
        super(rufParentContexts, rufLocation, rufResolver, rufName, rufChangeDetector);
        this.rufParentContexts = rufParentContexts;
        this.rufLocation = rufLocation;
        this.rufResolver = rufResolver;
        this.rufName = rufName;
        this.rufChangeDetector = rufChangeDetector;
        this.util = util;
        this.rufName = rufName || PRIMARY_OUTLET;
    }
    detach() {
        const componentRef = super.detach();
        const lastActivatedOutlet = this.util.lastActivatedOutlet;
        // Detach child routes when a parent route like /banner or /layout is being detached.
        if (lastActivatedOutlet && lastActivatedOutlet.isActivated) {
            const lastCompRef = lastActivatedOutlet.detach();
            this.util.setComponentRef(this.util.lastActivatedPath, lastCompRef);
        }
        else {
            this.util.setComponentRef(this.util.lastActivatedPath, componentRef);
        }
        return componentRef;
    }
    activateWith(activatedRoute, resolver) {
        this.storePreviousRoute(activatedRoute);
        super.activateWith(activatedRoute, resolver);
    }
    attach(ref, activatedRoute) {
        this.storePreviousRoute(activatedRoute);
        super.attach(ref, activatedRoute);
    }
    storePreviousRoute(activatedRoute) {
        this.util.lastActivatedPath = this.util.fullPath(activatedRoute.snapshot);
        if (!activatedRoute.children || activatedRoute.children.length === 0) {
            // Store router outlet only in case of leaf routes. This will be used when detaching parent routes.
            this.util.lastActivatedOutlet = this.rufParentContexts.getContext(this.rufName).outlet;
        }
    }
};
RufRouterOutletDirective = __decorate([
    Directive({
        selector: 'ruf-router-outlet' // tslint:disable-line
    }),
    __param(3, Attribute('name')),
    __metadata("design:paramtypes", [ChildrenOutletContexts,
        ViewContainerRef,
        ComponentFactoryResolver, String, ChangeDetectorRef,
        RufRouterUtilService])
], RufRouterOutletDirective);

var RufRouterModule_1;
let RufRouterModule = RufRouterModule_1 = class RufRouterModule {
    static forRoot() {
        return {
            ngModule: RufRouterModule_1,
            providers: [RufRouterUtilService]
        };
    }
};
RufRouterModule = RufRouterModule_1 = __decorate([
    NgModule({ declarations: [RufRouterOutletDirective], imports: [CommonModule], exports: [RufRouterOutletDirective] })
], RufRouterModule);

class RufRouteReuseStrategy extends RouteReuseStrategy {
}

let RufCardControlsDirective = class RufCardControlsDirective {
};
RufCardControlsDirective = __decorate([
    Directive({
        selector: 'ruf-card-controls' // tslint:disable-line
    })
], RufCardControlsDirective);
let RufCardSubtitleDirective = class RufCardSubtitleDirective {
};
RufCardSubtitleDirective = __decorate([
    Directive({
        selector: 'ruf-card-subtitle' // tslint:disable-line
    })
], RufCardSubtitleDirective);
let RufCardComponent = class RufCardComponent {
    constructor(_intl, changeDetectorRef) {
        this._intl = _intl;
        this.expandable = false;
        this.expanded = true;
        this._intlChanges = _intl.changes.subscribe(() => changeDetectorRef.markForCheck());
    }
    get expandLabel() {
        return this._expandLabel || this._intl.card.aria.expandLabel;
    }
    set expandLabel(value) {
        this._expandLabel = value;
    }
    get collapseLabel() {
        return this._collapseLabel || this._intl.card.aria.collapseLabel;
    }
    set collapseLabel(value) {
        this._collapseLabel = value;
    }
    get toggleLabel() {
        return this.expanded ? this.collapseLabel : this.expandLabel;
    }
    ngOnDestroy() {
        this._intlChanges.unsubscribe();
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], RufCardComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufCardComponent.prototype, "expandable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufCardComponent.prototype, "expanded", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufCardComponent.prototype, "expandLabel", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufCardComponent.prototype, "collapseLabel", null);
RufCardComponent = __decorate([
    Component({
        selector: 'ruf-card',
        template: "<mat-card class=\"ruf-card\" rufId=\"card_panel\" [ngClass]=\"{'ruf-card-collapsed': !expanded, 'ruf-card-expanded': expanded}\">\n  <mat-card-header class=\"ruf-card-header\" rufId=\"card_header\">\n    <button type=\"button\" mat-icon-button *ngIf=\"expandable\" (click)=\"expanded = !expanded\" class=\"ruf-card-expand\" [attr.aria-label]=\"toggleLabel\">\n      <mat-icon fisIcon=\"chevron\"></mat-icon>\n    </button>\n    <mat-card-title-group class=\"ruf-card-titlegroup\">\n      <mat-card-title class=\"ruf-card-title\" (click)=\"expandable && expanded = !expanded\">{{title}}</mat-card-title>\n      <mat-card-subtitle class=\"ruf-card-subtitle\">\n        <ng-content select=\"ruf-card-subtitle\"></ng-content>\n      </mat-card-subtitle>\n    </mat-card-title-group>\n    <div class=\"ruf-card-filler\"></div>\n    <div class=\"ruf-card-controls\">\n      <ng-content select=\"ruf-card-controls\"></ng-content>\n    </div>\n  </mat-card-header>\n  <mat-card-content class=\"ruf-card-content\" rufId=\"card_content\" [@expanded]=\"'' + expanded\">\n    <ng-content></ng-content>\n    <ng-content select=\"ruf-card-action-bar\"></ng-content>\n  </mat-card-content>\n</mat-card>\n",
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        animations: [
            trigger('expanded', [
                state('false', style({
                    height: 0,
                    visibility: 'hidden'
                })),
                state('true', style({
                    height: '*',
                    visibility: 'visible'
                })),
                transition('false => true', animate('300ms ease-in-out')),
                transition('true => false', animate('300ms ease-in-out'))
            ])
        ],
        styles: ["ruf-card{display:-webkit-box;display:flex}.ruf-card.mat-card{border-radius:2px;margin:0;padding:0}.ruf-card.mat-card .ruf-card-header{min-height:2.5rem;padding-left:12px}.ruf-card.mat-card .ruf-card-expand{cursor:pointer;height:30px;line-height:30px;margin:7px 5px 5px -5px;-webkit-transform:rotate(180deg);transform:rotate(180deg);-webkit-transition:-webkit-transform .3s ease-out;transition:transform .3s ease-out;transition:transform .3s ease-out,-webkit-transform .3s ease-out;width:30px}.ruf-card.mat-card.ruf-card-collapsed .ruf-card-expand{-webkit-transform:rotate(0);transform:rotate(0)}.ruf-card.mat-card .mat-select-underline{display:none}.ruf-card.mat-card .ruf-card-content{overflow:hidden}.ruf-card.mat-card .mat-card-header-text{margin:0}.ruf-card.mat-card .ruf-card-titlegroup{-ms-grid-row-align:center;align-self:center;margin:0;padding:5px 5px 5px 0}.ruf-card.mat-card .ruf-card-subtitle,.ruf-card.mat-card .ruf-card-title{margin-bottom:0}.ruf-card.mat-card .ruf-card-metric,.ruf-card.mat-card .ruf-card-metric-description{padding-right:10px;text-align:right}.ruf-card.mat-card .ruf-card-subtitle:not(:first-child),.ruf-card.mat-card .ruf-card-title:not(:first-child){margin-top:0}.ruf-card.mat-card .ruf-card-filler{-webkit-box-flex:1;flex:1 1 auto}.ruf-card.mat-card .ruf-card-controls{-ms-grid-row-align:center;align-self:center;-webkit-box-flex:0;flex:0 0 auto;margin-left:20px;padding:5px}"]
    }),
    __metadata("design:paramtypes", [RufShellIntl, ChangeDetectorRef])
], RufCardComponent);

let RufCardActionBarComponent = class RufCardActionBarComponent {
};
RufCardActionBarComponent = __decorate([
    Component({
        selector: 'ruf-card-action-bar',
        template: "<div class=\"ruf-card-action-bar\">\n  <div class=\"ruf-card-goto-links\">\n    <ng-content></ng-content>\n  </div>\n  <div class=\"ruf-card-filler\"></div>\n  <div class=\"ruf-card-action-icons\">\n    <ng-content select=\"mat-icon, [mat-icon-button]\"></ng-content>\n  </div>\n</div>\n",
        encapsulation: ViewEncapsulation.None,
        styles: ["ruf-card .ruf-card-action-bar{display:-webkit-box;display:flex;flex-wrap:wrap}ruf-card .ruf-card-action-bar .ruf-card-action-icons{-webkit-box-flex:0;flex:0 0 auto;margin-left:1.25rem;padding:.3125rem}ruf-card .ruf-card-action-bar .ruf-card-goto-links{-webkit-box-flex:1;flex:1 1 auto;padding:.3125rem}"]
    })
], RufCardActionBarComponent);

let RufCardModule = class RufCardModule {
};
RufCardModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            MatCardModule,
            RufUniqueIdModule,
            MatIconModule,
            MatButtonModule,
            RufIconModule,
            RufUtilsModule
        ],
        declarations: [RufCardComponent, RufCardActionBarComponent, RufCardControlsDirective, RufCardSubtitleDirective],
        exports: [RufCardComponent, RufCardActionBarComponent, RufCardControlsDirective, RufCardSubtitleDirective]
    })
], RufCardModule);

let RufStatusbarComponent = class RufStatusbarComponent {
    constructor(_intl, changeDetectorRef) {
        this._intl = _intl;
        this.color = 'accent';
        this.closeable = true;
        this.expandable = false;
        this.border = true;
        this.isSubtitleEmpty = false;
        this.visible = true;
        this.dismiss = new EventEmitter();
        this._intlChanges = _intl.changes.subscribe(() => changeDetectorRef.markForCheck());
    }
    get closeAriaLabel() {
        return this._closeAriaLabel || this._intl.statusbar.aria.closeIconLabel;
    }
    set closeAriaLabel(value) {
        this._closeAriaLabel = value;
    }
    get expandAriaLabel() {
        return this._expandAriaLabel || this._intl.statusbar.aria.expandIconLabel;
    }
    set expandAriaLabel(value) {
        this._expandAriaLabel = value;
    }
    get _class() {
        const colorClass = this.color ? `ruf-${this.color}` : 'ruf-accent';
        const borderClass = !this.border ? `ruf-statusbar-noborder` : '';
        return `${colorClass} ${borderClass}`;
    }
    onDismiss($event) {
        this.dismiss.emit();
    }
    ngOnDestroy() {
        this._intlChanges.unsubscribe();
    }
    ngAfterContentInit() {
        this.isSubtitleEmpty = this.subtitleContent.nativeElement.innerHTML.trim() === '';
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], RufStatusbarComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufStatusbarComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufStatusbarComponent.prototype, "closeable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufStatusbarComponent.prototype, "expandable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RufStatusbarComponent.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufStatusbarComponent.prototype, "border", void 0);
__decorate([
    ViewChild('subtitleRef', { static: true }),
    __metadata("design:type", ElementRef)
], RufStatusbarComponent.prototype, "subtitleContent", void 0);
__decorate([
    HostBinding('@animation'),
    Input(),
    __metadata("design:type", Object)
], RufStatusbarComponent.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufStatusbarComponent.prototype, "closeAriaLabel", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufStatusbarComponent.prototype, "expandAriaLabel", null);
__decorate([
    HostBinding('class'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], RufStatusbarComponent.prototype, "_class", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], RufStatusbarComponent.prototype, "dismiss", void 0);
RufStatusbarComponent = __decorate([
    Component({
        selector: 'ruf-statusbar',
        template: "<div class=\"ruf-statusbar-wrapper\" rufId=\"statubar\" role=\"alert\">\n  <div class=\"ruf-statusbar-header\">\n    <ng-content select=\"ruf-statusbar-icon\"></ng-content>\n    <div *ngIf=\"icon\" class=\"ruf-statusbar-icon\" rufId=\"ruf-statusbar-default-icon\">\n      <mat-icon rufId [rufIcon]=\"icon\" rufIconStyle='md' [color]=\"color\"></mat-icon>\n    </div>\n    <div class=\"ruf-statusbar-content\" [ngClass]=\"{'no-header-content': !title && isSubtitleEmpty}\">\n      <div class=\"ruf-statusbar-header-text\">\n        <div *ngIf=\"title\" class=\"ruf-statusbar-title\" rufId=\"statubar_title\">{{title}}</div>\n        <div class=\"ruf-statusbar-subtitle\" #subtitleRef rufId=\"statusbar-subtitle\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n      <div class=\"ruf-statusbar-detail\" [@expanded]=\"'' + (!expandable || trigger.value)\" rufId=\"statubar_detail\">\n        <ng-content select=\"ruf-statusbar-description, .ruf-statusbar-description\"></ng-content>\n      </div>\n    </div>\n    <button type=\"button\" [hidden]=\"!expandable\" rufToggleChevron fisStyle mat-icon-button class=\"ruf-statusbar-expand\" #trigger=\"rufToggle\"\n      [attr.aria-label]=\"expandAriaLabel\" rufId=\"statubar_expand\">\n    </button>\n\n    <button type=\"button\" *ngIf=\"closeable\" fisStyle mat-icon-button class=\"ruf-statusbar-close\" (click)=\"onDismiss($event)\" [attr.aria-label]=\"closeAriaLabel\"\n      rufId=\"statubar_close\">\n      <mat-icon rufIconStyle=\"sm\" fisIcon=\"close\"></mat-icon>\n    </button>\n  </div>\n</div>\n",
        animations: [trigger('animation', [
                state('0', style({ height: '0', 'min-height': '0', visibility: 'hidden' })),
                state('1', style({ height: '*', 'min-height': '*', visibility: 'visible' })),
                transition('0 => 1', animate('250ms ease-in')),
                transition('1 => 0', animate('250ms ease-out'))
            ]), trigger('expanded', [
                state('false', style({ height: 0, visibility: 'hidden' })),
                state('true', style({ height: '*', visibility: 'visible' })),
                transition('false => true', animate('300ms ease-in-out')),
                transition('true => false', animate('300ms ease-in-out'))
            ])],
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: ["ruf-statusbar{border-bottom-right-radius:.1875rem;border-left:.375rem solid;border-top-right-radius:.1875rem;display:block;min-height:2.5rem;overflow:hidden;padding:0 0 0 1rem;position:relative;-webkit-transition:border-left-color .2s;transition:border-left-color .2s}ruf-statusbar .ruf-statusbar-wrapper{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;-webkit-box-pack:center;justify-content:center;margin:auto;min-height:2.5rem}ruf-statusbar.ruf-statusbar-noborder{border-left:none}ruf-statusbar .ruf-statusbar-header{display:-webkit-box;display:flex;padding:2px}ruf-statusbar .ruf-statusbar-header .ruf-statusbar-icon{flex-shrink:0;margin-right:10px;overflow:hidden;padding-top:.4375rem;text-align:center}ruf-statusbar .ruf-statusbar-title{flex-shrink:1;margin-right:1rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}ruf-statusbar .ruf-statusbar-subtitle{-webkit-box-flex:1;flex-grow:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}ruf-statusbar .ruf-statusbar-close{flex-shrink:0;height:2.125rem!important;margin-left:auto;margin-right:.1875rem;min-width:auto}ruf-statusbar .ruf-statusbar-expand{flex-shrink:0;font-size:18px;height:1.25rem;margin-left:auto;min-width:auto}ruf-statusbar .ruf-statusbar-detail{display:-webkit-box;display:flex}ruf-statusbar ruf-statusbar-description{overflow-wrap:break-word;width:100%}ruf-statusbar ruf-statusbar-description .ruf-statusbar-description{margin-bottom:.5em;margin-right:.5em}ruf-statusbar ruf-statusbar-description .ruf-statusbar-description[style*=hidden]{margin-bottom:0}ruf-statusbar .ruf-statusbar-expand:after{position:inherit}ruf-statusbar .ruf-toggle.ruf-toggle-chevron{height:2.125rem;margin:0 .125rem .125rem;padding-right:.625rem!important}ruf-statusbar .ruf-toggle.ruf-toggle-chevron:after{margin-right:0;padding-left:0;padding-right:0}ruf-statusbar .ruf-statusbar-header-text{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;padding:.125rem 0}ruf-statusbar .ruf-statusbar-content{-webkit-box-flex:1;flex-grow:1;min-height:34px;min-width:0;padding-top:.4375rem;width:100%}ruf-statusbar .no-header-content{padding-top:.25rem}"]
    }),
    __metadata("design:paramtypes", [RufShellIntl, ChangeDetectorRef])
], RufStatusbarComponent);
let RufStatusbarIconComponent = class RufStatusbarIconComponent {
};
RufStatusbarIconComponent = __decorate([
    Component({
        selector: 'ruf-statusbar-icon',
        encapsulation: ViewEncapsulation.None,
        template: `
    <div class="ruf-statusbar-icon"><ng-content></ng-content></div>
  `
    })
], RufStatusbarIconComponent);
let RufStatusbarDescriptionComponent = class RufStatusbarDescriptionComponent {
};
RufStatusbarDescriptionComponent = __decorate([
    Component({
        selector: 'ruf-statusbar-description',
        encapsulation: ViewEncapsulation.None,
        template: `
   <div class="ruf-statusbar-description"><ng-content></ng-content></div>
  `
    })
], RufStatusbarDescriptionComponent);

let RufStatusbarModule = class RufStatusbarModule {
};
RufStatusbarModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            RufUniqueIdModule,
            MatIconModule,
            MatButtonModule,
            RufIconModule,
            RufUtilsModule,
            RufToggleModule
        ],
        declarations: [RufStatusbarComponent, RufStatusbarIconComponent, RufStatusbarDescriptionComponent],
        exports: [RufStatusbarComponent, RufStatusbarIconComponent, RufStatusbarDescriptionComponent]
    })
], RufStatusbarModule);

var RufDropdownType;
(function (RufDropdownType) {
    RufDropdownType["PopoverMenu"] = "popover-menu";
    RufDropdownType["ContextMenu"] = "context-menu";
    RufDropdownType["Dropdown"] = "dropdown";
})(RufDropdownType || (RufDropdownType = {}));
let RufDropdownPanelComponent = class RufDropdownPanelComponent {
    constructor(_overlay, _viewContainerRef) {
        this._overlay = _overlay;
        this._viewContainerRef = _viewContainerRef;
        this.hasBackdrop = true;
        this.openedChange = new EventEmitter();
        this.type = RufDropdownType.Dropdown;
        this.xPosition = 'center';
        this.yPosition = 'bottom';
        this.className = 'ruf-dropdown-panel-container';
        this.toggle = new EventEmitter();
    }
    ngOnChanges(changes) {
        if (changes &&
            changes.hasBackdrop &&
            changes.hasBackdrop.previousValue !== changes.hasBackdrop.currentValue) {
            // when value is changes for hasBackdrop set value null for overlay
            // so that it will create new overlay with updated backdrop value
            if (this._overlayRef) {
                this._overlayRef.detach();
                this._overlayRef = null;
            }
        }
    }
    open() {
        const origin = this._getOrigin();
        const overlay = this._getOverlayPosition();
        if (!this._overlayRef) {
            let positionStrategy;
            positionStrategy = this._overlay.position()
                .flexibleConnectedTo(this.origin.elementRef)
                .withPositions([
                Object.assign({}, origin.main, overlay.main),
                Object.assign({}, origin.fallback, overlay.fallback)
            ]);
            this.onPositionChanged({
                connectionPair: {
                    overlayX: overlay.main.overlayX,
                    overlayY: overlay.main.overlayY
                }
            });
            positionStrategy.positionChanges.subscribe(change => {
                this.onPositionChanged(change);
            });
            this._overlayRef = this._overlay.create({
                hasBackdrop: this.hasBackdrop,
                backdropClass: 'ruf-dropdown-panel-wrapper',
                positionStrategy
            });
            this._overlayRef.backdropClick().subscribe(() => this.close());
            this._portal = new TemplatePortal(this.content, this._viewContainerRef);
        }
        if (!this._overlayRef.hasAttached()) {
            this._overlayRef.attach(this._portal);
            this.opened = true;
            this.toggle.emit(true);
        }
        else {
            this.close();
            this.toggle.emit(false);
        }
    }
    ;
    _getOrigin() {
        let originPosition;
        originPosition = this._getPositionStrategy(this._getOriginValues(), this._getOverlayPositionValues()).originPosition;
        const { x, y } = this._invertPosition(originPosition.originX, originPosition.originY);
        if (this.type === RufDropdownType.PopoverMenu || this.type === RufDropdownType.ContextMenu) {
            return {
                main: originPosition,
                fallback: { originX: x, originY: y }
            };
        }
        else {
            return {
                main: { originX: 'start', originY: 'bottom' },
                fallback: { originX: 'end', originY: 'top' }
            };
        }
    }
    _getOverlayPosition() {
        const XPosition = this.xPosition;
        const YPosition = this.yPosition;
        let overlayPosition;
        overlayPosition = this._getPositionStrategy(this._getOriginValues(), this._getOverlayPositionValues()).overlayPosition;
        const { x, y } = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY);
        if (this.type === RufDropdownType.PopoverMenu || this.type === RufDropdownType.ContextMenu) {
            return {
                main: overlayPosition,
                fallback: { overlayX: x, overlayY: y }
            };
        }
        else {
            return {
                main: { overlayX: 'start', overlayY: 'top' },
                fallback: { overlayX: 'end', overlayY: 'bottom' }
            };
        }
    }
    _getOriginValues() {
        const xCenterYBottom = { originX: 'center', originY: 'bottom' };
        const xCenterYTop = { originX: 'center', originY: 'top' };
        const xStartYBottom = { originX: 'start', originY: 'bottom' };
        const xStartYTop = { originX: 'start', originY: 'top' };
        const xStartYCenter = { originX: 'start', originY: 'center' };
        const xEndYBottom = { originX: 'end', originY: 'bottom' };
        const xEndYTop = { originX: 'end', originY: 'top' };
        const xEndYCenter = { originX: 'end', originY: 'center' };
        return {
            xCenterYBottom: xCenterYBottom,
            xCenterYTop: xCenterYTop,
            xStartYBottom: xStartYBottom,
            xStartYTop: xStartYTop,
            xStartYCenter: xStartYCenter,
            xEndYBottom: xEndYBottom,
            xEndYTop: xEndYTop,
            xEndYCenter: xEndYCenter
        };
    }
    _getOverlayPositionValues() {
        const xCenterYTop = { overlayX: 'center', overlayY: 'top' };
        const xCenterYBottom = { overlayX: 'center', overlayY: 'bottom' };
        const xStartYTop = { overlayX: 'start', overlayY: 'top' };
        const xStartYBottom = { overlayX: 'start', overlayY: 'bottom' };
        const xStartYCenter = { overlayX: 'start', overlayY: 'center' };
        const xEndYTop = { overlayX: 'end', overlayY: 'top' };
        const xEndYBottom = { overlayX: 'end', overlayY: 'bottom' };
        const xEndYCenter = { overlayX: 'end', overlayY: 'center' };
        return {
            xCenterYTop: xCenterYTop,
            xCenterYBottom: xCenterYBottom,
            xStartYTop: xStartYTop,
            xStartYBottom: xStartYBottom,
            xStartYCenter: xStartYCenter,
            xEndYTop: xEndYTop,
            xEndYBottom: xEndYBottom,
            xEndYCenter: xEndYCenter
        };
    }
    _getPositionStrategy(origin, overlay) {
        let originPosition = origin.xCenterYBottom;
        let overlayPosition = overlay.xCenterYTop;
        if (this.xPosition === 'start') {
            if (this.yPosition === 'top') {
                originPosition = origin.xStartYTop;
                overlayPosition = overlay.xStartYBottom;
            }
            else if (this.yPosition === 'center' && this.type === RufDropdownType.PopoverMenu) {
                originPosition = origin.xStartYCenter;
                overlayPosition = overlay.xEndYCenter;
            }
            else if (this.yPosition === 'bottom' || (this.yPosition === 'center' && this.type === RufDropdownType.ContextMenu)) {
                originPosition = origin.xStartYBottom;
                overlayPosition = overlay.xStartYTop;
            }
        }
        else if (this.xPosition === 'end') {
            if (this.yPosition === 'top') {
                originPosition = origin.xEndYTop;
                overlayPosition = overlay.xEndYBottom;
            }
            else if (this.yPosition === 'center' && this.type === RufDropdownType.PopoverMenu) {
                originPosition = origin.xEndYCenter;
                overlayPosition = overlay.xStartYCenter;
            }
            else if (this.yPosition === 'bottom' || (this.yPosition === 'center' && this.type === RufDropdownType.ContextMenu)) {
                originPosition = origin.xEndYBottom;
                overlayPosition = overlay.xEndYTop;
            }
        }
        else if (this.xPosition === 'center') {
            originPosition = this.yPosition === 'top' ? origin.xCenterYTop : origin.xCenterYBottom;
            overlayPosition = this.yPosition === 'top' ? overlay.xCenterYBottom : overlay.xCenterYTop;
        }
        return {
            originPosition: originPosition,
            overlayPosition: overlayPosition
        };
    }
    _invertPosition(x, y) {
        if (x === 'start') {
            x = 'end';
        }
        else if (x === 'end') {
            x = 'start';
        }
        if (y === 'top') {
            y = 'bottom';
        }
        else if (y === 'bottom') {
            y = 'top';
        }
        return { x, y };
    }
    onPositionChanged($event) {
        if (this.type === RufDropdownType.PopoverMenu || this.type === RufDropdownType.ContextMenu) {
            if ($event.connectionPair.overlayY === 'top') {
                if ($event.connectionPair.overlayX === 'center') {
                    this.className = 'ruf-dropdown-panel-container ruf-popover-menu center-arrow-up';
                }
                else if ($event.connectionPair.overlayX === 'start') {
                    this.className = 'ruf-dropdown-panel-container ruf-popover-menu left-arrow-up';
                }
                else {
                    this.className = 'ruf-dropdown-panel-container ruf-popover-menu right-arrow-up';
                }
            }
            else if ($event.connectionPair.overlayY === 'center') {
                if ($event.connectionPair.overlayX === 'start') {
                    this.className = 'ruf-dropdown-panel-container ruf-popover-menu right-arrow-center';
                }
                else {
                    this.className = 'ruf-dropdown-panel-container ruf-popover-menu left-arrow-center';
                }
            }
            else {
                if ($event.connectionPair.overlayX === 'center') {
                    this.className = 'ruf-dropdown-panel-container ruf-popover-menu center-arrow-down';
                }
                else if ($event.connectionPair.overlayX === 'start') {
                    this.className = 'ruf-dropdown-panel-container ruf-popover-menu left-arrow-down';
                }
                else {
                    this.className = 'ruf-dropdown-panel-container ruf-popover-menu right-arrow-down';
                }
            }
        }
        else if (this.type === RufDropdownType.Dropdown) {
            this.className = 'ruf-dropdown-panel-container';
        }
    }
    close() {
        if (this.opened) {
            this.opened = false;
            this._overlayRef.detach();
            this.openedChange.emit(this.opened);
        }
    }
    hasPopup() {
        return true;
    }
    handleKeydown(event) {
        switch (event.keyCode) {
            case SPACE:
            case ENTER:
                this.open();
                event.preventDefault();
                event.stopPropagation();
                this.toggle.emit(true);
                break;
            case ESCAPE:
                this.close();
                this.toggle.emit(false);
                event.stopPropagation();
                break;
            default:
        }
    }
    handleClick(event) {
        this.open();
    }
};
__decorate([
    Input(),
    __metadata("design:type", CdkOverlayOrigin)
], RufDropdownPanelComponent.prototype, "origin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], RufDropdownPanelComponent.prototype, "opened", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufDropdownPanelComponent.prototype, "hasBackdrop", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], RufDropdownPanelComponent.prototype, "openedChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufDropdownPanelComponent.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufDropdownPanelComponent.prototype, "xPosition", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufDropdownPanelComponent.prototype, "yPosition", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], RufDropdownPanelComponent.prototype, "closeIcon", void 0);
__decorate([
    ViewChild(TemplateRef, { static: false }),
    __metadata("design:type", TemplateRef)
], RufDropdownPanelComponent.prototype, "content", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], RufDropdownPanelComponent.prototype, "toggle", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], RufDropdownPanelComponent.prototype, "handleClick", null);
RufDropdownPanelComponent = __decorate([
    Component({
        selector: 'ruf-dropdown-panel',
        template: "<ng-template>\n <div [ngClass]=\"className\">\n      <div *ngIf=\"closeIcon\">\n        <button type=\"button\" mat-icon-button class=\"dropdown-panel-close-icon\" (keydown.enter)=\"close()\" (keydown.space)=\"close()\" (click)=\"close()\" rufIconButton>\n          <mat-icon rufIconStyle=\"sm\" rufId fisIcon=\"close\"></mat-icon>\n        </button>\n        <br>\n      </div>\n      <div [ngClass]=\"{'dropdown-panel-content': closeIcon}\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n </ng-template>\n",
        encapsulation: ViewEncapsulation.None,
        styles: [".center-arrow-down:after,.center-arrow-down:before,.center-arrow-up:after,.center-arrow-up:before,.left-arrow-center:after,.left-arrow-center:before,.left-arrow-down:after,.left-arrow-down:before,.left-arrow-up:after,.left-arrow-up:before,.right-arrow-center:after,.right-arrow-center:before,.right-arrow-down:after,.right-arrow-down:before,.right-arrow-up:after,.right-arrow-up:before{border-style:solid;content:'';height:0;position:absolute;width:0;z-index:9999}.left-arrow-up{margin-top:.625rem;position:relative}.left-arrow-up:after,.left-arrow-up:before{bottom:100%;right:91%}.left-arrow-up:after{border-width:.625rem;margin-right:-.625rem}.left-arrow-up:before{border-width:.75rem;margin-right:-.75rem}.left-arrow-center{margin-right:.625rem;position:relative}.left-arrow-center:after,.left-arrow-center:before{bottom:50%;left:100%}.left-arrow-center:after{border-width:.625rem;margin-bottom:-.625rem}.left-arrow-center:before{border-width:.75rem;margin-bottom:-.75rem}.left-arrow-down{margin-bottom:.625rem;position:relative}.left-arrow-down:after,.left-arrow-down:before{right:91%;top:100%}.left-arrow-down:after{border-width:.625rem;margin-right:-.625rem}.left-arrow-down:before{border-width:.75rem;margin-right:-.75rem}.right-arrow-up{margin-top:.625rem;position:relative}.right-arrow-up:after,.right-arrow-up:before{bottom:100%;right:9%}.right-arrow-up:after{border-width:.625rem;margin-right:-.625rem}.right-arrow-up:before{border-width:.75rem;margin-right:-.75rem}.right-arrow-center{margin-left:.625rem;position:relative}.right-arrow-center:after,.right-arrow-center:before{right:100%;top:50%}.right-arrow-center:after{border-width:.625rem;margin-top:-.625rem}.right-arrow-center:before{border-width:.75rem;margin-top:-.75rem}.right-arrow-down{margin-bottom:.5rem;position:relative}.right-arrow-down:after,.right-arrow-down:before{right:9%;top:100%}.right-arrow-down:after{border-width:.625rem;margin-right:-.625rem}.right-arrow-down:before{border-width:.75rem;margin-right:-.75rem}.center-arrow-up{margin-top:.625rem;position:relative}.center-arrow-up:after,.center-arrow-up:before{bottom:100%;right:50%}.center-arrow-up:after{border-width:.625rem;margin-right:-.625rem}.center-arrow-up:before{border-width:.75rem;margin-right:-.75rem}.center-arrow-down{margin-bottom:.625rem;position:relative}.center-arrow-down:after,.center-arrow-down:before{left:50%;top:100%}.center-arrow-down:after{border-width:.625rem;margin-left:-.625rem}.center-arrow-down:before{border-width:.75rem;margin-left:-.75rem}.dropdown-panel-close-icon{float:right;opacity:.2}.dropdown-panel-close-icon:hover{cursor:pointer}.dropdown-panel-content{margin-right:1.25rem;margin-top:.5rem}.ruf-popover-menu{border-radius:.1875rem;border-style:solid;border-width:.0625rem}"]
    }),
    __metadata("design:paramtypes", [Overlay,
        ViewContainerRef])
], RufDropdownPanelComponent);

let RufDropdownPanelModule = class RufDropdownPanelModule {
};
RufDropdownPanelModule = __decorate([
    NgModule({
        imports: [CommonModule, OverlayModule, RufUniqueIdModule, RufIconModule, RufTriggerModule, MatButtonModule],
        declarations: [RufDropdownPanelComponent],
        exports: [RufDropdownPanelComponent]
    })
], RufDropdownPanelModule);

let RufEllipsisComponent = class RufEllipsisComponent {
    constructor(_intl, changeDetectorRef) {
        this._intl = _intl;
        this.changeDetectorRef = changeDetectorRef;
        this.showReadMore$ = new BehaviorSubject(false);
        this.lines = 5;
        this.lineHeight = 1;
        this.expand = new EventEmitter();
        this._intlChanges = _intl.changes.subscribe(() => this.changeDetectorRef.markForCheck());
    }
    get label() {
        return this._label || this._intl.ellipsis.label || '...';
    }
    set label(value) {
        this._label = value;
    }
    get ariaLabel() {
        return this._ariaLabel || this._intl.ellipsis.aria.label;
    }
    set ariaLabel(value) {
        this._ariaLabel = value;
    }
    checkReadMore() {
        if (this.text && this.ellipsisContainer.nativeElement.offsetHeight < this.ellipsisContainer.nativeElement.scrollHeight) {
            this.showReadMore$.next(true);
        }
        else {
            this.showReadMore$.next(false);
        }
    }
    ngAfterViewChecked() {
        this.checkReadMore();
        this.changeDetectorRef.detectChanges();
    }
    ngOnDestroy() {
        this._intlChanges.unsubscribe();
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], RufEllipsisComponent.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufEllipsisComponent.prototype, "lines", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RufEllipsisComponent.prototype, "lineHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufEllipsisComponent.prototype, "label", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufEllipsisComponent.prototype, "ariaLabel", null);
__decorate([
    ViewChild('ellipsisContainer', { static: false }),
    __metadata("design:type", ElementRef)
], RufEllipsisComponent.prototype, "ellipsisContainer", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], RufEllipsisComponent.prototype, "expand", void 0);
RufEllipsisComponent = __decorate([
    Component({
        selector: 'ruf-ellipsis',
        template: "<div  #ellipsisContainer [class]=\"'ellipsis-container'\" [style.maxHeight.rem]=\"lines * lineHeight\" [style.lineHeight.rem]=\"lineHeight\">\n  <div  class=\"ellipsis-wrapper\" >\n    <div class=\"ellipsis-content\" [innerHTML]=\"text\">\n    </div>\n  </div>\n  <span *ngIf=\"showReadMore$ | async\" [attr.aria-label]=\"ariaLabel\" class=\"ellipsis\">\n    <a (click)=\"expand.emit({'text': this.text});\" href=\"javascript:;\">{{label}}</a>\n  </span>\n</div>\n",
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: ["ruf-ellipsis .ellipsis-container{max-height:calc(5rem);overflow:hidden;position:relative}ruf-ellipsis .ellipsis-container:before{content:'';float:left;height:100%;width:1px}ruf-ellipsis .ellipsis-wrapper{float:right;margin-left:-1px;width:100%}ruf-ellipsis .ellipsis-content{margin:0}ruf-ellipsis .ellipsis-content p{margin-bottom:1rem;margin-top:0}ruf-ellipsis .ellipsis{bottom:0;position:absolute;right:0;text-align:right;width:auto}"]
    }),
    __metadata("design:paramtypes", [RufShellIntl, ChangeDetectorRef])
], RufEllipsisComponent);

let RufEllipsisModule = class RufEllipsisModule {
};
RufEllipsisModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            RufUtilsModule
        ],
        declarations: [RufEllipsisComponent],
        exports: [RufEllipsisComponent]
    })
], RufEllipsisModule);

let RufInkbarDirective = class RufInkbarDirective {
    constructor(renderer, elm) {
        this.renderer = renderer;
        this.elm = elm;
        this._color = 'primary';
        this._position = 'bottom';
        this.rufInkbar = 'ruf-inkbar';
        // add default classes;
        this._updateClass(this._color, null);
        this._updateClass(this._position, null);
    }
    get inkbarPosition() {
        return this._position;
    }
    set inkbarPosition(value) {
        const position = value || 'bottom';
        this._updateClass(position, this._position);
        this._position = position;
    }
    get inkbarColor() {
        return this._color;
    }
    set inkbarColor(value) {
        const color = value || 'primary';
        this._updateClass(color, this._color);
        this._color = color;
    }
    // method to update the class based on the input
    _updateClass(newValue, oldValue) {
        if (oldValue) {
            // remove class only if newValue is not null
            this.renderer.removeClass(this.elm.nativeElement, `ruf-inkbar-${oldValue}`);
        }
        if (newValue) {
            this.renderer.addClass(this.elm.nativeElement, `ruf-inkbar-${newValue}`);
        }
    }
};
__decorate([
    HostBinding('class.ruf-inkbar'),
    __metadata("design:type", Object)
], RufInkbarDirective.prototype, "rufInkbar", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufInkbarDirective.prototype, "inkbarPosition", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufInkbarDirective.prototype, "inkbarColor", null);
RufInkbarDirective = __decorate([
    Directive({
        selector: '[rufInkbar]',
        exportAs: 'rufInkbar'
    }),
    __metadata("design:paramtypes", [Renderer2, ElementRef])
], RufInkbarDirective);
let RufInkbarActiveDirective = class RufInkbarActiveDirective {
    constructor() {
        this.rufInkbarItem = 'ruf-inkbar-item';
    }
    get _inkbarActive() {
        return this.rufInkbarActive;
    }
};
__decorate([
    HostBinding('class.ruf-inkbar-item'),
    __metadata("design:type", Object)
], RufInkbarActiveDirective.prototype, "rufInkbarItem", void 0);
__decorate([
    HostBinding('class.ruf-inkbar-active'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], RufInkbarActiveDirective.prototype, "_inkbarActive", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], RufInkbarActiveDirective.prototype, "rufInkbarActive", void 0);
RufInkbarActiveDirective = __decorate([
    Directive({
        selector: '[rufInkbarActive]',
        exportAs: 'rufInkbarActive'
    })
], RufInkbarActiveDirective);

let RufInkbarModule = class RufInkbarModule {
};
RufInkbarModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [RufInkbarDirective, RufInkbarActiveDirective],
        exports: [
            RufInkbarDirective, RufInkbarActiveDirective
        ]
    })
], RufInkbarModule);

let RufSidePanelComponent = class RufSidePanelComponent {
    constructor(_intl, changeDetectorRef) {
        this._intl = _intl;
        this.changeDetectorRef = changeDetectorRef;
        /* tslint:disable:no-input-rename */
        this.isPinned = false;
        this.togglePin = new EventEmitter();
        this._intlChanges = _intl.changes.subscribe(() => {
            changeDetectorRef.markForCheck();
        });
    }
    get pinLabel() {
        return this._pinLabel || this._intl.sidepanel.aria.pinLabel;
    }
    set pinLabel(value) {
        this._pinLabel = value;
    }
    get unpinLabel() {
        return this._unpinLabel || this._intl.sidepanel.aria.unpinLabel;
    }
    set unpinLabel(value) {
        this._unpinLabel = value;
    }
    get toggleLabel() {
        return this.isPinned ? this.unpinLabel : this.pinLabel;
    }
    onPintoggle($event) {
        this.isPinned = !this.isPinned;
        this.togglePin.emit({ 'pinned': this.isPinned });
    }
    ngOnDestroy() {
        this._intlChanges.unsubscribe();
    }
};
__decorate([
    Input('pinned'),
    __metadata("design:type", Object)
], RufSidePanelComponent.prototype, "isPinned", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], RufSidePanelComponent.prototype, "togglePin", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufSidePanelComponent.prototype, "pinLabel", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufSidePanelComponent.prototype, "unpinLabel", null);
RufSidePanelComponent = __decorate([
    Component({
        selector: 'ruf-side-panel',
        template: "<div rufId class=\"ruf-side-panel-container\">\n  <button type=\"button\"\n          rufId=\"ruf_toggle_pin\"\n          class=\"ruf-side-panel-pin\"\n          mat-icon-button\n          fisStyle\n          [attr.aria-label]=\"toggleLabel\"\n          (click)=\"onPintoggle($event)\">\n      <mat-icon rufIconStyle=\"lg\" rufId=\"pin_icon\"\n              [fisIcon]=\"isPinned ? 'pin-remove': 'pin'\">\n      </mat-icon>\n  </button>\n  <ng-content></ng-content>\n</div>\n",
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: ["ruf-side-panel .ruf-side-panel-container{border-style:solid;border-width:.0625rem;bottom:0;box-sizing:border-box;height:100%;max-width:25rem;min-width:18.75rem;overflow:auto;position:relative;top:0;width:100%}ruf-side-panel .ruf-side-panel-pin{float:right;margin:.3125rem}"]
    }),
    __metadata("design:paramtypes", [RufShellIntl,
        ChangeDetectorRef])
], RufSidePanelComponent);

let RufSidePanelModule = class RufSidePanelModule {
};
RufSidePanelModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            MatButtonModule,
            MatIconModule,
            RufIconModule,
            RufUtilsModule,
            RufUniqueIdModule
        ],
        declarations: [RufSidePanelComponent],
        exports: [RufSidePanelComponent]
    })
], RufSidePanelModule);

const SHELL_MODULES = [
    RufToggleModule,
    RufTriggerModule,
    RufDynamicMenubarModule,
    RufDynamicSideMenuModule,
    RufMenubarModule,
    RufSidemenuModule,
    RufBannerModule,
    RufToolbarModule,
    RufAppCanvasModule,
    RufFooterModule,
    RufLayoutModule,
    RufI18nModule,
    RufLabeledIconModule,
    RufIconButtonModule,
    RufPageHeaderModule,
    FlexLayoutModule,
    RufNavbarModule,
    RufMegamenuModule,
    RufDialogPanelModule,
    RufUtilsModule,
    RufRouterModule,
    RufMenuLabelModule,
    RufUniqueIdModule,
    RufSitemapModule,
    RufDropdownPanelModule,
    RufCardModule,
    RufIconModule,
    RufStatusbarModule,
    RufEllipsisModule,
    RufSidePanelModule,
    RufInkbarModule
];
let RufShellRootModule = class RufShellRootModule {
};
RufShellRootModule = __decorate([
    NgModule({
        imports: [
            RufToggleModule,
            RufTriggerModule,
            RufDynamicMenubarModule,
            RufDynamicSideMenuModule,
            RufMenubarModule,
            RufSidemenuModule,
            RufBannerModule,
            RufToolbarModule,
            RufAppCanvasModule,
            RufFooterModule,
            RufLayoutModule,
            RufI18nModule,
            FlexLayoutModule,
            RufLabeledIconModule,
            RufIconButtonModule,
            RufPageHeaderModule,
            RufNavbarModule,
            RufDialogPanelModule,
            RufUtilsModule,
            RufRouterModule,
            RufMegamenuModule,
            RufUniqueIdModule,
            RufSitemapModule,
            RufDropdownPanelModule,
            RufCardModule,
            RufIconModule,
            RufStatusbarModule,
            RufEllipsisModule,
            RufSidePanelModule,
            RufInkbarModule
        ],
        exports: SHELL_MODULES
    })
], RufShellRootModule);
let RufShellModule = class RufShellModule {
};
RufShellModule = __decorate([
    NgModule({
        imports: SHELL_MODULES,
        exports: SHELL_MODULES,
        providers: []
    })
], RufShellModule);

let RufDynamicSegmentComponent = class RufDynamicSegmentComponent {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this.items = [];
        /* tslint:disable:no-output-rename */
        // Renaming output to avoid duplicate `select` identifiers
        this.selectEmitter = new EventEmitter();
    }
    set selectedPath(id) {
        this._selectedPath = id;
    }
    get selectedPath() {
        return this._selectedPath;
    }
    ngAfterViewInit() {
        this.addNewKeyboardNav();
        this.segmentItems.changes.subscribe(() => {
            this.addNewKeyboardNav();
        });
    }
    onKey(event) {
        this._keyboardNav.onKeyDown(event);
    }
    ngOnChanges(changes) {
        if (changes.selectedPath && changes.selectedPath.currentValue) {
            this.selectSegmentItem({ path: changes.selectedPath.currentValue });
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    // Set Keyboard navigation
    addNewKeyboardNav() {
        this._keyboardNav = new RufKeyboardNavigation();
        this.subscription = this._keyboardNav.init(this._elementRef, this.segmentItems).subscribe(item => {
            this.selectSegmentItem({ path: item.value });
        });
        this._keyboardNav.addTabIndex(this.segmentItems);
    }
    /**
     * Set selectedPath and activate dynamic-segment item
     * @param item
     */
    selectSegmentItem(item) {
        this._selectedPath = item.path;
        const selectedIndex = this.selectedIndex();
        if (this._keyboardNav) {
            this._keyboardNav.setActiveItem((selectedIndex === -1) ? 0 : selectedIndex);
        }
        if (this.segmentItems) {
            // if segmentItems are not present, the component view is not loaded yet.
            // This means 'selectSegmentItem' is called from 'ngOnChanges' and the host element has [selectedPath] input.
            const selectedItem = (selectedIndex === -1) ? null : this.items[selectedIndex];
            this.selectEmitter.emit(selectedItem);
        }
    }
    /**
     * @returns - index of the selected dynamic-segment item. -1 if no dynamic-segment is selected.
     */
    selectedIndex() {
        let index = -1;
        if (this.segmentItems) {
            index = this.items.findIndex((segmentItem, i) => this._matches(segmentItem.path));
        }
        return index;
    }
    _matches(path) {
        if (path && this.selectedPath) {
            const pattern = new RegExp('^((\/)?' + this.selectedPath + ')(\/.*)?$'); // use word boundary to exact match
            if (path === this.selectedPath || pattern.test(path)) { // match with and parent dynamic-segment item
                return true;
            }
        }
        return false;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Array)
], RufDynamicSegmentComponent.prototype, "items", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], RufDynamicSegmentComponent.prototype, "showActiveItemClip", void 0);
__decorate([
    Output('select'),
    __metadata("design:type", Object)
], RufDynamicSegmentComponent.prototype, "selectEmitter", void 0);
__decorate([
    ViewChildren(MatButtonToggle),
    __metadata("design:type", QueryList)
], RufDynamicSegmentComponent.prototype, "segmentItems", void 0);
__decorate([
    ContentChild(TemplateRef, { static: false }),
    __metadata("design:type", Object)
], RufDynamicSegmentComponent.prototype, "navActions", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RufDynamicSegmentComponent.prototype, "selectedPath", null);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], RufDynamicSegmentComponent.prototype, "onKey", null);
RufDynamicSegmentComponent = __decorate([
    Component({
        selector: 'ruf-dynamic-segment',
        template: "<div class=\"segment-layout\" role=\"menubar\">\n  <mat-button-toggle-group rufId=\"segmentGroup\" fisStyle class=\"segment-group\" value=\"{{selectedPath}}\">\n    <mat-button-toggle rufId class=\"segment-item\"\n                       [class.mat-button-toggle-selected]=\"selectedPath === item.path ? true : false\"\n                       [class.mat-button-toggle-checked]=\"selectedPath === item.path ? true : false\"\n                       [class.segment-clip]=\"showActiveItemClip\"\n                       fisStyle\n                       *ngFor=\"let item of items\"\n                       (click)=\"selectSegmentItem(item)\"\n                       value=\"{{item.path}}\"\n                       title=\"{{item.tooltipText}}\"\n                       role=\"menuitem\">\n      {{item.label}}\n      <ng-template [ngTemplateOutlet]=\"navActions\" [ngTemplateOutletContext]=\"{item: item}\">\n      </ng-template>\n    </mat-button-toggle>\n  </mat-button-toggle-group>\n</div>\n",
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [".segment-layout{-webkit-box-align:stretch;align-items:stretch;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.segment-layout .mat-button-toggle-group{overflow:visible}.segment-item:focus{outline:0}.segment-item>label{cursor:pointer;text-align:center;width:100%}.segment-group>.segment-item{-webkit-box-align:center;align-items:center;border-bottom-style:solid;border-bottom-width:.125rem;border-color:transparent;border-top-style:solid;border-top-width:.125rem;cursor:pointer;display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1 auto;-webkit-box-pack:center;justify-content:center;padding:0;-webkit-transition:background-color .2s;transition:background-color .2s}.segment-group>.segment-clip::after{border-left:10px solid transparent;border-right:10px solid transparent;border-top:15px solid transparent;content:'';left:calc(50% - 10px);position:absolute;top:100%}"]
    }),
    __metadata("design:paramtypes", [ElementRef])
], RufDynamicSegmentComponent);

let RufDynamicSegmentModule = class RufDynamicSegmentModule {
};
RufDynamicSegmentModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            MatButtonToggleModule,
            RufUniqueIdModule
        ],
        declarations: [
            RufDynamicSegmentComponent
        ],
        exports: [
            RufDynamicSegmentComponent
        ]
    })
], RufDynamicSegmentModule);

export { RUF_ICON_STYLE_VALUES, RUF_INFO, RUF_MARGIN_VALUES, RUF_PADDING_VALUES, RufAppCanvasComponent, RufAppCanvasModule, RufBannerBrandComponent, RufBannerComponent, RufBannerControlsDirective, RufBannerModule, RufBannerRowDirective, RufCardActionBarComponent, RufCardComponent, RufCardControlsDirective, RufCardModule, RufCardSubtitleDirective, RufCart, RufCurrencyPipe, RufDatePipe, RufDialogContentDirective, RufDialogFooterDirective, RufDialogHeaderDirective, RufDialogPanelComponent, RufDialogPanelModule, RufDropdownPanelComponent, RufDropdownPanelModule, RufDropdownType, RufDynamicMenubarComponent, RufDynamicMenubarModule, RufDynamicNavType, RufDynamicSegmentComponent, RufDynamicSegmentModule, RufDynamicSideMenuComponent, RufDynamicSideMenuModule, RufElementRefBase, RufEllipsisComponent, RufEllipsisModule, RufFocusableDirective, RufFooterComponent, RufFooterControlsDirective, RufFooterModule, RufI18nModule, RufIconButtonDirective, RufIconButtonModule, RufIconDirective, RufIconModule, RufIconStyleDirective, RufIfDirective, RufInkbarActiveDirective, RufInkbarDirective, RufInkbarModule, RufKeyCodes, RufKeyboardNavigation, RufLabeledIconComponent, RufLabeledIconModule, RufLayoutModule, RufLocaleService, RufMDIStrategy, RufMarginDirective, RufMegamenuComponent, RufMegamenuModule, RufMegamenuSearchComponent, RufMenuLabelComponent, RufMenuLabelModule, RufMenubarComponent, RufMenubarItemComponent, RufMenubarModule, RufMixinBase, RufNavbarComponent, RufNavbarModule, RufPaddingDirective, RufPageHeaderComponent, RufPageHeaderDescriptionComponent, RufPageHeaderIconComponent, RufPageHeaderModule, RufPageHeaderRowDirective, RufPageHeaderTitleComponent, RufRouteReuseStrategy, RufRouterModule, RufRouterOutletDirective, RufRouterUtilService, RufSearchService, RufShellIntl, RufShellModule, RufShellRootModule, RufSidePanelComponent, RufSidePanelModule, RufSidemenuChildrenComponent, RufSidemenuComponent, RufSidemenuItemComponent, RufSidemenuModule, RufSitemapComponent, RufSitemapModule, RufStatusbarComponent, RufStatusbarDescriptionComponent, RufStatusbarIconComponent, RufStatusbarModule, RufToggleDirective, RufToggleModule, RufToolbarComponent, RufToolbarFillerDirective, RufToolbarModule, RufToolbarRowDirective, RufTriggerDirective, RufTriggerModule, RufUniqueIdDirective, RufUniqueIdModule, RufUtilsModule, RufWindowRef, info, infoToken, localeFactory, rufMixinColor, throwTargetMissingError, versionString, ɵ0 };
//# sourceMappingURL=ruf-shell.js.map
