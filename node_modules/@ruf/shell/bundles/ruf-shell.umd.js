/*!
FIS Responsive UI Framework: @ruf/shell
Version: 6.0.0

© 2018
Fidelity National Information Services, Inc. and/or its subsidiaries - All Rights Reserved worldwide.
This document is protected under the trade secret and copyright laws as the property of Fidelity National Information Services, Inc. and/or its subsidiaries.
Copying, reproduction or distribution should be limited and only to employees with a “need to know” to do their job. Any disclosure of this document to third parties is strictly prohibited.
*/

/*!
FIS Responsive UI Framework: @ruf/shell
Version: undefined

© 2018
Fidelity National Information Services, Inc. and/or its subsidiaries - All Rights Reserved worldwide.
This document is protected under the trade secret and copyright laws as the property of Fidelity National Information Services, Inc. and/or its subsidiaries.
Copying, reproduction or distribution should be limited and only to employees with a “need to know” to do their job. Any disclosure of this document to third parties is strictly prohibited.
*/

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('@angular/common'), require('@angular/cdk/a11y'), require('@angular/cdk/keycodes'), require('@angular/material/button'), require('@angular/material/dialog'), require('@angular/material/icon'), require('@angular/material/tabs'), require('rxjs/operators'), require('@angular/material/menu'), require('@angular/cdk/overlay'), require('@angular/flex-layout'), require('@angular/animations'), require('@angular/router'), require('@angular/material/card'), require('@angular/cdk/portal'), require('@angular/material/button-toggle')) :
    typeof define === 'function' && define.amd ? define('@ruf/shell', ['exports', '@angular/core', 'rxjs', '@angular/common', '@angular/cdk/a11y', '@angular/cdk/keycodes', '@angular/material/button', '@angular/material/dialog', '@angular/material/icon', '@angular/material/tabs', 'rxjs/operators', '@angular/material/menu', '@angular/cdk/overlay', '@angular/flex-layout', '@angular/animations', '@angular/router', '@angular/material/card', '@angular/cdk/portal', '@angular/material/button-toggle'], factory) :
    (global = global || self, factory((global.ruf = global.ruf || {}, global.ruf.shell = {}), global.ng.core, global.Rx, global.ng.common, global.ng.cdk.a11y, global.ng.cdk.keycodes, global.ng.material.button, global.ng.material.dialog, global.ng.material.icon, global.ng.material.tabs, global.Rx.Observable.prototype, global.ng.material.menu, global.ng.cdk.overlay, global.ng['flex-layout'], global.ng.animations, global.ng.router, global.ng.material.card, global.ng.cdk.portal, global.ng.material['button-toggle']));
}(this, function (exports, core, rxjs, common, a11y, keycodes, button, dialog, icon, tabs, operators, menu, overlay, flexLayout, animations, router, card, portal, buttonToggle) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    var versionString = '4.7.0-beta8-SNAPSHOT';

    function infoToken() {
        return new core.InjectionToken('RUF_INFO');
    }
    var RUF_INFO = infoToken;
    var info = {
        version: versionString,
        get copyright() {
            return '© ' + new Date().getFullYear() + ' FIS';
        }
    };
    console.log('RUF ' + info.version);
    console.log(info.copyright);

    function _window() {
        // return the global native browser window object
        return window;
    }
    var RufWindowRef = /** @class */ (function () {
        function RufWindowRef() {
        }
        Object.defineProperty(RufWindowRef.prototype, "nativeWindow", {
            get: function () {
                return _window();
            },
            enumerable: true,
            configurable: true
        });
        RufWindowRef = __decorate([
            core.Injectable()
        ], RufWindowRef);
        return RufWindowRef;
    }());

    /**
     * Labels used by all shell components that require internationalization.
     * These components also have individual attributes for these labels.
     * Users can either provide attributes
     * e.g., `closeIconTitle` can be provided by users for title of modal dialog close button.
     * <button mat-icon-button mat-dialog-close [title]="closeIconTitle">
     * </button>
     * or
     * Provide an instance of this class which overrides `closeIconTitle`.
     * */
    var RufShellIntl = /** @class */ (function () {
        function RufShellIntl() {
            /**
             * Stream that emits whenever the labels here are changed. Use this to notify
             * components if the labels have changed after initialization.
             */
            this.changes = new rxjs.Subject();
            this.dynamicmenubar = {
                aria: { closeIconLabel: 'Close' }
            };
            this.dialog = { closeIconTitle: 'Close' };
            this.banner = {
                altText: 'logo',
                aria: {
                    label: 'Banner',
                    labelledBy: null
                }
            };
            this.toolbar = {
                aria: { label: 'Toolbar' }
            };
            this.statusbar = {
                aria: { closeIconLabel: 'Close', expandIconLabel: 'Expand' }
            };
            this.ellipsis = {
                label: '...Read More',
                aria: { label: 'Read More' }
            };
            this.megamenu = {
                placeholder: 'Search',
                aria: { clearSearchLabel: 'Clear search' }
            };
            this.megamenusearch = {
                placeholder: 'Search',
                aria: { clearSearchLabel: 'Clear search' }
            };
            this.card = {
                aria: {
                    expandLabel: 'Expand',
                    collapseLabel: 'Collapse'
                }
            };
            this.fileupload = {
                aria: {
                    label: 'Choose File'
                },
                label: 'Choose File',
                placeholder: 'No file chosen',
                fileNameLabel: 'File Name',
                sizeLabel: 'Size',
                progressLabel: 'Progress'
            };
            this.sidepanel = {
                aria: {
                    pinLabel: 'Pin',
                    unpinLabel: 'Unpin'
                }
            };
        }
        RufShellIntl = __decorate([
            core.Injectable()
        ], RufShellIntl);
        return RufShellIntl;
    }());

    /**
     * This attribute directive should be placed on any element that needs to get focus on keyboard navigation
     */
    var RufFocusableDirective = /** @class */ (function () {
        function RufFocusableDirective(_elementRef) {
            this._elementRef = _elementRef;
        }
        RufFocusableDirective.prototype.focus = function () {
            this._elementRef.nativeElement.focus();
        };
        Object.defineProperty(RufFocusableDirective.prototype, "disabled", {
            get: function () {
                return this._elementRef.nativeElement.disabled;
            },
            enumerable: true,
            configurable: true
        });
        RufFocusableDirective = __decorate([
            core.Directive({
                selector: '[rufFocusable], [ruf-focusable]' // tslint:disable-line
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], RufFocusableDirective);
        return RufFocusableDirective;
    }());

    var ɵ0 = info;
    var RufUtilsModule = /** @class */ (function () {
        function RufUtilsModule() {
        }
        RufUtilsModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule],
                declarations: [
                    RufFocusableDirective
                ],
                exports: [
                    RufFocusableDirective
                ],
                providers: [RufWindowRef, RufShellIntl, { provide: RUF_INFO, useValue: ɵ0 }]
            })
        ], RufUtilsModule);
        return RufUtilsModule;
    }());

    /**The MIT License

    Copyright (c) 2017 Google, Inc.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    */
    var RufKeyCodes = /** @class */ (function () {
        function RufKeyCodes() {
        }
        RufKeyCodes.ENTER = 13;
        RufKeyCodes.ESCAPE = 27;
        RufKeyCodes.SPACE = 32;
        RufKeyCodes.LEFT_ARROW = 37;
        RufKeyCodes.UP_ARROW = 38;
        RufKeyCodes.RIGHT_ARROW = 39;
        RufKeyCodes.DOWN_ARROW = 40;
        return RufKeyCodes;
    }());
    var RufKeyboardNavigation = /** @class */ (function () {
        function RufKeyboardNavigation() {
            this._direction = 'row';
        }
        // To receive select notifications, subscribe to this function
        RufKeyboardNavigation.prototype.init = function (container, items) {
            this._container = container;
            this._items = items;
            this._FocusKeyManager = new a11y.FocusKeyManager(items).withWrap();
            this._ListKeyManager = new a11y.ListKeyManager(items);
            if (items.length > 0) {
                this.setActiveItemWithoutFocus(0);
                this._ListKeyManager.setActiveItem.call(this._FocusKeyManager, 0);
            }
            this._subscription = new rxjs.Subject();
            return this._subscription;
        };
        RufKeyboardNavigation.prototype.setActiveItem = function (index) {
            this._FocusKeyManager.setActiveItem(index);
        };
        RufKeyboardNavigation.prototype.setActiveItemWithoutFocus = function (index) {
            this._ListKeyManager.setActiveItem.call(this._FocusKeyManager, index);
        };
        RufKeyboardNavigation.prototype.navigate = function (event) {
            switch (event.keyCode) {
                case RufKeyCodes.ESCAPE:
                    this._container.nativeElement.focus();
                    break;
                case RufKeyCodes.LEFT_ARROW:
                case RufKeyCodes.UP_ARROW:
                    this._FocusKeyManager.setPreviousItemActive();
                    // prevent scrollbar catching the event
                    this.preventEventPropagation(event);
                    break;
                case RufKeyCodes.RIGHT_ARROW:
                case RufKeyCodes.DOWN_ARROW:
                    this._FocusKeyManager.setNextItemActive();
                    // prevent scrollbar catching the event
                    this.preventEventPropagation(event);
                    break;
                case RufKeyCodes.SPACE:
                case RufKeyCodes.ENTER:
                    this.selectFocusedItem();
                    // prevent scrollbar catching the event
                    this.preventEventPropagation(event);
                    break;
                case keycodes.HOME:
                    this._FocusKeyManager.setFirstItemActive();
                    // prevent scrollbar catching the event
                    this.preventEventPropagation(event);
                    break;
                case keycodes.END:
                    this._FocusKeyManager.setLastItemActive();
                    // prevent scrollbar catching the event
                    this.preventEventPropagation(event);
                    break;
                default:
                    this._FocusKeyManager.onKeydown(event);
                    break;
            }
        };
        RufKeyboardNavigation.prototype.preventEventPropagation = function (event) {
            event.preventDefault();
            event.stopPropagation();
        };
        RufKeyboardNavigation.prototype.onKeyDown = function (event) {
            if (this._items.length === 0) {
                return;
            }
            this.navigate(event);
        };
        RufKeyboardNavigation.prototype.addTabIndex = function (focusableItems) {
            focusableItems.forEach(function (child, index) {
                if (index === 0) {
                    child._elementRef.nativeElement.setAttribute('tabindex', 0);
                }
                else {
                    child._elementRef.nativeElement.setAttribute('tabindex', -1);
                }
            });
        };
        RufKeyboardNavigation.prototype.selectFocusedItem = function () {
            if (this._FocusKeyManager.activeItem) {
                this._subscription.next(this._FocusKeyManager.activeItem);
            }
        };
        RufKeyboardNavigation.prototype.focus = function (path) {
            if (!this._items || this._items.length === 0) {
                return;
            }
            var item = this._items.find(function (f) { return f.path === path; });
            var index = this._items.toArray().indexOf(item);
            this._FocusKeyManager.setActiveItem(index);
        };
        RufKeyboardNavigation.prototype.isActive = function () {
            return this._FocusKeyManager.activeItem !== undefined;
        };
        RufKeyboardNavigation.prototype.setDirection = function (direction) {
            if (direction === 'column') {
                this._direction = direction;
            }
        };
        return RufKeyboardNavigation;
    }());

    // tslint doesn't see the selector is kebab-case here
    /* tslint:disable:directive-selector-name */
    var RufToolbarFillerDirective = /** @class */ (function () {
        function RufToolbarFillerDirective(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            renderer.setStyle(el.nativeElement, 'flex', '1 1 auto');
        }
        RufToolbarFillerDirective = __decorate([
            core.Directive({ selector: '[rufToolbarFiller]' }),
            __metadata("design:paramtypes", [core.ElementRef, core.Renderer2])
        ], RufToolbarFillerDirective);
        return RufToolbarFillerDirective;
    }());

    /**
     * @license
     * The MIT License

     * Copyright (c) 2010-2019 Google LLC. http://angular.io/license

     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
     * files (the "Software"), * to deal in the Software without restriction, including without limitation the rights to use, copy,
     * modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
     * is furnished to do so, subject to the following conditions:

     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    function rufMixinColor(base, defaultColor) {
        return /** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, __spread(args)) || this;
                // Set the default color that can be specified from the mixin.
                _this.color = defaultColor;
                return _this;
            }
            Object.defineProperty(class_1.prototype, "color", {
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    var colorPalette = value || defaultColor;
                    if (colorPalette !== this._color) {
                        if (this._color) {
                            this._elementRef.nativeElement.classList.remove("ruf-" + this._color);
                        }
                        if (colorPalette) {
                            this._elementRef.nativeElement.classList.add("ruf-" + colorPalette);
                        }
                        this._color = colorPalette;
                    }
                },
                enumerable: true,
                configurable: true
            });
            return class_1;
        }(base));
    }
    var RufElementRefBase = /** @class */ (function () {
        function RufElementRefBase(_elementRef) {
            this._elementRef = _elementRef;
        }
        return RufElementRefBase;
    }());
    var RufMixinBase = rufMixinColor(RufElementRefBase);

    var RufToolbarRowDirective = /** @class */ (function () {
        function RufToolbarRowDirective() {
        }
        RufToolbarRowDirective = __decorate([
            core.Directive({
                selector: 'ruf-toolbar-row' // tslint:disable-line
            })
        ], RufToolbarRowDirective);
        return RufToolbarRowDirective;
    }());
    var RufToolbarComponent = /** @class */ (function (_super) {
        __extends(RufToolbarComponent, _super);
        function RufToolbarComponent(_elementRef, _intl, changeDetectorRef) {
            var _this = _super.call(this, _elementRef) || this;
            _this._elementRef = _elementRef;
            _this._intl = _intl;
            _this.children = [];
            _this._intlChanges = _intl.changes.subscribe(function () {
                changeDetectorRef.markForCheck();
            });
            return _this;
        }
        Object.defineProperty(RufToolbarComponent.prototype, "ariaLabel", {
            get: function () {
                return this._ariaLabel || this._intl.toolbar.aria.label;
            },
            /* tslint:disable:no-input-rename */
            set: function (label) {
                this._ariaLabel = label;
            },
            enumerable: true,
            configurable: true
        });
        RufToolbarComponent.prototype.ngAfterContentInit = function () {
            this._keyboardNav = new RufKeyboardNavigation();
            this._keyboardNav.init(this._elementRef, this.toolbarItems);
            this._keyboardNav.addTabIndex(this.toolbarItems);
        };
        RufToolbarComponent.prototype.onKey = function (event) {
            switch (event.keyCode) {
                case RufKeyCodes.SPACE:
                case RufKeyCodes.ENTER:
                    event.stopPropagation();
                    break;
                default:
                    this._keyboardNav.onKeyDown(event);
            }
        };
        RufToolbarComponent.prototype.ngOnDestroy = function () {
            this._intlChanges.unsubscribe();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufToolbarComponent.prototype, "color", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufToolbarComponent.prototype, "ariaLabel", null);
        __decorate([
            core.ContentChildren(RufFocusableDirective, { descendants: true }),
            __metadata("design:type", core.QueryList)
        ], RufToolbarComponent.prototype, "toolbarItems", void 0);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], RufToolbarComponent.prototype, "onKey", null);
        RufToolbarComponent = __decorate([
            core.Component({
                selector: 'ruf-toolbar',
                template: "<div class=\"ruf-toolbar-rows\" rufId=\"toolbar\" >\n  <ruf-toolbar-row  class=\"ruf-toolbar-first-row\" rufId=\"toolbar_row\" role=\"toolbar\" [attr.aria-label]=\"ariaLabel\">\n    <ng-content></ng-content>\n  </ruf-toolbar-row>\n  <ng-content select=\"ruf-toolbar-row\"></ng-content>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: ["ruf-toolbar{display:block;flex-shrink:0;min-height:inherit;overflow:hidden}ruf-toolbar .mat-select{padding-top:0}.ruf-toolbar-separator{border-left-style:solid;border-left-width:1px;display:inline-block;height:1.4375rem;margin:0 .625rem;vertical-align:middle;word-wrap:nowrap}.ruf-toolbar-rows{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;min-height:inherit}ruf-toolbar-row{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;min-height:inherit}ruf-toolbar-row>*{margin-left:.625rem}ruf-toolbar-row>:nth-last-child(1){margin-left:.625rem;margin-right:.625rem}ruf-toolbar-row>:nth-last-child(1).ruf-square{margin-right:0}ruf-toolbar-row>:only-child{border:0}"]
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                RufShellIntl,
                core.ChangeDetectorRef])
        ], RufToolbarComponent);
        return RufToolbarComponent;
    }(RufMixinBase));

    var RufUniqueIdDirective = /** @class */ (function () {
        function RufUniqueIdDirective(el) {
            this.el = el;
        }
        RufUniqueIdDirective.prototype.ngOnInit = function () {
            if (core.isDevMode()) {
                var currentElement = this.el.nativeElement;
                if (!currentElement.id) {
                    currentElement.id = this.rufId ? this.getUniqueId(this.rufId) : this.generateID();
                }
            }
        };
        /**
         * Walks up the tree, picking up uids as it goes
         * @param node
         * @returns parent ID
         */
        RufUniqueIdDirective.prototype.getParentID = function (node) {
            var tempParentId = '';
            if (node.attributes && node.attributes.id) {
                return node.attributes.id.value;
            }
            if (node.parentNode) {
                tempParentId = this.getParentID(node.parentNode);
            }
            return tempParentId;
        };
        /**
         * Generates an idempotent id on the element this directive is attached to
         * Based on the name and attributes (but ignores the angular temp name that can be different each run)
         * @returns string
         */
        RufUniqueIdDirective.prototype.generateID = function () {
            var nel = this.el.nativeElement;
            var parentID = this.getParentID(nel);
            var tempUid = parentID === '' ? nel.tagName.toLowerCase() : parentID + '_' + nel.nodeName.toLowerCase();
            tempUid = this.getUniqueId(tempUid);
            return tempUid;
        };
        /**
         * Check for unique id in DOM
         * @returns string
         */
        RufUniqueIdDirective.prototype.getUniqueId = function (tempId) {
            var count = 0;
            var genId = tempId + '_';
            tempId = genId + count;
            while (document.getElementById(tempId) !== null) {
                count++;
                tempId = genId + count;
            }
            return tempId;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufUniqueIdDirective.prototype, "rufId", void 0);
        RufUniqueIdDirective = __decorate([
            core.Directive({
                selector: '[rufId]'
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], RufUniqueIdDirective);
        return RufUniqueIdDirective;
    }());

    var RufUniqueIdModule = /** @class */ (function () {
        function RufUniqueIdModule() {
        }
        RufUniqueIdModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule],
                declarations: [RufUniqueIdDirective],
                exports: [RufUniqueIdDirective]
            })
        ], RufUniqueIdModule);
        return RufUniqueIdModule;
    }());

    var RufToolbarModule = /** @class */ (function () {
        function RufToolbarModule() {
        }
        RufToolbarModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule, RufUniqueIdModule, RufUtilsModule],
                declarations: [RufToolbarComponent, RufToolbarFillerDirective, RufToolbarRowDirective],
                exports: [RufToolbarComponent, RufToolbarFillerDirective, RufToolbarRowDirective]
            })
        ], RufToolbarModule);
        return RufToolbarModule;
    }());

    var RufBannerRowDirective = /** @class */ (function () {
        function RufBannerRowDirective() {
        }
        RufBannerRowDirective = __decorate([
            core.Directive({
                selector: 'ruf-banner-row' // tslint:disable-line
            })
        ], RufBannerRowDirective);
        return RufBannerRowDirective;
    }());
    var RufBannerControlsDirective = /** @class */ (function () {
        function RufBannerControlsDirective() {
        }
        RufBannerControlsDirective = __decorate([
            core.Directive({
                selector: '[rufBannerControls]' // tslint:disable-line
            })
        ], RufBannerControlsDirective);
        return RufBannerControlsDirective;
    }());
    var RufBannerBrandComponent = /** @class */ (function () {
        function RufBannerBrandComponent(_intl, changeDetectorRef) {
            this._intl = _intl;
            this.logoClass = 'fis-logo';
            this.showLogo = true;
            this._intlChanges = _intl.changes.subscribe(function () { return changeDetectorRef.markForCheck(); });
        }
        Object.defineProperty(RufBannerBrandComponent.prototype, "altText", {
            get: function () {
                return this._altText || this._intl.banner.altText;
            },
            set: function (value) {
                this._altText = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufBannerBrandComponent.prototype, "ariaLabel", {
            get: function () {
                return this._ariaLabel || this._intl.banner.aria.label;
            },
            set: function (value) {
                this._ariaLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufBannerBrandComponent.prototype, "ariaLabelledby", {
            get: function () {
                return this._ariaLabelledby || this._intl.banner.aria.labelledBy;
            },
            set: function (value) {
                this._ariaLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        RufBannerBrandComponent.prototype.ngOnDestroy = function () {
            this._intlChanges.unsubscribe();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufBannerBrandComponent.prototype, "logoUrl", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufBannerBrandComponent.prototype, "title", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufBannerBrandComponent.prototype, "logoClass", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufBannerBrandComponent.prototype, "showLogo", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufBannerBrandComponent.prototype, "altText", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufBannerBrandComponent.prototype, "ariaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufBannerBrandComponent.prototype, "ariaLabelledby", null);
        RufBannerBrandComponent = __decorate([
            core.Component({
                selector: 'ruf-banner-brand',
                template: "\n    <div rufId [class]=\"'ruf-banner-brand-logo ' + (!logoUrl && logoClass)\" *ngIf=\"showLogo\" >\n      <span hidden=\"true\" aria-hidden=\"false\" [attr.aria-label]=\"ariaLabel\"\n      [attr.aria-labelledby]=\"ariaLabelledby\">{{ariaLabel}}</span>\n      <img rufId *ngIf=\"logoUrl\" [src]=\"logoUrl\" [attr.alt]=\"altText\">\n    </div>\n    <div rufId class=\"ruf-toolbar-separator\" *ngIf=\"title && showLogo\"></div>\n    <h1 *ngIf=\"title\" class=\"ruf-banner-brand-title\">{{title}}</h1>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [RufShellIntl, core.ChangeDetectorRef])
        ], RufBannerBrandComponent);
        return RufBannerBrandComponent;
    }());
    var RufBannerComponent = /** @class */ (function () {
        function RufBannerComponent() {
        }
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufBannerComponent.prototype, "color", void 0);
        __decorate([
            core.ContentChild(RufBannerControlsDirective, { static: false }),
            __metadata("design:type", RufBannerControlsDirective)
        ], RufBannerComponent.prototype, "controls", void 0);
        RufBannerComponent = __decorate([
            core.Component({
                selector: 'ruf-banner',
                template: "<header class=\"ruf-banner-header\" role=\"banner\">\n  <ruf-toolbar [color]=\"color\" class=\"ruf-banner-toolbar\" rufId=\"banner_toolbar\">\n    <ng-content></ng-content>\n    <div *ngIf=\"controls\" class=\"ruf-banner-filler\"></div>\n    <ng-content select=\"[rufBannerControls]\"></ng-content>\n    <ng-content select=\"ruf-banner-row\" ngProjectAs=\"ruf-toolbar-row\"></ng-content>\n  </ruf-toolbar>\n</header>\n",
                encapsulation: core.ViewEncapsulation.None,
                styles: ["ruf-banner{display:block;flex-shrink:0;min-height:3rem;overflow:hidden;z-index:100}.ruf-banner-toolbar{height:inherit}.ruf-banner-toolbar ruf-banner-row,.ruf-banner-toolbar ruf-toolbar-row{margin:0 auto;padding:0;width:100%}.ruf-banner-header{min-height:inherit}ruf-banner-brand{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;height:3rem}ruf-banner-brand .ruf-toolbar-separator{display:none}.ruf-banner-filler{-webkit-box-flex:1;flex:1 1 auto}.ruf-banner-brand-logo{line-height:0}.ruf-banner-brand-logo.fis-logo{background-size:4.375rem;height:2.375rem;max-width:4.375rem;width:4.375rem}.ruf-banner-brand-title{display:none;white-space:nowrap}@media (min-width:960px){.ruf-banner-brand-title,ruf-banner-brand .ruf-toolbar-separator{display:block}}"]
            }),
            __metadata("design:paramtypes", [])
        ], RufBannerComponent);
        return RufBannerComponent;
    }());

    var RufBannerModule = /** @class */ (function () {
        function RufBannerModule() {
        }
        RufBannerModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    RufToolbarModule,
                    RufUniqueIdModule,
                    RufUtilsModule
                ],
                declarations: [
                    RufBannerComponent,
                    RufBannerRowDirective,
                    RufBannerBrandComponent,
                    RufBannerControlsDirective
                ],
                exports: [
                    RufBannerComponent,
                    RufBannerRowDirective,
                    RufBannerBrandComponent,
                    RufBannerControlsDirective
                ]
            })
        ], RufBannerModule);
        return RufBannerModule;
    }());

    var RufDialogHeaderDirective = /** @class */ (function () {
        function RufDialogHeaderDirective() {
        }
        RufDialogHeaderDirective = __decorate([
            core.Directive({
                selector: 'ruf-dialog-header' // tslint:disable-line
            })
        ], RufDialogHeaderDirective);
        return RufDialogHeaderDirective;
    }());
    var RufDialogContentDirective = /** @class */ (function () {
        function RufDialogContentDirective() {
        }
        RufDialogContentDirective = __decorate([
            core.Directive({
                selector: 'ruf-dialog-content' // tslint:disable-line
            })
        ], RufDialogContentDirective);
        return RufDialogContentDirective;
    }());
    var RufDialogFooterDirective = /** @class */ (function () {
        function RufDialogFooterDirective() {
        }
        RufDialogFooterDirective = __decorate([
            core.Directive({
                selector: 'ruf-dialog-footer' // tslint:disable-line
            })
        ], RufDialogFooterDirective);
        return RufDialogFooterDirective;
    }());
    var RufDialogPanelComponent = /** @class */ (function () {
        function RufDialogPanelComponent(_intl, changeDetectorRef) {
            this._intl = _intl;
            this.tabindex = 0;
            this.separator = false;
            this._intlChanges = _intl.changes.subscribe(function () { return changeDetectorRef.markForCheck(); });
        }
        Object.defineProperty(RufDialogPanelComponent.prototype, "closeIconTitle", {
            get: function () {
                return this._closeIconTitle || this._intl.dialog.closeIconTitle;
            },
            set: function (value) {
                this._closeIconTitle = value;
            },
            enumerable: true,
            configurable: true
        });
        RufDialogPanelComponent.prototype.ngOnDestroy = function () {
            this._intlChanges.unsubscribe();
        };
        __decorate([
            core.ContentChild(RufDialogFooterDirective, { static: false }),
            __metadata("design:type", RufDialogFooterDirective)
        ], RufDialogPanelComponent.prototype, "footer", void 0);
        __decorate([
            core.HostBinding('attr.tabindex'),
            __metadata("design:type", Object)
        ], RufDialogPanelComponent.prototype, "tabindex", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufDialogPanelComponent.prototype, "separator", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufDialogPanelComponent.prototype, "closeIconTitle", null);
        RufDialogPanelComponent = __decorate([
            core.Component({
                selector: 'ruf-dialog-panel',
                template: "<div class=\"ruf-dialog-panel\" rufId=\"dialog_panel\" [ngClass]=\"{'ruf-dialog-separator-enabled': separator}\">\n  <div #title mat-dialog-title class=\"ruf-dialog-header\" rufId=\"dialog_header\">\n    <div class=\"ruf-dialog-header-bar\">\n      <ng-content select=\"ruf-dialog-header\"></ng-content>\n      <span class=\"ruf-dialog-header-filler\"></span>\n      <button type=\"button\" mat-icon-button fisStyle mat-dialog-close rufId=\"dialog_close_icon\" [title]=\"closeIconTitle\">\n        <mat-icon fisIcon=\"close\" rufIconStyle=\"sm\" alt=\"fis-close-icon\"></mat-icon>\n      </button>\n    </div>\n    <hr *ngIf=\"title.children.length > 0 && separator\" class=\"ruf-dialog-separator\">\n  </div>\n  <div mat-dialog-content class=\"ruf-dialog-content\" rufId=\"dialog_content\">\n    <ng-content select=\"ruf-dialog-content\"></ng-content>\n  </div>\n  <div #actions mat-dialog-actions class=\"ruf-dialog-footer\" [class.ruf-footer-empty]=\"!footer\" rufId=\"dialog_footer\">\n    <hr *ngIf=\"actions.children.length > 0  && separator\" class=\"ruf-dialog-separator\">\n    <ng-content select=\"ruf-dialog-footer\"></ng-content>\n  </div>\n  <ng-content></ng-content>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".ruf-dialog-header{margin-bottom:1.125rem;min-height:2.25rem;position:relative}.ruf-dialog-header .ruf-dialog-header-bar{display:block}.ruf-dialog-header .ruf-dialog-header-bar ruf-dialog-header{display:block;padding-right:.9375rem;width:90%}.ruf-dialog-header .ruf-dialog-header-bar .mat-icon-button{position:absolute;right:0;top:-.1875rem}.mat-dialog-container,.ruf-dialog-panel{padding:1.25rem}mat-dialog-container.mat-dialog-container{border-radius:4px}mat-dialog-container.mat-dialog-container .ruf-dialog-panel{margin:-1.25rem}mat-dialog-container.mat-dialog-container .ruf-dialog-panel .ruf-dialog-footer{display:block;margin-bottom:.625rem;margin-top:1.25rem;min-height:2.625rem;padding:0}mat-dialog-container.mat-dialog-container .ruf-dialog-panel .ruf-dialog-footer ruf-dialog-footer{display:block;padding-top:.5rem}mat-dialog-container.mat-dialog-container .ruf-dialog-panel .ruf-dialog-footer.ruf-footer-empty{display:none}mat-dialog-container.mat-dialog-container .ruf-dialog-separator{margin-left:-1.25rem;margin-right:-1.25rem}mat-dialog-container.mat-dialog-container .ruf-dialog-content{margin:-1.25rem;padding:.625rem 1.25rem}.ruf-dialog-separator{border-style:solid}.ruf-dialog-footer>.ruf-dialog-separator{margin-bottom:0;margin-top:.5rem}mat-dialog-container.mat-dialog-container .ruf-dialog-separator-enabled .ruf-dialog-header{min-height:2.9375rem}mat-dialog-container.mat-dialog-container .ruf-dialog-separator-enabled.ruf-dialog-panel .ruf-dialog-footer{min-height:3.3125rem}mat-dialog-container.mat-dialog-container .ruf-dialog-separator-enabled.ruf-dialog-panel .ruf-dialog-footer ruf-dialog-footer{padding-top:1.125rem}mat-dialog-container.mat-dialog-container .ruf-dialog-separator-enabled .ruf-dialog-content{padding:1.25rem}"]
            }),
            __metadata("design:paramtypes", [RufShellIntl, core.ChangeDetectorRef])
        ], RufDialogPanelComponent);
        return RufDialogPanelComponent;
    }());

    var RufIconDirective = /** @class */ (function () {
        function RufIconDirective(matIcon) {
            this.matIcon = matIcon;
            this.icon = '';
        }
        Object.defineProperty(RufIconDirective.prototype, "fisIcon", {
            set: function (val) {
                this.icon = val || '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufIconDirective.prototype, "rufIcon", {
            set: function (val) {
                this.icon = val || '';
            },
            enumerable: true,
            configurable: true
        });
        RufIconDirective.prototype.ngOnChanges = function (changes) {
            // the matIcon is intentionally left unchanged if fisIcon or rufIcon is set to empty:
            // it is assumed that fontSet and fontIcon are changed appropriately.
            if (this.matIcon &&
                ((changes.fisIcon && changes.fisIcon.currentValue) ||
                    (changes.rufIcon && changes.rufIcon.currentValue))) {
                var currentIcon = changes.fisIcon ? changes.fisIcon.currentValue : changes.rufIcon.currentValue;
                this.matIcon.fontSet = 'fisfont';
                this.matIcon.fontIcon = 'fis-icon-' + currentIcon;
                var chg = new core.SimpleChange('', this.matIcon.fontIcon, true);
                this.matIcon.ngOnChanges({ fontIcon: chg });
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufIconDirective.prototype, "fisIcon", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufIconDirective.prototype, "rufIcon", null);
        RufIconDirective = __decorate([
            core.Directive({ selector: '[fisIcon], [rufIcon]' }),
            __param(0, core.Self()),
            __param(0, core.Optional()),
            __metadata("design:paramtypes", [icon.MatIcon])
        ], RufIconDirective);
        return RufIconDirective;
    }());

    /* tslint:disable:max-line-length */
    var RUF_ICON_STYLE_VALUES = ['rotate-90', 'rotate-180', 'rotate-270', 'flip-horizontal', 'flip-vertical', 'spin', 'pulse', 'xs', 'sm', 'md', 'lg', 'xl'];
    var RufIconStyleDirective = /** @class */ (function () {
        function RufIconStyleDirective(renderer, elementRef) {
            this.renderer = renderer;
            this.elementRef = elementRef;
            this.classPrefix = 'fis-icon-';
        }
        RufIconStyleDirective.prototype.ngOnChanges = function (changes) {
            if (changes.rufIconStyle) {
                var previous = this._validateValue(changes.rufIconStyle.previousValue);
                var current = this._validateValue(changes.rufIconStyle.currentValue);
                this.renderer.removeClass(this.elementRef.nativeElement, this.classPrefix + previous);
                this.renderer.addClass(this.elementRef.nativeElement, this.classPrefix + current);
            }
        };
        RufIconStyleDirective.prototype._validateValue = function (val) {
            if (RUF_ICON_STYLE_VALUES.indexOf(val) !== -1) {
                return val;
            }
            return 'md';
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufIconStyleDirective.prototype, "rufIconStyle", void 0);
        RufIconStyleDirective = __decorate([
            core.Directive({
                selector: '[rufIconStyle]',
                exportAs: 'rufIconStyle'
            }),
            __metadata("design:paramtypes", [core.Renderer2, core.ElementRef])
        ], RufIconStyleDirective);
        return RufIconStyleDirective;
    }());

    var RufIconModule = /** @class */ (function () {
        function RufIconModule() {
        }
        RufIconModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule],
                declarations: [RufIconDirective, RufIconStyleDirective],
                exports: [RufIconDirective, RufIconStyleDirective, icon.MatIconModule]
            })
        ], RufIconModule);
        return RufIconModule;
    }());

    var RufDialogPanelModule = /** @class */ (function () {
        function RufDialogPanelModule() {
        }
        RufDialogPanelModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    icon.MatIconModule,
                    button.MatButtonModule,
                    dialog.MatDialogModule,
                    RufUniqueIdModule,
                    RufIconModule,
                    RufUtilsModule
                ],
                declarations: [RufDialogPanelComponent, RufDialogHeaderDirective, RufDialogContentDirective, RufDialogFooterDirective],
                exports: [RufDialogPanelComponent, RufDialogHeaderDirective, RufDialogContentDirective, RufDialogFooterDirective]
            })
        ], RufDialogPanelModule);
        return RufDialogPanelModule;
    }());


    (function (RufDynamicNavType) {
        RufDynamicNavType["Nav"] = "nav";
        RufDynamicNavType["Tabs"] = "tabs";
    })(exports.RufDynamicNavType || (exports.RufDynamicNavType = {}));
    var RufDynamicMenubarComponent = /** @class */ (function (_super) {
        __extends(RufDynamicMenubarComponent, _super);
        function RufDynamicMenubarComponent(_elementRef, _renderer, _intl, changeDetectorRef) {
            var _this = _super.call(this, _elementRef) || this;
            _this._elementRef = _elementRef;
            _this._renderer = _renderer;
            _this._intl = _intl;
            _this._isMenuItemClosed = false;
            _this.items = [];
            _this.tabLabels = [];
            _this.tabSubscription = rxjs.Subscription.EMPTY;
            _this.selectedIndex = 0;
            _this.focusedIndex = 0;
            _this.closedItemIndexLessThanSelectedIndex = false;
            _this.select = new core.EventEmitter();
            /* tslint:disable:no-output-rename */
            _this.closeEmitter = new core.EventEmitter();
            _this._intlChanges = _intl.changes.subscribe(function () { return changeDetectorRef.markForCheck(); });
            _this.type = exports.RufDynamicNavType.Nav;
            return _this;
        }
        Object.defineProperty(RufDynamicMenubarComponent.prototype, "closeAriaLabel", {
            get: function () {
                return this._closeAriaLabel || this._intl.dynamicmenubar.aria.closeIconLabel;
            },
            set: function (value) {
                this._closeAriaLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufDynamicMenubarComponent.prototype, "type", {
            get: function () {
                return this._type;
            },
            set: function (value) {
                this._renderer.removeClass(this._elementRef.nativeElement, "ruf-dynamic-" + this._type);
                this._type = value || exports.RufDynamicNavType.Nav;
                this._renderer.addClass(this._elementRef.nativeElement, "ruf-dynamic-" + this._type);
            },
            enumerable: true,
            configurable: true
        });
        RufDynamicMenubarComponent.prototype.ngOnInit = function () {
            // remove the body element from matTabGroup since we are never going to need it.
            var matTabGroupElem = this._elementRef.nativeElement.children[0];
            matTabGroupElem.removeChild(matTabGroupElem.children[1]);
        };
        RufDynamicMenubarComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.tabLabels = this.menuLabels.toArray();
            this.tabSubscription = this.menuLabels.changes.subscribe(function (value) {
                _this.tabLabels = value.toArray();
            });
        };
        RufDynamicMenubarComponent.prototype.ngOnChanges = function (changes) {
            var _this = this;
            if (changes.items && this.selectedIndex > -1 && this.items[this.selectedIndex]) {
                // adding a setTimeout to delay the emil call in order to avoid ExpressionChangedAfterItHasBeenCheckedError
                // need to see if there is a better solution for this
                // https://stackoverflow.com/questions/44070732/angular-4-expressionchangedafterithasbeencheckederror-expression-has-changed
                var indexToSet_1 = this.closedItemIndexLessThanSelectedIndex ? this.selectedIndex - 1 : this.selectedIndex;
                setTimeout(function () {
                    _this.onSelect({ index: indexToSet_1 });
                });
                this.closedItemIndexLessThanSelectedIndex = false;
            }
        };
        Object.defineProperty(RufDynamicMenubarComponent.prototype, "selectedPath", {
            get: function () {
                return this._selectedPath;
            },
            set: function (path) {
                var _this = this;
                var e_1, _a;
                if (this.selectedPath === path) {
                    return;
                }
                this._selectedPath = path;
                // Check if selectedPath match with any first level items
                var selected = path ? this.items.filter(function (item) { return _this.matches(path, item); }) : null;
                // If selectedPath matches with first level items, first matched item will be selected (and select event emitter will be emitted).
                if (selected && selected.length > 0) {
                    if (this.selectedIndex === this.items.indexOf(selected[0])) {
                        setTimeout(function () { return _this.onSelect({ index: _this.selectedIndex }); });
                    }
                    else {
                        this.selectedIndex = this.items.indexOf(selected[0]);
                    }
                    return;
                }
                else {
                    try {
                        // If selectedPath does not match with any first level item, check if matches with children of each first level item
                        for (var _b = __values(this.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var item = _c.value;
                            if (item.children && item.children.length > 0) {
                                selected = path ? item.children.filter(function (citem) { return _this.matches(path, citem); }) : null;
                                if (selected && selected.length > 0) {
                                    // If selectedPath match with child menu, set selectedIndex to Parent and selectedPath to child menu
                                    this.onChildSelect(selected[0], item);
                                    return;
                                }
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                // If selectedPath does not match with first level items as well as child menu,
                // select first item.
                // FIXME: The `ngOnChange` event should take care of this. Currently it only checks for `items` changes.
                setTimeout(function () { return _this.onSelect({ index: 0 }); });
            },
            enumerable: true,
            configurable: true
        });
        RufDynamicMenubarComponent.prototype.isChild = function (parent, childPath) {
            var _this = this;
            if (!childPath || parent.path === childPath) {
                return false;
            }
            var selected = parent.children.filter(function (citem) { return _this.matches(childPath, citem); });
            if (selected && selected.length > 0) {
                return true;
            }
            return false;
        };
        RufDynamicMenubarComponent.prototype.onSelect = function ($event) {
            if (this.items.length > 0) {
                this.selectedIndex = $event.index;
                var selectedItem = this.items[$event.index];
                // SDHTML-18280, SDHTML-18231
                // Focus on the next element after menuitem is closed.
                // We dont need to handle focus on click and enter because focus for those events will be handled by mat-tabs.
                if (this._isMenuItemClosed) {
                    this.focusTabOnIndex(this.selectedIndex);
                    this._isMenuItemClosed = false;
                }
                // This condition added to avoid select emitter for parent item on selecting child item
                if (selectedItem.children && selectedItem.children.length > 0) {
                    if (this.isChild(selectedItem, this._selectedPath)) {
                        return;
                    }
                    else {
                        selectedItem = selectedItem.children[0];
                    }
                }
                this._selectedPath = selectedItem.path;
                this.select.emit(selectedItem);
            }
        };
        RufDynamicMenubarComponent.prototype.onFocusChange = function ($event) {
            this.focusedIndex = $event.index;
        };
        RufDynamicMenubarComponent.prototype.OnSelectFocusedIndex = function (event) {
            this.tabLabels[this.focusedIndex].handleKeydown(event);
        };
        RufDynamicMenubarComponent.prototype.onChildMenuToggle = function (event) {
            if (!event) {
                // this.selectedIndex is used to ensure that it gives focus to parent element
                // when child is selected using mouse click.
                this.focusTabOnIndex(this.selectedIndex);
            }
        };
        RufDynamicMenubarComponent.prototype.onChildSelect = function ($event, item) {
            this.selectedIndex = this.items.indexOf(item);
            this._selectedPath = $event.path;
            this.select.emit($event);
        };
        RufDynamicMenubarComponent.prototype.matches = function (path, item) {
            if (path && item.path) {
                if (path === item.path) {
                    return true;
                }
            }
            return false;
        };
        RufDynamicMenubarComponent.prototype.close = function (item) {
            // check if the index of the item being closed is smaller than the item that is currently selected
            // if it is, and if the user actually closes the tab - we'll have to set the selectedIndex to selectedIndex - 1
            // otherwise the selectedItem will change
            // See https://etojira.fnfis.com/browse/SDHTML-16688 for details
            this.closedItemIndexLessThanSelectedIndex = false;
            if (this.items.indexOf(item) < this.selectedIndex) {
                this.closedItemIndexLessThanSelectedIndex = true;
            }
            this._isMenuItemClosed = true;
            this.closeEmitter.emit(item);
        };
        RufDynamicMenubarComponent.prototype.focusTabOnIndex = function (index) {
            this._elementRef.nativeElement.getElementsByClassName('mat-tab-label')[index].focus();
        };
        RufDynamicMenubarComponent.prototype._handleKeydown = function (event, item) {
            switch (event.keyCode) {
                case keycodes.ENTER:
                case keycodes.SPACE:
                    this.close(item);
                    event.stopPropagation();
                    break;
                case keycodes.ESCAPE:
                    this.focusTabOnIndex(this.focusedIndex);
                    event.stopPropagation();
                    break;
                default:
            }
        };
        RufDynamicMenubarComponent.prototype.ngOnDestroy = function () {
            this._intlChanges.unsubscribe();
            this.tabSubscription.unsubscribe();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], RufDynamicMenubarComponent.prototype, "items", void 0);
        __decorate([
            core.ViewChildren('menuLabel'),
            __metadata("design:type", core.QueryList)
        ], RufDynamicMenubarComponent.prototype, "menuLabels", void 0);
        __decorate([
            core.Input('activeColor'),
            __metadata("design:type", Object)
        ], RufDynamicMenubarComponent.prototype, "color", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufDynamicMenubarComponent.prototype, "closeAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufDynamicMenubarComponent.prototype, "type", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], RufDynamicMenubarComponent.prototype, "select", void 0);
        __decorate([
            core.Output('close'),
            __metadata("design:type", Object)
        ], RufDynamicMenubarComponent.prototype, "closeEmitter", void 0);
        __decorate([
            core.ContentChild(core.TemplateRef, { static: false }),
            __metadata("design:type", Object)
        ], RufDynamicMenubarComponent.prototype, "navActions", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufDynamicMenubarComponent.prototype, "selectedPath", null);
        RufDynamicMenubarComponent = __decorate([
            core.Component({
                selector: 'ruf-dynamic-menubar',
                template: "<mat-tab-group rufId [selectedIndex]=\"selectedIndex\" (selectedTabChange)=\"onSelect($event)\" (focusChange)=\"onFocusChange($event)\" (keydown.enter)=\"OnSelectFocusedIndex($event)\" (keydown.space)=\"OnSelectFocusedIndex($event)\">\n  <mat-tab rufId *ngFor=\"let item of items;let currentIndex=index\">\n    <ng-template matTabLabel>\n      <ruf-menu-label #menuLabel rufId [label]=\"item.label\" [icon]=\"item.icon\" [children]=\"item.children\"\n                      (select)=\"onChildSelect($event, item)\"\n                      (toggle)=\"onChildMenuToggle($event)\"\n                      [selectedPath]=\"selectedPath\">\n        <ng-template [ngTemplateOutlet]=\"navActions\" [ngTemplateOutletContext]=\"{item: item}\">\n        </ng-template>\n        <button type=\"button\" mat-icon-button rufId=\"dynamic_menubar_close_icon\" fisStyle class=\"ruf-close\" [attr.tabindex]=\"focusedIndex === currentIndex ? 0 : -1\" *ngIf=\"item.closeable === true\" (keydown)=\"_handleKeydown($event, item)\" (click)=\"close(item)\" role=\"button\" [attr.aria-label]=\"closeAriaLabel\">\n          <mat-icon fisIcon=\"close\" class=\"fis-icon-xs\"></mat-icon>\n        </button>\n      </ruf-menu-label>\n    </ng-template>\n  </mat-tab>\n</mat-tab-group>\n\n",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: ["ruf-dynamic-menubar{-webkit-box-flex:1;flex-grow:1;overflow:hidden}ruf-dynamic-menubar.ruf-dynamic-menubar-flex-height .mat-tab-labels>.mat-tab-label{height:inherit}ruf-dynamic-menubar .mat-tab-labels>.mat-tab-label{height:2.75rem;min-width:48px;padding-left:.9375rem;padding-right:.9375rem}ruf-dynamic-menubar .mat-tab-header{border:0}ruf-dynamic-menubar .ruf-menu-label-trigger{margin-left:-.9375rem;margin-right:-.9375rem}ruf-menu-label .ruf-close.mat-icon-button[fisStyle]{margin-left:.3125rem;padding:1px 3px;-webkit-transition:text-shadow .1s ease-in,color .1s ease-in;transition:text-shadow .1s ease-in,color .1s ease-in}ruf-menu-label .ruf-close.mat-icon-button[fisStyle]:hover{text-shadow:1px 0 0}"]
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                core.Renderer2,
                RufShellIntl,
                core.ChangeDetectorRef])
        ], RufDynamicMenubarComponent);
        return RufDynamicMenubarComponent;
    }(RufMixinBase));

    var RufLabeledIconComponent = /** @class */ (function () {
        function RufLabeledIconComponent() {
            this.fontSet = 'fisfont';
        }
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufLabeledIconComponent.prototype, "fontSet", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufLabeledIconComponent.prototype, "fontIcon", void 0);
        RufLabeledIconComponent = __decorate([
            core.Component({
                selector: 'ruf-labeled-icon',
                template: "<mat-icon [fontSet]=\"fontSet\" [fontIcon]=\"fontIcon\" [class.ruf-no-text]=\"ref.childNodes.length == 0\" [class.ruf-no-icon]=\"!fontIcon\" rufId></mat-icon>\n<span #ref rufId><ng-content></ng-content></span>\n\n",
                encapsulation: core.ViewEncapsulation.None,
                styles: ["ruf-labeled-icon{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;min-height:24px;overflow:hidden;white-space:nowrap}ruf-labeled-icon>span{-webkit-box-flex:1;flex:1;flex-basis:auto;margin-left:.625rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}ruf-labeled-icon>mat-icon.ruf-no-text+span{margin-left:0}ruf-labeled-icon>mat-icon.ruf-no-icon{display:none}ruf-labeled-icon>mat-icon.ruf-no-icon+span{margin-left:0}"]
            })
        ], RufLabeledIconComponent);
        return RufLabeledIconComponent;
    }());

    var RufLabeledIconModule = /** @class */ (function () {
        function RufLabeledIconModule() {
        }
        RufLabeledIconModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule, icon.MatIconModule, RufUniqueIdModule],
                declarations: [RufLabeledIconComponent],
                exports: [RufLabeledIconComponent]
            })
        ], RufLabeledIconModule);
        return RufLabeledIconModule;
    }());

    var RufMenubarComponent = /** @class */ (function (_super) {
        __extends(RufMenubarComponent, _super);
        function RufMenubarComponent(_elementRef, _renderer) {
            var _this = _super.call(this, _elementRef) || this;
            _this._elementRef = _elementRef;
            _this._renderer = _renderer;
            _this._selectedPathSubject = new rxjs.BehaviorSubject(_this._selectedPath);
            _this._selectedPath$ = rxjs.from(_this._selectedPathSubject);
            _this._activatedPathSubject = new rxjs.Subject();
            _this._activatedPath$ = rxjs.from(_this._activatedPathSubject);
            // if true, selecting automatically activates the item
            _this.autoActivate = true;
            _this.direction = 'row';
            /* tslint:disable:no-output-rename */
            // Renaming output to avoid duplicate `select` identifiers
            _this.selectEmitter = new core.EventEmitter();
            return _this;
        }
        RufMenubarComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.addNewKeyboardNav();
            setTimeout(function () { return _this.addTabIndex(); });
        };
        RufMenubarComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.menuItems.changes.subscribe(function () {
                _this.addNewKeyboardNav();
                if (_this._keyboardNav) {
                    _this._keyboardNav.setActiveItemWithoutFocus(_this.selectedIndex(_this.selectedPath));
                }
            });
        };
        RufMenubarComponent.prototype.addNewKeyboardNav = function () {
            var _this = this;
            this._keyboardNav = new RufKeyboardNavigation();
            this._keyboardNav.setDirection(this.direction);
            this._keyboardNav.init(this._elementRef, this.menuItems).subscribe(function (item) { return _this.select(item.path, item.data); });
        };
        RufMenubarComponent.prototype.setActiveItem = function (path) {
            this._keyboardNav.setActiveItemWithoutFocus(this.selectedIndex(path));
            // if path is null, set tabindex to 0 for first menuitem
            if (!path) {
                this.addTabIndex();
            }
        };
        RufMenubarComponent.prototype.firstChild = function () {
            return this.menuItems ? this.menuItems.toArray()[0] : null;
        };
        RufMenubarComponent.prototype.addTabIndex = function () {
            if (this.firstChild()) {
                this.firstChild().tabindex = 0;
            }
        };
        RufMenubarComponent.prototype.selectedIndex = function (path) {
            var index = 0;
            if (path && this.menuItems) {
                index = this.menuItems.toArray().findIndex(function (menuItem) {
                    return menuItem.matches(path);
                });
            }
            return index;
        };
        RufMenubarComponent.prototype.select = function (path, data, event) {
            if (!path) {
                this._selectedPath = null;
                return;
            }
            this.selectEmitter.emit({
                path: path,
                data: data,
                event: event
            });
            if (this.autoActivate) {
                this.activate(path);
            }
            this._keyboardNav.focus(path);
            this._activatedPathSubject.next(path);
        };
        RufMenubarComponent.prototype.activate = function (path) {
            this._selectedPath = path;
            this._selectedPathSubject.next(path);
        };
        Object.defineProperty(RufMenubarComponent.prototype, "selectedPath", {
            get: function () {
                return this._selectedPath;
            },
            // Selection of an item is driven by this input if it is used.
            // Otherwise, the select method (which is invoked on click of an item) changes the selectedPath automatically.
            // If this property setter is invoked, it turns off automatic selection.
            // Normally, this should only happen when a selectedPath property binding is used.
            set: function (path) {
                this.autoActivate = false;
                this.activate(path);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufMenubarComponent.prototype, "selectedPath$", {
            get: function () {
                return this._selectedPath$;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufMenubarComponent.prototype, "activatedPath$", {
            get: function () {
                return this._activatedPath$;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufMenubarComponent.prototype, "inkbarPosition", {
            get: function () {
                return this._inkbarPosition;
            },
            set: function (position) {
                this._updateInkbarPosition(position === 'start' ? position : 'end');
            },
            enumerable: true,
            configurable: true
        });
        RufMenubarComponent.prototype.getLayoutClass = function () {
            return {
                'ruf-menubar-layout': true,
                'ruf-layout-row': this.direction !== 'column',
                'ruf-layout-column': this.direction === 'column',
                'ruf-layout-row-xs': this.directionXs === 'row',
                'ruf-layout-column-xs': this.directionXs === 'column',
                'ruf-layout-row-sm': this.directionSm === 'row',
                'ruf-layout-column-sm': this.directionSm === 'column',
                'ruf-layout-row-md': this.directionMd === 'row',
                'ruf-layout-column-md': this.directionMd === 'column',
                'ruf-layout-row-lg': this.directionLg === 'row',
                'ruf-layout-column-lg': this.directionLg === 'column',
                'ruf-layout-row-xl': this.directionXl === 'row',
                'ruf-layout-column-xl': this.directionXl === 'column',
                'ruf-layout-row-gt-xs': this.directionGtXs === 'row',
                'ruf-layout-column-gt-xs': this.directionGtXs === 'column',
                'ruf-layout-row-gt-sm': this.directionGtSm === 'row',
                'ruf-layout-column-gt-sm': this.directionGtSm === 'column',
                'ruf-layout-row-gt-md': this.directionGtMd === 'row',
                'ruf-layout-column-gt-md': this.directionGtMd === 'column',
                'ruf-layout-row-gt-lg': this.directionGtLg === 'row',
                'ruf-layout-column-gt-lg': this.directionGtLg === 'column',
                'ruf-layout-row-lt-sm': this.directionLtSm === 'row',
                'ruf-layout-column-lt-sm': this.directionLtSm === 'column',
                'ruf-layout-row-lt-md': this.directionLtMd === 'row',
                'ruf-layout-column-lt-md': this.directionLtMd === 'column',
                'ruf-layout-row-lt-lg': this.directionLtLg === 'row',
                'ruf-layout-column-lt-lg': this.directionLtLg === 'column',
                'ruf-layout-row-lt-xl': this.directionLtXl === 'row',
                'ruf-layout-column-lt-xl': this.directionLtXl === 'column'
            };
        };
        RufMenubarComponent.prototype._updateInkbarPosition = function (position) {
            this._renderer.removeClass(this._elementRef.nativeElement, "ruf-menubar-inkbar-" + this._inkbarPosition);
            this._renderer.addClass(this._elementRef.nativeElement, "ruf-menubar-inkbar-" + position);
            this._inkbarPosition = position;
        };
        RufMenubarComponent.prototype.onKey = function (event) {
            if (this._keyboardNav && this._keyboardNav.isActive()) {
                this._keyboardNav.onKeyDown(event);
            }
        };
        __decorate([
            core.Input('activeColor'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "color", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "direction", void 0);
        __decorate([
            core.Input('direction.xs'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "directionXs", void 0);
        __decorate([
            core.Input('direction.sm'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "directionSm", void 0);
        __decorate([
            core.Input('direction.md'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "directionMd", void 0);
        __decorate([
            core.Input('direction.lg'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "directionLg", void 0);
        __decorate([
            core.Input('direction.xl'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "directionXl", void 0);
        __decorate([
            core.Input('direction.gt-xs'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "directionGtXs", void 0);
        __decorate([
            core.Input('direction.gt-sm'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "directionGtSm", void 0);
        __decorate([
            core.Input('direction.gt-md'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "directionGtMd", void 0);
        __decorate([
            core.Input('direction.gt-lg'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "directionGtLg", void 0);
        __decorate([
            core.Input('direction.lt-sm'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "directionLtSm", void 0);
        __decorate([
            core.Input('direction.lt-md'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "directionLtMd", void 0);
        __decorate([
            core.Input('direction.lt-lg'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "directionLtLg", void 0);
        __decorate([
            core.Input('direction.lt-xl'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "directionLtXl", void 0);
        __decorate([
            core.Output('select'),
            __metadata("design:type", Object)
        ], RufMenubarComponent.prototype, "selectEmitter", void 0);
        __decorate([
            core.ContentChildren(core.forwardRef(function () { return RufMenubarItemComponent; })),
            __metadata("design:type", core.QueryList)
        ], RufMenubarComponent.prototype, "menuItems", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufMenubarComponent.prototype, "selectedPath", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufMenubarComponent.prototype, "inkbarPosition", null);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], RufMenubarComponent.prototype, "onKey", null);
        RufMenubarComponent = __decorate([
            core.Component({
                selector: 'ruf-menubar',
                template: "<div [ngClass]=\"getLayoutClass()\" role=\"menubar\">\n  <ng-content></ng-content>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: ["ruf-menubar{-ms-grid-row-align:stretch;align-self:stretch;display:block}.ruf-menubar-layout{-webkit-box-align:stretch;align-items:stretch;height:100%}.ruf-menu-item{-webkit-box-align:center;align-items:center;border-color:transparent;cursor:pointer;display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1 auto;-webkit-transition:background-color .2s;transition:background-color .2s}.ruf-menu-item:focus{outline:0}.ruf-layout-row{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-menubar-layout.ruf-layout-column{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-menubar-layout.ruf-layout-column>ul{padding-left:0}.ruf-menubar-layout.ruf-layout-column .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}@media (min-width:0) and (max-width:599px){.ruf-layout-row-xs{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-xs>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-xs .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-xs{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-xs>ul{padding-left:0}.ruf-layout-column-xs .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:600px) and (max-width:959px){.ruf-layout-row-sm{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-sm>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-sm .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-sm{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-sm>ul{padding-left:0}.ruf-layout-column-sm .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:960px) and (max-width:1279px){.ruf-layout-row-md{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-md>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-md .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-md{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-md>ul{padding-left:0}.ruf-layout-column-md .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1280px) and (max-width:1919px){.ruf-layout-row-lg{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-lg>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-lg .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-lg{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-lg>ul{padding-left:0}.ruf-layout-column-lg .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1920px){.ruf-layout-row-xl{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-xl>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-xl .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-xl{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-xl>ul{padding-left:0}.ruf-layout-column-xl .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:600px){.ruf-layout-row-gt-xs{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-xs>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-xs .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-xs{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-xs>ul{padding-left:0}.ruf-layout-column-gt-xs .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:960px){.ruf-layout-row-gt-sm{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-sm>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-sm .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-sm{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-sm>ul{padding-left:0}.ruf-layout-column-gt-sm .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1280px){.ruf-layout-row-gt-md{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-md>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-md .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-md{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-md>ul{padding-left:0}.ruf-layout-column-gt-md .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1920px){.ruf-layout-row-gt-lg{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-lg>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-lg .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-lg{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-lg>ul{padding-left:0}.ruf-layout-column-gt-lg .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}"]
            }),
            __metadata("design:paramtypes", [core.ElementRef, core.Renderer2])
        ], RufMenubarComponent);
        return RufMenubarComponent;
    }(RufMixinBase));

    var RufMenubarItemComponent = /** @class */ (function () {
        // this can probably only be achieved in nav-menubar
        // @HostBinding('attr.aria-haspopup') hasPopup = true;
        function RufMenubarItemComponent(menubar, _elementRef) {
            this.menubar = menubar;
            this._elementRef = _elementRef;
            this.unsubscribe = new rxjs.Subject();
            this.selectable = true;
            this.menuitem = true;
            this.role = 'menuitem';
            this.tabindex = -1;
            this.active = false;
        }
        RufMenubarItemComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.menubar.selectedPath$.pipe(operators.takeUntil(this.unsubscribe), operators.distinctUntilChanged())
                .subscribe(function (path) {
                _this.active = _this.matches(path);
                setTimeout(function () {
                    _this.tabindex = _this.active ? 0 : -1;
                    _this.menubar.setActiveItem(path);
                });
            });
            this.menubar.activatedPath$.pipe(operators.takeUntil(this.unsubscribe), operators.distinctUntilChanged())
                .subscribe(function (path) {
                var match = _this.matches(path);
                setTimeout(function () { return _this.tabindex = match ? 0 : -1; });
            });
        };
        RufMenubarItemComponent.prototype.ngOnDestroy = function () {
            this.unsubscribe.next();
            this.unsubscribe.complete();
        };
        RufMenubarItemComponent.prototype.onClick = function (event) {
            if (!event.cancelBubble) {
                if (this.selectable) {
                    this.menubar.select(this.path, this.data, event);
                }
                else {
                    // still change activated state since user clicked on the item
                    this.menubar.activate(this.path);
                }
            }
        };
        RufMenubarItemComponent.prototype.focus = function () {
            if (this._elementRef) {
                this._elementRef.nativeElement.focus();
            }
        };
        RufMenubarItemComponent.prototype.matches = function (selectedPath) {
            if (selectedPath && this.path) {
                var pattern = new RegExp('^((\/)?' + this.path + ')(\/.*)?$'); // use word boundary to exact match
                if (selectedPath === this.path || pattern.test(selectedPath)) { // match with current menuitem and with parent menuitem
                    return true;
                }
            }
            return false;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufMenubarItemComponent.prototype, "path", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufMenubarItemComponent.prototype, "data", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufMenubarItemComponent.prototype, "selectable", void 0);
        __decorate([
            core.HostBinding('class.ruf-menu-item'),
            __metadata("design:type", Object)
        ], RufMenubarItemComponent.prototype, "menuitem", void 0);
        __decorate([
            core.HostBinding('attr.role'),
            __metadata("design:type", Object)
        ], RufMenubarItemComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('attr.tabindex'),
            __metadata("design:type", Object)
        ], RufMenubarItemComponent.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('class.ruf-menubar-item-active'),
            __metadata("design:type", Object)
        ], RufMenubarItemComponent.prototype, "active", void 0);
        __decorate([
            core.HostListener('click', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], RufMenubarItemComponent.prototype, "onClick", null);
        RufMenubarItemComponent = __decorate([
            core.Component({
                selector: 'ruf-menubar-item, [rufMenubarItem]',
                template: "\n      <ng-content></ng-content>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [RufMenubarComponent, core.ElementRef])
        ], RufMenubarItemComponent);
        return RufMenubarItemComponent;
    }());

    var RufMenubarModule = /** @class */ (function () {
        function RufMenubarModule() {
        }
        RufMenubarModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule, RufUniqueIdModule],
                providers: [RufKeyboardNavigation],
                declarations: [RufMenubarComponent, RufMenubarItemComponent],
                exports: [RufMenubarComponent, RufMenubarItemComponent]
            })
        ], RufMenubarModule);
        return RufMenubarModule;
    }());

    var RufMenuLabelComponent = /** @class */ (function () {
        function RufMenuLabelComponent() {
            this.label = '';
            this.icon = '';
            // on child menu toggle
            this.toggle = new core.EventEmitter();
            this.select = new core.EventEmitter();
            this.rowLayout = true; // tells the internal labeled-icon that it is in a row.
        }
        RufMenuLabelComponent.prototype.handleClick = function (event) {
            // labels with children will not propagate the click event by default
            if (this.children && this.children.length > 0) {
                event.preventDefault();
                event.stopPropagation();
            }
        };
        RufMenuLabelComponent.prototype.hasPopup = function () {
            return this.children ? this.children.length > 0 : false;
        };
        RufMenuLabelComponent.prototype.onClose = function () {
            this.toggle.emit(false);
        };
        RufMenuLabelComponent.prototype.handleKeydown = function (event) {
            var _this = this;
            if (!this.children || this.children.length === 0) {
                return;
            }
            switch (event.keyCode) {
                case keycodes.SPACE:
                case keycodes.ENTER:
                    this.trigger.openMenu();
                    if (this.trigger.menu) {
                        // This is needed for dynamic menubar since it uses setTimeout for selecting a tab.
                        // This should be removed when we refactor dynamic menubar.
                        setTimeout(function () {
                            _this.trigger.menu.focusFirstItem();
                        });
                    }
                    event.preventDefault();
                    event.stopPropagation();
                    this.toggle.emit(true);
                    break;
                case keycodes.ESCAPE:
                    this.trigger.closeMenu();
                    this.toggle.emit(false);
                    event.stopPropagation();
                    break;
                default:
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufMenuLabelComponent.prototype, "label", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufMenuLabelComponent.prototype, "icon", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], RufMenuLabelComponent.prototype, "children", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], RufMenuLabelComponent.prototype, "toggle", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], RufMenuLabelComponent.prototype, "select", void 0);
        __decorate([
            core.HostBinding('class.ruf-layout-row'),
            __metadata("design:type", Object)
        ], RufMenuLabelComponent.prototype, "rowLayout", void 0);
        __decorate([
            core.ViewChild(menu.MatMenuTrigger, { static: false }),
            __metadata("design:type", menu.MatMenuTrigger)
        ], RufMenuLabelComponent.prototype, "trigger", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufMenuLabelComponent.prototype, "selectedPath", void 0);
        __decorate([
            core.HostListener('click', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], RufMenuLabelComponent.prototype, "handleClick", null);
        RufMenuLabelComponent = __decorate([
            core.Component({
                selector: 'ruf-menu-label',
                template: "<div class=\"ruf-menu-label-wrap\" rufId>\n  <!-- ideally, Angular would support putting matMenuTriggerFor on the host -->\n  <div class=\"ruf-menu-label-trigger\" *ngIf=\"children && children.length > 0\" [matMenuTriggerFor]=\"menu\" (menuClosed)=\"toggle.emit(false)\" (menuOpened)=\"toggle.emit(true)\"></div>\n  <ruf-labeled-icon fontSet=\"fisfont\" [fontIcon]=\"icon\" rufId>\n    <span class=\"ruf-menu-label-container\">\n      {{ label }}\n      <mat-icon class=\"ruf-menu-label-chevron\" aria-hidden=\"true\" rufId=\"menu_label_link\" *ngIf=\"children && children.length > 0\" fisIcon=\"arrow-down\"></mat-icon>\n    </span>\n\n    <span (click)=\"$event.stopPropagation()\" rufId=\"menu_label_content\">\n      <ng-content></ng-content>\n    </span>\n  </ruf-labeled-icon>\n</div>\n\n<mat-menu class=\"ruf-cust-menu\" rufId=\"menu\" #menu=\"matMenu\" yPosition=\"below\" [overlapTrigger]=\"false\">\n  <button type=\"button\" rufId=\"menu_button\" *ngFor=\"let child of children\" mat-menu-item (click)=\"select.emit(child)\"\n          [class.ruf-menu-selected]=\"selectedPath && child.path === selectedPath\"\n          [attr.aria-selected]=\"selectedPath && child.path === selectedPath\">\n    <mat-icon rufId=\"menu_icon\" *ngIf=\"child.icon\" fontSet=\"fisfont\" [fontIcon]=\"child.icon\"></mat-icon>\n    <span>{{ child.label }}</span>\n  </button>\n</mat-menu>\n",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: ["ruf-menu-label{display:block!important;min-width:100%}ruf-menu-label ruf-labeled-icon{-webkit-box-pack:center;justify-content:center;width:100%}ruf-menu-label ruf-labeled-icon>span{-webkit-box-flex:0;flex:0 1 auto}.ruf-menu-label-wrap{position:relative}.ruf-menu-label-trigger{bottom:0;left:0;position:absolute;right:0;top:0}.ruf-menu-label-chevron{color:currentColor;margin-left:5px}.ruf-menu-label-container{-webkit-box-align:center;align-items:center;display:-webkit-inline-box;display:inline-flex}.ruf-cust-menu .mat-menu-content{border-style:solid;border-width:0 1px 1px;min-width:7.5rem;padding-bottom:0;padding-top:0}.ruf-cust-menu .mat-menu-content .mat-menu-item{height:2.75rem;line-height:2.75rem}.ruf-cust-menu .mat-menu-content .ruf-menu-selected{text-decoration:underline}"]
            })
        ], RufMenuLabelComponent);
        return RufMenuLabelComponent;
    }());

    /**
     * Throws an exception for the case when dropdown trigger doesn't have a valid ruf-dropdown-panel instance
     * @docs-private
     */
    function throwTargetMissingError() {
        throw Error("rufTrigger: must pass in RufTriggerTarget instance.\n    Example:\n    <button [rufTrigger]=\"menuLabel\">Open menu</button>\n    <ruf-menu-label #menuLabel ...></ruf-menu-label>\n    ");
    }

    var RufTriggerDirective = /** @class */ (function (_super) {
        __extends(RufTriggerDirective, _super);
        function RufTriggerDirective(elRef, renderer) {
            var _this = _super.call(this, elRef) || this;
            _this.elRef = elRef;
            _this.renderer = renderer;
            _this.subscription = rxjs.Subscription.EMPTY;
            return _this;
        }
        RufTriggerDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            this._checkTarget();
            if (this.target.hasPopup()) {
                this.renderer.setAttribute(this.elRef.nativeElement, 'aria-haspopup', 'true');
                this.renderer.setAttribute(this.elRef.nativeElement, 'aria-expanded', 'false');
            }
            else {
                this.renderer.removeAttribute(this.elRef.nativeElement, 'aria-haspopup');
                this.renderer.removeAttribute(this.elRef.nativeElement, 'aria-expanded');
            }
            if (this.subscription === rxjs.Subscription.EMPTY) {
                this.subscription = this.target.toggle.subscribe(function (opened) {
                    _this.renderer.setAttribute(_this.elRef.nativeElement, 'aria-expanded', opened ? 'true' : 'false');
                    if (!opened) {
                        _this.elRef.nativeElement.focus();
                    }
                });
            }
        };
        RufTriggerDirective.prototype.handleClickEvent = function (event) {
            this.target.handleClick(event);
        };
        RufTriggerDirective.prototype.handleKeydownEvent = function (event) {
            this.target.handleKeydown(event);
        };
        RufTriggerDirective.prototype._checkTarget = function () {
            if (!this.target) {
                throwTargetMissingError();
            }
        };
        RufTriggerDirective.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        __decorate([
            core.Input('rufTrigger'),
            __metadata("design:type", Object)
        ], RufTriggerDirective.prototype, "target", void 0);
        __decorate([
            core.HostListener('click', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], RufTriggerDirective.prototype, "handleClickEvent", null);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], RufTriggerDirective.prototype, "handleKeydownEvent", null);
        RufTriggerDirective = __decorate([
            core.Directive({
                selector: '[rufTrigger]',
                exportAs: 'rufTrigger'
            }),
            __metadata("design:paramtypes", [core.ElementRef, core.Renderer2])
        ], RufTriggerDirective);
        return RufTriggerDirective;
    }(overlay.CdkOverlayOrigin));

    var RufTriggerModule = /** @class */ (function () {
        function RufTriggerModule() {
        }
        RufTriggerModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule],
                declarations: [RufTriggerDirective],
                exports: [RufTriggerDirective]
            })
        ], RufTriggerModule);
        return RufTriggerModule;
    }());

    var RufMenuLabelModule = /** @class */ (function () {
        function RufMenuLabelModule() {
        }
        RufMenuLabelModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule,
                    menu.MatMenuModule,
                    icon.MatIconModule,
                    RufLabeledIconModule,
                    RufUniqueIdModule,
                    RufIconModule,
                    RufTriggerModule
                ],
                declarations: [RufMenuLabelComponent],
                exports: [RufMenuLabelComponent]
            })
        ], RufMenuLabelModule);
        return RufMenuLabelModule;
    }());

    var RufDynamicMenubarModule = /** @class */ (function () {
        function RufDynamicMenubarModule() {
        }
        RufDynamicMenubarModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    tabs.MatTabsModule,
                    button.MatButtonModule,
                    RufLabeledIconModule,
                    RufMenubarModule,
                    RufMenuLabelModule,
                    RufUniqueIdModule,
                    RufUtilsModule,
                    RufIconModule,
                    RufTriggerModule
                ],
                declarations: [RufDynamicMenubarComponent],
                exports: [RufDynamicMenubarComponent]
            })
        ], RufDynamicMenubarModule);
        return RufDynamicMenubarModule;
    }());

    var RufDynamicSideMenuComponent = /** @class */ (function () {
        function RufDynamicSideMenuComponent(document, _renderer, _mediaObserver, _elementRef) {
            this.document = document;
            this._renderer = _renderer;
            this._mediaObserver = _mediaObserver;
            this._elementRef = _elementRef;
            this.items = [];
            this._inkbarPosition = this._inkbarPosition || 'start';
            this.multi = true;
            this._select = new core.EventEmitter();
            // @HostBinding('class.ruf-dynamic-sidemenu-minimized')
            this.minimized = false;
            this.minimizedXs = false;
            this.minimizedSm = false;
            this.minimizedMd = false;
            this.minimizedLg = false;
            this.minimizedXl = false;
            this.minimizedGtXs = false;
            this.minimizedGtSm = false;
            this.minimizedGtMd = false;
            this.minimizedGtLg = false;
        }
        RufDynamicSideMenuComponent.prototype.isMinimized = function () {
            return [
                this.minimized,
                this.minimizedXs && this._mediaObserver.isActive('xs'),
                this.minimizedSm && this._mediaObserver.isActive('sm'),
                this.minimizedMd && this._mediaObserver.isActive('md'),
                this.minimizedLg && this._mediaObserver.isActive('lg'),
                this.minimizedXl && this._mediaObserver.isActive('xl'),
                this.minimizedGtXs && this._mediaObserver.isActive('gt-xs'),
                this.minimizedGtSm && this._mediaObserver.isActive('gt-sm'),
                this.minimizedGtMd && this._mediaObserver.isActive('gt-md'),
                this.minimizedGtLg && this._mediaObserver.isActive('gt-lg')
            ].some(function (x) { return x === true; });
        };
        RufDynamicSideMenuComponent.prototype.onSelect = function ($event) {
            if (!($event.data && $event.data.children)) {
                this._selectedPath = $event.path;
                this._select.emit($event.data);
            }
            else if ($event && $event.event) {
                $event.event.preventDefault();
                $event.event.stopPropagation();
            }
        };
        RufDynamicSideMenuComponent.prototype.getRufId = function (item) {
            return 'dynamic_sidemenu_' + item.label.toLowerCase().replace(/ /g, '_');
        };
        RufDynamicSideMenuComponent.prototype.closeMenu = function () {
            this.menuTrigger.closeMenu();
        };
        RufDynamicSideMenuComponent.prototype.setPopupData = function (event, data) {
            var _this = this;
            this.sideMenuPopupData = data;
            event.currentTarget.classList.add('ruf-active');
            // focus on the first menu item
            setTimeout(function () {
                var cdkOverlayClass = ".ruf-sidemenu-popup-backdrop + .cdk-overlay-connected-position-bounding-box";
                var cdkOverlayElement = _this.document.querySelector(cdkOverlayClass);
                if (cdkOverlayElement) {
                    // set left position for cdkOverlay based on the position of menuitem.
                    // so we need to get left and width value from BoundingClientRect;
                    var rufMenuItem = _this._elementRef.nativeElement.querySelector('.ruf-menu-item');
                    var rufMenuItemClientTect = rufMenuItem.getBoundingClientRect();
                    cdkOverlayElement.style.left = rufMenuItemClientTect.left + rufMenuItemClientTect.width + 'px';
                    var firstMenuItem = _this.document.querySelector(cdkOverlayClass + " .ruf-menu-item");
                    if (firstMenuItem) {
                        firstMenuItem.focus();
                    }
                }
            });
        };
        RufDynamicSideMenuComponent.prototype.onPopupClose = function () {
            // remove active class when popop is closed
            var currentActiveItem = this._elementRef.nativeElement.querySelector('.ruf-menu-item.ruf-active');
            if (currentActiveItem) {
                currentActiveItem.focus();
                this._renderer.removeClass(currentActiveItem, 'ruf-active');
            }
        };
        RufDynamicSideMenuComponent.prototype.keyHandler = function (event) {
            switch (event.keyCode) {
                case keycodes.ENTER:
                case keycodes.SPACE:
                    event.currentTarget.click();
                    break;
                default:
            }
        };
        RufDynamicSideMenuComponent.prototype.getOverlayClasses = function () {
            var colorClass = this._activeColor ? "ruf-" + this._activeColor : "";
            return this.popupBackgroundClass + " " + colorClass + " ruf-menubar-inkbar-" + this._inkbarPosition;
        };
        RufDynamicSideMenuComponent.prototype.toggleChildItems = function (currentTrigger) {
            if (this.multi === false) {
                this._triggers.toArray()
                    .filter(function (element) { return element.value === true && element !== currentTrigger; })
                    .forEach(function (element) {
                    element.value = false;
                });
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], RufDynamicSideMenuComponent.prototype, "items", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufDynamicSideMenuComponent.prototype, "popupBackgroundClass", void 0);
        __decorate([
            core.ViewChild(menu.MatMenuTrigger, { static: false }),
            __metadata("design:type", menu.MatMenuTrigger)
        ], RufDynamicSideMenuComponent.prototype, "menuTrigger", void 0);
        __decorate([
            core.ViewChild('menuTrigger', { static: false }),
            __metadata("design:type", core.ElementRef)
        ], RufDynamicSideMenuComponent.prototype, "trigger", void 0);
        __decorate([
            core.Input('selectedPath'),
            __metadata("design:type", String)
        ], RufDynamicSideMenuComponent.prototype, "_selectedPath", void 0);
        __decorate([
            core.Input('activeColor'),
            __metadata("design:type", String)
        ], RufDynamicSideMenuComponent.prototype, "_activeColor", void 0);
        __decorate([
            core.Input('inkbarPosition'),
            __metadata("design:type", Object)
        ], RufDynamicSideMenuComponent.prototype, "_inkbarPosition", void 0);
        __decorate([
            core.Input('multi'),
            __metadata("design:type", Object)
        ], RufDynamicSideMenuComponent.prototype, "multi", void 0);
        __decorate([
            core.Output('select'),
            __metadata("design:type", Object)
        ], RufDynamicSideMenuComponent.prototype, "_select", void 0);
        __decorate([
            core.ViewChildren('trigger'),
            __metadata("design:type", core.QueryList)
        ], RufDynamicSideMenuComponent.prototype, "_triggers", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufDynamicSideMenuComponent.prototype, "minimized", void 0);
        __decorate([
            core.Input('minimized.xs'),
            __metadata("design:type", Object)
        ], RufDynamicSideMenuComponent.prototype, "minimizedXs", void 0);
        __decorate([
            core.Input('minimized.sm'),
            __metadata("design:type", Object)
        ], RufDynamicSideMenuComponent.prototype, "minimizedSm", void 0);
        __decorate([
            core.Input('minimized.md'),
            __metadata("design:type", Object)
        ], RufDynamicSideMenuComponent.prototype, "minimizedMd", void 0);
        __decorate([
            core.Input('minimized.lg'),
            __metadata("design:type", Object)
        ], RufDynamicSideMenuComponent.prototype, "minimizedLg", void 0);
        __decorate([
            core.Input('minimized.xl'),
            __metadata("design:type", Object)
        ], RufDynamicSideMenuComponent.prototype, "minimizedXl", void 0);
        __decorate([
            core.Input('minimized.gt-xs'),
            __metadata("design:type", Object)
        ], RufDynamicSideMenuComponent.prototype, "minimizedGtXs", void 0);
        __decorate([
            core.Input('minimized.gt-sm'),
            __metadata("design:type", Object)
        ], RufDynamicSideMenuComponent.prototype, "minimizedGtSm", void 0);
        __decorate([
            core.Input('minimized.gt-md'),
            __metadata("design:type", Object)
        ], RufDynamicSideMenuComponent.prototype, "minimizedGtMd", void 0);
        __decorate([
            core.Input('minimized.gt-lg'),
            __metadata("design:type", Object)
        ], RufDynamicSideMenuComponent.prototype, "minimizedGtLg", void 0);
        RufDynamicSideMenuComponent = __decorate([
            core.Component({
                selector: 'ruf-dynamic-sidemenu',
                template: "<ruf-sidemenu rufId=\"dynamic_sidemenu\" [activeColor]=\"_activeColor\"\n   [inkbarPosition]=\"_inkbarPosition\"\n   [selectedPath]=\"_selectedPath\"\n   [ngClass]=\"{'ruf-dynamic-sidemenu-minimized': isMinimized()}\"\n   (select)=\"onSelect($event)\">\n\n  <ng-container *ngFor=\"let item of items\">\n    <a [rufId]=\"getRufId(item)\" [data]=\"item\" *ngIf=\"!item.children || item.children.length === 0 \" [path]=\"item.path\"\n      rufSidemenuItem>\n      <mat-icon *ngIf=\"isMinimized()\" [fontIcon]=\"item.icon\"></mat-icon>\n      <ruf-labeled-icon *ngIf=\"!isMinimized()\" [fontIcon]=\"item.icon\" [ngClass]=\"{'sidemenu-item-with-no-icon': !item.icon}\">{{item.label}}\n      </ruf-labeled-icon>\n    </a>\n    <ng-container *ngIf=\"item.children && item.children.length > 0\">\n      <ng-container *ngIf=\"!isMinimized(); else minimizedTemplate\">\n        <a [rufId]=\"getRufId(item)\" [data]=\"item\" [path]=\"item.path\" rufSidemenuItem rufToggleChevron\n         #trigger=\"rufToggle\" (toggleChange)=\"toggleChildItems(trigger)\">\n          <ruf-labeled-icon [fontIcon]=\"item.icon\" [ngClass]=\"{'sidemenu-item-with-no-icon': !item.icon}\">{{item.label}}\n          </ruf-labeled-icon>\n        </a>\n        <ruf-sidemenu-children [rufId]=\"getRufId(item)+'_children'\" [visible]=\"trigger.value\"\n          [menuTrigger]=\"trigger\">\n          <a rufId *ngFor=\"let child of item.children\" [data]=\"child\" [path]=\"child.path\" rufSidemenuItem>\n            <ruf-labeled-icon [fontIcon]=\"child.icon\" [ngClass]=\"{'sidemenu-item-with-no-icon': !child.icon}\">{{child.label}}\n            </ruf-labeled-icon>\n          </a>\n        </ruf-sidemenu-children>\n      </ng-container>\n\n      <ng-template #minimizedTemplate>\n        <a [rufId]=\"getRufId(item)\"\n           [data]=\"item\"\n           [path]=\"item.path\"\n           rufSidemenuItem\n           #menuTrigger\n           [matMenuTriggerFor]=\"sideMenuPopup\"\n           (click)=\"setPopupData($event, item)\"\n           (keydown)=\"keyHandler($event)\">\n          <mat-icon [fontIcon]=\"item.icon\"></mat-icon>\n          <mat-icon fisIcon=\"arrow-down\" rufIconStyle=\"xs\" class=\"ruf-expand-sidemenu-popup-icon\"></mat-icon>\n      </a>\n      </ng-template>\n    </ng-container>\n\n  </ng-container>\n\n  <mat-menu #sideMenuPopup=\"matMenu\" overlapTrigger=\"true\" [class]=\"getOverlayClasses()\" (closed)=\"onPopupClose()\"\n    backdropClass=\"ruf-sidemenu-popup-backdrop\">\n    <ruf-sidemenu-children *ngIf=\"sideMenuPopupData\" rufId=\"ruf-sidemenu-children-items-popup\">\n      <p class=\"ruf-side-menu-popup-title\">{{sideMenuPopupData?.label}}</p>\n      <a rufId *ngFor=\"let child of sideMenuPopupData?.children\" [data]=\"child\" [path]=\"child.path\" (keydown.enter)=\"closeMenu()\"\n        rufSidemenuItem>\n        <span>{{child.label}}</span>\n    </a>\n    </ruf-sidemenu-children>\n  </mat-menu>\n</ruf-sidemenu>\n",
                encapsulation: core.ViewEncapsulation.None,
                styles: ["ruf-dynamic-sidemenu .sidemenu-item-with-no-icon .mat-icon{visibility:hidden;width:0}ruf-dynamic-sidemenu .sidemenu-item-with-no-icon span{margin-left:0}ruf-dynamic-sidemenu ruf-labeled-icon{white-space:normal}ruf-dynamic-sidemenu ruf-sidemenu.ruf-dynamic-sidemenu-minimized{box-shadow:none;min-width:auto}ruf-dynamic-sidemenu ruf-sidemenu.ruf-dynamic-sidemenu-minimized .ruf-menubar-layout.ruf-layout-column .ruf-menu-item{padding-right:0}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel{border-radius:0;box-shadow:none}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel.ruf-menubar-inkbar-start .ruf-menu-item{border-left-width:.25rem;border-left-style:solid}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel.ruf-menubar-inkbar-end .ruf-menu-item{border-right-width:.25rem;border-right-style:solid}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-menu-item{padding-left:.9375rem;padding-right:.9375rem}.ruf-expand-sidemenu-popup-icon{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex}.ruf-side-menu-popup-title{padding-left:1.1875rem}"]
            }),
            __param(0, core.Inject(common.DOCUMENT)),
            __metadata("design:paramtypes", [Object, core.Renderer2,
                flexLayout.MediaObserver,
                core.ElementRef])
        ], RufDynamicSideMenuComponent);
        return RufDynamicSideMenuComponent;
    }());

    /**
     * Directive that can be applied on any element, and that toggles an attribute that can be used by the underlying element as need be.
     */
    var RufToggleDirective = /** @class */ (function (_super) {
        __extends(RufToggleDirective, _super);
        function RufToggleDirective(elRef) {
            var _this = _super.call(this, elRef) || this;
            _this.elRef = elRef;
            // boolean property that gets toggled when the underlying element is clicked
            // tslint:disable-next-line:no-input-rename
            _this.value = false;
            _this.chevron = false;
            _this.arrow = false;
            _this.toggleChange = new core.EventEmitter();
            _this.toggle = true;
            return _this;
        }
        Object.defineProperty(RufToggleDirective.prototype, "active", {
            get: function () {
                return this.value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufToggleDirective.prototype, "rufToggle", {
            set: function (val) {
                this.value = val || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufToggleDirective.prototype, "rufToggleChevron", {
            set: function (val) {
                this.arrow = false;
                this.chevron = true;
                this.value = val || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufToggleDirective.prototype, "rufToggleArrow", {
            set: function (val) {
                this.arrow = true;
                this.chevron = false;
                this.value = val || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufToggleDirective.prototype, "normal", {
            get: function () {
                return !this.chevron && !this.arrow;
            },
            enumerable: true,
            configurable: true
        });
        // select should focus the element and toggle value
        RufToggleDirective.prototype.select = function (event) {
            this.elRef.nativeElement.focus();
            this.toggleValue(event);
        };
        RufToggleDirective.prototype.toggleValue = function (event) {
            event.stopPropagation();
            event.preventDefault();
            // For Safari browser, event.stopPropagation() is not setting the value of
            // event.cancelBubble as true. So, we need to explicitly set it.
            event.cancelBubble = true;
            this.value = !this.value;
            this.toggleChange.emit({ trigger: this.elRef, value: this.value, event: event });
        };
        RufToggleDirective.prototype.onClick = function (event) {
            this.toggleValue(event);
        };
        RufToggleDirective.prototype.onKey = function (event) {
            switch (event.keyCode) {
                case keycodes.ENTER:
                case keycodes.SPACE:
                    this.toggleValue(event);
                    break;
                default:
            }
        };
        __decorate([
            core.HostBinding('class.ruf-toggle-active'),
            __metadata("design:type", Object)
        ], RufToggleDirective.prototype, "value", void 0);
        __decorate([
            core.HostBinding('class.ruf-toggle-chevron'),
            __metadata("design:type", Object)
        ], RufToggleDirective.prototype, "chevron", void 0);
        __decorate([
            core.HostBinding('class.ruf-toggle-arrow'),
            __metadata("design:type", Object)
        ], RufToggleDirective.prototype, "arrow", void 0);
        __decorate([
            core.HostBinding('class.ruf-active'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], RufToggleDirective.prototype, "active", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], RufToggleDirective.prototype, "rufToggle", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], RufToggleDirective.prototype, "rufToggleChevron", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], RufToggleDirective.prototype, "rufToggleArrow", null);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], RufToggleDirective.prototype, "toggleChange", void 0);
        __decorate([
            core.HostBinding('class.ruf-toggle'),
            __metadata("design:type", Object)
        ], RufToggleDirective.prototype, "toggle", void 0);
        __decorate([
            core.HostBinding('class.ruf-toggle-normal'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], RufToggleDirective.prototype, "normal", null);
        __decorate([
            core.HostListener('click', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], RufToggleDirective.prototype, "onClick", null);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], RufToggleDirective.prototype, "onKey", null);
        RufToggleDirective = __decorate([
            core.Directive({
                selector: '[rufToggle], [rufToggleChevron], [rufToggleArrow]',
                exportAs: 'rufToggle'
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], RufToggleDirective);
        return RufToggleDirective;
    }(overlay.CdkOverlayOrigin));

    var RufToggleModule = /** @class */ (function () {
        function RufToggleModule() {
        }
        RufToggleModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule, overlay.OverlayModule],
                declarations: [RufToggleDirective],
                exports: [RufToggleDirective]
            })
        ], RufToggleModule);
        return RufToggleModule;
    }());

    var RufSidemenuItemComponent = /** @class */ (function (_super) {
        __extends(RufSidemenuItemComponent, _super);
        function RufSidemenuItemComponent(menubar, _elementRef) {
            var _this = _super.call(this, menubar) || this;
            _this.menubar = menubar;
            _this._elementRef = _elementRef;
            return _this;
        }
        RufSidemenuItemComponent = __decorate([
            core.Component({
                selector: 'ruf-sidemenu-item, [rufSidemenuItem]',
                template: "\n      <ng-content></ng-content>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __param(0, core.Inject(core.forwardRef(function () { return RufSidemenuComponent; }))),
            __metadata("design:paramtypes", [RufSidemenuComponent,
                core.ElementRef])
        ], RufSidemenuItemComponent);
        return RufSidemenuItemComponent;
    }(RufMenubarItemComponent));

    var RufSidemenuComponent = /** @class */ (function (_super) {
        __extends(RufSidemenuComponent, _super);
        function RufSidemenuComponent(_elementRef, _renderer) {
            var _this = _super.call(this, _elementRef, _renderer) || this;
            _this.direction = 'column';
            _this.inkbarPosition = 'start';
            _this.orientation = 'vertical';
            return _this;
        }
        __decorate([
            core.HostBinding('attr.aria-orientation'),
            __metadata("design:type", Object)
        ], RufSidemenuComponent.prototype, "orientation", void 0);
        __decorate([
            core.ContentChildren(core.forwardRef(function () { return RufSidemenuItemComponent; })),
            __metadata("design:type", core.QueryList)
        ], RufSidemenuComponent.prototype, "menuItems", void 0);
        RufSidemenuComponent = __decorate([
            core.Component({
                selector: 'ruf-sidemenu',
                template: "<div [ngClass]=\"getLayoutClass()\" role=\"menubar\">\n  <ng-content></ng-content>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None,
                providers: [RufMenubarComponent],
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: ["ruf-menubar{-ms-grid-row-align:stretch;align-self:stretch;display:block}.ruf-menubar-layout{-webkit-box-align:stretch;align-items:stretch;height:100%}.ruf-menu-item{-webkit-box-align:center;align-items:center;border-color:transparent;cursor:pointer;display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1 auto;-webkit-transition:background-color .2s;transition:background-color .2s}.ruf-menu-item:focus{outline:0}.ruf-layout-row{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-menubar-layout.ruf-layout-column{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-menubar-layout.ruf-layout-column>ul{padding-left:0}.ruf-menubar-layout.ruf-layout-column .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}@media (min-width:0) and (max-width:599px){.ruf-layout-row-xs{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-xs>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-xs .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-xs{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-xs>ul{padding-left:0}.ruf-layout-column-xs .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:600px) and (max-width:959px){.ruf-layout-row-sm{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-sm>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-sm .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-sm{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-sm>ul{padding-left:0}.ruf-layout-column-sm .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:960px) and (max-width:1279px){.ruf-layout-row-md{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-md>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-md .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-md{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-md>ul{padding-left:0}.ruf-layout-column-md .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1280px) and (max-width:1919px){.ruf-layout-row-lg{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-lg>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-lg .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-lg{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-lg>ul{padding-left:0}.ruf-layout-column-lg .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1920px){.ruf-layout-row-xl{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-xl>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-xl .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-xl{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-xl>ul{padding-left:0}.ruf-layout-column-xl .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:600px){.ruf-layout-row-gt-xs{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-xs>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-xs .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-xs{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-xs>ul{padding-left:0}.ruf-layout-column-gt-xs .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:960px){.ruf-layout-row-gt-sm{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-sm>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-sm .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-sm{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-sm>ul{padding-left:0}.ruf-layout-column-gt-sm .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1280px){.ruf-layout-row-gt-md{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-md>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-md .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-md{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-md>ul{padding-left:0}.ruf-layout-column-gt-md .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}@media (min-width:1920px){.ruf-layout-row-gt-lg{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.ruf-layout-row-gt-lg>ul{padding-left:0;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.ruf-layout-row-gt-lg .ruf-menu-item{border-bottom-width:.125rem;border-top-width:.125rem;-webkit-box-pack:center;justify-content:center;border-style:solid none;padding:.125rem .9375rem}.ruf-layout-column-gt-lg{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.ruf-layout-column-gt-lg>ul{padding-left:0}.ruf-layout-column-gt-lg .ruf-menu-item{border-left-width:.125rem;border-right-width:.125rem;-webkit-box-pack:start;justify-content:flex-start;border-style:none solid;padding:.5rem .9375rem}}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel,ruf-sidemenu{display:block;max-width:15.625rem;min-width:6.25rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel>nav,ruf-sidemenu>nav{overflow-y:auto}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-menu-item,ruf-sidemenu .ruf-menu-item{-webkit-box-flex:0;flex:0 1 0;min-height:3.125rem;-webkit-transition:background-color .2s;transition:background-color .2s}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel.ruf-menubar-inkbar-start .ruf-menubar-layout.ruf-layout-column .ruf-menu-item,ruf-sidemenu.ruf-menubar-inkbar-start .ruf-menubar-layout.ruf-layout-column .ruf-menu-item{border-left-width:.25rem}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel.ruf-menubar-inkbar-end .ruf-menubar-layout.ruf-layout-column .ruf-menu-item,ruf-sidemenu.ruf-menubar-inkbar-end .ruf-menubar-layout.ruf-layout-column .ruf-menu-item{border-right-width:.25rem}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-sidemenu-children,ruf-sidemenu .ruf-sidemenu-children{overflow:hidden}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-sidemenu-children .ruf-menu-item,ruf-sidemenu .ruf-sidemenu-children .ruf-menu-item{height:1.875rem;min-height:1.875rem}.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-sidemenu-children .ruf-menu-item:active,.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-sidemenu-children .ruf-menu-item:focus,.ruf-sidemenu-popup-backdrop+* .mat-menu-panel .ruf-sidemenu-children .ruf-menu-item:hover,ruf-sidemenu .ruf-sidemenu-children .ruf-menu-item:active,ruf-sidemenu .ruf-sidemenu-children .ruf-menu-item:focus,ruf-sidemenu .ruf-sidemenu-children .ruf-menu-item:hover{text-decoration:underline}"]
            }),
            __metadata("design:paramtypes", [core.ElementRef, core.Renderer2])
        ], RufSidemenuComponent);
        return RufSidemenuComponent;
    }(RufMenubarComponent));

    /**
     * description
     */
    var RufSidemenuChildrenComponent = /** @class */ (function () {
        function RufSidemenuChildrenComponent(_elementRef, sidemenuComp) {
            this._elementRef = _elementRef;
            this.sidemenuComp = sidemenuComp;
            this.visible = true;
            this.sidemenuChildren = true;
        }
        RufSidemenuChildrenComponent.prototype.ngOnChanges = function (changes) {
            if (changes.visible) {
                this.visibleState = changes.visible.currentValue;
            }
        };
        RufSidemenuChildrenComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (this.childItems && this.childItems.length > 0) {
                this._keyboardSideNav = new RufKeyboardNavigation();
                this._keyboardSideNav.init(this._elementRef, this.childItems).subscribe(function (path) {
                    _this.sidemenuComp.select(path.path, path.data);
                });
            }
        };
        RufSidemenuChildrenComponent.prototype.setActiveItem = function (event) {
            // set active item when parent is clicked
            if (event.toState) {
                this._keyboardSideNav.setActiveItem(0);
            }
        };
        RufSidemenuChildrenComponent.prototype.onKey = function (event) {
            switch (event.keyCode) {
                case RufKeyCodes.ESCAPE:
                    if (this.menuTrigger) {
                        this.menuTrigger.select(event);
                    }
                    break;
                default:
                    if (this._keyboardSideNav && this._keyboardSideNav.isActive()) {
                        this._keyboardSideNav.onKeyDown(event);
                    }
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufSidemenuChildrenComponent.prototype, "visible", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", RufToggleDirective)
        ], RufSidemenuChildrenComponent.prototype, "menuTrigger", void 0);
        __decorate([
            core.HostBinding('class.ruf-sidemenu-children'),
            __metadata("design:type", Object)
        ], RufSidemenuChildrenComponent.prototype, "sidemenuChildren", void 0);
        __decorate([
            core.HostBinding('@visible'),
            __metadata("design:type", Boolean)
        ], RufSidemenuChildrenComponent.prototype, "visibleState", void 0);
        __decorate([
            core.ContentChildren(core.forwardRef(function () { return RufSidemenuItemComponent; })),
            __metadata("design:type", core.QueryList)
        ], RufSidemenuChildrenComponent.prototype, "childItems", void 0);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], RufSidemenuChildrenComponent.prototype, "onKey", null);
        RufSidemenuChildrenComponent = __decorate([
            core.Component({
                selector: "[rufSidemenuChildren], ruf-sidemenu-children",
                exportAs: 'rufSidemenuChildren',
                template: "<div (@visible.done)=\"setActiveItem($event)\" [@visible]=\"visible\"><ng-content></ng-content></div>",
                encapsulation: core.ViewEncapsulation.None,
                animations: [
                    animations.trigger('visible', [
                        animations.state('0', animations.style({
                            height: 0
                        })),
                        animations.state('1', animations.style({
                            height: '*'
                        })),
                        animations.transition('0 => 1', animations.animate('300ms ease-in-out')),
                        animations.transition('1 => 0', animations.animate('300ms ease-in-out'))
                    ])
                ]
            }),
            __metadata("design:paramtypes", [core.ElementRef, RufSidemenuComponent])
        ], RufSidemenuChildrenComponent);
        return RufSidemenuChildrenComponent;
    }());

    var RufSidemenuModule = /** @class */ (function () {
        function RufSidemenuModule() {
        }
        RufSidemenuModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule, RufMenubarModule, RufToggleModule],
                declarations: [RufSidemenuComponent, RufSidemenuItemComponent, RufSidemenuChildrenComponent],
                exports: [RufSidemenuComponent, RufSidemenuItemComponent, RufSidemenuChildrenComponent]
            })
        ], RufSidemenuModule);
        return RufSidemenuModule;
    }());

    var RufDynamicSideMenuModule = /** @class */ (function () {
        function RufDynamicSideMenuModule() {
        }
        RufDynamicSideMenuModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    RufUtilsModule,
                    RufUniqueIdModule,
                    RufToggleModule,
                    RufLabeledIconModule,
                    RufSidemenuModule,
                    RufIconModule,
                    flexLayout.FlexLayoutModule,
                    menu.MatMenuModule
                ],
                declarations: [RufDynamicSideMenuComponent],
                exports: [RufDynamicSideMenuComponent]
            })
        ], RufDynamicSideMenuModule);
        return RufDynamicSideMenuModule;
    }());

    var RufFooterControlsDirective = /** @class */ (function () {
        function RufFooterControlsDirective() {
        }
        RufFooterControlsDirective = __decorate([
            core.Directive({
                selector: '[rufFooterControls]'
            })
        ], RufFooterControlsDirective);
        return RufFooterControlsDirective;
    }());
    var RufFooterComponent = /** @class */ (function () {
        function RufFooterComponent() {
            this.role = 'contentinfo';
        }
        RufFooterComponent.prototype.ngOnInit = function () { };
        __decorate([
            core.HostBinding('attr.role'),
            __metadata("design:type", Object)
        ], RufFooterComponent.prototype, "role", void 0);
        __decorate([
            core.ContentChild(RufFooterControlsDirective, { static: false }),
            __metadata("design:type", RufFooterControlsDirective)
        ], RufFooterComponent.prototype, "controls", void 0);
        RufFooterComponent = __decorate([
            core.Component({
                selector: 'ruf-footer',
                template: "<ruf-toolbar class=\"ruf-footer-toolbar\" rufId=\"footer_toolbar\">\n  <ng-content></ng-content>\n  <div rufToolbarFiller *ngIf=\"controls\" class=\"ruf-footer-filler\"></div>\n  <ng-content select=\"[rufFooterControls]\"></ng-content>\n</ruf-toolbar>\n",
                encapsulation: core.ViewEncapsulation.None,
                styles: ["ruf-footer{border-top-style:solid;border-top-width:1px;display:block;flex-shrink:0;min-height:2.5rem;overflow:hidden}.ruf-footer-toolbar{height:2.5rem;margin:0 auto;padding:0 .625rem;width:100%}.ruf-footer-filler{-webkit-box-flex:1;flex:1 1 auto}"]
            }),
            __metadata("design:paramtypes", [])
        ], RufFooterComponent);
        return RufFooterComponent;
    }());

    var RufFooterModule = /** @class */ (function () {
        function RufFooterModule() {
        }
        RufFooterModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule, RufToolbarModule, RufUniqueIdModule],
                declarations: [RufFooterComponent, RufFooterControlsDirective],
                exports: [RufFooterComponent, RufFooterControlsDirective]
            })
        ], RufFooterModule);
        return RufFooterModule;
    }());

    var RufIconButtonDirective = /** @class */ (function () {
        function RufIconButtonDirective(_matButton) {
            this._active = false;
            this._dark = false;
            this._activeClass = 'activeClass';
            this.fontSet = 'fisfont';
            // can be used in a container that supports the ruf-square class
            this.square = true;
            this.darkClass = this._dark;
            this.activeClass = false;
            this.primaryClass = false;
            this.transition = 'background-color 1s ease';
            this.tabindex = 0;
            if (_matButton) {
                _matButton.disableRipple = true;
            }
        }
        Object.defineProperty(RufIconButtonDirective.prototype, "activeColor", {
            set: function (color) {
                if (color === 'primary') {
                    this._activeClass = 'primaryClass';
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufIconButtonDirective.prototype, "active", {
            get: function () {
                return this._active;
            },
            set: function (isActive) {
                this._active = !!isActive;
                this[this._activeClass] = this._active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufIconButtonDirective.prototype, "dark", {
            get: function () {
                return this._dark;
            },
            set: function (isActive) {
                this._dark = isActive;
                this.darkClass = isActive === '' || isActive;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufIconButtonDirective.prototype, "fontSet", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufIconButtonDirective.prototype, "fontIcon", void 0);
        __decorate([
            core.HostBinding('class.ruf-square'),
            __metadata("design:type", Object)
        ], RufIconButtonDirective.prototype, "square", void 0);
        __decorate([
            core.HostBinding('class.ruf-background-dark'),
            __metadata("design:type", Object)
        ], RufIconButtonDirective.prototype, "darkClass", void 0);
        __decorate([
            core.HostBinding('class.ruf-background-darker'),
            __metadata("design:type", Object)
        ], RufIconButtonDirective.prototype, "activeClass", void 0);
        __decorate([
            core.HostBinding('class.ruf-background-primary-dark'),
            __metadata("design:type", Object)
        ], RufIconButtonDirective.prototype, "primaryClass", void 0);
        __decorate([
            core.HostBinding('style.transition'),
            __metadata("design:type", Object)
        ], RufIconButtonDirective.prototype, "transition", void 0);
        __decorate([
            core.HostBinding('attr.tabindex'),
            __metadata("design:type", Object)
        ], RufIconButtonDirective.prototype, "tabindex", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RufIconButtonDirective.prototype, "activeColor", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], RufIconButtonDirective.prototype, "active", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RufIconButtonDirective.prototype, "dark", null);
        RufIconButtonDirective = __decorate([
            core.Directive({
                selector: '[rufIconButton]',
                exportAs: 'rufIconButton'
            }),
            __param(0, core.Self()),
            __param(0, core.Optional()),
            __metadata("design:paramtypes", [button.MatButton])
        ], RufIconButtonDirective);
        return RufIconButtonDirective;
    }());

    var RufIconButtonModule = /** @class */ (function () {
        function RufIconButtonModule() {
        }
        RufIconButtonModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule, button.MatButtonModule],
                declarations: [RufIconButtonDirective],
                exports: [RufIconButtonDirective]
            })
        ], RufIconButtonModule);
        return RufIconButtonModule;
    }());

    var FALSY = ['false', false, 0];
    var RufIfDirective = /** @class */ (function (_super) {
        __extends(RufIfDirective, _super);
        function RufIfDirective(templateRef, viewContainer, monitor, elRef, styleUtils, changeDetectorRef) {
            var _this = _super.call(this, monitor, elRef, styleUtils) || this;
            _this.templateRef = templateRef;
            _this.viewContainer = viewContainer;
            _this.elRef = elRef;
            _this.styleUtils = styleUtils;
            _this.changeDetectorRef = changeDetectorRef;
            _this.isAlreadyInserted = false;
            return _this;
        }
        Object.defineProperty(RufIfDirective.prototype, "rufIfXs", {
            set: function (val) {
                this._cacheInput('rufIfXs', val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufIfDirective.prototype, "rufIfGtXs", {
            set: function (val) {
                this._cacheInput('rufIfGtXs', val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufIfDirective.prototype, "rufIfSm", {
            set: function (val) {
                this._cacheInput('rufIfSm', val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufIfDirective.prototype, "rufIfGtSm", {
            set: function (val) {
                this._cacheInput('rufIfGtSm', val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufIfDirective.prototype, "rufIfMd", {
            set: function (val) {
                this._cacheInput('rufIfMd', val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufIfDirective.prototype, "rufIfGtMd", {
            set: function (val) {
                this._cacheInput('rufIfGtMd', val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufIfDirective.prototype, "rufIfLg", {
            set: function (val) {
                this._cacheInput('rufIfLg', val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufIfDirective.prototype, "rufIfGtLg", {
            set: function (val) {
                this._cacheInput('rufIfGtLg', val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufIfDirective.prototype, "rufIfXl", {
            set: function (val) {
                this._cacheInput('rufIfXl', val);
            },
            enumerable: true,
            configurable: true
        });
        RufIfDirective.prototype._getDisplayStyle = function () {
            // this is not used for rufIf, only prevents error from being throw as BaseDirective invokes it
            return 'block';
        };
        RufIfDirective.prototype.ngOnChanges = function (changes) {
            if (changes['rufIf'] != null || this._mqActivation) {
                this._updateWithValue();
            }
        };
        RufIfDirective.prototype.ngOnInit = function () {
            var _this = this;
            this._listenForMediaQueryChanges('rufIf', false, function (changes) {
                _this._updateWithValue(changes.value);
                _this.changeDetectorRef.markForCheck();
            });
            this._updateWithValue();
        };
        RufIfDirective.prototype.ngOnDestroy = function () {
            _super.prototype.ngOnDestroy.call(this);
        };
        RufIfDirective.prototype._updateWithValue = function (value) {
            value = value || this._getDefaultVal('rufIf', false);
            if (this._mqActivation) {
                value = this._mqActivation.activatedInput;
            }
            var shouldShow = this._validateTruthy(value);
            this._update(shouldShow);
        };
        // Insert or remove the template
        RufIfDirective.prototype._update = function (value) {
            if (value && !this.isAlreadyInserted) {
                this.viewContainer.createEmbeddedView(this.templateRef);
                this.isAlreadyInserted = true;
            }
            else if (!value && this.isAlreadyInserted) {
                this.viewContainer.clear();
                this.isAlreadyInserted = false;
            }
        };
        RufIfDirective.prototype._validateTruthy = function (value) {
            return FALSY.indexOf(value) === -1;
        };
        __decorate([
            core.Input('rufIfXs'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RufIfDirective.prototype, "rufIfXs", null);
        __decorate([
            core.Input('rufIfGtXs'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RufIfDirective.prototype, "rufIfGtXs", null);
        __decorate([
            core.Input('rufIfSm'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RufIfDirective.prototype, "rufIfSm", null);
        __decorate([
            core.Input('rufIfGtSm'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RufIfDirective.prototype, "rufIfGtSm", null);
        __decorate([
            core.Input('rufIfMd'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RufIfDirective.prototype, "rufIfMd", null);
        __decorate([
            core.Input('rufIfGtMd'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RufIfDirective.prototype, "rufIfGtMd", null);
        __decorate([
            core.Input('rufIfLg'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RufIfDirective.prototype, "rufIfLg", null);
        __decorate([
            core.Input('rufIfGtLg'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RufIfDirective.prototype, "rufIfGtLg", null);
        __decorate([
            core.Input('rufIfXl'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RufIfDirective.prototype, "rufIfXl", null);
        RufIfDirective = __decorate([
            core.Directive({
                selector: "\n    [rufIfXs],\n    [rufIfGtXs],\n    [rufIfSm],\n    [rufIfGtSm],\n    [rufIfMd],\n    [rufIfGtMd],\n    [rufIfLg],\n    [rufIfGtLg],\n    [rufIfXl]\n  "
            }),
            __metadata("design:paramtypes", [core.TemplateRef,
                core.ViewContainerRef,
                flexLayout.MediaMonitor,
                core.ElementRef,
                flexLayout.StyleUtils,
                core.ChangeDetectorRef])
        ], RufIfDirective);
        return RufIfDirective;
    }(flexLayout.BaseDirective));

    var RUF_PADDING_VALUES = ['none', 'auto', 'small', 'medium', 'large'];
    var RufPaddingDirective = /** @class */ (function () {
        function RufPaddingDirective(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.classPrefix = 'ruf-padding';
            this._positions = {
                rufPadding: ['-'],
                rufPaddingVertical: ['-top-', '-bottom-'],
                rufPaddingHorizontal: ['-left-', '-right-'],
                rufPaddingTop: ['-top-'],
                rufPaddingRight: ['-right-'],
                rufPaddingBottom: ['-bottom-'],
                rufPaddingLeft: ['-left-']
            };
            this.rufPadding = '';
            this.rufPaddingVertical = '';
            this.rufPaddingHorizontal = '';
            this.rufPaddingTop = '';
            this.rufPaddingRight = '';
            this.rufPaddingBottom = '';
            this.rufPaddingLeft = '';
            this.padding = true;
        }
        RufPaddingDirective.prototype.ngOnChanges = function (changes) {
            var _this = this;
            Object.keys(changes).forEach(function (key) {
                _this.update(key, changes[key]);
            });
        };
        RufPaddingDirective.prototype.update = function (key, change) {
            var _this = this;
            var previous = this._validateValue(change.previousValue);
            var current = this._validateValue(change.currentValue);
            var positions = this._positions[key];
            positions.forEach(function (pos) {
                // remove
                _this.renderer.removeClass(_this.el.nativeElement, _this.classPrefix + pos + previous);
                // add
                _this.renderer.addClass(_this.el.nativeElement, _this.classPrefix + pos + current);
            });
        };
        RufPaddingDirective.prototype._validateValue = function (val) {
            if (RUF_PADDING_VALUES.indexOf(val) !== -1) {
                return val;
            }
            return 'medium';
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufPaddingDirective.prototype, "rufPadding", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufPaddingDirective.prototype, "rufPaddingVertical", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufPaddingDirective.prototype, "rufPaddingHorizontal", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufPaddingDirective.prototype, "rufPaddingTop", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufPaddingDirective.prototype, "rufPaddingRight", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufPaddingDirective.prototype, "rufPaddingBottom", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufPaddingDirective.prototype, "rufPaddingLeft", void 0);
        __decorate([
            core.HostBinding('class.ruf-padding'),
            __metadata("design:type", Object)
        ], RufPaddingDirective.prototype, "padding", void 0);
        RufPaddingDirective = __decorate([
            core.Directive({
                selector: "\n    [rufPadding],\n    [rufPaddingVertical],\n    [rufPaddingHorizontal],\n    [rufPaddingTop],\n    [rufPaddingRight],\n    [rufPaddingBottom],\n    [rufPaddingLeft]\n  ",
                exportAs: 'rufPadding'
            }),
            __metadata("design:paramtypes", [core.ElementRef, core.Renderer2])
        ], RufPaddingDirective);
        return RufPaddingDirective;
    }());

    var RUF_MARGIN_VALUES = ['none', 'auto', 'small', 'medium', 'large'];
    var RufMarginDirective = /** @class */ (function () {
        function RufMarginDirective(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.classPrefix = 'ruf-margin';
            this._positions = {
                rufMargin: ['-'],
                rufMarginVertical: ['-top-', '-bottom-'],
                rufMarginHorizontal: ['-left-', '-right-'],
                rufMarginTop: ['-top-'],
                rufMarginRight: ['-right-'],
                rufMarginBottom: ['-bottom-'],
                rufMarginLeft: ['-left-']
            };
            this.rufMargin = '';
            this.rufMarginVertical = '';
            this.rufMarginHorizontal = '';
            this.rufMarginTop = '';
            this.rufMarginRight = '';
            this.rufMarginBottom = '';
            this.rufMarginLeft = '';
            this.margin = true;
        }
        RufMarginDirective.prototype.ngOnChanges = function (changes) {
            var _this = this;
            Object.keys(changes).forEach(function (key) {
                _this.update(key, changes[key]);
            });
        };
        RufMarginDirective.prototype.update = function (key, change) {
            var _this = this;
            var previous = this._validateValue(change.previousValue);
            var current = this._validateValue(change.currentValue);
            var positions = this._positions[key];
            positions.forEach(function (pos) {
                // remove
                _this.renderer.removeClass(_this.el.nativeElement, _this.classPrefix + pos + previous);
                // add
                _this.renderer.addClass(_this.el.nativeElement, _this.classPrefix + pos + current);
            });
        };
        RufMarginDirective.prototype._validateValue = function (val) {
            if (RUF_MARGIN_VALUES.indexOf(val) !== -1) {
                return val;
            }
            return 'medium';
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufMarginDirective.prototype, "rufMargin", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufMarginDirective.prototype, "rufMarginVertical", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufMarginDirective.prototype, "rufMarginHorizontal", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufMarginDirective.prototype, "rufMarginTop", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufMarginDirective.prototype, "rufMarginRight", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufMarginDirective.prototype, "rufMarginBottom", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufMarginDirective.prototype, "rufMarginLeft", void 0);
        __decorate([
            core.HostBinding('class.ruf-margin'),
            __metadata("design:type", Object)
        ], RufMarginDirective.prototype, "margin", void 0);
        RufMarginDirective = __decorate([
            core.Directive({
                selector: "\n    [rufMargin],\n    [rufMarginVertical],\n    [rufMarginHorizontal],\n    [rufMarginTop],\n    [rufMarginRight],\n    [rufMarginBottom],\n    [rufMarginLeft]\n  ",
                exportAs: 'rufMargin'
            }),
            __metadata("design:paramtypes", [core.ElementRef, core.Renderer2])
        ], RufMarginDirective);
        return RufMarginDirective;
    }());

    var RufLayoutModule = /** @class */ (function () {
        function RufLayoutModule() {
        }
        RufLayoutModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule, flexLayout.FlexLayoutModule],
                declarations: [RufMarginDirective, RufPaddingDirective, RufIfDirective],
                exports: [RufMarginDirective, RufPaddingDirective, RufIfDirective, flexLayout.FlexLayoutModule]
            })
        ], RufLayoutModule);
        return RufLayoutModule;
    }());

    var RufPageHeaderRowDirective = /** @class */ (function () {
        function RufPageHeaderRowDirective() {
        }
        RufPageHeaderRowDirective = __decorate([
            core.Directive({
                selector: 'ruf-page-header-row' // tslint:disable-line
            })
        ], RufPageHeaderRowDirective);
        return RufPageHeaderRowDirective;
    }());
    var RufPageHeaderIconComponent = /** @class */ (function () {
        function RufPageHeaderIconComponent() {
        }
        RufPageHeaderIconComponent = __decorate([
            core.Component({
                selector: 'ruf-page-header-icon',
                encapsulation: core.ViewEncapsulation.None,
                template: "\n    <div><ng-content></ng-content></div>\n  "
            })
        ], RufPageHeaderIconComponent);
        return RufPageHeaderIconComponent;
    }());
    var RufPageHeaderTitleComponent = /** @class */ (function () {
        function RufPageHeaderTitleComponent() {
        }
        RufPageHeaderTitleComponent = __decorate([
            core.Component({
                selector: 'ruf-page-header-title',
                encapsulation: core.ViewEncapsulation.None,
                template: "\n    <ng-content></ng-content>\n  "
            })
        ], RufPageHeaderTitleComponent);
        return RufPageHeaderTitleComponent;
    }());
    var RufPageHeaderDescriptionComponent = /** @class */ (function () {
        function RufPageHeaderDescriptionComponent() {
        }
        RufPageHeaderDescriptionComponent = __decorate([
            core.Component({
                selector: 'ruf-page-header-description',
                encapsulation: core.ViewEncapsulation.None,
                template: "\n    <ng-content></ng-content>\n  "
            })
        ], RufPageHeaderDescriptionComponent);
        return RufPageHeaderDescriptionComponent;
    }());
    var RufPageHeaderComponent = /** @class */ (function () {
        function RufPageHeaderComponent() {
        }
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufPageHeaderComponent.prototype, "name", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufPageHeaderComponent.prototype, "title", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufPageHeaderComponent.prototype, "description", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufPageHeaderComponent.prototype, "icon", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufPageHeaderComponent.prototype, "color", void 0);
        RufPageHeaderComponent = __decorate([
            core.Component({
                selector: 'ruf-page-header',
                template: "<ruf-toolbar [color]=\"color\" rufId=\"pageheader_toolbar\" class=\"ruf-pageheader-toolbar\" >\n  <ruf-page-header-icon rufId=\"pageheader_icon\" *ngIf=\"icon\" class=\"ruf-page-header-text-icon\">{{icon}}</ruf-page-header-icon>\n  <ng-content select=\"ruf-page-header-icon\"></ng-content>\n  <div class=\"ruf-page-header-title-area\">\n    <ruf-page-header-title *ngIf=\"title\" rufId=\"pageheader_title\">{{title}}</ruf-page-header-title>\n    <ng-content rufId=\"pageheader_title_tag\" select=\"ruf-page-header-title\"></ng-content>\n    <ruf-page-header-description rufId=\"pageheader_description\" *ngIf=\"description\">{{description}}</ruf-page-header-description>\n    <ng-content rufId=\"pageheader_title_tag\" select=\"ruf-page-header-description\"></ng-content>\n  </div>\n  <div rufToolbarFiller></div>\n  <ng-content></ng-content>\n  <ng-content select=\"ruf-page-header-row\" ngProjectAs=\"ruf-toolbar-row\"></ng-content>\n</ruf-toolbar>\n",
                encapsulation: core.ViewEncapsulation.None,
                styles: ["ruf-page-header{display:block;min-height:2.375rem;width:100%}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows>.ruf-toolbar-first-row{-webkit-box-align:end;align-items:flex-end;padding:.625rem 0}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows .ruf-page-header-title-area{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;-webkit-box-pack:center;justify-content:center;min-height:2.5rem}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows .ruf-page-header-metric,ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows ruf-page-header-title{margin:0;text-transform:capitalize}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows .ruf-page-header-metric-description,ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows ruf-page-header-description{text-transform:initial}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows>ruf-page-header-row,ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows>ruf-toolbar-row{margin:0 auto;padding:0;width:100%}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows ruf-page-header-icon{border-radius:50%;flex-shrink:0;height:2.5rem;overflow:hidden;text-align:center;width:2.5rem}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows ruf-page-header-icon>div{font-size:1.875rem;line-height:2.625rem}ruf-page-header .ruf-pageheader-toolbar>.ruf-toolbar-rows ruf-page-header-icon.ruf-page-header-text-icon>div{font-size:1.125rem;line-height:2.5rem;text-transform:lowercase}"]
            }),
            __metadata("design:paramtypes", [])
        ], RufPageHeaderComponent);
        return RufPageHeaderComponent;
    }());

    var RufPageHeaderModule = /** @class */ (function () {
        function RufPageHeaderModule() {
        }
        RufPageHeaderModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule, RufToolbarModule, RufUniqueIdModule],
                declarations: [
                    RufPageHeaderComponent,
                    RufPageHeaderTitleComponent,
                    RufPageHeaderDescriptionComponent,
                    RufPageHeaderIconComponent,
                    RufPageHeaderRowDirective
                ],
                exports: [
                    RufPageHeaderComponent,
                    RufPageHeaderTitleComponent,
                    RufPageHeaderDescriptionComponent,
                    RufPageHeaderIconComponent,
                    RufPageHeaderRowDirective
                ]
            })
        ], RufPageHeaderModule);
        return RufPageHeaderModule;
    }());

    var RufAppCanvasComponent = /** @class */ (function () {
        function RufAppCanvasComponent() {
        }
        RufAppCanvasComponent = __decorate([
            core.Component({
                selector: 'ruf-app-canvas',
                template: "<ng-content></ng-content>",
                encapsulation: core.ViewEncapsulation.None,
                styles: ["ruf-app-canvas{display:block;height:100%;padding:0 0 30px;width:100%}"]
            })
        ], RufAppCanvasComponent);
        return RufAppCanvasComponent;
    }());

    var RufAppCanvasModule = /** @class */ (function () {
        function RufAppCanvasModule() {
        }
        RufAppCanvasModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule],
                declarations: [RufAppCanvasComponent],
                exports: [RufAppCanvasComponent]
            })
        ], RufAppCanvasModule);
        return RufAppCanvasModule;
    }());

    var RufLocaleService = /** @class */ (function () {
        function RufLocaleService() {
            this._locale = 'en';
            this._localeSubject = new rxjs.BehaviorSubject(this._locale);
            this._locale$ = rxjs.from(this._localeSubject);
        }
        Object.defineProperty(RufLocaleService.prototype, "locale", {
            get: function () {
                return this._locale;
            },
            set: function (locale) {
                this._locale = locale;
                this._localeSubject.next(locale);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufLocaleService.prototype, "locale$", {
            get: function () {
                return this._locale$;
            },
            enumerable: true,
            configurable: true
        });
        RufLocaleService = __decorate([
            core.Injectable()
        ], RufLocaleService);
        return RufLocaleService;
    }());

    var RufCurrencyPipe = /** @class */ (function () {
        function RufCurrencyPipe(localeService) {
            var _this = this;
            this.localeService = localeService;
            this.subscription = localeService.locale$.subscribe(function (data) {
                _this.currencyPipe = new common.CurrencyPipe(data);
            });
        }
        RufCurrencyPipe.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        RufCurrencyPipe.prototype.transform = function (value, currencyCode, symbolDisplay, digits) {
            return this.currencyPipe.transform(value, currencyCode, symbolDisplay, digits);
        };
        RufCurrencyPipe = __decorate([
            core.Pipe({
                name: 'rufCurrency',
                pure: false
            }),
            __metadata("design:paramtypes", [RufLocaleService])
        ], RufCurrencyPipe);
        return RufCurrencyPipe;
    }());

    var RufDatePipe = /** @class */ (function () {
        function RufDatePipe(localeService) {
            var _this = this;
            this.localeService = localeService;
            this.subscription = localeService.locale$.subscribe(function (data) {
                _this.datePipe = new common.DatePipe(data);
            });
        }
        RufDatePipe.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        RufDatePipe.prototype.transform = function (value, pattern) {
            return this.datePipe.transform(value, pattern);
        };
        RufDatePipe = __decorate([
            core.Pipe({
                name: 'rufDate',
                pure: false
            }),
            __metadata("design:paramtypes", [RufLocaleService])
        ], RufDatePipe);
        return RufDatePipe;
    }());

    var RufI18nModule = /** @class */ (function () {
        function RufI18nModule() {
        }
        RufI18nModule_1 = RufI18nModule;
        RufI18nModule.forRoot = function () {
            return {
                ngModule: RufI18nModule_1,
                providers: [{ provide: core.LOCALE_ID, useFactory: localeFactory, deps: [RufLocaleService] }, RufLocaleService]
            };
        };
        var RufI18nModule_1;
        RufI18nModule = RufI18nModule_1 = __decorate([
            core.NgModule({
                imports: [common.CommonModule],
                declarations: [RufDatePipe, RufCurrencyPipe],
                exports: [RufDatePipe, RufCurrencyPipe]
            })
        ], RufI18nModule);
        return RufI18nModule;
    }());
    function localeFactory(localeService) {
        return localeService.locale;
    }

    var RufNavbarComponent = /** @class */ (function () {
        function RufNavbarComponent() {
            this.role = 'navigation';
        }
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufNavbarComponent.prototype, "color", void 0);
        __decorate([
            core.HostBinding('attr.role'),
            __metadata("design:type", Object)
        ], RufNavbarComponent.prototype, "role", void 0);
        RufNavbarComponent = __decorate([
            core.Component({
                selector: 'ruf-navbar',
                template: "<ruf-toolbar [color]=\"color\" rufId=\"navbar_toolbar\">\n  <ng-content></ng-content>\n</ruf-toolbar>\n",
                encapsulation: core.ViewEncapsulation.None,
                styles: ["ruf-navbar{display:block;flex-shrink:0;min-height:2.8125rem;overflow:hidden}"]
            }),
            __metadata("design:paramtypes", [])
        ], RufNavbarComponent);
        return RufNavbarComponent;
    }());

    var RufNavbarModule = /** @class */ (function () {
        function RufNavbarModule() {
        }
        RufNavbarModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule, RufToolbarModule, RufUniqueIdModule],
                declarations: [RufNavbarComponent],
                exports: [RufNavbarComponent]
            })
        ], RufNavbarModule);
        return RufNavbarModule;
    }());

    var RufMegamenuSearchComponent = /** @class */ (function () {
        function RufMegamenuSearchComponent(_intl, changeDetectorRef) {
            this._intl = _intl;
            this.filterValue = new core.EventEmitter();
            this.inputFocus = new core.EventEmitter();
            this._intlChanges = _intl.changes.subscribe(function () { return changeDetectorRef.markForCheck(); });
        }
        Object.defineProperty(RufMegamenuSearchComponent.prototype, "placeholder", {
            get: function () {
                return this._placeholder || this._intl.megamenusearch.placeholder;
            },
            set: function (value) {
                this._placeholder = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufMegamenuSearchComponent.prototype, "clearSearchLabel", {
            get: function () {
                return this._clearSearchLabel || this._intl.megamenusearch.aria.clearSearchLabel;
            },
            set: function (value) {
                this._clearSearchLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        RufMegamenuSearchComponent.prototype.clear = function ($event) {
            this.filter.nativeElement.value = '';
            this.filterValue.emit('');
            $event.preventDefault();
            $event.stopPropagation();
        };
        RufMegamenuSearchComponent.prototype.handleKeyDown = function ($event) {
            switch ($event.keyCode) {
                case RufKeyCodes.SPACE:
                case RufKeyCodes.ENTER:
                    this.clear($event);
                    break;
            }
        };
        RufMegamenuSearchComponent.prototype.ngOnDestroy = function () {
            this._intlChanges.unsubscribe();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufMegamenuSearchComponent.prototype, "placeholder", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufMegamenuSearchComponent.prototype, "clearSearchLabel", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], RufMegamenuSearchComponent.prototype, "filterValue", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], RufMegamenuSearchComponent.prototype, "inputFocus", void 0);
        __decorate([
            core.ViewChild('filter', { static: false }),
            __metadata("design:type", core.ElementRef)
        ], RufMegamenuSearchComponent.prototype, "filter", void 0);
        RufMegamenuSearchComponent = __decorate([
            core.Component({
                selector: 'ruf-megamenu-search',
                template: "<div class=\"fis-search-input-container\" [class.ruf-focus]='inputFocusClass'>\n  <div class=\"fis-icon-search\"></div>\n  <input type=\"text\" #filter (focus)=\"inputFocus.emit(filter.value);inputFocusClass = true\" (keyup.enter)=\"filterValue.emit(filter.value)\"\n         (blur)=\"inputFocusClass = false;\"\n         (input)=\"filterValue.emit(filter.value)\" [placeholder]=\"placeholder\"\n         [attr.aria-label]=\"placeholder\">\n  <i class=\"fis-icon-close\" (click)=\"clear($event);inputFocusClass = true;filter.focus();\"\n       (keydown)=\"handleKeyDown($event)\"\n       (blur)=\"inputFocusClass = false;\"\n       [title]=\"clearSearchLabel\"\n       role=\"button\" [attr.aria-label]=\"clearSearchLabel\" tabindex=\"0\"></i>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: ["ruf-megamenu-search{padding-right:0}ruf-megamenu-search input{background-color:transparent;border:0 solid;content:'\\E93E';height:40px;outline:0;width:100%}ruf-megamenu-search input[type=text]::-ms-clear{display:none}ruf-megamenu-search .fis-icon-search{font-size:22px;margin-left:5px;margin-top:10px}ruf-megamenu-search .fis-icon-close{-ms-grid-row-align:center;align-self:center;height:1em;margin-right:5px;position:relative}ruf-megamenu-search .fis-search-input-container{display:-webkit-box;display:flex}"]
            }),
            __metadata("design:paramtypes", [RufShellIntl, core.ChangeDetectorRef])
        ], RufMegamenuSearchComponent);
        return RufMegamenuSearchComponent;
    }());

    // the object we reduce into during search preparation
    var RufCart = /** @class */ (function () {
        function RufCart() {
        }
        return RufCart;
    }());
    var RufSearchService = /** @class */ (function () {
        function RufSearchService() {
            this.SPLITTER = String.fromCharCode(167);
        }
        RufSearchService.prototype.recursiveReduce = function (items, context) {
            var _this = this;
            return items.reduce(function (cart, item) {
                if (item.children && item.children.length > 0) {
                    // this is a parent
                    var newContext = context.concat([item.label]);
                    var childCart = _this.recursiveReduce(item.children, newContext);
                    // we need to add a parent object with this objects children
                    var parent_1 = {
                        label: item.label,
                        path: item.path,
                        context: context.join(', '),
                        children: childCart.children,
                        searchKey: childCart.searchKeys.join(_this.SPLITTER) // only searchkeys of non-parent nodes
                    };
                    // only add this parent, if it has children
                    if (childCart.children && childCart.children.length > 0) {
                        cart.parents.push(parent_1);
                    }
                    // we get the parent nodes from the children of this item and only pass these up
                    cart.parents = cart.parents.concat(childCart.parents); // the reduced items are basically pushed up to the highest level
                    // we also append the childcart keys to the parent (for searching purposes)
                    // This isn't necessary anymore as we only have one level cart.searchKeys = cart.searchKeys.concat(childCart.searchKeys);
                }
                else {
                    // this is a child, so we add it to this carts children
                    item.searchKey = item.label.toLowerCase(); // we make the search key lowercase here for all children
                    cart.children.push(item);
                    cart.searchKeys.push(item.searchKey);
                }
                return cart;
            }, {
                // start with an empty cart
                parents: [],
                children: [],
                searchKeys: []
            });
        };
        // prepares the search items
        RufSearchService.prototype.prepareSearch = function (items) {
            var _this = this;
            // the goal is to recursively parse the tree structure for parents of children
            // children are nodes with no children, parents are nodes with children
            var preparedItems = this.recursiveReduce(items, []);
            // we return a function here that performs the search on the prepared items
            return function (term) {
                return _this.performSearch(preparedItems.parents, term);
            };
        };
        // used to create a reduced version of what gets displayed, and also
        // detaches from the original object
        RufSearchService.prototype.copySearchItem = function (item, newChildren) {
            return {
                label: item.label,
                path: item.path,
                context: item.context,
                children: newChildren
            };
        };
        // The search assumes that there each item in the array only has one level of children
        // this explicit structure is created in the prepare search
        RufSearchService.prototype.performSearch = function (items, term) {
            var _this = this;
            var searchTerm = term.toLowerCase(); // lowercase search term vs lowercase search key
            // call the reduce to omit non matching items
            return items.reduce(
            // newItems is the returned value from the prev function call
            function (newItems, item) {
                // first we check if the parent item will be added (checking this here prevents unnecessary looping)
                if (item.searchKey && item.searchKey.indexOf(searchTerm) > -1) {
                    // filter the children
                    // (we know there are children as the searchkey collates only child keys)
                    var reducedChildren = item.children.filter(function (child) {
                        return child.searchKey.indexOf(searchTerm) > -1;
                    });
                    // there will always be atleast one child that matches
                    // (as have already we checked the collated search key)
                    newItems.push(_this.copySearchItem(item, reducedChildren));
                }
                return newItems;
            }, [] // initial empty array
            );
        };
        RufSearchService = __decorate([
            core.Injectable()
        ], RufSearchService);
        return RufSearchService;
    }());

    var RufMegamenuComponent = /** @class */ (function () {
        function RufMegamenuComponent(searchService, _intl, changeDetectorRef) {
            this.searchService = searchService;
            this._intl = _intl;
            this.items = [];
            this.select = new core.EventEmitter();
            // Subjects: denotes user interaction streams
            // search related properties
            this.searchTerms$ = new rxjs.Subject(); // stream of search terms
            // sidemenu select event stream
            this.selectedSidemenuItems$ = new rxjs.Subject(); // stream of selected items (same type has this.items)
            this.preparedSearchableItems = function (term) { return []; };
            this._intlChanges = _intl.changes.subscribe(function () { return changeDetectorRef.markForCheck(); });
        }
        Object.defineProperty(RufMegamenuComponent.prototype, "searchPlaceholder", {
            get: function () {
                return this._searchPlaceholder || this._intl.megamenu.placeholder;
            },
            set: function (value) {
                this._searchPlaceholder = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufMegamenuComponent.prototype, "clearSearchAriaLabel", {
            get: function () {
                return this._clearSearchAriaLabel || this._intl.megamenu.aria.clearSearchLabel;
            },
            set: function (value) {
                this._clearSearchAriaLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        RufMegamenuComponent.prototype.ngOnInit = function () {
            var _this = this;
            // map search terms to a search results stream ready to be consumed by sitemap
            var searchResults$ = this.searchTerms$.pipe(operators.distinctUntilChanged(), operators.debounceTime(400), // don't search unless user stopped typing for 400ms
            operators.switchMap(function (term) { return _this.search(term); }), // ignore already triggered searches.
            operators.startWith([])); // start with empty results
            // map sidemenu select event to selected item's children array
            var selectedItemChildren$ = this.selectedSidemenuItems$.pipe(operators.withLatestFrom(searchResults$), // combine each event with the latest of the searchResults$ stream
            operators.map(function (_a) {
                var _b = __read(_a, 2), item = _b[0], searchResults = _b[1];
                if (!item) {
                    return searchResults || [];
                }
                // map to the selected item's children or an empty array.
                return item.data || [];
            }));
            // sitemap data stream is a merge of search results and selected item's children streams
            this.sitemapItems$ = rxjs.merge(selectedItemChildren$, searchResults$);
        };
        RufMegamenuComponent.prototype.ngOnChanges = function (changes) {
            // when any changes to the items occur, re-prepare the search
            if (changes.items && changes.items.currentValue) {
                this.preparedSearchableItems = this.searchService.prepareSearch(changes.items.currentValue);
            }
        };
        RufMegamenuComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // once the sidemenu is created (after view init), select first sidemenu item
            setTimeout(function () {
                if (_this.items[0]) {
                    _this.sidemenu.select(_this.items[0].path, _this.items[0].children);
                }
            });
        };
        RufMegamenuComponent.prototype.search = function (term) {
            var results = this.items;
            // if no prepared searchable data is available we just return everything
            if (this.preparedSearchableItems) {
                // now we process the searching of the data
                results = this.preparedSearchableItems(term);
            }
            if (!term || term === '') {
                results = [];
            }
            // return observable of results using same type has this.item
            return rxjs.of(results);
        };
        RufMegamenuComponent.prototype.ngOnDestroy = function () {
            this._intlChanges.unsubscribe();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufMegamenuComponent.prototype, "searchPlaceholder", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufMegamenuComponent.prototype, "clearSearchAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], RufMegamenuComponent.prototype, "items", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], RufMegamenuComponent.prototype, "select", void 0);
        __decorate([
            core.ViewChild('sidemenu', { static: true }),
            __metadata("design:type", RufSidemenuComponent)
        ], RufMegamenuComponent.prototype, "sidemenu", void 0);
        RufMegamenuComponent = __decorate([
            core.Component({
                selector: 'ruf-megamenu',
                template: "<div class=\"ruf-sidemenu-container\">\n  <ruf-megamenu-search (filterValue)=\"searchTerms$.next($event)\" (inputFocus)=\"selectedSidemenuItems$.next()\" [placeholder]=\"searchPlaceholder\" [clearSearchLabel]=\"clearSearchAriaLabel\"></ruf-megamenu-search>\n  <ruf-sidemenu #sidemenu [selectedPath]=\"(selectedSidemenuItems$ | async)?.path\" (select)=\"selectedSidemenuItems$.next($event);\">\n    <ruf-sidemenu-item *ngFor=\"let item of items\" [path]=\"item.path\" [data]=\"item.children\">{{item.label}}</ruf-sidemenu-item>\n  </ruf-sidemenu>\n</div>\n<div class=\"ruf-sitemap-container\">\n  <ruf-sitemap [items]=\"sitemapItems$\" (select)=\"select.emit($event)\">\n  </ruf-sitemap>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                providers: [RufSearchService],
                styles: ["ruf-megamenu{display:-webkit-box;display:flex;flex-shrink:0;overflow-x:auto;padding:20px 20px 20px 0;width:100%}ruf-megamenu .ruf-sidemenu-container{height:100%;max-width:200px;min-width:200px;overflow-x:hidden;overflow-y:auto}ruf-megamenu .ruf-sidemenu-container ruf-sidemenu{flex-shrink:0;min-width:200px}ruf-megamenu .fis-search-input-container,ruf-megamenu .ruf-focus{border-left-style:solid;border-left-width:2px}ruf-megamenu .ruf-sitemap-container{border-style:solid;border-width:20px;display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1 1 auto}ruf-megamenu .ruf-sidemenu-container::-webkit-scrollbar{width:.5em}ruf-megamenu ruf-sitemap{padding:18px}ruf-megamenu::-webkit-scrollbar{height:.5em}"]
            }),
            __metadata("design:paramtypes", [RufSearchService, RufShellIntl, core.ChangeDetectorRef])
        ], RufMegamenuComponent);
        return RufMegamenuComponent;
    }());

    var RufSitemapComponent = /** @class */ (function () {
        function RufSitemapComponent(_elementRef) {
            this._elementRef = _elementRef;
            this.role = 'menubar';
            this.select = new core.EventEmitter();
            this.direction = 'row';
        }
        RufSitemapComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this.sitemapItems.length > 0) {
                this.addNewKeyboardNav();
            }
            this.sitemapItems.changes.subscribe(function (changes) {
                if (_this.sitemapItems.length > 0) {
                    _this.addNewKeyboardNav();
                }
            });
        };
        RufSitemapComponent.prototype.addNewKeyboardNav = function () {
            this._keyboardNav = new RufKeyboardNavigation();
            this._keyboardNav.setDirection(this.direction);
            this._keyboardNav.init(this._elementRef, this.sitemapItems);
            this._keyboardNav.addTabIndex(this.sitemapItems);
        };
        // emit the currently selected
        RufSitemapComponent.prototype.selectItem = function (sitemapItem) {
            this.select.emit(sitemapItem);
        };
        RufSitemapComponent.prototype.onKey = function (event, item) {
            this._keyboardNav.onKeyDown(event);
            switch (event.keyCode) {
                case RufKeyCodes.ENTER:
                case RufKeyCodes.SPACE:
                    this.selectItem(item);
                    break;
            }
        };
        RufSitemapComponent.prototype.uniqueItem = function (index, item) {
            return item.path;
        };
        __decorate([
            core.HostBinding('attr.role'),
            __metadata("design:type", Object)
        ], RufSitemapComponent.prototype, "role", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", rxjs.Observable)
        ], RufSitemapComponent.prototype, "items", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], RufSitemapComponent.prototype, "select", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufSitemapComponent.prototype, "direction", void 0);
        __decorate([
            core.ViewChildren(RufFocusableDirective),
            __metadata("design:type", core.QueryList)
        ], RufSitemapComponent.prototype, "sitemapItems", void 0);
        RufSitemapComponent = __decorate([
            core.Component({
                selector: 'ruf-sitemap',
                template: "<div class=\"ruf-sitemap-wrap\">\n  <div *ngFor=\"let parent of items | async; trackBy: uniqueItem \" class=\"ruf-sitemap-parent\">\n    <small *ngIf=\"parent.context\" class=\"ruf-sitemap-context\">{{parent.context}}\n      <span class=\"fis-icon-chevron-double\"></span>\n    </small>\n    <div class=\"ruf-title\">{{ parent.label }}</div><br>\n\n    <ul class=\"ruf-sitemap-children\">\n      <li *ngFor=\"let child of parent.children; trackBy: uniqueItem\" class=\"ruf-sitemap-child\">\n        <a (click)=\"selectItem(child);\" (keydown)=\"onKey($event, child)\" role=\"menuitem\" title=\"{{ child.label }}\" rufFocusable>{{ child.label }}</a>\n      </li>\n    </ul>\n  </div>\n</div>\n\n",
                encapsulation: core.ViewEncapsulation.None,
                providers: [],
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: ["ruf-sitemap{display:block;max-height:100%;overflow-y:auto;padding:20px;width:100%}ruf-sitemap .ruf-sitemap-wrap{display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1 1 auto;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-flow:row wrap}ruf-sitemap .fis-icon-chevron-double{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}ruf-sitemap .ruf-sitemap-context{display:block;padding-left:10px}ruf-sitemap .ruf-sitemap-parent{width:200px}ruf-sitemap .ruf-sitemap-parent .ruf-title{cursor:default;display:inline-block;padding:5px 10px;text-transform:uppercase;white-space:pre-wrap;word-wrap:break-word}ruf-sitemap .ruf-sitemap-parent ul{margin:4px 4px 16px 0;padding-left:25px}ruf-sitemap .ruf-sitemap-parent ul .ruf-title{list-style-type:none}ruf-sitemap .ruf-sitemap-parent ul li{padding:4px}ruf-sitemap .ruf-sitemap-parent ul li a{cursor:pointer}ruf-sitemap .ruf-sitemap-parent ul li a:hover{text-decoration:underline}ruf-sitemap::-webkit-scrollbar{width:.5em}ruf-sitemap::-webkit-scrollbar-button{height:.5em}"]
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], RufSitemapComponent);
        return RufSitemapComponent;
    }());

    var RufSitemapModule = /** @class */ (function () {
        function RufSitemapModule() {
        }
        RufSitemapModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule, RufUtilsModule],
                declarations: [RufSitemapComponent],
                exports: [RufSitemapComponent]
            })
        ], RufSitemapModule);
        return RufSitemapModule;
    }());

    var RufMegamenuModule = /** @class */ (function () {
        function RufMegamenuModule() {
        }
        RufMegamenuModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    RufToolbarModule,
                    RufSidemenuModule,
                    RufSitemapModule,
                    RufUtilsModule
                ],
                declarations: [
                    RufMegamenuComponent,
                    RufMegamenuSearchComponent
                ],
                exports: [
                    RufMegamenuComponent
                ],
                providers: []
            })
        ], RufMegamenuModule);
        return RufMegamenuModule;
    }());

    var RufMDIStrategy = /** @class */ (function () {
        function RufMDIStrategy(util) {
            this.util = util;
            this.handlers = {};
        }
        /**
         * Decides when the route should be stored
         * @param route the route that the user is currently on
         * @returns boolean indicating whether the route should or should not be stored
         */
        RufMDIStrategy.prototype.shouldDetach = function (route) {
            return true;
        };
        /**
         * Stores the complete route path and its component state (as ComponentRef) for later attachment
         * @param route This is stored for later comparison to requested routes, see `this.shouldAttach`
         * @param handle A DetachedRouteHandle which is later retrieved by this.retrieve to restore state
         */
        RufMDIStrategy.prototype.store = function (route, handle) {
            var path = this.util.getLeafNodePath(route);
            // path is '' when route has loadChildren.
            if (path) {
                if (route.component) {
                    this.handlers[path] = handle;
                }
                // route does not have component. this means it is a parent route like ruf/shell/banner or ruf/shell/layout.
                // In this case, previously stored leaf node handler should be re-stored.
                if (!route.component && handle) {
                    // This condition is when parent route is being stored but it's the child route whose reference needs to be stored instead.
                    // In this case, retrieve the component ref from RufRouterUtilService and create a new DetachedRouteHandle.
                    this.handlers[path] = {
                        componentRef: this.util.getComponentRef(path),
                        route: this.util.getLeafNode(handle['route'])
                    };
                }
            }
        };
        /**
         * Determines whether there is a stored route and, if yes, should it be rendered in place of requested route
         * @param route The route the user requested
         * @returns boolean indicating whether or not to render the stored route
         */
        RufMDIStrategy.prototype.shouldAttach = function (route) {
            var path = this.util.getLeafNodePath(route);
            return !!route.routeConfig && !!this.handlers[path];
        };
        /**
         * Finds the locally stored instance of the requested route and returns it if it exists
         * @param route New route the user has requested
         * @returns DetachedRouteHandle object which can be used to render the component
         */
        RufMDIStrategy.prototype.retrieve = function (route) {
            if (!route.routeConfig) {
                return null;
            }
            if (route.routeConfig.loadChildren) {
                return null;
            }
            return this.handlers[this.util.fullPath(route)];
        };
        /**
         * Determines whether or not the current route should be reused
         * @param future The route the user is navigating to as triggered by the router
         * @param curr The route the user is currently on
         * @returns boolean indicating true if the user intends to leave the current route
         */
        RufMDIStrategy.prototype.shouldReuseRoute = function (future, curr) {
            return ((future.routeConfig === curr.routeConfig) &&
                (JSON.stringify(future.params) === JSON.stringify(curr.params)));
        };
        /**
         *  Remove component reference from handlers.
         *  Destroy the route component
         *  @param path The key against which DetachedRouteHandle with component reference is stored for detached route
         */
        RufMDIStrategy.prototype.destroy = function (path) {
            if (this.handlers[path] && this.util.getComponentRef(path)) {
                this.util.getComponentRef(path).destroy();
                delete this.handlers[path];
            }
        };
        return RufMDIStrategy;
    }());

    var RufRouterUtilService = /** @class */ (function () {
        function RufRouterUtilService() {
            this._routeComp = {};
        }
        Object.defineProperty(RufRouterUtilService.prototype, "lastActivatedPath", {
            get: function () {
                return this._lastActivatedPath;
            },
            set: function (path) {
                this._lastActivatedPath = path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufRouterUtilService.prototype, "lastActivatedOutlet", {
            get: function () {
                return this._lastActivatedOutlet;
            },
            set: function (outlet) {
                this._lastActivatedOutlet = outlet;
            },
            enumerable: true,
            configurable: true
        });
        RufRouterUtilService.prototype.setComponentRef = function (path, componentRef) {
            this._routeComp[path] = componentRef;
        };
        RufRouterUtilService.prototype.getComponentRef = function (path) {
            return this._routeComp[path];
        };
        RufRouterUtilService.prototype.fullPath = function (snapshot) {
            var path = '';
            var rootElems = snapshot.pathFromRoot;
            rootElems.forEach(function (child) {
                var urlArray = child.url;
                urlArray.forEach(function (url) {
                    path += "/" + url.path;
                });
            });
            return path;
        };
        RufRouterUtilService.prototype.getLeafNodePath = function (route) {
            var path;
            // if (!route.routeConfig.loadChildren) {
            // If !route.component, this is a parent route. Return path of the leaf node in this case.
            if (!route.component) {
                var leafNode = this.getLeafNode(route);
                path = this.fullPath(leafNode);
            }
            else {
                path = this.fullPath(route);
            }
            // }
            return path;
        };
        RufRouterUtilService.prototype.getLeafNode = function (route) {
            if (!route.children || route.children.length === 0) {
                return route;
            }
            return this.getLeafNode(route.firstChild || route.children[0]);
        };
        RufRouterUtilService = __decorate([
            core.Injectable()
        ], RufRouterUtilService);
        return RufRouterUtilService;
    }());

    var RufRouterOutletDirective = /** @class */ (function (_super) {
        __extends(RufRouterOutletDirective, _super);
        function RufRouterOutletDirective(rufParentContexts, rufLocation, rufResolver, rufName, rufChangeDetector, util) {
            var _this = _super.call(this, rufParentContexts, rufLocation, rufResolver, rufName, rufChangeDetector) || this;
            _this.rufParentContexts = rufParentContexts;
            _this.rufLocation = rufLocation;
            _this.rufResolver = rufResolver;
            _this.rufName = rufName;
            _this.rufChangeDetector = rufChangeDetector;
            _this.util = util;
            _this.rufName = rufName || router.PRIMARY_OUTLET;
            return _this;
        }
        RufRouterOutletDirective.prototype.detach = function () {
            var componentRef = _super.prototype.detach.call(this);
            var lastActivatedOutlet = this.util.lastActivatedOutlet;
            // Detach child routes when a parent route like /banner or /layout is being detached.
            if (lastActivatedOutlet && lastActivatedOutlet.isActivated) {
                var lastCompRef = lastActivatedOutlet.detach();
                this.util.setComponentRef(this.util.lastActivatedPath, lastCompRef);
            }
            else {
                this.util.setComponentRef(this.util.lastActivatedPath, componentRef);
            }
            return componentRef;
        };
        RufRouterOutletDirective.prototype.activateWith = function (activatedRoute, resolver) {
            this.storePreviousRoute(activatedRoute);
            _super.prototype.activateWith.call(this, activatedRoute, resolver);
        };
        RufRouterOutletDirective.prototype.attach = function (ref, activatedRoute) {
            this.storePreviousRoute(activatedRoute);
            _super.prototype.attach.call(this, ref, activatedRoute);
        };
        RufRouterOutletDirective.prototype.storePreviousRoute = function (activatedRoute) {
            this.util.lastActivatedPath = this.util.fullPath(activatedRoute.snapshot);
            if (!activatedRoute.children || activatedRoute.children.length === 0) {
                // Store router outlet only in case of leaf routes. This will be used when detaching parent routes.
                this.util.lastActivatedOutlet = this.rufParentContexts.getContext(this.rufName).outlet;
            }
        };
        RufRouterOutletDirective = __decorate([
            core.Directive({
                selector: 'ruf-router-outlet' // tslint:disable-line
            }),
            __param(3, core.Attribute('name')),
            __metadata("design:paramtypes", [router.ChildrenOutletContexts,
                core.ViewContainerRef,
                core.ComponentFactoryResolver, String, core.ChangeDetectorRef,
                RufRouterUtilService])
        ], RufRouterOutletDirective);
        return RufRouterOutletDirective;
    }(router.RouterOutlet));

    var RufRouterModule = /** @class */ (function () {
        function RufRouterModule() {
        }
        RufRouterModule_1 = RufRouterModule;
        RufRouterModule.forRoot = function () {
            return {
                ngModule: RufRouterModule_1,
                providers: [RufRouterUtilService]
            };
        };
        var RufRouterModule_1;
        RufRouterModule = RufRouterModule_1 = __decorate([
            core.NgModule({ declarations: [RufRouterOutletDirective], imports: [common.CommonModule], exports: [RufRouterOutletDirective] })
        ], RufRouterModule);
        return RufRouterModule;
    }());

    var RufRouteReuseStrategy = /** @class */ (function (_super) {
        __extends(RufRouteReuseStrategy, _super);
        function RufRouteReuseStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return RufRouteReuseStrategy;
    }(router.RouteReuseStrategy));

    var RufCardControlsDirective = /** @class */ (function () {
        function RufCardControlsDirective() {
        }
        RufCardControlsDirective = __decorate([
            core.Directive({
                selector: 'ruf-card-controls' // tslint:disable-line
            })
        ], RufCardControlsDirective);
        return RufCardControlsDirective;
    }());
    var RufCardSubtitleDirective = /** @class */ (function () {
        function RufCardSubtitleDirective() {
        }
        RufCardSubtitleDirective = __decorate([
            core.Directive({
                selector: 'ruf-card-subtitle' // tslint:disable-line
            })
        ], RufCardSubtitleDirective);
        return RufCardSubtitleDirective;
    }());
    var RufCardComponent = /** @class */ (function () {
        function RufCardComponent(_intl, changeDetectorRef) {
            this._intl = _intl;
            this.expandable = false;
            this.expanded = true;
            this._intlChanges = _intl.changes.subscribe(function () { return changeDetectorRef.markForCheck(); });
        }
        Object.defineProperty(RufCardComponent.prototype, "expandLabel", {
            get: function () {
                return this._expandLabel || this._intl.card.aria.expandLabel;
            },
            set: function (value) {
                this._expandLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufCardComponent.prototype, "collapseLabel", {
            get: function () {
                return this._collapseLabel || this._intl.card.aria.collapseLabel;
            },
            set: function (value) {
                this._collapseLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufCardComponent.prototype, "toggleLabel", {
            get: function () {
                return this.expanded ? this.collapseLabel : this.expandLabel;
            },
            enumerable: true,
            configurable: true
        });
        RufCardComponent.prototype.ngOnDestroy = function () {
            this._intlChanges.unsubscribe();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufCardComponent.prototype, "title", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufCardComponent.prototype, "expandable", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufCardComponent.prototype, "expanded", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufCardComponent.prototype, "expandLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufCardComponent.prototype, "collapseLabel", null);
        RufCardComponent = __decorate([
            core.Component({
                selector: 'ruf-card',
                template: "<mat-card class=\"ruf-card\" rufId=\"card_panel\" [ngClass]=\"{'ruf-card-collapsed': !expanded, 'ruf-card-expanded': expanded}\">\n  <mat-card-header class=\"ruf-card-header\" rufId=\"card_header\">\n    <button type=\"button\" mat-icon-button *ngIf=\"expandable\" (click)=\"expanded = !expanded\" class=\"ruf-card-expand\" [attr.aria-label]=\"toggleLabel\">\n      <mat-icon fisIcon=\"chevron\"></mat-icon>\n    </button>\n    <mat-card-title-group class=\"ruf-card-titlegroup\">\n      <mat-card-title class=\"ruf-card-title\" (click)=\"expandable && expanded = !expanded\">{{title}}</mat-card-title>\n      <mat-card-subtitle class=\"ruf-card-subtitle\">\n        <ng-content select=\"ruf-card-subtitle\"></ng-content>\n      </mat-card-subtitle>\n    </mat-card-title-group>\n    <div class=\"ruf-card-filler\"></div>\n    <div class=\"ruf-card-controls\">\n      <ng-content select=\"ruf-card-controls\"></ng-content>\n    </div>\n  </mat-card-header>\n  <mat-card-content class=\"ruf-card-content\" rufId=\"card_content\" [@expanded]=\"'' + expanded\">\n    <ng-content></ng-content>\n    <ng-content select=\"ruf-card-action-bar\"></ng-content>\n  </mat-card-content>\n</mat-card>\n",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('expanded', [
                        animations.state('false', animations.style({
                            height: 0,
                            visibility: 'hidden'
                        })),
                        animations.state('true', animations.style({
                            height: '*',
                            visibility: 'visible'
                        })),
                        animations.transition('false => true', animations.animate('300ms ease-in-out')),
                        animations.transition('true => false', animations.animate('300ms ease-in-out'))
                    ])
                ],
                styles: ["ruf-card{display:-webkit-box;display:flex}.ruf-card.mat-card{border-radius:2px;margin:0;padding:0}.ruf-card.mat-card .ruf-card-header{min-height:2.5rem;padding-left:12px}.ruf-card.mat-card .ruf-card-expand{cursor:pointer;height:30px;line-height:30px;margin:7px 5px 5px -5px;-webkit-transform:rotate(180deg);transform:rotate(180deg);-webkit-transition:-webkit-transform .3s ease-out;transition:transform .3s ease-out;transition:transform .3s ease-out,-webkit-transform .3s ease-out;width:30px}.ruf-card.mat-card.ruf-card-collapsed .ruf-card-expand{-webkit-transform:rotate(0);transform:rotate(0)}.ruf-card.mat-card .mat-select-underline{display:none}.ruf-card.mat-card .ruf-card-content{overflow:hidden}.ruf-card.mat-card .mat-card-header-text{margin:0}.ruf-card.mat-card .ruf-card-titlegroup{-ms-grid-row-align:center;align-self:center;margin:0;padding:5px 5px 5px 0}.ruf-card.mat-card .ruf-card-subtitle,.ruf-card.mat-card .ruf-card-title{margin-bottom:0}.ruf-card.mat-card .ruf-card-metric,.ruf-card.mat-card .ruf-card-metric-description{padding-right:10px;text-align:right}.ruf-card.mat-card .ruf-card-subtitle:not(:first-child),.ruf-card.mat-card .ruf-card-title:not(:first-child){margin-top:0}.ruf-card.mat-card .ruf-card-filler{-webkit-box-flex:1;flex:1 1 auto}.ruf-card.mat-card .ruf-card-controls{-ms-grid-row-align:center;align-self:center;-webkit-box-flex:0;flex:0 0 auto;margin-left:20px;padding:5px}"]
            }),
            __metadata("design:paramtypes", [RufShellIntl, core.ChangeDetectorRef])
        ], RufCardComponent);
        return RufCardComponent;
    }());

    var RufCardActionBarComponent = /** @class */ (function () {
        function RufCardActionBarComponent() {
        }
        RufCardActionBarComponent = __decorate([
            core.Component({
                selector: 'ruf-card-action-bar',
                template: "<div class=\"ruf-card-action-bar\">\n  <div class=\"ruf-card-goto-links\">\n    <ng-content></ng-content>\n  </div>\n  <div class=\"ruf-card-filler\"></div>\n  <div class=\"ruf-card-action-icons\">\n    <ng-content select=\"mat-icon, [mat-icon-button]\"></ng-content>\n  </div>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None,
                styles: ["ruf-card .ruf-card-action-bar{display:-webkit-box;display:flex;flex-wrap:wrap}ruf-card .ruf-card-action-bar .ruf-card-action-icons{-webkit-box-flex:0;flex:0 0 auto;margin-left:1.25rem;padding:.3125rem}ruf-card .ruf-card-action-bar .ruf-card-goto-links{-webkit-box-flex:1;flex:1 1 auto;padding:.3125rem}"]
            })
        ], RufCardActionBarComponent);
        return RufCardActionBarComponent;
    }());

    var RufCardModule = /** @class */ (function () {
        function RufCardModule() {
        }
        RufCardModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    card.MatCardModule,
                    RufUniqueIdModule,
                    icon.MatIconModule,
                    button.MatButtonModule,
                    RufIconModule,
                    RufUtilsModule
                ],
                declarations: [RufCardComponent, RufCardActionBarComponent, RufCardControlsDirective, RufCardSubtitleDirective],
                exports: [RufCardComponent, RufCardActionBarComponent, RufCardControlsDirective, RufCardSubtitleDirective]
            })
        ], RufCardModule);
        return RufCardModule;
    }());

    var RufStatusbarComponent = /** @class */ (function () {
        function RufStatusbarComponent(_intl, changeDetectorRef) {
            this._intl = _intl;
            this.color = 'accent';
            this.closeable = true;
            this.expandable = false;
            this.border = true;
            this.isSubtitleEmpty = false;
            this.visible = true;
            this.dismiss = new core.EventEmitter();
            this._intlChanges = _intl.changes.subscribe(function () { return changeDetectorRef.markForCheck(); });
        }
        Object.defineProperty(RufStatusbarComponent.prototype, "closeAriaLabel", {
            get: function () {
                return this._closeAriaLabel || this._intl.statusbar.aria.closeIconLabel;
            },
            set: function (value) {
                this._closeAriaLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufStatusbarComponent.prototype, "expandAriaLabel", {
            get: function () {
                return this._expandAriaLabel || this._intl.statusbar.aria.expandIconLabel;
            },
            set: function (value) {
                this._expandAriaLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufStatusbarComponent.prototype, "_class", {
            get: function () {
                var colorClass = this.color ? "ruf-" + this.color : 'ruf-accent';
                var borderClass = !this.border ? "ruf-statusbar-noborder" : '';
                return colorClass + " " + borderClass;
            },
            enumerable: true,
            configurable: true
        });
        RufStatusbarComponent.prototype.onDismiss = function ($event) {
            this.dismiss.emit();
        };
        RufStatusbarComponent.prototype.ngOnDestroy = function () {
            this._intlChanges.unsubscribe();
        };
        RufStatusbarComponent.prototype.ngAfterContentInit = function () {
            this.isSubtitleEmpty = this.subtitleContent.nativeElement.innerHTML.trim() === '';
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufStatusbarComponent.prototype, "title", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufStatusbarComponent.prototype, "color", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufStatusbarComponent.prototype, "closeable", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufStatusbarComponent.prototype, "expandable", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufStatusbarComponent.prototype, "icon", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufStatusbarComponent.prototype, "border", void 0);
        __decorate([
            core.ViewChild('subtitleRef', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], RufStatusbarComponent.prototype, "subtitleContent", void 0);
        __decorate([
            core.HostBinding('@animation'),
            core.Input(),
            __metadata("design:type", Object)
        ], RufStatusbarComponent.prototype, "visible", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufStatusbarComponent.prototype, "closeAriaLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufStatusbarComponent.prototype, "expandAriaLabel", null);
        __decorate([
            core.HostBinding('class'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], RufStatusbarComponent.prototype, "_class", null);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], RufStatusbarComponent.prototype, "dismiss", void 0);
        RufStatusbarComponent = __decorate([
            core.Component({
                selector: 'ruf-statusbar',
                template: "<div class=\"ruf-statusbar-wrapper\" rufId=\"statubar\" role=\"alert\">\n  <div class=\"ruf-statusbar-header\">\n    <ng-content select=\"ruf-statusbar-icon\"></ng-content>\n    <div *ngIf=\"icon\" class=\"ruf-statusbar-icon\" rufId=\"ruf-statusbar-default-icon\">\n      <mat-icon rufId [rufIcon]=\"icon\" rufIconStyle='md' [color]=\"color\"></mat-icon>\n    </div>\n    <div class=\"ruf-statusbar-content\" [ngClass]=\"{'no-header-content': !title && isSubtitleEmpty}\">\n      <div class=\"ruf-statusbar-header-text\">\n        <div *ngIf=\"title\" class=\"ruf-statusbar-title\" rufId=\"statubar_title\">{{title}}</div>\n        <div class=\"ruf-statusbar-subtitle\" #subtitleRef rufId=\"statusbar-subtitle\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n      <div class=\"ruf-statusbar-detail\" [@expanded]=\"'' + (!expandable || trigger.value)\" rufId=\"statubar_detail\">\n        <ng-content select=\"ruf-statusbar-description, .ruf-statusbar-description\"></ng-content>\n      </div>\n    </div>\n    <button type=\"button\" [hidden]=\"!expandable\" rufToggleChevron fisStyle mat-icon-button class=\"ruf-statusbar-expand\" #trigger=\"rufToggle\"\n      [attr.aria-label]=\"expandAriaLabel\" rufId=\"statubar_expand\">\n    </button>\n\n    <button type=\"button\" *ngIf=\"closeable\" fisStyle mat-icon-button class=\"ruf-statusbar-close\" (click)=\"onDismiss($event)\" [attr.aria-label]=\"closeAriaLabel\"\n      rufId=\"statubar_close\">\n      <mat-icon rufIconStyle=\"sm\" fisIcon=\"close\"></mat-icon>\n    </button>\n  </div>\n</div>\n",
                animations: [animations.trigger('animation', [
                        animations.state('0', animations.style({ height: '0', 'min-height': '0', visibility: 'hidden' })),
                        animations.state('1', animations.style({ height: '*', 'min-height': '*', visibility: 'visible' })),
                        animations.transition('0 => 1', animations.animate('250ms ease-in')),
                        animations.transition('1 => 0', animations.animate('250ms ease-out'))
                    ]), animations.trigger('expanded', [
                        animations.state('false', animations.style({ height: 0, visibility: 'hidden' })),
                        animations.state('true', animations.style({ height: '*', visibility: 'visible' })),
                        animations.transition('false => true', animations.animate('300ms ease-in-out')),
                        animations.transition('true => false', animations.animate('300ms ease-in-out'))
                    ])],
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: ["ruf-statusbar{border-bottom-right-radius:.1875rem;border-left:.375rem solid;border-top-right-radius:.1875rem;display:block;min-height:2.5rem;overflow:hidden;padding:0 0 0 1rem;position:relative;-webkit-transition:border-left-color .2s;transition:border-left-color .2s}ruf-statusbar .ruf-statusbar-wrapper{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;-webkit-box-pack:center;justify-content:center;margin:auto;min-height:2.5rem}ruf-statusbar.ruf-statusbar-noborder{border-left:none}ruf-statusbar .ruf-statusbar-header{display:-webkit-box;display:flex;padding:2px}ruf-statusbar .ruf-statusbar-header .ruf-statusbar-icon{flex-shrink:0;margin-right:10px;overflow:hidden;padding-top:.4375rem;text-align:center}ruf-statusbar .ruf-statusbar-title{flex-shrink:1;margin-right:1rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}ruf-statusbar .ruf-statusbar-subtitle{-webkit-box-flex:1;flex-grow:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}ruf-statusbar .ruf-statusbar-close{flex-shrink:0;height:2.125rem!important;margin-left:auto;margin-right:.1875rem;min-width:auto}ruf-statusbar .ruf-statusbar-expand{flex-shrink:0;font-size:18px;height:1.25rem;margin-left:auto;min-width:auto}ruf-statusbar .ruf-statusbar-detail{display:-webkit-box;display:flex}ruf-statusbar ruf-statusbar-description{overflow-wrap:break-word;width:100%}ruf-statusbar ruf-statusbar-description .ruf-statusbar-description{margin-bottom:.5em;margin-right:.5em}ruf-statusbar ruf-statusbar-description .ruf-statusbar-description[style*=hidden]{margin-bottom:0}ruf-statusbar .ruf-statusbar-expand:after{position:inherit}ruf-statusbar .ruf-toggle.ruf-toggle-chevron{height:2.125rem;margin:0 .125rem .125rem;padding-right:.625rem!important}ruf-statusbar .ruf-toggle.ruf-toggle-chevron:after{margin-right:0;padding-left:0;padding-right:0}ruf-statusbar .ruf-statusbar-header-text{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;padding:.125rem 0}ruf-statusbar .ruf-statusbar-content{-webkit-box-flex:1;flex-grow:1;min-height:34px;min-width:0;padding-top:.4375rem;width:100%}ruf-statusbar .no-header-content{padding-top:.25rem}"]
            }),
            __metadata("design:paramtypes", [RufShellIntl, core.ChangeDetectorRef])
        ], RufStatusbarComponent);
        return RufStatusbarComponent;
    }());
    var RufStatusbarIconComponent = /** @class */ (function () {
        function RufStatusbarIconComponent() {
        }
        RufStatusbarIconComponent = __decorate([
            core.Component({
                selector: 'ruf-statusbar-icon',
                encapsulation: core.ViewEncapsulation.None,
                template: "\n    <div class=\"ruf-statusbar-icon\"><ng-content></ng-content></div>\n  "
            })
        ], RufStatusbarIconComponent);
        return RufStatusbarIconComponent;
    }());
    var RufStatusbarDescriptionComponent = /** @class */ (function () {
        function RufStatusbarDescriptionComponent() {
        }
        RufStatusbarDescriptionComponent = __decorate([
            core.Component({
                selector: 'ruf-statusbar-description',
                encapsulation: core.ViewEncapsulation.None,
                template: "\n   <div class=\"ruf-statusbar-description\"><ng-content></ng-content></div>\n  "
            })
        ], RufStatusbarDescriptionComponent);
        return RufStatusbarDescriptionComponent;
    }());

    var RufStatusbarModule = /** @class */ (function () {
        function RufStatusbarModule() {
        }
        RufStatusbarModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    RufUniqueIdModule,
                    icon.MatIconModule,
                    button.MatButtonModule,
                    RufIconModule,
                    RufUtilsModule,
                    RufToggleModule
                ],
                declarations: [RufStatusbarComponent, RufStatusbarIconComponent, RufStatusbarDescriptionComponent],
                exports: [RufStatusbarComponent, RufStatusbarIconComponent, RufStatusbarDescriptionComponent]
            })
        ], RufStatusbarModule);
        return RufStatusbarModule;
    }());


    (function (RufDropdownType) {
        RufDropdownType["PopoverMenu"] = "popover-menu";
        RufDropdownType["ContextMenu"] = "context-menu";
        RufDropdownType["Dropdown"] = "dropdown";
    })(exports.RufDropdownType || (exports.RufDropdownType = {}));
    var RufDropdownPanelComponent = /** @class */ (function () {
        function RufDropdownPanelComponent(_overlay, _viewContainerRef) {
            this._overlay = _overlay;
            this._viewContainerRef = _viewContainerRef;
            this.hasBackdrop = true;
            this.openedChange = new core.EventEmitter();
            this.type = exports.RufDropdownType.Dropdown;
            this.xPosition = 'center';
            this.yPosition = 'bottom';
            this.className = 'ruf-dropdown-panel-container';
            this.toggle = new core.EventEmitter();
        }
        RufDropdownPanelComponent.prototype.ngOnChanges = function (changes) {
            if (changes &&
                changes.hasBackdrop &&
                changes.hasBackdrop.previousValue !== changes.hasBackdrop.currentValue) {
                // when value is changes for hasBackdrop set value null for overlay
                // so that it will create new overlay with updated backdrop value
                if (this._overlayRef) {
                    this._overlayRef.detach();
                    this._overlayRef = null;
                }
            }
        };
        RufDropdownPanelComponent.prototype.open = function () {
            var _this = this;
            var origin = this._getOrigin();
            var overlay = this._getOverlayPosition();
            if (!this._overlayRef) {
                var positionStrategy = void 0;
                positionStrategy = this._overlay.position()
                    .flexibleConnectedTo(this.origin.elementRef)
                    .withPositions([
                    __assign({}, origin.main, overlay.main),
                    __assign({}, origin.fallback, overlay.fallback)
                ]);
                this.onPositionChanged({
                    connectionPair: {
                        overlayX: overlay.main.overlayX,
                        overlayY: overlay.main.overlayY
                    }
                });
                positionStrategy.positionChanges.subscribe(function (change) {
                    _this.onPositionChanged(change);
                });
                this._overlayRef = this._overlay.create({
                    hasBackdrop: this.hasBackdrop,
                    backdropClass: 'ruf-dropdown-panel-wrapper',
                    positionStrategy: positionStrategy
                });
                this._overlayRef.backdropClick().subscribe(function () { return _this.close(); });
                this._portal = new portal.TemplatePortal(this.content, this._viewContainerRef);
            }
            if (!this._overlayRef.hasAttached()) {
                this._overlayRef.attach(this._portal);
                this.opened = true;
                this.toggle.emit(true);
            }
            else {
                this.close();
                this.toggle.emit(false);
            }
        };
        RufDropdownPanelComponent.prototype._getOrigin = function () {
            var originPosition;
            originPosition = this._getPositionStrategy(this._getOriginValues(), this._getOverlayPositionValues()).originPosition;
            var _a = this._invertPosition(originPosition.originX, originPosition.originY), x = _a.x, y = _a.y;
            if (this.type === exports.RufDropdownType.PopoverMenu || this.type === exports.RufDropdownType.ContextMenu) {
                return {
                    main: originPosition,
                    fallback: { originX: x, originY: y }
                };
            }
            else {
                return {
                    main: { originX: 'start', originY: 'bottom' },
                    fallback: { originX: 'end', originY: 'top' }
                };
            }
        };
        RufDropdownPanelComponent.prototype._getOverlayPosition = function () {
            var XPosition = this.xPosition;
            var YPosition = this.yPosition;
            var overlayPosition;
            overlayPosition = this._getPositionStrategy(this._getOriginValues(), this._getOverlayPositionValues()).overlayPosition;
            var _a = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY), x = _a.x, y = _a.y;
            if (this.type === exports.RufDropdownType.PopoverMenu || this.type === exports.RufDropdownType.ContextMenu) {
                return {
                    main: overlayPosition,
                    fallback: { overlayX: x, overlayY: y }
                };
            }
            else {
                return {
                    main: { overlayX: 'start', overlayY: 'top' },
                    fallback: { overlayX: 'end', overlayY: 'bottom' }
                };
            }
        };
        RufDropdownPanelComponent.prototype._getOriginValues = function () {
            var xCenterYBottom = { originX: 'center', originY: 'bottom' };
            var xCenterYTop = { originX: 'center', originY: 'top' };
            var xStartYBottom = { originX: 'start', originY: 'bottom' };
            var xStartYTop = { originX: 'start', originY: 'top' };
            var xStartYCenter = { originX: 'start', originY: 'center' };
            var xEndYBottom = { originX: 'end', originY: 'bottom' };
            var xEndYTop = { originX: 'end', originY: 'top' };
            var xEndYCenter = { originX: 'end', originY: 'center' };
            return {
                xCenterYBottom: xCenterYBottom,
                xCenterYTop: xCenterYTop,
                xStartYBottom: xStartYBottom,
                xStartYTop: xStartYTop,
                xStartYCenter: xStartYCenter,
                xEndYBottom: xEndYBottom,
                xEndYTop: xEndYTop,
                xEndYCenter: xEndYCenter
            };
        };
        RufDropdownPanelComponent.prototype._getOverlayPositionValues = function () {
            var xCenterYTop = { overlayX: 'center', overlayY: 'top' };
            var xCenterYBottom = { overlayX: 'center', overlayY: 'bottom' };
            var xStartYTop = { overlayX: 'start', overlayY: 'top' };
            var xStartYBottom = { overlayX: 'start', overlayY: 'bottom' };
            var xStartYCenter = { overlayX: 'start', overlayY: 'center' };
            var xEndYTop = { overlayX: 'end', overlayY: 'top' };
            var xEndYBottom = { overlayX: 'end', overlayY: 'bottom' };
            var xEndYCenter = { overlayX: 'end', overlayY: 'center' };
            return {
                xCenterYTop: xCenterYTop,
                xCenterYBottom: xCenterYBottom,
                xStartYTop: xStartYTop,
                xStartYBottom: xStartYBottom,
                xStartYCenter: xStartYCenter,
                xEndYTop: xEndYTop,
                xEndYBottom: xEndYBottom,
                xEndYCenter: xEndYCenter
            };
        };
        RufDropdownPanelComponent.prototype._getPositionStrategy = function (origin, overlay) {
            var originPosition = origin.xCenterYBottom;
            var overlayPosition = overlay.xCenterYTop;
            if (this.xPosition === 'start') {
                if (this.yPosition === 'top') {
                    originPosition = origin.xStartYTop;
                    overlayPosition = overlay.xStartYBottom;
                }
                else if (this.yPosition === 'center' && this.type === exports.RufDropdownType.PopoverMenu) {
                    originPosition = origin.xStartYCenter;
                    overlayPosition = overlay.xEndYCenter;
                }
                else if (this.yPosition === 'bottom' || (this.yPosition === 'center' && this.type === exports.RufDropdownType.ContextMenu)) {
                    originPosition = origin.xStartYBottom;
                    overlayPosition = overlay.xStartYTop;
                }
            }
            else if (this.xPosition === 'end') {
                if (this.yPosition === 'top') {
                    originPosition = origin.xEndYTop;
                    overlayPosition = overlay.xEndYBottom;
                }
                else if (this.yPosition === 'center' && this.type === exports.RufDropdownType.PopoverMenu) {
                    originPosition = origin.xEndYCenter;
                    overlayPosition = overlay.xStartYCenter;
                }
                else if (this.yPosition === 'bottom' || (this.yPosition === 'center' && this.type === exports.RufDropdownType.ContextMenu)) {
                    originPosition = origin.xEndYBottom;
                    overlayPosition = overlay.xEndYTop;
                }
            }
            else if (this.xPosition === 'center') {
                originPosition = this.yPosition === 'top' ? origin.xCenterYTop : origin.xCenterYBottom;
                overlayPosition = this.yPosition === 'top' ? overlay.xCenterYBottom : overlay.xCenterYTop;
            }
            return {
                originPosition: originPosition,
                overlayPosition: overlayPosition
            };
        };
        RufDropdownPanelComponent.prototype._invertPosition = function (x, y) {
            if (x === 'start') {
                x = 'end';
            }
            else if (x === 'end') {
                x = 'start';
            }
            if (y === 'top') {
                y = 'bottom';
            }
            else if (y === 'bottom') {
                y = 'top';
            }
            return { x: x, y: y };
        };
        RufDropdownPanelComponent.prototype.onPositionChanged = function ($event) {
            if (this.type === exports.RufDropdownType.PopoverMenu || this.type === exports.RufDropdownType.ContextMenu) {
                if ($event.connectionPair.overlayY === 'top') {
                    if ($event.connectionPair.overlayX === 'center') {
                        this.className = 'ruf-dropdown-panel-container ruf-popover-menu center-arrow-up';
                    }
                    else if ($event.connectionPair.overlayX === 'start') {
                        this.className = 'ruf-dropdown-panel-container ruf-popover-menu left-arrow-up';
                    }
                    else {
                        this.className = 'ruf-dropdown-panel-container ruf-popover-menu right-arrow-up';
                    }
                }
                else if ($event.connectionPair.overlayY === 'center') {
                    if ($event.connectionPair.overlayX === 'start') {
                        this.className = 'ruf-dropdown-panel-container ruf-popover-menu right-arrow-center';
                    }
                    else {
                        this.className = 'ruf-dropdown-panel-container ruf-popover-menu left-arrow-center';
                    }
                }
                else {
                    if ($event.connectionPair.overlayX === 'center') {
                        this.className = 'ruf-dropdown-panel-container ruf-popover-menu center-arrow-down';
                    }
                    else if ($event.connectionPair.overlayX === 'start') {
                        this.className = 'ruf-dropdown-panel-container ruf-popover-menu left-arrow-down';
                    }
                    else {
                        this.className = 'ruf-dropdown-panel-container ruf-popover-menu right-arrow-down';
                    }
                }
            }
            else if (this.type === exports.RufDropdownType.Dropdown) {
                this.className = 'ruf-dropdown-panel-container';
            }
        };
        RufDropdownPanelComponent.prototype.close = function () {
            if (this.opened) {
                this.opened = false;
                this._overlayRef.detach();
                this.openedChange.emit(this.opened);
            }
        };
        RufDropdownPanelComponent.prototype.hasPopup = function () {
            return true;
        };
        RufDropdownPanelComponent.prototype.handleKeydown = function (event) {
            switch (event.keyCode) {
                case keycodes.SPACE:
                case keycodes.ENTER:
                    this.open();
                    event.preventDefault();
                    event.stopPropagation();
                    this.toggle.emit(true);
                    break;
                case keycodes.ESCAPE:
                    this.close();
                    this.toggle.emit(false);
                    event.stopPropagation();
                    break;
                default:
            }
        };
        RufDropdownPanelComponent.prototype.handleClick = function (event) {
            this.open();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", overlay.CdkOverlayOrigin)
        ], RufDropdownPanelComponent.prototype, "origin", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RufDropdownPanelComponent.prototype, "opened", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufDropdownPanelComponent.prototype, "hasBackdrop", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], RufDropdownPanelComponent.prototype, "openedChange", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufDropdownPanelComponent.prototype, "type", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufDropdownPanelComponent.prototype, "xPosition", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufDropdownPanelComponent.prototype, "yPosition", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RufDropdownPanelComponent.prototype, "closeIcon", void 0);
        __decorate([
            core.ViewChild(core.TemplateRef, { static: false }),
            __metadata("design:type", core.TemplateRef)
        ], RufDropdownPanelComponent.prototype, "content", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], RufDropdownPanelComponent.prototype, "toggle", void 0);
        __decorate([
            core.HostListener('click', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], RufDropdownPanelComponent.prototype, "handleClick", null);
        RufDropdownPanelComponent = __decorate([
            core.Component({
                selector: 'ruf-dropdown-panel',
                template: "<ng-template>\n <div [ngClass]=\"className\">\n      <div *ngIf=\"closeIcon\">\n        <button type=\"button\" mat-icon-button class=\"dropdown-panel-close-icon\" (keydown.enter)=\"close()\" (keydown.space)=\"close()\" (click)=\"close()\" rufIconButton>\n          <mat-icon rufIconStyle=\"sm\" rufId fisIcon=\"close\"></mat-icon>\n        </button>\n        <br>\n      </div>\n      <div [ngClass]=\"{'dropdown-panel-content': closeIcon}\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n </ng-template>\n",
                encapsulation: core.ViewEncapsulation.None,
                styles: [".center-arrow-down:after,.center-arrow-down:before,.center-arrow-up:after,.center-arrow-up:before,.left-arrow-center:after,.left-arrow-center:before,.left-arrow-down:after,.left-arrow-down:before,.left-arrow-up:after,.left-arrow-up:before,.right-arrow-center:after,.right-arrow-center:before,.right-arrow-down:after,.right-arrow-down:before,.right-arrow-up:after,.right-arrow-up:before{border-style:solid;content:'';height:0;position:absolute;width:0;z-index:9999}.left-arrow-up{margin-top:.625rem;position:relative}.left-arrow-up:after,.left-arrow-up:before{bottom:100%;right:91%}.left-arrow-up:after{border-width:.625rem;margin-right:-.625rem}.left-arrow-up:before{border-width:.75rem;margin-right:-.75rem}.left-arrow-center{margin-right:.625rem;position:relative}.left-arrow-center:after,.left-arrow-center:before{bottom:50%;left:100%}.left-arrow-center:after{border-width:.625rem;margin-bottom:-.625rem}.left-arrow-center:before{border-width:.75rem;margin-bottom:-.75rem}.left-arrow-down{margin-bottom:.625rem;position:relative}.left-arrow-down:after,.left-arrow-down:before{right:91%;top:100%}.left-arrow-down:after{border-width:.625rem;margin-right:-.625rem}.left-arrow-down:before{border-width:.75rem;margin-right:-.75rem}.right-arrow-up{margin-top:.625rem;position:relative}.right-arrow-up:after,.right-arrow-up:before{bottom:100%;right:9%}.right-arrow-up:after{border-width:.625rem;margin-right:-.625rem}.right-arrow-up:before{border-width:.75rem;margin-right:-.75rem}.right-arrow-center{margin-left:.625rem;position:relative}.right-arrow-center:after,.right-arrow-center:before{right:100%;top:50%}.right-arrow-center:after{border-width:.625rem;margin-top:-.625rem}.right-arrow-center:before{border-width:.75rem;margin-top:-.75rem}.right-arrow-down{margin-bottom:.5rem;position:relative}.right-arrow-down:after,.right-arrow-down:before{right:9%;top:100%}.right-arrow-down:after{border-width:.625rem;margin-right:-.625rem}.right-arrow-down:before{border-width:.75rem;margin-right:-.75rem}.center-arrow-up{margin-top:.625rem;position:relative}.center-arrow-up:after,.center-arrow-up:before{bottom:100%;right:50%}.center-arrow-up:after{border-width:.625rem;margin-right:-.625rem}.center-arrow-up:before{border-width:.75rem;margin-right:-.75rem}.center-arrow-down{margin-bottom:.625rem;position:relative}.center-arrow-down:after,.center-arrow-down:before{left:50%;top:100%}.center-arrow-down:after{border-width:.625rem;margin-left:-.625rem}.center-arrow-down:before{border-width:.75rem;margin-left:-.75rem}.dropdown-panel-close-icon{float:right;opacity:.2}.dropdown-panel-close-icon:hover{cursor:pointer}.dropdown-panel-content{margin-right:1.25rem;margin-top:.5rem}.ruf-popover-menu{border-radius:.1875rem;border-style:solid;border-width:.0625rem}"]
            }),
            __metadata("design:paramtypes", [overlay.Overlay,
                core.ViewContainerRef])
        ], RufDropdownPanelComponent);
        return RufDropdownPanelComponent;
    }());

    var RufDropdownPanelModule = /** @class */ (function () {
        function RufDropdownPanelModule() {
        }
        RufDropdownPanelModule = __decorate([
            core.NgModule({
                imports: [common.CommonModule, overlay.OverlayModule, RufUniqueIdModule, RufIconModule, RufTriggerModule, button.MatButtonModule],
                declarations: [RufDropdownPanelComponent],
                exports: [RufDropdownPanelComponent]
            })
        ], RufDropdownPanelModule);
        return RufDropdownPanelModule;
    }());

    var RufEllipsisComponent = /** @class */ (function () {
        function RufEllipsisComponent(_intl, changeDetectorRef) {
            var _this = this;
            this._intl = _intl;
            this.changeDetectorRef = changeDetectorRef;
            this.showReadMore$ = new rxjs.BehaviorSubject(false);
            this.lines = 5;
            this.lineHeight = 1;
            this.expand = new core.EventEmitter();
            this._intlChanges = _intl.changes.subscribe(function () { return _this.changeDetectorRef.markForCheck(); });
        }
        Object.defineProperty(RufEllipsisComponent.prototype, "label", {
            get: function () {
                return this._label || this._intl.ellipsis.label || '...';
            },
            set: function (value) {
                this._label = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufEllipsisComponent.prototype, "ariaLabel", {
            get: function () {
                return this._ariaLabel || this._intl.ellipsis.aria.label;
            },
            set: function (value) {
                this._ariaLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        RufEllipsisComponent.prototype.checkReadMore = function () {
            if (this.text && this.ellipsisContainer.nativeElement.offsetHeight < this.ellipsisContainer.nativeElement.scrollHeight) {
                this.showReadMore$.next(true);
            }
            else {
                this.showReadMore$.next(false);
            }
        };
        RufEllipsisComponent.prototype.ngAfterViewChecked = function () {
            this.checkReadMore();
            this.changeDetectorRef.detectChanges();
        };
        RufEllipsisComponent.prototype.ngOnDestroy = function () {
            this._intlChanges.unsubscribe();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RufEllipsisComponent.prototype, "text", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufEllipsisComponent.prototype, "lines", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RufEllipsisComponent.prototype, "lineHeight", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufEllipsisComponent.prototype, "label", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufEllipsisComponent.prototype, "ariaLabel", null);
        __decorate([
            core.ViewChild('ellipsisContainer', { static: false }),
            __metadata("design:type", core.ElementRef)
        ], RufEllipsisComponent.prototype, "ellipsisContainer", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], RufEllipsisComponent.prototype, "expand", void 0);
        RufEllipsisComponent = __decorate([
            core.Component({
                selector: 'ruf-ellipsis',
                template: "<div  #ellipsisContainer [class]=\"'ellipsis-container'\" [style.maxHeight.rem]=\"lines * lineHeight\" [style.lineHeight.rem]=\"lineHeight\">\n  <div  class=\"ellipsis-wrapper\" >\n    <div class=\"ellipsis-content\" [innerHTML]=\"text\">\n    </div>\n  </div>\n  <span *ngIf=\"showReadMore$ | async\" [attr.aria-label]=\"ariaLabel\" class=\"ellipsis\">\n    <a (click)=\"expand.emit({'text': this.text});\" href=\"javascript:;\">{{label}}</a>\n  </span>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: ["ruf-ellipsis .ellipsis-container{max-height:calc(5rem);overflow:hidden;position:relative}ruf-ellipsis .ellipsis-container:before{content:'';float:left;height:100%;width:1px}ruf-ellipsis .ellipsis-wrapper{float:right;margin-left:-1px;width:100%}ruf-ellipsis .ellipsis-content{margin:0}ruf-ellipsis .ellipsis-content p{margin-bottom:1rem;margin-top:0}ruf-ellipsis .ellipsis{bottom:0;position:absolute;right:0;text-align:right;width:auto}"]
            }),
            __metadata("design:paramtypes", [RufShellIntl, core.ChangeDetectorRef])
        ], RufEllipsisComponent);
        return RufEllipsisComponent;
    }());

    var RufEllipsisModule = /** @class */ (function () {
        function RufEllipsisModule() {
        }
        RufEllipsisModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    RufUtilsModule
                ],
                declarations: [RufEllipsisComponent],
                exports: [RufEllipsisComponent]
            })
        ], RufEllipsisModule);
        return RufEllipsisModule;
    }());

    var RufInkbarDirective = /** @class */ (function () {
        function RufInkbarDirective(renderer, elm) {
            this.renderer = renderer;
            this.elm = elm;
            this._color = 'primary';
            this._position = 'bottom';
            this.rufInkbar = 'ruf-inkbar';
            // add default classes;
            this._updateClass(this._color, null);
            this._updateClass(this._position, null);
        }
        Object.defineProperty(RufInkbarDirective.prototype, "inkbarPosition", {
            get: function () {
                return this._position;
            },
            set: function (value) {
                var position = value || 'bottom';
                this._updateClass(position, this._position);
                this._position = position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufInkbarDirective.prototype, "inkbarColor", {
            get: function () {
                return this._color;
            },
            set: function (value) {
                var color = value || 'primary';
                this._updateClass(color, this._color);
                this._color = color;
            },
            enumerable: true,
            configurable: true
        });
        // method to update the class based on the input
        RufInkbarDirective.prototype._updateClass = function (newValue, oldValue) {
            if (oldValue) {
                // remove class only if newValue is not null
                this.renderer.removeClass(this.elm.nativeElement, "ruf-inkbar-" + oldValue);
            }
            if (newValue) {
                this.renderer.addClass(this.elm.nativeElement, "ruf-inkbar-" + newValue);
            }
        };
        __decorate([
            core.HostBinding('class.ruf-inkbar'),
            __metadata("design:type", Object)
        ], RufInkbarDirective.prototype, "rufInkbar", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufInkbarDirective.prototype, "inkbarPosition", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufInkbarDirective.prototype, "inkbarColor", null);
        RufInkbarDirective = __decorate([
            core.Directive({
                selector: '[rufInkbar]',
                exportAs: 'rufInkbar'
            }),
            __metadata("design:paramtypes", [core.Renderer2, core.ElementRef])
        ], RufInkbarDirective);
        return RufInkbarDirective;
    }());
    var RufInkbarActiveDirective = /** @class */ (function () {
        function RufInkbarActiveDirective() {
            this.rufInkbarItem = 'ruf-inkbar-item';
        }
        Object.defineProperty(RufInkbarActiveDirective.prototype, "_inkbarActive", {
            get: function () {
                return this.rufInkbarActive;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.HostBinding('class.ruf-inkbar-item'),
            __metadata("design:type", Object)
        ], RufInkbarActiveDirective.prototype, "rufInkbarItem", void 0);
        __decorate([
            core.HostBinding('class.ruf-inkbar-active'),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [])
        ], RufInkbarActiveDirective.prototype, "_inkbarActive", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RufInkbarActiveDirective.prototype, "rufInkbarActive", void 0);
        RufInkbarActiveDirective = __decorate([
            core.Directive({
                selector: '[rufInkbarActive]',
                exportAs: 'rufInkbarActive'
            })
        ], RufInkbarActiveDirective);
        return RufInkbarActiveDirective;
    }());

    var RufInkbarModule = /** @class */ (function () {
        function RufInkbarModule() {
        }
        RufInkbarModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule
                ],
                declarations: [RufInkbarDirective, RufInkbarActiveDirective],
                exports: [
                    RufInkbarDirective, RufInkbarActiveDirective
                ]
            })
        ], RufInkbarModule);
        return RufInkbarModule;
    }());

    var RufSidePanelComponent = /** @class */ (function () {
        function RufSidePanelComponent(_intl, changeDetectorRef) {
            this._intl = _intl;
            this.changeDetectorRef = changeDetectorRef;
            /* tslint:disable:no-input-rename */
            this.isPinned = false;
            this.togglePin = new core.EventEmitter();
            this._intlChanges = _intl.changes.subscribe(function () {
                changeDetectorRef.markForCheck();
            });
        }
        Object.defineProperty(RufSidePanelComponent.prototype, "pinLabel", {
            get: function () {
                return this._pinLabel || this._intl.sidepanel.aria.pinLabel;
            },
            set: function (value) {
                this._pinLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufSidePanelComponent.prototype, "unpinLabel", {
            get: function () {
                return this._unpinLabel || this._intl.sidepanel.aria.unpinLabel;
            },
            set: function (value) {
                this._unpinLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RufSidePanelComponent.prototype, "toggleLabel", {
            get: function () {
                return this.isPinned ? this.unpinLabel : this.pinLabel;
            },
            enumerable: true,
            configurable: true
        });
        RufSidePanelComponent.prototype.onPintoggle = function ($event) {
            this.isPinned = !this.isPinned;
            this.togglePin.emit({ 'pinned': this.isPinned });
        };
        RufSidePanelComponent.prototype.ngOnDestroy = function () {
            this._intlChanges.unsubscribe();
        };
        __decorate([
            core.Input('pinned'),
            __metadata("design:type", Object)
        ], RufSidePanelComponent.prototype, "isPinned", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], RufSidePanelComponent.prototype, "togglePin", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufSidePanelComponent.prototype, "pinLabel", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufSidePanelComponent.prototype, "unpinLabel", null);
        RufSidePanelComponent = __decorate([
            core.Component({
                selector: 'ruf-side-panel',
                template: "<div rufId class=\"ruf-side-panel-container\">\n  <button type=\"button\"\n          rufId=\"ruf_toggle_pin\"\n          class=\"ruf-side-panel-pin\"\n          mat-icon-button\n          fisStyle\n          [attr.aria-label]=\"toggleLabel\"\n          (click)=\"onPintoggle($event)\">\n      <mat-icon rufIconStyle=\"lg\" rufId=\"pin_icon\"\n              [fisIcon]=\"isPinned ? 'pin-remove': 'pin'\">\n      </mat-icon>\n  </button>\n  <ng-content></ng-content>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: ["ruf-side-panel .ruf-side-panel-container{border-style:solid;border-width:.0625rem;bottom:0;box-sizing:border-box;height:100%;max-width:25rem;min-width:18.75rem;overflow:auto;position:relative;top:0;width:100%}ruf-side-panel .ruf-side-panel-pin{float:right;margin:.3125rem}"]
            }),
            __metadata("design:paramtypes", [RufShellIntl,
                core.ChangeDetectorRef])
        ], RufSidePanelComponent);
        return RufSidePanelComponent;
    }());

    var RufSidePanelModule = /** @class */ (function () {
        function RufSidePanelModule() {
        }
        RufSidePanelModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    button.MatButtonModule,
                    icon.MatIconModule,
                    RufIconModule,
                    RufUtilsModule,
                    RufUniqueIdModule
                ],
                declarations: [RufSidePanelComponent],
                exports: [RufSidePanelComponent]
            })
        ], RufSidePanelModule);
        return RufSidePanelModule;
    }());

    var SHELL_MODULES = [
        RufToggleModule,
        RufTriggerModule,
        RufDynamicMenubarModule,
        RufDynamicSideMenuModule,
        RufMenubarModule,
        RufSidemenuModule,
        RufBannerModule,
        RufToolbarModule,
        RufAppCanvasModule,
        RufFooterModule,
        RufLayoutModule,
        RufI18nModule,
        RufLabeledIconModule,
        RufIconButtonModule,
        RufPageHeaderModule,
        flexLayout.FlexLayoutModule,
        RufNavbarModule,
        RufMegamenuModule,
        RufDialogPanelModule,
        RufUtilsModule,
        RufRouterModule,
        RufMenuLabelModule,
        RufUniqueIdModule,
        RufSitemapModule,
        RufDropdownPanelModule,
        RufCardModule,
        RufIconModule,
        RufStatusbarModule,
        RufEllipsisModule,
        RufSidePanelModule,
        RufInkbarModule
    ];
    var RufShellRootModule = /** @class */ (function () {
        function RufShellRootModule() {
        }
        RufShellRootModule = __decorate([
            core.NgModule({
                imports: [
                    RufToggleModule,
                    RufTriggerModule,
                    RufDynamicMenubarModule,
                    RufDynamicSideMenuModule,
                    RufMenubarModule,
                    RufSidemenuModule,
                    RufBannerModule,
                    RufToolbarModule,
                    RufAppCanvasModule,
                    RufFooterModule,
                    RufLayoutModule,
                    RufI18nModule,
                    flexLayout.FlexLayoutModule,
                    RufLabeledIconModule,
                    RufIconButtonModule,
                    RufPageHeaderModule,
                    RufNavbarModule,
                    RufDialogPanelModule,
                    RufUtilsModule,
                    RufRouterModule,
                    RufMegamenuModule,
                    RufUniqueIdModule,
                    RufSitemapModule,
                    RufDropdownPanelModule,
                    RufCardModule,
                    RufIconModule,
                    RufStatusbarModule,
                    RufEllipsisModule,
                    RufSidePanelModule,
                    RufInkbarModule
                ],
                exports: SHELL_MODULES
            })
        ], RufShellRootModule);
        return RufShellRootModule;
    }());
    var RufShellModule = /** @class */ (function () {
        function RufShellModule() {
        }
        RufShellModule = __decorate([
            core.NgModule({
                imports: SHELL_MODULES,
                exports: SHELL_MODULES,
                providers: []
            })
        ], RufShellModule);
        return RufShellModule;
    }());

    var RufDynamicSegmentComponent = /** @class */ (function () {
        function RufDynamicSegmentComponent(_elementRef) {
            this._elementRef = _elementRef;
            this.items = [];
            /* tslint:disable:no-output-rename */
            // Renaming output to avoid duplicate `select` identifiers
            this.selectEmitter = new core.EventEmitter();
        }
        Object.defineProperty(RufDynamicSegmentComponent.prototype, "selectedPath", {
            get: function () {
                return this._selectedPath;
            },
            set: function (id) {
                this._selectedPath = id;
            },
            enumerable: true,
            configurable: true
        });
        RufDynamicSegmentComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.addNewKeyboardNav();
            this.segmentItems.changes.subscribe(function () {
                _this.addNewKeyboardNav();
            });
        };
        RufDynamicSegmentComponent.prototype.onKey = function (event) {
            this._keyboardNav.onKeyDown(event);
        };
        RufDynamicSegmentComponent.prototype.ngOnChanges = function (changes) {
            if (changes.selectedPath && changes.selectedPath.currentValue) {
                this.selectSegmentItem({ path: changes.selectedPath.currentValue });
            }
        };
        RufDynamicSegmentComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        // Set Keyboard navigation
        RufDynamicSegmentComponent.prototype.addNewKeyboardNav = function () {
            var _this = this;
            this._keyboardNav = new RufKeyboardNavigation();
            this.subscription = this._keyboardNav.init(this._elementRef, this.segmentItems).subscribe(function (item) {
                _this.selectSegmentItem({ path: item.value });
            });
            this._keyboardNav.addTabIndex(this.segmentItems);
        };
        /**
         * Set selectedPath and activate dynamic-segment item
         * @param item
         */
        RufDynamicSegmentComponent.prototype.selectSegmentItem = function (item) {
            this._selectedPath = item.path;
            var selectedIndex = this.selectedIndex();
            if (this._keyboardNav) {
                this._keyboardNav.setActiveItem((selectedIndex === -1) ? 0 : selectedIndex);
            }
            if (this.segmentItems) {
                // if segmentItems are not present, the component view is not loaded yet.
                // This means 'selectSegmentItem' is called from 'ngOnChanges' and the host element has [selectedPath] input.
                var selectedItem = (selectedIndex === -1) ? null : this.items[selectedIndex];
                this.selectEmitter.emit(selectedItem);
            }
        };
        /**
         * @returns - index of the selected dynamic-segment item. -1 if no dynamic-segment is selected.
         */
        RufDynamicSegmentComponent.prototype.selectedIndex = function () {
            var _this = this;
            var index = -1;
            if (this.segmentItems) {
                index = this.items.findIndex(function (segmentItem, i) { return _this._matches(segmentItem.path); });
            }
            return index;
        };
        RufDynamicSegmentComponent.prototype._matches = function (path) {
            if (path && this.selectedPath) {
                var pattern = new RegExp('^((\/)?' + this.selectedPath + ')(\/.*)?$'); // use word boundary to exact match
                if (path === this.selectedPath || pattern.test(path)) { // match with and parent dynamic-segment item
                    return true;
                }
            }
            return false;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], RufDynamicSegmentComponent.prototype, "items", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RufDynamicSegmentComponent.prototype, "showActiveItemClip", void 0);
        __decorate([
            core.Output('select'),
            __metadata("design:type", Object)
        ], RufDynamicSegmentComponent.prototype, "selectEmitter", void 0);
        __decorate([
            core.ViewChildren(buttonToggle.MatButtonToggle),
            __metadata("design:type", core.QueryList)
        ], RufDynamicSegmentComponent.prototype, "segmentItems", void 0);
        __decorate([
            core.ContentChild(core.TemplateRef, { static: false }),
            __metadata("design:type", Object)
        ], RufDynamicSegmentComponent.prototype, "navActions", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RufDynamicSegmentComponent.prototype, "selectedPath", null);
        __decorate([
            core.HostListener('keydown', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [KeyboardEvent]),
            __metadata("design:returntype", void 0)
        ], RufDynamicSegmentComponent.prototype, "onKey", null);
        RufDynamicSegmentComponent = __decorate([
            core.Component({
                selector: 'ruf-dynamic-segment',
                template: "<div class=\"segment-layout\" role=\"menubar\">\n  <mat-button-toggle-group rufId=\"segmentGroup\" fisStyle class=\"segment-group\" value=\"{{selectedPath}}\">\n    <mat-button-toggle rufId class=\"segment-item\"\n                       [class.mat-button-toggle-selected]=\"selectedPath === item.path ? true : false\"\n                       [class.mat-button-toggle-checked]=\"selectedPath === item.path ? true : false\"\n                       [class.segment-clip]=\"showActiveItemClip\"\n                       fisStyle\n                       *ngFor=\"let item of items\"\n                       (click)=\"selectSegmentItem(item)\"\n                       value=\"{{item.path}}\"\n                       title=\"{{item.tooltipText}}\"\n                       role=\"menuitem\">\n      {{item.label}}\n      <ng-template [ngTemplateOutlet]=\"navActions\" [ngTemplateOutletContext]=\"{item: item}\">\n      </ng-template>\n    </mat-button-toggle>\n  </mat-button-toggle-group>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".segment-layout{-webkit-box-align:stretch;align-items:stretch;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.segment-layout .mat-button-toggle-group{overflow:visible}.segment-item:focus{outline:0}.segment-item>label{cursor:pointer;text-align:center;width:100%}.segment-group>.segment-item{-webkit-box-align:center;align-items:center;border-bottom-style:solid;border-bottom-width:.125rem;border-color:transparent;border-top-style:solid;border-top-width:.125rem;cursor:pointer;display:-webkit-box;display:flex;-webkit-box-flex:1;flex:1 auto;-webkit-box-pack:center;justify-content:center;padding:0;-webkit-transition:background-color .2s;transition:background-color .2s}.segment-group>.segment-clip::after{border-left:10px solid transparent;border-right:10px solid transparent;border-top:15px solid transparent;content:'';left:calc(50% - 10px);position:absolute;top:100%}"]
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], RufDynamicSegmentComponent);
        return RufDynamicSegmentComponent;
    }());

    var RufDynamicSegmentModule = /** @class */ (function () {
        function RufDynamicSegmentModule() {
        }
        RufDynamicSegmentModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    buttonToggle.MatButtonToggleModule,
                    RufUniqueIdModule
                ],
                declarations: [
                    RufDynamicSegmentComponent
                ],
                exports: [
                    RufDynamicSegmentComponent
                ]
            })
        ], RufDynamicSegmentModule);
        return RufDynamicSegmentModule;
    }());

    exports.RUF_ICON_STYLE_VALUES = RUF_ICON_STYLE_VALUES;
    exports.RUF_INFO = RUF_INFO;
    exports.RUF_MARGIN_VALUES = RUF_MARGIN_VALUES;
    exports.RUF_PADDING_VALUES = RUF_PADDING_VALUES;
    exports.RufAppCanvasComponent = RufAppCanvasComponent;
    exports.RufAppCanvasModule = RufAppCanvasModule;
    exports.RufBannerBrandComponent = RufBannerBrandComponent;
    exports.RufBannerComponent = RufBannerComponent;
    exports.RufBannerControlsDirective = RufBannerControlsDirective;
    exports.RufBannerModule = RufBannerModule;
    exports.RufBannerRowDirective = RufBannerRowDirective;
    exports.RufCardActionBarComponent = RufCardActionBarComponent;
    exports.RufCardComponent = RufCardComponent;
    exports.RufCardControlsDirective = RufCardControlsDirective;
    exports.RufCardModule = RufCardModule;
    exports.RufCardSubtitleDirective = RufCardSubtitleDirective;
    exports.RufCart = RufCart;
    exports.RufCurrencyPipe = RufCurrencyPipe;
    exports.RufDatePipe = RufDatePipe;
    exports.RufDialogContentDirective = RufDialogContentDirective;
    exports.RufDialogFooterDirective = RufDialogFooterDirective;
    exports.RufDialogHeaderDirective = RufDialogHeaderDirective;
    exports.RufDialogPanelComponent = RufDialogPanelComponent;
    exports.RufDialogPanelModule = RufDialogPanelModule;
    exports.RufDropdownPanelComponent = RufDropdownPanelComponent;
    exports.RufDropdownPanelModule = RufDropdownPanelModule;
    exports.RufDynamicMenubarComponent = RufDynamicMenubarComponent;
    exports.RufDynamicMenubarModule = RufDynamicMenubarModule;
    exports.RufDynamicSegmentComponent = RufDynamicSegmentComponent;
    exports.RufDynamicSegmentModule = RufDynamicSegmentModule;
    exports.RufDynamicSideMenuComponent = RufDynamicSideMenuComponent;
    exports.RufDynamicSideMenuModule = RufDynamicSideMenuModule;
    exports.RufElementRefBase = RufElementRefBase;
    exports.RufEllipsisComponent = RufEllipsisComponent;
    exports.RufEllipsisModule = RufEllipsisModule;
    exports.RufFocusableDirective = RufFocusableDirective;
    exports.RufFooterComponent = RufFooterComponent;
    exports.RufFooterControlsDirective = RufFooterControlsDirective;
    exports.RufFooterModule = RufFooterModule;
    exports.RufI18nModule = RufI18nModule;
    exports.RufIconButtonDirective = RufIconButtonDirective;
    exports.RufIconButtonModule = RufIconButtonModule;
    exports.RufIconDirective = RufIconDirective;
    exports.RufIconModule = RufIconModule;
    exports.RufIconStyleDirective = RufIconStyleDirective;
    exports.RufIfDirective = RufIfDirective;
    exports.RufInkbarActiveDirective = RufInkbarActiveDirective;
    exports.RufInkbarDirective = RufInkbarDirective;
    exports.RufInkbarModule = RufInkbarModule;
    exports.RufKeyCodes = RufKeyCodes;
    exports.RufKeyboardNavigation = RufKeyboardNavigation;
    exports.RufLabeledIconComponent = RufLabeledIconComponent;
    exports.RufLabeledIconModule = RufLabeledIconModule;
    exports.RufLayoutModule = RufLayoutModule;
    exports.RufLocaleService = RufLocaleService;
    exports.RufMDIStrategy = RufMDIStrategy;
    exports.RufMarginDirective = RufMarginDirective;
    exports.RufMegamenuComponent = RufMegamenuComponent;
    exports.RufMegamenuModule = RufMegamenuModule;
    exports.RufMegamenuSearchComponent = RufMegamenuSearchComponent;
    exports.RufMenuLabelComponent = RufMenuLabelComponent;
    exports.RufMenuLabelModule = RufMenuLabelModule;
    exports.RufMenubarComponent = RufMenubarComponent;
    exports.RufMenubarItemComponent = RufMenubarItemComponent;
    exports.RufMenubarModule = RufMenubarModule;
    exports.RufMixinBase = RufMixinBase;
    exports.RufNavbarComponent = RufNavbarComponent;
    exports.RufNavbarModule = RufNavbarModule;
    exports.RufPaddingDirective = RufPaddingDirective;
    exports.RufPageHeaderComponent = RufPageHeaderComponent;
    exports.RufPageHeaderDescriptionComponent = RufPageHeaderDescriptionComponent;
    exports.RufPageHeaderIconComponent = RufPageHeaderIconComponent;
    exports.RufPageHeaderModule = RufPageHeaderModule;
    exports.RufPageHeaderRowDirective = RufPageHeaderRowDirective;
    exports.RufPageHeaderTitleComponent = RufPageHeaderTitleComponent;
    exports.RufRouteReuseStrategy = RufRouteReuseStrategy;
    exports.RufRouterModule = RufRouterModule;
    exports.RufRouterOutletDirective = RufRouterOutletDirective;
    exports.RufRouterUtilService = RufRouterUtilService;
    exports.RufSearchService = RufSearchService;
    exports.RufShellIntl = RufShellIntl;
    exports.RufShellModule = RufShellModule;
    exports.RufShellRootModule = RufShellRootModule;
    exports.RufSidePanelComponent = RufSidePanelComponent;
    exports.RufSidePanelModule = RufSidePanelModule;
    exports.RufSidemenuChildrenComponent = RufSidemenuChildrenComponent;
    exports.RufSidemenuComponent = RufSidemenuComponent;
    exports.RufSidemenuItemComponent = RufSidemenuItemComponent;
    exports.RufSidemenuModule = RufSidemenuModule;
    exports.RufSitemapComponent = RufSitemapComponent;
    exports.RufSitemapModule = RufSitemapModule;
    exports.RufStatusbarComponent = RufStatusbarComponent;
    exports.RufStatusbarDescriptionComponent = RufStatusbarDescriptionComponent;
    exports.RufStatusbarIconComponent = RufStatusbarIconComponent;
    exports.RufStatusbarModule = RufStatusbarModule;
    exports.RufToggleDirective = RufToggleDirective;
    exports.RufToggleModule = RufToggleModule;
    exports.RufToolbarComponent = RufToolbarComponent;
    exports.RufToolbarFillerDirective = RufToolbarFillerDirective;
    exports.RufToolbarModule = RufToolbarModule;
    exports.RufToolbarRowDirective = RufToolbarRowDirective;
    exports.RufTriggerDirective = RufTriggerDirective;
    exports.RufTriggerModule = RufTriggerModule;
    exports.RufUniqueIdDirective = RufUniqueIdDirective;
    exports.RufUniqueIdModule = RufUniqueIdModule;
    exports.RufUtilsModule = RufUtilsModule;
    exports.RufWindowRef = RufWindowRef;
    exports.info = info;
    exports.infoToken = infoToken;
    exports.localeFactory = localeFactory;
    exports.rufMixinColor = rufMixinColor;
    exports.throwTargetMissingError = throwTargetMissingError;
    exports.versionString = versionString;
    exports.ɵ0 = ɵ0;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ruf-shell.umd.js.map
