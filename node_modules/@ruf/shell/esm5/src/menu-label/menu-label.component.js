import * as tslib_1 from "tslib";
import { Input, Output, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, HostBinding, HostListener, ViewChild } from '@angular/core';
import { ENTER, SPACE, ESCAPE } from '@angular/cdk/keycodes';
import { MatMenuTrigger } from '@angular/material/menu';
var RufMenuLabelComponent = /** @class */ (function () {
    function RufMenuLabelComponent() {
        this.label = '';
        this.icon = '';
        // on child menu toggle
        this.toggle = new EventEmitter();
        this.select = new EventEmitter();
        this.rowLayout = true; // tells the internal labeled-icon that it is in a row.
    }
    RufMenuLabelComponent.prototype.handleClick = function (event) {
        // labels with children will not propagate the click event by default
        if (this.children && this.children.length > 0) {
            event.preventDefault();
            event.stopPropagation();
        }
    };
    RufMenuLabelComponent.prototype.hasPopup = function () {
        return this.children ? this.children.length > 0 : false;
    };
    RufMenuLabelComponent.prototype.onClose = function () {
        this.toggle.emit(false);
    };
    RufMenuLabelComponent.prototype.handleKeydown = function (event) {
        var _this = this;
        if (!this.children || this.children.length === 0) {
            return;
        }
        switch (event.keyCode) {
            case SPACE:
            case ENTER:
                this.trigger.openMenu();
                if (this.trigger.menu) {
                    // This is needed for dynamic menubar since it uses setTimeout for selecting a tab.
                    // This should be removed when we refactor dynamic menubar.
                    setTimeout(function () {
                        _this.trigger.menu.focusFirstItem();
                    });
                }
                event.preventDefault();
                event.stopPropagation();
                this.toggle.emit(true);
                break;
            case ESCAPE:
                this.trigger.closeMenu();
                this.toggle.emit(false);
                event.stopPropagation();
                break;
            default:
        }
    };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], RufMenuLabelComponent.prototype, "label", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], RufMenuLabelComponent.prototype, "icon", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Array)
    ], RufMenuLabelComponent.prototype, "children", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", Object)
    ], RufMenuLabelComponent.prototype, "toggle", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", Object)
    ], RufMenuLabelComponent.prototype, "select", void 0);
    tslib_1.__decorate([
        HostBinding('class.ruf-layout-row'),
        tslib_1.__metadata("design:type", Object)
    ], RufMenuLabelComponent.prototype, "rowLayout", void 0);
    tslib_1.__decorate([
        ViewChild(MatMenuTrigger, { static: false }),
        tslib_1.__metadata("design:type", MatMenuTrigger)
    ], RufMenuLabelComponent.prototype, "trigger", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], RufMenuLabelComponent.prototype, "selectedPath", void 0);
    tslib_1.__decorate([
        HostListener('click', ['$event']),
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", [Object]),
        tslib_1.__metadata("design:returntype", void 0)
    ], RufMenuLabelComponent.prototype, "handleClick", null);
    RufMenuLabelComponent = tslib_1.__decorate([
        Component({
            selector: 'ruf-menu-label',
            template: "<div class=\"ruf-menu-label-wrap\" rufId>\n  <!-- ideally, Angular would support putting matMenuTriggerFor on the host -->\n  <div class=\"ruf-menu-label-trigger\" *ngIf=\"children && children.length > 0\" [matMenuTriggerFor]=\"menu\" (menuClosed)=\"toggle.emit(false)\" (menuOpened)=\"toggle.emit(true)\"></div>\n  <ruf-labeled-icon fontSet=\"fisfont\" [fontIcon]=\"icon\" rufId>\n    <span class=\"ruf-menu-label-container\">\n      {{ label }}\n      <mat-icon class=\"ruf-menu-label-chevron\" aria-hidden=\"true\" rufId=\"menu_label_link\" *ngIf=\"children && children.length > 0\" fisIcon=\"arrow-down\"></mat-icon>\n    </span>\n\n    <span (click)=\"$event.stopPropagation()\" rufId=\"menu_label_content\">\n      <ng-content></ng-content>\n    </span>\n  </ruf-labeled-icon>\n</div>\n\n<mat-menu class=\"ruf-cust-menu\" rufId=\"menu\" #menu=\"matMenu\" yPosition=\"below\" [overlapTrigger]=\"false\">\n  <button type=\"button\" rufId=\"menu_button\" *ngFor=\"let child of children\" mat-menu-item (click)=\"select.emit(child)\"\n          [class.ruf-menu-selected]=\"selectedPath && child.path === selectedPath\"\n          [attr.aria-selected]=\"selectedPath && child.path === selectedPath\">\n    <mat-icon rufId=\"menu_icon\" *ngIf=\"child.icon\" fontSet=\"fisfont\" [fontIcon]=\"child.icon\"></mat-icon>\n    <span>{{ child.label }}</span>\n  </button>\n</mat-menu>\n",
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: ["ruf-menu-label{display:block!important;min-width:100%}ruf-menu-label ruf-labeled-icon{-webkit-box-pack:center;justify-content:center;width:100%}ruf-menu-label ruf-labeled-icon>span{-webkit-box-flex:0;flex:0 1 auto}.ruf-menu-label-wrap{position:relative}.ruf-menu-label-trigger{bottom:0;left:0;position:absolute;right:0;top:0}.ruf-menu-label-chevron{color:currentColor;margin-left:5px}.ruf-menu-label-container{-webkit-box-align:center;align-items:center;display:-webkit-inline-box;display:inline-flex}.ruf-cust-menu .mat-menu-content{border-style:solid;border-width:0 1px 1px;min-width:7.5rem;padding-bottom:0;padding-top:0}.ruf-cust-menu .mat-menu-content .mat-menu-item{height:2.75rem;line-height:2.75rem}.ruf-cust-menu .mat-menu-content .ruf-menu-selected{text-decoration:underline}"]
        })
    ], RufMenuLabelComponent);
    return RufMenuLabelComponent;
}());
export { RufMenuLabelComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVudS1sYWJlbC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AcnVmL3NoZWxsLyIsInNvdXJjZXMiOlsic3JjL21lbnUtbGFiZWwvbWVudS1sYWJlbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDTCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixTQUFTLEVBQ1QsaUJBQWlCLEVBQ2pCLHVCQUF1QixFQUN2QixXQUFXLEVBQ1gsWUFBWSxFQUNaLFNBQVMsRUFDVixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM3RCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFheEQ7SUFQQTtRQVFXLFVBQUssR0FBRyxFQUFFLENBQUM7UUFDWCxTQUFJLEdBQUcsRUFBRSxDQUFDO1FBRW5CLHVCQUF1QjtRQUNiLFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBVyxDQUFDO1FBRXJDLFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBeUIsQ0FBQztRQUN4QixjQUFTLEdBQUcsSUFBSSxDQUFDLENBQUMsdURBQXVEO0lBa0RoSCxDQUFDO0lBNUNDLDJDQUFXLEdBQVgsVUFBWSxLQUFLO1FBQ2YscUVBQXFFO1FBQ3JFLElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDN0MsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3ZCLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQztTQUN6QjtJQUNILENBQUM7SUFFRCx3Q0FBUSxHQUFSO1FBQ0UsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztJQUMxRCxDQUFDO0lBRUQsdUNBQU8sR0FBUDtRQUNFLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRCw2Q0FBYSxHQUFiLFVBQWMsS0FBSztRQUFuQixpQkEwQkM7UUF6QkMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ2hELE9BQU87U0FDUjtRQUNELFFBQVEsS0FBSyxDQUFDLE9BQU8sRUFBRTtZQUNyQixLQUFLLEtBQUssQ0FBQztZQUNYLEtBQUssS0FBSztnQkFDUixJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUN4QixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFO29CQUNyQixtRkFBbUY7b0JBQ25GLDJEQUEyRDtvQkFDM0QsVUFBVSxDQUFDO3dCQUNULEtBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO29CQUNyQyxDQUFDLENBQUMsQ0FBQztpQkFDSjtnQkFDRCxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7Z0JBQ3ZCLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQztnQkFDeEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3ZCLE1BQU07WUFDUixLQUFLLE1BQU07Z0JBQ1QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDekIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3hCLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQztnQkFDeEIsTUFBTTtZQUNSLFFBQVE7U0FDVDtJQUNILENBQUM7SUF2RFE7UUFBUixLQUFLLEVBQUU7O3dEQUFZO0lBQ1g7UUFBUixLQUFLLEVBQUU7O3VEQUFXO0lBQ1Y7UUFBUixLQUFLLEVBQUU7OzJEQUFtQztJQUVqQztRQUFULE1BQU0sRUFBRTs7eURBQXNDO0lBRXJDO1FBQVQsTUFBTSxFQUFFOzt5REFBb0Q7SUFDeEI7UUFBcEMsV0FBVyxDQUFDLHNCQUFzQixDQUFDOzs0REFBa0I7SUFDVjtRQUEzQyxTQUFTLENBQUMsY0FBYyxFQUFFLEVBQUMsTUFBTSxFQUFFLEtBQUssRUFBQyxDQUFDOzBDQUFVLGNBQWM7MERBQUM7SUFFM0Q7UUFBUixLQUFLLEVBQUU7OytEQUFzQjtJQUc5QjtRQURDLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQzs7Ozs0REFPakM7SUFwQlUscUJBQXFCO1FBUGpDLFNBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxnQkFBZ0I7WUFDMUIsKzJDQUEwQztZQUUxQyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtZQUNyQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTs7U0FDaEQsQ0FBQztPQUNXLHFCQUFxQixDQTBEakM7SUFBRCw0QkFBQztDQUFBLEFBMURELElBMERDO1NBMURZLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIElucHV0LFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlcixcbiAgQ29tcG9uZW50LFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIEhvc3RCaW5kaW5nLFxuICBIb3N0TGlzdGVuZXIsXG4gIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEVOVEVSLCBTUEFDRSwgRVNDQVBFIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IE1hdE1lbnVUcmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvbWVudSc7XG5pbXBvcnQgeyBSdWZUcmlnZ2VyVGFyZ2V0IH0gZnJvbSAnLi4vdHJpZ2dlci90cmlnZ2VyLmludGVyZmFjZSc7XG5cbi8vIEZJWE1FOiB0aGlzIGNvbXBvbmVudCBzaG91bGQgYmUgaW5kZXBlbmRlbnQgb2YgZHluYW1pYy1tZW51YmFyLiBDb25zaWRlciBjb21tb24vbWVudS1pdGVtLnRzIGZvciBjb21tb24gaW50ZXJmYWNlLlxuaW1wb3J0IHsgUnVmRHluYW1pY01lbnViYXJJdGVtIH0gZnJvbSAnLi4vZHluYW1pYy1tZW51YmFyL2R5bmFtaWMtbWVudWJhci1pdGVtJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAncnVmLW1lbnUtbGFiZWwnLFxuICB0ZW1wbGF0ZVVybDogJy4vbWVudS1sYWJlbC5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL21lbnUtbGFiZWwuY29tcG9uZW50LnNjc3MnXSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgUnVmTWVudUxhYmVsQ29tcG9uZW50IGltcGxlbWVudHMgUnVmVHJpZ2dlclRhcmdldCB7XG4gIEBJbnB1dCgpIGxhYmVsID0gJyc7XG4gIEBJbnB1dCgpIGljb24gPSAnJztcbiAgQElucHV0KCkgY2hpbGRyZW46IFJ1ZkR5bmFtaWNNZW51YmFySXRlbVtdO1xuICAvLyBvbiBjaGlsZCBtZW51IHRvZ2dsZVxuICBAT3V0cHV0KCkgdG9nZ2xlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIEBPdXRwdXQoKSBzZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyPFJ1ZkR5bmFtaWNNZW51YmFySXRlbT4oKTtcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5ydWYtbGF5b3V0LXJvdycpIHJvd0xheW91dCA9IHRydWU7IC8vIHRlbGxzIHRoZSBpbnRlcm5hbCBsYWJlbGVkLWljb24gdGhhdCBpdCBpcyBpbiBhIHJvdy5cbiAgQFZpZXdDaGlsZChNYXRNZW51VHJpZ2dlciwge3N0YXRpYzogZmFsc2V9KSB0cmlnZ2VyOiBNYXRNZW51VHJpZ2dlcjtcblxuICBASW5wdXQoKSBzZWxlY3RlZFBhdGg6IHN0cmluZztcblxuICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXG4gIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgLy8gbGFiZWxzIHdpdGggY2hpbGRyZW4gd2lsbCBub3QgcHJvcGFnYXRlIHRoZSBjbGljayBldmVudCBieSBkZWZhdWx0XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4gJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgaGFzUG9wdXAoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4gPyB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgOiBmYWxzZTtcbiAgfVxuXG4gIG9uQ2xvc2UoKSB7XG4gICAgdGhpcy50b2dnbGUuZW1pdChmYWxzZSk7XG4gIH1cblxuICBoYW5kbGVLZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgY2FzZSBTUEFDRTpcbiAgICAgIGNhc2UgRU5URVI6XG4gICAgICAgIHRoaXMudHJpZ2dlci5vcGVuTWVudSgpO1xuICAgICAgICBpZiAodGhpcy50cmlnZ2VyLm1lbnUpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCBmb3IgZHluYW1pYyBtZW51YmFyIHNpbmNlIGl0IHVzZXMgc2V0VGltZW91dCBmb3Igc2VsZWN0aW5nIGEgdGFiLlxuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiB3ZSByZWZhY3RvciBkeW5hbWljIG1lbnViYXIuXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIubWVudS5mb2N1c0ZpcnN0SXRlbSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZS5lbWl0KHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRVNDQVBFOlxuICAgICAgICB0aGlzLnRyaWdnZXIuY2xvc2VNZW51KCk7XG4gICAgICAgIHRoaXMudG9nZ2xlLmVtaXQoZmFsc2UpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG59XG4iXX0=