var RufMDIStrategy = /** @class */ (function () {
    function RufMDIStrategy(util) {
        this.util = util;
        this.handlers = {};
    }
    /**
     * Decides when the route should be stored
     * @param route the route that the user is currently on
     * @returns boolean indicating whether the route should or should not be stored
     */
    RufMDIStrategy.prototype.shouldDetach = function (route) {
        return true;
    };
    /**
     * Stores the complete route path and its component state (as ComponentRef) for later attachment
     * @param route This is stored for later comparison to requested routes, see `this.shouldAttach`
     * @param handle A DetachedRouteHandle which is later retrieved by this.retrieve to restore state
     */
    RufMDIStrategy.prototype.store = function (route, handle) {
        var path = this.util.getLeafNodePath(route);
        // path is '' when route has loadChildren.
        if (path) {
            if (route.component) {
                this.handlers[path] = handle;
            }
            // route does not have component. this means it is a parent route like ruf/shell/banner or ruf/shell/layout.
            // In this case, previously stored leaf node handler should be re-stored.
            if (!route.component && handle) {
                // This condition is when parent route is being stored but it's the child route whose reference needs to be stored instead.
                // In this case, retrieve the component ref from RufRouterUtilService and create a new DetachedRouteHandle.
                this.handlers[path] = {
                    componentRef: this.util.getComponentRef(path),
                    route: this.util.getLeafNode(handle['route'])
                };
            }
        }
    };
    /**
     * Determines whether there is a stored route and, if yes, should it be rendered in place of requested route
     * @param route The route the user requested
     * @returns boolean indicating whether or not to render the stored route
     */
    RufMDIStrategy.prototype.shouldAttach = function (route) {
        var path = this.util.getLeafNodePath(route);
        return !!route.routeConfig && !!this.handlers[path];
    };
    /**
     * Finds the locally stored instance of the requested route and returns it if it exists
     * @param route New route the user has requested
     * @returns DetachedRouteHandle object which can be used to render the component
     */
    RufMDIStrategy.prototype.retrieve = function (route) {
        if (!route.routeConfig) {
            return null;
        }
        if (route.routeConfig.loadChildren) {
            return null;
        }
        return this.handlers[this.util.fullPath(route)];
    };
    /**
     * Determines whether or not the current route should be reused
     * @param future The route the user is navigating to as triggered by the router
     * @param curr The route the user is currently on
     * @returns boolean indicating true if the user intends to leave the current route
     */
    RufMDIStrategy.prototype.shouldReuseRoute = function (future, curr) {
        return ((future.routeConfig === curr.routeConfig) &&
            (JSON.stringify(future.params) === JSON.stringify(curr.params)));
    };
    /**
     *  Remove component reference from handlers.
     *  Destroy the route component
     *  @param path The key against which DetachedRouteHandle with component reference is stored for detached route
     */
    RufMDIStrategy.prototype.destroy = function (path) {
        if (this.handlers[path] && this.util.getComponentRef(path)) {
            this.util.getComponentRef(path).destroy();
            delete this.handlers[path];
        }
    };
    return RufMDIStrategy;
}());
export { RufMDIStrategy };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWRpLXN0cmF0ZWd5LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHJ1Zi9zaGVsbC8iLCJzb3VyY2VzIjpbInNyYy9yb3V0ZXIvbWRpLXN0cmF0ZWd5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUtBO0lBR0Usd0JBQXNCLElBQTBCO1FBQTFCLFNBQUksR0FBSixJQUFJLENBQXNCO1FBRnhDLGFBQVEsR0FBMkMsRUFBRSxDQUFDO0lBRVgsQ0FBQztJQUVwRDs7OztPQUlHO0lBQ0gscUNBQVksR0FBWixVQUFhLEtBQTZCO1FBQ3hDLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCw4QkFBSyxHQUFMLFVBQU0sS0FBNkIsRUFBRSxNQUEyQjtRQUM5RCxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5QywwQ0FBMEM7UUFDMUMsSUFBSSxJQUFJLEVBQUU7WUFDUixJQUFJLEtBQUssQ0FBQyxTQUFTLEVBQUU7Z0JBQ25CLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDO2FBQzlCO1lBQ0QsNEdBQTRHO1lBQzVHLHlFQUF5RTtZQUN6RSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsSUFBSSxNQUFNLEVBQUU7Z0JBQzlCLDJIQUEySDtnQkFDM0gsMkdBQTJHO2dCQUMzRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHO29CQUNwQixZQUFZLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDO29CQUM3QyxLQUFLLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2lCQUM5QyxDQUFDO2FBQ0g7U0FDRjtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gscUNBQVksR0FBWixVQUFhLEtBQTZCO1FBQ3hDLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzlDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxpQ0FBUSxHQUFSLFVBQVMsS0FBNkI7UUFDcEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUU7WUFDdEIsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUU7WUFDbEMsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILHlDQUFnQixHQUFoQixVQUFpQixNQUE4QixFQUFFLElBQTRCO1FBQzNFLE9BQU8sQ0FDSCxDQUFDLE1BQU0sQ0FBQyxXQUFXLEtBQUssSUFBSSxDQUFDLFdBQVcsQ0FBQztZQUN6QyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQ2hFLENBQUM7SUFDTixDQUFDO0lBRUg7Ozs7T0FJRztJQUNELGdDQUFPLEdBQVAsVUFBUSxJQUFZO1FBQ2xCLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN0RCxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUMxQyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDNUI7SUFDUCxDQUFDO0lBQ0gscUJBQUM7QUFBRCxDQUFDLEFBeEZELElBd0ZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBEZXRhY2hlZFJvdXRlSGFuZGxlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IFJ1ZlJvdXRlUmV1c2VTdHJhdGVneSB9IGZyb20gJy4vcm91dGUtcmV1c2Utc3RyYXRlZ3knO1xuaW1wb3J0IHsgUnVmUm91dGVyVXRpbFNlcnZpY2UgfSBmcm9tICcuL3JvdXRlci11dGlsLnNlcnZpY2UnO1xuXG5leHBvcnQgY2xhc3MgUnVmTURJU3RyYXRlZ3kgaW1wbGVtZW50cyBSdWZSb3V0ZVJldXNlU3RyYXRlZ3kge1xuICBwcml2YXRlIGhhbmRsZXJzOiB7IFtrZXk6IHN0cmluZ106IERldGFjaGVkUm91dGVIYW5kbGUgfSA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCB1dGlsOiBSdWZSb3V0ZXJVdGlsU2VydmljZSkge31cblxuICAvKipcbiAgICogRGVjaWRlcyB3aGVuIHRoZSByb3V0ZSBzaG91bGQgYmUgc3RvcmVkXG4gICAqIEBwYXJhbSByb3V0ZSB0aGUgcm91dGUgdGhhdCB0aGUgdXNlciBpcyBjdXJyZW50bHkgb25cbiAgICogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHJvdXRlIHNob3VsZCBvciBzaG91bGQgbm90IGJlIHN0b3JlZFxuICAgKi9cbiAgc2hvdWxkRGV0YWNoKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBjb21wbGV0ZSByb3V0ZSBwYXRoIGFuZCBpdHMgY29tcG9uZW50IHN0YXRlIChhcyBDb21wb25lbnRSZWYpIGZvciBsYXRlciBhdHRhY2htZW50XG4gICAqIEBwYXJhbSByb3V0ZSBUaGlzIGlzIHN0b3JlZCBmb3IgbGF0ZXIgY29tcGFyaXNvbiB0byByZXF1ZXN0ZWQgcm91dGVzLCBzZWUgYHRoaXMuc2hvdWxkQXR0YWNoYFxuICAgKiBAcGFyYW0gaGFuZGxlIEEgRGV0YWNoZWRSb3V0ZUhhbmRsZSB3aGljaCBpcyBsYXRlciByZXRyaWV2ZWQgYnkgdGhpcy5yZXRyaWV2ZSB0byByZXN0b3JlIHN0YXRlXG4gICAqL1xuICBzdG9yZShyb3V0ZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgaGFuZGxlOiBEZXRhY2hlZFJvdXRlSGFuZGxlKTogdm9pZCB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMudXRpbC5nZXRMZWFmTm9kZVBhdGgocm91dGUpO1xuICAgIC8vIHBhdGggaXMgJycgd2hlbiByb3V0ZSBoYXMgbG9hZENoaWxkcmVuLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICBpZiAocm91dGUuY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnNbcGF0aF0gPSBoYW5kbGU7XG4gICAgICB9XG4gICAgICAvLyByb3V0ZSBkb2VzIG5vdCBoYXZlIGNvbXBvbmVudC4gdGhpcyBtZWFucyBpdCBpcyBhIHBhcmVudCByb3V0ZSBsaWtlIHJ1Zi9zaGVsbC9iYW5uZXIgb3IgcnVmL3NoZWxsL2xheW91dC5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgcHJldmlvdXNseSBzdG9yZWQgbGVhZiBub2RlIGhhbmRsZXIgc2hvdWxkIGJlIHJlLXN0b3JlZC5cbiAgICAgIGlmICghcm91dGUuY29tcG9uZW50ICYmIGhhbmRsZSkge1xuICAgICAgICAvLyBUaGlzIGNvbmRpdGlvbiBpcyB3aGVuIHBhcmVudCByb3V0ZSBpcyBiZWluZyBzdG9yZWQgYnV0IGl0J3MgdGhlIGNoaWxkIHJvdXRlIHdob3NlIHJlZmVyZW5jZSBuZWVkcyB0byBiZSBzdG9yZWQgaW5zdGVhZC5cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCByZXRyaWV2ZSB0aGUgY29tcG9uZW50IHJlZiBmcm9tIFJ1ZlJvdXRlclV0aWxTZXJ2aWNlIGFuZCBjcmVhdGUgYSBuZXcgRGV0YWNoZWRSb3V0ZUhhbmRsZS5cbiAgICAgICAgdGhpcy5oYW5kbGVyc1twYXRoXSA9IHtcbiAgICAgICAgICBjb21wb25lbnRSZWY6IHRoaXMudXRpbC5nZXRDb21wb25lbnRSZWYocGF0aCksXG4gICAgICAgICAgcm91dGU6IHRoaXMudXRpbC5nZXRMZWFmTm9kZShoYW5kbGVbJ3JvdXRlJ10pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGVyZSBpcyBhIHN0b3JlZCByb3V0ZSBhbmQsIGlmIHllcywgc2hvdWxkIGl0IGJlIHJlbmRlcmVkIGluIHBsYWNlIG9mIHJlcXVlc3RlZCByb3V0ZVxuICAgKiBAcGFyYW0gcm91dGUgVGhlIHJvdXRlIHRoZSB1c2VyIHJlcXVlc3RlZFxuICAgKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdG8gcmVuZGVyIHRoZSBzdG9yZWQgcm91dGVcbiAgICovXG4gIHNob3VsZEF0dGFjaChyb3V0ZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLnV0aWwuZ2V0TGVhZk5vZGVQYXRoKHJvdXRlKTtcbiAgICByZXR1cm4gISFyb3V0ZS5yb3V0ZUNvbmZpZyAmJiAhIXRoaXMuaGFuZGxlcnNbcGF0aF07XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIGxvY2FsbHkgc3RvcmVkIGluc3RhbmNlIG9mIHRoZSByZXF1ZXN0ZWQgcm91dGUgYW5kIHJldHVybnMgaXQgaWYgaXQgZXhpc3RzXG4gICAqIEBwYXJhbSByb3V0ZSBOZXcgcm91dGUgdGhlIHVzZXIgaGFzIHJlcXVlc3RlZFxuICAgKiBAcmV0dXJucyBEZXRhY2hlZFJvdXRlSGFuZGxlIG9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byByZW5kZXIgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgcmV0cmlldmUocm91dGU6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QpOiBEZXRhY2hlZFJvdXRlSGFuZGxlIHtcbiAgICBpZiAoIXJvdXRlLnJvdXRlQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJvdXRlLnJvdXRlQ29uZmlnLmxvYWRDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhbmRsZXJzW3RoaXMudXRpbC5mdWxsUGF0aChyb3V0ZSldO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIGN1cnJlbnQgcm91dGUgc2hvdWxkIGJlIHJldXNlZFxuICAgKiBAcGFyYW0gZnV0dXJlIFRoZSByb3V0ZSB0aGUgdXNlciBpcyBuYXZpZ2F0aW5nIHRvIGFzIHRyaWdnZXJlZCBieSB0aGUgcm91dGVyXG4gICAqIEBwYXJhbSBjdXJyIFRoZSByb3V0ZSB0aGUgdXNlciBpcyBjdXJyZW50bHkgb25cbiAgICogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIHRydWUgaWYgdGhlIHVzZXIgaW50ZW5kcyB0byBsZWF2ZSB0aGUgY3VycmVudCByb3V0ZVxuICAgKi9cbiAgc2hvdWxkUmV1c2VSb3V0ZShmdXR1cmU6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIGN1cnI6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAoZnV0dXJlLnJvdXRlQ29uZmlnID09PSBjdXJyLnJvdXRlQ29uZmlnKSAmJlxuICAgICAgICAoSlNPTi5zdHJpbmdpZnkoZnV0dXJlLnBhcmFtcykgPT09IEpTT04uc3RyaW5naWZ5KGN1cnIucGFyYW1zKSlcbiAgICAgICk7XG4gIH1cblxuLyoqXG4gKiAgUmVtb3ZlIGNvbXBvbmVudCByZWZlcmVuY2UgZnJvbSBoYW5kbGVycy5cbiAqICBEZXN0cm95IHRoZSByb3V0ZSBjb21wb25lbnRcbiAqICBAcGFyYW0gcGF0aCBUaGUga2V5IGFnYWluc3Qgd2hpY2ggRGV0YWNoZWRSb3V0ZUhhbmRsZSB3aXRoIGNvbXBvbmVudCByZWZlcmVuY2UgaXMgc3RvcmVkIGZvciBkZXRhY2hlZCByb3V0ZVxuICovXG4gIGRlc3Ryb3kocGF0aDogc3RyaW5nKSAge1xuICAgIGlmICh0aGlzLmhhbmRsZXJzW3BhdGhdICYmIHRoaXMudXRpbC5nZXRDb21wb25lbnRSZWYocGF0aCkpIHtcbiAgICAgICAgICB0aGlzLnV0aWwuZ2V0Q29tcG9uZW50UmVmKHBhdGgpLmRlc3Ryb3koKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5oYW5kbGVyc1twYXRoXTtcbiAgICAgICAgfVxuICB9XG59XG4iXX0=