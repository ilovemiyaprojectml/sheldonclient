import * as tslib_1 from "tslib";
import { Directive, Input, HostBinding, Renderer2, ElementRef } from '@angular/core';
var RufInkbarDirective = /** @class */ (function () {
    function RufInkbarDirective(renderer, elm) {
        this.renderer = renderer;
        this.elm = elm;
        this._color = 'primary';
        this._position = 'bottom';
        this.rufInkbar = 'ruf-inkbar';
        // add default classes;
        this._updateClass(this._color, null);
        this._updateClass(this._position, null);
    }
    Object.defineProperty(RufInkbarDirective.prototype, "inkbarPosition", {
        get: function () {
            return this._position;
        },
        set: function (value) {
            var position = value || 'bottom';
            this._updateClass(position, this._position);
            this._position = position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RufInkbarDirective.prototype, "inkbarColor", {
        get: function () {
            return this._color;
        },
        set: function (value) {
            var color = value || 'primary';
            this._updateClass(color, this._color);
            this._color = color;
        },
        enumerable: true,
        configurable: true
    });
    // method to update the class based on the input
    RufInkbarDirective.prototype._updateClass = function (newValue, oldValue) {
        if (oldValue) {
            // remove class only if newValue is not null
            this.renderer.removeClass(this.elm.nativeElement, "ruf-inkbar-" + oldValue);
        }
        if (newValue) {
            this.renderer.addClass(this.elm.nativeElement, "ruf-inkbar-" + newValue);
        }
    };
    tslib_1.__decorate([
        HostBinding('class.ruf-inkbar'),
        tslib_1.__metadata("design:type", Object)
    ], RufInkbarDirective.prototype, "rufInkbar", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], RufInkbarDirective.prototype, "inkbarPosition", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], RufInkbarDirective.prototype, "inkbarColor", null);
    RufInkbarDirective = tslib_1.__decorate([
        Directive({
            selector: '[rufInkbar]',
            exportAs: 'rufInkbar'
        }),
        tslib_1.__metadata("design:paramtypes", [Renderer2, ElementRef])
    ], RufInkbarDirective);
    return RufInkbarDirective;
}());
export { RufInkbarDirective };
var RufInkbarActiveDirective = /** @class */ (function () {
    function RufInkbarActiveDirective() {
        this.rufInkbarItem = 'ruf-inkbar-item';
    }
    Object.defineProperty(RufInkbarActiveDirective.prototype, "_inkbarActive", {
        get: function () {
            return this.rufInkbarActive;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        HostBinding('class.ruf-inkbar-item'),
        tslib_1.__metadata("design:type", Object)
    ], RufInkbarActiveDirective.prototype, "rufInkbarItem", void 0);
    tslib_1.__decorate([
        HostBinding('class.ruf-inkbar-active'),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [])
    ], RufInkbarActiveDirective.prototype, "_inkbarActive", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], RufInkbarActiveDirective.prototype, "rufInkbarActive", void 0);
    RufInkbarActiveDirective = tslib_1.__decorate([
        Directive({
            selector: '[rufInkbarActive]',
            exportAs: 'rufInkbarActive'
        })
    ], RufInkbarActiveDirective);
    return RufInkbarActiveDirective;
}());
export { RufInkbarActiveDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5rYmFyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BydWYvc2hlbGwvIiwic291cmNlcyI6WyJzcmMvaW5rYmFyL2lua2Jhci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDSCxTQUFTLEVBQ1QsS0FBSyxFQUNMLFdBQVcsRUFDWCxTQUFTLEVBQ1QsVUFBVSxFQUViLE1BQU0sZUFBZSxDQUFDO0FBT3ZCO0lBMEJJLDRCQUFvQixRQUFtQixFQUFVLEdBQWU7UUFBNUMsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUFVLFFBQUcsR0FBSCxHQUFHLENBQVk7UUF6QnhELFdBQU0sR0FBRyxTQUFTLENBQUM7UUFDbkIsY0FBUyxHQUFHLFFBQVEsQ0FBQztRQUNJLGNBQVMsR0FBRyxZQUFZLENBQUM7UUF3QnRELHVCQUF1QjtRQUN2QixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUF4QkQsc0JBQUksOENBQWM7YUFBbEI7WUFDSSxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDMUIsQ0FBQzthQUNELFVBQW1CLEtBQWE7WUFDNUIsSUFBTSxRQUFRLEdBQUcsS0FBSyxJQUFJLFFBQVEsQ0FBQztZQUNuQyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDNUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUM7UUFDOUIsQ0FBQzs7O09BTEE7SUFRRCxzQkFBSSwyQ0FBVzthQUFmO1lBQ0ksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3ZCLENBQUM7YUFFRCxVQUFnQixLQUFhO1lBQ3pCLElBQU0sS0FBSyxHQUFHLEtBQUssSUFBSSxTQUFTLENBQUE7WUFDaEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3RDLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLENBQUM7OztPQU5BO0lBY0QsZ0RBQWdEO0lBQ3hDLHlDQUFZLEdBQXBCLFVBQXFCLFFBQVEsRUFBRSxRQUFRO1FBQ25DLElBQUksUUFBUSxFQUFFO1lBQ1YsNENBQTRDO1lBQzVDLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLGdCQUFjLFFBQVUsQ0FBQyxDQUFDO1NBQy9FO1FBQ0QsSUFBSSxRQUFRLEVBQUU7WUFDVixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxnQkFBYyxRQUFVLENBQUMsQ0FBQztTQUM1RTtJQUNMLENBQUM7SUF0Q2dDO1FBQWhDLFdBQVcsQ0FBQyxrQkFBa0IsQ0FBQzs7eURBQTBCO0lBRzFEO1FBREMsS0FBSyxFQUFFOzs7NERBR1A7SUFRRDtRQURDLEtBQUssRUFBRTs7O3lEQUdQO0lBbEJRLGtCQUFrQjtRQUw5QixTQUFTLENBQUM7WUFDUCxRQUFRLEVBQUUsYUFBYTtZQUN2QixRQUFRLEVBQUUsV0FBVztTQUN4QixDQUFDO2lEQTRCZ0MsU0FBUyxFQUFlLFVBQVU7T0ExQnZELGtCQUFrQixDQTBDOUI7SUFBRCx5QkFBQztDQUFBLEFBMUNELElBMENDO1NBMUNZLGtCQUFrQjtBQWtEL0I7SUFMQTtRQU0wQyxrQkFBYSxHQUFHLGlCQUFpQixDQUFDO0lBTTVFLENBQUM7SUFKRyxzQkFBSSxtREFBYTthQUFqQjtZQUNJLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUNoQyxDQUFDOzs7T0FBQTtJQUpxQztRQUFyQyxXQUFXLENBQUMsdUJBQXVCLENBQUM7O21FQUFtQztJQUV4RTtRQURDLFdBQVcsQ0FBQyx5QkFBeUIsQ0FBQzs7O2lFQUd0QztJQUNRO1FBQVIsS0FBSyxFQUFFOztxRUFBMEI7SUFOekIsd0JBQXdCO1FBTHBDLFNBQVMsQ0FBQztZQUNQLFFBQVEsRUFBRSxtQkFBbUI7WUFDN0IsUUFBUSxFQUFFLGlCQUFpQjtTQUM5QixDQUFDO09BRVcsd0JBQXdCLENBT3BDO0lBQUQsK0JBQUM7Q0FBQSxBQVBELElBT0M7U0FQWSx3QkFBd0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIERpcmVjdGl2ZSxcbiAgICBJbnB1dCxcbiAgICBIb3N0QmluZGluZyxcbiAgICBSZW5kZXJlcjIsXG4gICAgRWxlbWVudFJlZixcbiAgICBBZnRlclZpZXdJbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tydWZJbmtiYXJdJyxcbiAgICBleHBvcnRBczogJ3J1Zklua2Jhcidcbn0pXG5cbmV4cG9ydCBjbGFzcyBSdWZJbmtiYXJEaXJlY3RpdmUge1xuICAgIHByaXZhdGUgX2NvbG9yID0gJ3ByaW1hcnknO1xuICAgIHByaXZhdGUgX3Bvc2l0aW9uID0gJ2JvdHRvbSc7XG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5ydWYtaW5rYmFyJykgcnVmSW5rYmFyID0gJ3J1Zi1pbmtiYXInO1xuXG4gICAgQElucHV0KClcbiAgICBnZXQgaW5rYmFyUG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbjtcbiAgICB9XG4gICAgc2V0IGlua2JhclBvc2l0aW9uKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB2YWx1ZSB8fCAnYm90dG9tJztcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2xhc3MocG9zaXRpb24sIHRoaXMuX3Bvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCBpbmtiYXJDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgIH1cblxuICAgIHNldCBpbmtiYXJDb2xvcih2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gdmFsdWUgfHwgJ3ByaW1hcnknXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNsYXNzKGNvbG9yLCB0aGlzLl9jb2xvcik7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gY29sb3I7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIGVsbTogRWxlbWVudFJlZikge1xuICAgICAgICAvLyBhZGQgZGVmYXVsdCBjbGFzc2VzO1xuICAgICAgICB0aGlzLl91cGRhdGVDbGFzcyh0aGlzLl9jb2xvciwgbnVsbCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNsYXNzKHRoaXMuX3Bvc2l0aW9uLCBudWxsKTtcbiAgICB9XG5cbiAgICAvLyBtZXRob2QgdG8gdXBkYXRlIHRoZSBjbGFzcyBiYXNlZCBvbiB0aGUgaW5wdXRcbiAgICBwcml2YXRlIF91cGRhdGVDbGFzcyhuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgY2xhc3Mgb25seSBpZiBuZXdWYWx1ZSBpcyBub3QgbnVsbFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsbS5uYXRpdmVFbGVtZW50LCBgcnVmLWlua2Jhci0ke29sZFZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsbS5uYXRpdmVFbGVtZW50LCBgcnVmLWlua2Jhci0ke25ld1ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3J1Zklua2JhckFjdGl2ZV0nLFxuICAgIGV4cG9ydEFzOiAncnVmSW5rYmFyQWN0aXZlJ1xufSlcblxuZXhwb3J0IGNsYXNzIFJ1Zklua2JhckFjdGl2ZURpcmVjdGl2ZSB7XG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5ydWYtaW5rYmFyLWl0ZW0nKSBydWZJbmtiYXJJdGVtID0gJ3J1Zi1pbmtiYXItaXRlbSc7XG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5ydWYtaW5rYmFyLWFjdGl2ZScpXG4gICAgZ2V0IF9pbmtiYXJBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1Zklua2JhckFjdGl2ZTtcbiAgICB9XG4gICAgQElucHV0KCkgcnVmSW5rYmFyQWN0aXZlOiBib29sZWFuO1xufVxuIl19