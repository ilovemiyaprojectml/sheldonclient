import * as tslib_1 from "tslib";
import { Directive, HostBinding, Input, Renderer2, ElementRef } from '@angular/core';
export var RUF_PADDING_VALUES = ['none', 'auto', 'small', 'medium', 'large'];
var RufPaddingDirective = /** @class */ (function () {
    function RufPaddingDirective(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.classPrefix = 'ruf-padding';
        this._positions = {
            rufPadding: ['-'],
            rufPaddingVertical: ['-top-', '-bottom-'],
            rufPaddingHorizontal: ['-left-', '-right-'],
            rufPaddingTop: ['-top-'],
            rufPaddingRight: ['-right-'],
            rufPaddingBottom: ['-bottom-'],
            rufPaddingLeft: ['-left-']
        };
        this.rufPadding = '';
        this.rufPaddingVertical = '';
        this.rufPaddingHorizontal = '';
        this.rufPaddingTop = '';
        this.rufPaddingRight = '';
        this.rufPaddingBottom = '';
        this.rufPaddingLeft = '';
        this.padding = true;
    }
    RufPaddingDirective.prototype.ngOnChanges = function (changes) {
        var _this = this;
        Object.keys(changes).forEach(function (key) {
            _this.update(key, changes[key]);
        });
    };
    RufPaddingDirective.prototype.update = function (key, change) {
        var _this = this;
        var previous = this._validateValue(change.previousValue);
        var current = this._validateValue(change.currentValue);
        var positions = this._positions[key];
        positions.forEach(function (pos) {
            // remove
            _this.renderer.removeClass(_this.el.nativeElement, _this.classPrefix + pos + previous);
            // add
            _this.renderer.addClass(_this.el.nativeElement, _this.classPrefix + pos + current);
        });
    };
    RufPaddingDirective.prototype._validateValue = function (val) {
        if (RUF_PADDING_VALUES.indexOf(val) !== -1) {
            return val;
        }
        return 'medium';
    };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], RufPaddingDirective.prototype, "rufPadding", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], RufPaddingDirective.prototype, "rufPaddingVertical", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], RufPaddingDirective.prototype, "rufPaddingHorizontal", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], RufPaddingDirective.prototype, "rufPaddingTop", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], RufPaddingDirective.prototype, "rufPaddingRight", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], RufPaddingDirective.prototype, "rufPaddingBottom", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], RufPaddingDirective.prototype, "rufPaddingLeft", void 0);
    tslib_1.__decorate([
        HostBinding('class.ruf-padding'),
        tslib_1.__metadata("design:type", Object)
    ], RufPaddingDirective.prototype, "padding", void 0);
    RufPaddingDirective = tslib_1.__decorate([
        Directive({
            selector: "\n    [rufPadding],\n    [rufPaddingVertical],\n    [rufPaddingHorizontal],\n    [rufPaddingTop],\n    [rufPaddingRight],\n    [rufPaddingBottom],\n    [rufPaddingLeft]\n  ",
            exportAs: 'rufPadding'
        }),
        tslib_1.__metadata("design:paramtypes", [ElementRef, Renderer2])
    ], RufPaddingDirective);
    return RufPaddingDirective;
}());
export { RufPaddingDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFkZGluZy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AcnVmL3NoZWxsLyIsInNvdXJjZXMiOlsic3JjL2xheW91dC9wYWRkaW5nLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUE0QixTQUFTLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRS9HLE1BQU0sQ0FBQyxJQUFNLGtCQUFrQixHQUFHLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBYy9FO0lBdUJFLDZCQUFvQixFQUFjLEVBQVUsUUFBbUI7UUFBM0MsT0FBRSxHQUFGLEVBQUUsQ0FBWTtRQUFVLGFBQVEsR0FBUixRQUFRLENBQVc7UUF0QnZELGdCQUFXLEdBQUcsYUFBYSxDQUFDO1FBRTVCLGVBQVUsR0FBRztZQUNuQixVQUFVLEVBQUUsQ0FBQyxHQUFHLENBQUM7WUFDakIsa0JBQWtCLEVBQUUsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDO1lBQ3pDLG9CQUFvQixFQUFFLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQztZQUMzQyxhQUFhLEVBQUUsQ0FBQyxPQUFPLENBQUM7WUFDeEIsZUFBZSxFQUFFLENBQUMsU0FBUyxDQUFDO1lBQzVCLGdCQUFnQixFQUFFLENBQUMsVUFBVSxDQUFDO1lBQzlCLGNBQWMsRUFBRSxDQUFDLFFBQVEsQ0FBQztTQUMzQixDQUFDO1FBRU8sZUFBVSxHQUFHLEVBQUUsQ0FBQztRQUNoQix1QkFBa0IsR0FBRyxFQUFFLENBQUM7UUFDeEIseUJBQW9CLEdBQUcsRUFBRSxDQUFDO1FBQzFCLGtCQUFhLEdBQUcsRUFBRSxDQUFDO1FBQ25CLG9CQUFlLEdBQUcsRUFBRSxDQUFDO1FBQ3JCLHFCQUFnQixHQUFHLEVBQUUsQ0FBQztRQUN0QixtQkFBYyxHQUFHLEVBQUUsQ0FBQztRQUVLLFlBQU8sR0FBRyxJQUFJLENBQUM7SUFFaUIsQ0FBQztJQUVuRSx5Q0FBVyxHQUFYLFVBQVksT0FBc0I7UUFBbEMsaUJBSUM7UUFIQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFBLEdBQUc7WUFDOUIsS0FBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDakMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sb0NBQU0sR0FBZCxVQUFlLEdBQUcsRUFBRSxNQUFNO1FBQTFCLGlCQVdDO1FBVkMsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDM0QsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDekQsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUV2QyxTQUFTLENBQUMsT0FBTyxDQUFDLFVBQUEsR0FBRztZQUNuQixTQUFTO1lBQ1QsS0FBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsS0FBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQUUsS0FBSSxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUcsUUFBUSxDQUFDLENBQUM7WUFDcEYsTUFBTTtZQUNOLEtBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEtBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLEtBQUksQ0FBQyxXQUFXLEdBQUcsR0FBRyxHQUFHLE9BQU8sQ0FBQyxDQUFDO1FBQ2xGLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVPLDRDQUFjLEdBQXRCLFVBQXVCLEdBQUc7UUFDeEIsSUFBSSxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7WUFDMUMsT0FBTyxHQUFHLENBQUM7U0FDWjtRQUNELE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFwQ1E7UUFBUixLQUFLLEVBQUU7OzJEQUFpQjtJQUNoQjtRQUFSLEtBQUssRUFBRTs7bUVBQXlCO0lBQ3hCO1FBQVIsS0FBSyxFQUFFOztxRUFBMkI7SUFDMUI7UUFBUixLQUFLLEVBQUU7OzhEQUFvQjtJQUNuQjtRQUFSLEtBQUssRUFBRTs7Z0VBQXNCO0lBQ3JCO1FBQVIsS0FBSyxFQUFFOztpRUFBdUI7SUFDdEI7UUFBUixLQUFLLEVBQUU7OytEQUFxQjtJQUVLO1FBQWpDLFdBQVcsQ0FBQyxtQkFBbUIsQ0FBQzs7d0RBQWdCO0lBckJ0QyxtQkFBbUI7UUFaL0IsU0FBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLDhLQVFUO1lBQ0QsUUFBUSxFQUFFLFlBQVk7U0FDdkIsQ0FBQztpREF3QndCLFVBQVUsRUFBb0IsU0FBUztPQXZCcEQsbUJBQW1CLENBa0QvQjtJQUFELDBCQUFDO0NBQUEsQUFsREQsSUFrREM7U0FsRFksbUJBQW1CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0QmluZGluZywgSW5wdXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcywgUmVuZGVyZXIyLCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmV4cG9ydCBjb25zdCBSVUZfUEFERElOR19WQUxVRVMgPSBbJ25vbmUnLCAnYXV0bycsICdzbWFsbCcsICdtZWRpdW0nLCAnbGFyZ2UnXTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBgXG4gICAgW3J1ZlBhZGRpbmddLFxuICAgIFtydWZQYWRkaW5nVmVydGljYWxdLFxuICAgIFtydWZQYWRkaW5nSG9yaXpvbnRhbF0sXG4gICAgW3J1ZlBhZGRpbmdUb3BdLFxuICAgIFtydWZQYWRkaW5nUmlnaHRdLFxuICAgIFtydWZQYWRkaW5nQm90dG9tXSxcbiAgICBbcnVmUGFkZGluZ0xlZnRdXG4gIGAsXG4gIGV4cG9ydEFzOiAncnVmUGFkZGluZydcbn0pXG5leHBvcnQgY2xhc3MgUnVmUGFkZGluZ0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIHByaXZhdGUgY2xhc3NQcmVmaXggPSAncnVmLXBhZGRpbmcnO1xuXG4gIHByaXZhdGUgX3Bvc2l0aW9ucyA9IHtcbiAgICBydWZQYWRkaW5nOiBbJy0nXSxcbiAgICBydWZQYWRkaW5nVmVydGljYWw6IFsnLXRvcC0nLCAnLWJvdHRvbS0nXSxcbiAgICBydWZQYWRkaW5nSG9yaXpvbnRhbDogWyctbGVmdC0nLCAnLXJpZ2h0LSddLFxuICAgIHJ1ZlBhZGRpbmdUb3A6IFsnLXRvcC0nXSxcbiAgICBydWZQYWRkaW5nUmlnaHQ6IFsnLXJpZ2h0LSddLFxuICAgIHJ1ZlBhZGRpbmdCb3R0b206IFsnLWJvdHRvbS0nXSxcbiAgICBydWZQYWRkaW5nTGVmdDogWyctbGVmdC0nXVxuICB9O1xuXG4gIEBJbnB1dCgpIHJ1ZlBhZGRpbmcgPSAnJztcbiAgQElucHV0KCkgcnVmUGFkZGluZ1ZlcnRpY2FsID0gJyc7XG4gIEBJbnB1dCgpIHJ1ZlBhZGRpbmdIb3Jpem9udGFsID0gJyc7XG4gIEBJbnB1dCgpIHJ1ZlBhZGRpbmdUb3AgPSAnJztcbiAgQElucHV0KCkgcnVmUGFkZGluZ1JpZ2h0ID0gJyc7XG4gIEBJbnB1dCgpIHJ1ZlBhZGRpbmdCb3R0b20gPSAnJztcbiAgQElucHV0KCkgcnVmUGFkZGluZ0xlZnQgPSAnJztcblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnJ1Zi1wYWRkaW5nJykgcGFkZGluZyA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbDogRWxlbWVudFJlZiwgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyKSB7fVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBPYmplY3Qua2V5cyhjaGFuZ2VzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZShrZXksIGNoYW5nZXNba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZShrZXksIGNoYW5nZSkge1xuICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5fdmFsaWRhdGVWYWx1ZShjaGFuZ2UucHJldmlvdXNWYWx1ZSk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuX3ZhbGlkYXRlVmFsdWUoY2hhbmdlLmN1cnJlbnRWYWx1ZSk7XG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5fcG9zaXRpb25zW2tleV07XG5cbiAgICBwb3NpdGlvbnMuZm9yRWFjaChwb3MgPT4ge1xuICAgICAgLy8gcmVtb3ZlXG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgdGhpcy5jbGFzc1ByZWZpeCArIHBvcyArIHByZXZpb3VzKTtcbiAgICAgIC8vIGFkZFxuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIHRoaXMuY2xhc3NQcmVmaXggKyBwb3MgKyBjdXJyZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX3ZhbGlkYXRlVmFsdWUodmFsKSB7XG4gICAgaWYgKFJVRl9QQURESU5HX1ZBTFVFUy5pbmRleE9mKHZhbCkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gJ21lZGl1bSc7XG4gIH1cbn1cbiJdfQ==