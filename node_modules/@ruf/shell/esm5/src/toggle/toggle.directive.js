import * as tslib_1 from "tslib";
import { Directive, ElementRef, HostBinding, HostListener, Input, Output, EventEmitter } from '@angular/core';
import { ENTER, SPACE } from '@angular/cdk/keycodes';
import { CdkOverlayOrigin } from '@angular/cdk/overlay';
/**
 * Directive that can be applied on any element, and that toggles an attribute that can be used by the underlying element as need be.
 */
var RufToggleDirective = /** @class */ (function (_super) {
    tslib_1.__extends(RufToggleDirective, _super);
    function RufToggleDirective(elRef) {
        var _this = _super.call(this, elRef) || this;
        _this.elRef = elRef;
        // boolean property that gets toggled when the underlying element is clicked
        // tslint:disable-next-line:no-input-rename
        _this.value = false;
        _this.chevron = false;
        _this.arrow = false;
        _this.toggleChange = new EventEmitter();
        _this.toggle = true;
        return _this;
    }
    Object.defineProperty(RufToggleDirective.prototype, "active", {
        get: function () {
            return this.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RufToggleDirective.prototype, "rufToggle", {
        set: function (val) {
            this.value = val || false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RufToggleDirective.prototype, "rufToggleChevron", {
        set: function (val) {
            this.arrow = false;
            this.chevron = true;
            this.value = val || false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RufToggleDirective.prototype, "rufToggleArrow", {
        set: function (val) {
            this.arrow = true;
            this.chevron = false;
            this.value = val || false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RufToggleDirective.prototype, "normal", {
        get: function () {
            return !this.chevron && !this.arrow;
        },
        enumerable: true,
        configurable: true
    });
    // select should focus the element and toggle value
    RufToggleDirective.prototype.select = function (event) {
        this.elRef.nativeElement.focus();
        this.toggleValue(event);
    };
    RufToggleDirective.prototype.toggleValue = function (event) {
        event.stopPropagation();
        event.preventDefault();
        // For Safari browser, event.stopPropagation() is not setting the value of
        // event.cancelBubble as true. So, we need to explicitly set it.
        event.cancelBubble = true;
        this.value = !this.value;
        this.toggleChange.emit({ trigger: this.elRef, value: this.value, event: event });
    };
    RufToggleDirective.prototype.onClick = function (event) {
        this.toggleValue(event);
    };
    RufToggleDirective.prototype.onKey = function (event) {
        switch (event.keyCode) {
            case ENTER:
            case SPACE:
                this.toggleValue(event);
                break;
            default:
        }
    };
    tslib_1.__decorate([
        HostBinding('class.ruf-toggle-active'),
        tslib_1.__metadata("design:type", Object)
    ], RufToggleDirective.prototype, "value", void 0);
    tslib_1.__decorate([
        HostBinding('class.ruf-toggle-chevron'),
        tslib_1.__metadata("design:type", Object)
    ], RufToggleDirective.prototype, "chevron", void 0);
    tslib_1.__decorate([
        HostBinding('class.ruf-toggle-arrow'),
        tslib_1.__metadata("design:type", Object)
    ], RufToggleDirective.prototype, "arrow", void 0);
    tslib_1.__decorate([
        HostBinding('class.ruf-active'),
        tslib_1.__metadata("design:type", Object),
        tslib_1.__metadata("design:paramtypes", [])
    ], RufToggleDirective.prototype, "active", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], RufToggleDirective.prototype, "rufToggle", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], RufToggleDirective.prototype, "rufToggleChevron", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], RufToggleDirective.prototype, "rufToggleArrow", null);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], RufToggleDirective.prototype, "toggleChange", void 0);
    tslib_1.__decorate([
        HostBinding('class.ruf-toggle'),
        tslib_1.__metadata("design:type", Object)
    ], RufToggleDirective.prototype, "toggle", void 0);
    tslib_1.__decorate([
        HostBinding('class.ruf-toggle-normal'),
        tslib_1.__metadata("design:type", Object),
        tslib_1.__metadata("design:paramtypes", [])
    ], RufToggleDirective.prototype, "normal", null);
    tslib_1.__decorate([
        HostListener('click', ['$event']),
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", [Object]),
        tslib_1.__metadata("design:returntype", void 0)
    ], RufToggleDirective.prototype, "onClick", null);
    tslib_1.__decorate([
        HostListener('keydown', ['$event']),
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", [KeyboardEvent]),
        tslib_1.__metadata("design:returntype", void 0)
    ], RufToggleDirective.prototype, "onKey", null);
    RufToggleDirective = tslib_1.__decorate([
        Directive({
            selector: '[rufToggle], [rufToggleChevron], [rufToggleArrow]',
            exportAs: 'rufToggle'
        }),
        tslib_1.__metadata("design:paramtypes", [ElementRef])
    ], RufToggleDirective);
    return RufToggleDirective;
}(CdkOverlayOrigin));
export { RufToggleDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BydWYvc2hlbGwvIiwic291cmNlcyI6WyJzcmMvdG9nZ2xlL3RvZ2dsZS5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDOUcsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUNyRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUV4RDs7R0FFRztBQUtIO0lBQXdDLDhDQUFnQjtJQXFDdEQsNEJBQW9CLEtBQWlCO1FBQXJDLFlBQ0Usa0JBQU0sS0FBSyxDQUFDLFNBQ2I7UUFGbUIsV0FBSyxHQUFMLEtBQUssQ0FBWTtRQXBDckMsNEVBQTRFO1FBQzVFLDJDQUEyQztRQUNILFdBQUssR0FBRyxLQUFLLENBQUM7UUFFYixhQUFPLEdBQUcsS0FBSyxDQUFDO1FBRWxCLFdBQUssR0FBRyxLQUFLLENBQUM7UUEwQjNDLGtCQUFZLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFFbkMsWUFBTSxHQUFHLElBQUksQ0FBQzs7SUFJL0MsQ0FBQztJQTdCQSxzQkFBSSxzQ0FBTTthQUFWO1lBQ0csT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3BCLENBQUM7OztPQUFBO0lBR0gsc0JBQUkseUNBQVM7YUFBYixVQUFjLEdBQVk7WUFDeEIsSUFBSSxDQUFDLEtBQUssR0FBRyxHQUFHLElBQUksS0FBSyxDQUFDO1FBQzVCLENBQUM7OztPQUFBO0lBR0Qsc0JBQUksZ0RBQWdCO2FBQXBCLFVBQXFCLEdBQVk7WUFDL0IsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7WUFDbkIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENB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QmluZGluZywgSG9zdExpc3RlbmVyLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEVOVEVSLCBTUEFDRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQgeyBDZGtPdmVybGF5T3JpZ2luIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuXG4vKipcbiAqIERpcmVjdGl2ZSB0aGF0IGNhbiBiZSBhcHBsaWVkIG9uIGFueSBlbGVtZW50LCBhbmQgdGhhdCB0b2dnbGVzIGFuIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSB1c2VkIGJ5IHRoZSB1bmRlcmx5aW5nIGVsZW1lbnQgYXMgbmVlZCBiZS5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3J1ZlRvZ2dsZV0sIFtydWZUb2dnbGVDaGV2cm9uXSwgW3J1ZlRvZ2dsZUFycm93XScsXG4gIGV4cG9ydEFzOiAncnVmVG9nZ2xlJ1xufSlcbmV4cG9ydCBjbGFzcyBSdWZUb2dnbGVEaXJlY3RpdmUgZXh0ZW5kcyBDZGtPdmVybGF5T3JpZ2luIHtcbiAgLy8gYm9vbGVhbiBwcm9wZXJ0eSB0aGF0IGdldHMgdG9nZ2xlZCB3aGVuIHRoZSB1bmRlcmx5aW5nIGVsZW1lbnQgaXMgY2xpY2tlZFxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5wdXQtcmVuYW1lXG4gIEBIb3N0QmluZGluZygnY2xhc3MucnVmLXRvZ2dsZS1hY3RpdmUnKSB2YWx1ZSA9IGZhbHNlO1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3MucnVmLXRvZ2dsZS1jaGV2cm9uJykgY2hldnJvbiA9IGZhbHNlO1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3MucnVmLXRvZ2dsZS1hcnJvdycpIGFycm93ID0gZmFsc2U7XG5cbiAgIEBIb3N0QmluZGluZygnY2xhc3MucnVmLWFjdGl2ZScpXG4gICBnZXQgYWN0aXZlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gIEBJbnB1dCgpXG4gIHNldCBydWZUb2dnbGUodmFsOiBib29sZWFuKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbCB8fCBmYWxzZTtcbiAgfVxuXG4gIEBJbnB1dCgpXG4gIHNldCBydWZUb2dnbGVDaGV2cm9uKHZhbDogYm9vbGVhbikge1xuICAgIHRoaXMuYXJyb3cgPSBmYWxzZTtcbiAgICB0aGlzLmNoZXZyb24gPSB0cnVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWwgfHwgZmFsc2U7XG4gIH1cblxuICBASW5wdXQoKVxuICBzZXQgcnVmVG9nZ2xlQXJyb3codmFsOiBib29sZWFuKSB7XG4gICAgdGhpcy5hcnJvdyA9IHRydWU7XG4gICAgdGhpcy5jaGV2cm9uID0gZmFsc2U7XG4gICAgdGhpcy52YWx1ZSA9IHZhbCB8fCBmYWxzZTtcbiAgfVxuXG4gIEBPdXRwdXQoKSB0b2dnbGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5ydWYtdG9nZ2xlJykgdG9nZ2xlID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsUmVmOiBFbGVtZW50UmVmKSB7XG4gICAgc3VwZXIoZWxSZWYpO1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5ydWYtdG9nZ2xlLW5vcm1hbCcpXG4gIGdldCBub3JtYWwoKSB7XG4gICAgcmV0dXJuICF0aGlzLmNoZXZyb24gJiYgIXRoaXMuYXJyb3c7XG4gIH1cblxuICAvLyBzZWxlY3Qgc2hvdWxkIGZvY3VzIHRoZSBlbGVtZW50IGFuZCB0b2dnbGUgdmFsdWVcbiAgc2VsZWN0KGV2ZW50KSB7XG4gICAgdGhpcy5lbFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgdGhpcy50b2dnbGVWYWx1ZShldmVudCk7XG4gIH1cblxuICB0b2dnbGVWYWx1ZShldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy8gRm9yIFNhZmFyaSBicm93c2VyLCBldmVudC5zdG9wUHJvcGFnYXRpb24oKSBpcyBub3Qgc2V0dGluZyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBldmVudC5jYW5jZWxCdWJibGUgYXMgdHJ1ZS4gU28sIHdlIG5lZWQgdG8gZXhwbGljaXRseSBzZXQgaXQuXG4gICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnZhbHVlID0gIXRoaXMudmFsdWU7XG4gICAgdGhpcy50b2dnbGVDaGFuZ2UuZW1pdCh7dHJpZ2dlcjogdGhpcy5lbFJlZiwgdmFsdWU6IHRoaXMudmFsdWUsIGV2ZW50OiBldmVudH0pO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKVxuICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy50b2dnbGVWYWx1ZShldmVudCk7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgb25LZXkoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgRU5URVI6XG4gICAgICBjYXNlIFNQQUNFOlxuICAgICAgICB0aGlzLnRvZ2dsZVZhbHVlKGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxufVxuIl19