import * as tslib_1 from "tslib";
import { Input, Output, EventEmitter, Component, ChangeDetectorRef, ViewEncapsulation, ChangeDetectionStrategy, ElementRef, Renderer2, TemplateRef, ContentChild, ViewChildren, QueryList } from '@angular/core';
import { ENTER, SPACE, ESCAPE } from '@angular/cdk/keycodes';
import { Subscription } from 'rxjs';
import { RufShellIntl } from '../utils/shell-intl';
import { RufMixinBase } from '../common/color/color';
export var RufDynamicNavType;
(function (RufDynamicNavType) {
    RufDynamicNavType["Nav"] = "nav";
    RufDynamicNavType["Tabs"] = "tabs";
})(RufDynamicNavType || (RufDynamicNavType = {}));
var RufDynamicMenubarComponent = /** @class */ (function (_super) {
    tslib_1.__extends(RufDynamicMenubarComponent, _super);
    function RufDynamicMenubarComponent(_elementRef, _renderer, _intl, changeDetectorRef) {
        var _this = _super.call(this, _elementRef) || this;
        _this._elementRef = _elementRef;
        _this._renderer = _renderer;
        _this._intl = _intl;
        _this._isMenuItemClosed = false;
        _this.items = [];
        _this.tabLabels = [];
        _this.tabSubscription = Subscription.EMPTY;
        _this.selectedIndex = 0;
        _this.focusedIndex = 0;
        _this.closedItemIndexLessThanSelectedIndex = false;
        _this.select = new EventEmitter();
        /* tslint:disable:no-output-rename */
        _this.closeEmitter = new EventEmitter();
        _this._intlChanges = _intl.changes.subscribe(function () { return changeDetectorRef.markForCheck(); });
        _this.type = RufDynamicNavType.Nav;
        return _this;
    }
    Object.defineProperty(RufDynamicMenubarComponent.prototype, "closeAriaLabel", {
        get: function () {
            return this._closeAriaLabel || this._intl.dynamicmenubar.aria.closeIconLabel;
        },
        set: function (value) {
            this._closeAriaLabel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RufDynamicMenubarComponent.prototype, "type", {
        get: function () {
            return this._type;
        },
        set: function (value) {
            this._renderer.removeClass(this._elementRef.nativeElement, "ruf-dynamic-" + this._type);
            this._type = value || RufDynamicNavType.Nav;
            this._renderer.addClass(this._elementRef.nativeElement, "ruf-dynamic-" + this._type);
        },
        enumerable: true,
        configurable: true
    });
    RufDynamicMenubarComponent.prototype.ngOnInit = function () {
        // remove the body element from matTabGroup since we are never going to need it.
        var matTabGroupElem = this._elementRef.nativeElement.children[0];
        matTabGroupElem.removeChild(matTabGroupElem.children[1]);
    };
    RufDynamicMenubarComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.tabLabels = this.menuLabels.toArray();
        this.tabSubscription = this.menuLabels.changes.subscribe(function (value) {
            _this.tabLabels = value.toArray();
        });
    };
    RufDynamicMenubarComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes.items && this.selectedIndex > -1 && this.items[this.selectedIndex]) {
            // adding a setTimeout to delay the emil call in order to avoid ExpressionChangedAfterItHasBeenCheckedError
            // need to see if there is a better solution for this
            // https://stackoverflow.com/questions/44070732/angular-4-expressionchangedafterithasbeencheckederror-expression-has-changed
            var indexToSet_1 = this.closedItemIndexLessThanSelectedIndex ? this.selectedIndex - 1 : this.selectedIndex;
            setTimeout(function () {
                _this.onSelect({ index: indexToSet_1 });
            });
            this.closedItemIndexLessThanSelectedIndex = false;
        }
    };
    Object.defineProperty(RufDynamicMenubarComponent.prototype, "selectedPath", {
        get: function () {
            return this._selectedPath;
        },
        set: function (path) {
            var _this = this;
            var e_1, _a;
            if (this.selectedPath === path) {
                return;
            }
            this._selectedPath = path;
            // Check if selectedPath match with any first level items
            var selected = path ? this.items.filter(function (item) { return _this.matches(path, item); }) : null;
            // If selectedPath matches with first level items, first matched item will be selected (and select event emitter will be emitted).
            if (selected && selected.length > 0) {
                if (this.selectedIndex === this.items.indexOf(selected[0])) {
                    setTimeout(function () { return _this.onSelect({ index: _this.selectedIndex }); });
                }
                else {
                    this.selectedIndex = this.items.indexOf(selected[0]);
                }
                return;
            }
            else {
                try {
                    // If selectedPath does not match with any first level item, check if matches with children of each first level item
                    for (var _b = tslib_1.__values(this.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var item = _c.value;
                        if (item.children && item.children.length > 0) {
                            selected = path ? item.children.filter(function (citem) { return _this.matches(path, citem); }) : null;
                            if (selected && selected.length > 0) {
                                // If selectedPath match with child menu, set selectedIndex to Parent and selectedPath to child menu
                                this.onChildSelect(selected[0], item);
                                return;
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            // If selectedPath does not match with first level items as well as child menu,
            // select first item.
            // FIXME: The `ngOnChange` event should take care of this. Currently it only checks for `items` changes.
            setTimeout(function () { return _this.onSelect({ index: 0 }); });
        },
        enumerable: true,
        configurable: true
    });
    RufDynamicMenubarComponent.prototype.isChild = function (parent, childPath) {
        var _this = this;
        if (!childPath || parent.path === childPath) {
            return false;
        }
        var selected = parent.children.filter(function (citem) { return _this.matches(childPath, citem); });
        if (selected && selected.length > 0) {
            return true;
        }
        return false;
    };
    RufDynamicMenubarComponent.prototype.onSelect = function ($event) {
        if (this.items.length > 0) {
            this.selectedIndex = $event.index;
            var selectedItem = this.items[$event.index];
            // SDHTML-18280, SDHTML-18231
            // Focus on the next element after menuitem is closed.
            // We dont need to handle focus on click and enter because focus for those events will be handled by mat-tabs.
            if (this._isMenuItemClosed) {
                this.focusTabOnIndex(this.selectedIndex);
                this._isMenuItemClosed = false;
            }
            // This condition added to avoid select emitter for parent item on selecting child item
            if (selectedItem.children && selectedItem.children.length > 0) {
                if (this.isChild(selectedItem, this._selectedPath)) {
                    return;
                }
                else {
                    selectedItem = selectedItem.children[0];
                }
            }
            this._selectedPath = selectedItem.path;
            this.select.emit(selectedItem);
        }
    };
    RufDynamicMenubarComponent.prototype.onFocusChange = function ($event) {
        this.focusedIndex = $event.index;
    };
    RufDynamicMenubarComponent.prototype.OnSelectFocusedIndex = function (event) {
        this.tabLabels[this.focusedIndex].handleKeydown(event);
    };
    RufDynamicMenubarComponent.prototype.onChildMenuToggle = function (event) {
        if (!event) {
            // this.selectedIndex is used to ensure that it gives focus to parent element
            // when child is selected using mouse click.
            this.focusTabOnIndex(this.selectedIndex);
        }
    };
    RufDynamicMenubarComponent.prototype.onChildSelect = function ($event, item) {
        this.selectedIndex = this.items.indexOf(item);
        this._selectedPath = $event.path;
        this.select.emit($event);
    };
    RufDynamicMenubarComponent.prototype.matches = function (path, item) {
        if (path && item.path) {
            if (path === item.path) {
                return true;
            }
        }
        return false;
    };
    RufDynamicMenubarComponent.prototype.close = function (item) {
        // check if the index of the item being closed is smaller than the item that is currently selected
        // if it is, and if the user actually closes the tab - we'll have to set the selectedIndex to selectedIndex - 1
        // otherwise the selectedItem will change
        // See https://etojira.fnfis.com/browse/SDHTML-16688 for details
        this.closedItemIndexLessThanSelectedIndex = false;
        if (this.items.indexOf(item) < this.selectedIndex) {
            this.closedItemIndexLessThanSelectedIndex = true;
        }
        this._isMenuItemClosed = true;
        this.closeEmitter.emit(item);
    };
    RufDynamicMenubarComponent.prototype.focusTabOnIndex = function (index) {
        this._elementRef.nativeElement.getElementsByClassName('mat-tab-label')[index].focus();
    };
    RufDynamicMenubarComponent.prototype._handleKeydown = function (event, item) {
        switch (event.keyCode) {
            case ENTER:
            case SPACE:
                this.close(item);
                event.stopPropagation();
                break;
            case ESCAPE:
                this.focusTabOnIndex(this.focusedIndex);
                event.stopPropagation();
                break;
            default:
        }
    };
    RufDynamicMenubarComponent.prototype.ngOnDestroy = function () {
        this._intlChanges.unsubscribe();
        this.tabSubscription.unsubscribe();
    };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Array)
    ], RufDynamicMenubarComponent.prototype, "items", void 0);
    tslib_1.__decorate([
        ViewChildren('menuLabel'),
        tslib_1.__metadata("design:type", QueryList)
    ], RufDynamicMenubarComponent.prototype, "menuLabels", void 0);
    tslib_1.__decorate([
        Input('activeColor'),
        tslib_1.__metadata("design:type", Object)
    ], RufDynamicMenubarComponent.prototype, "color", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], RufDynamicMenubarComponent.prototype, "closeAriaLabel", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], RufDynamicMenubarComponent.prototype, "type", null);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", Object)
    ], RufDynamicMenubarComponent.prototype, "select", void 0);
    tslib_1.__decorate([
        Output('close'),
        tslib_1.__metadata("design:type", Object)
    ], RufDynamicMenubarComponent.prototype, "closeEmitter", void 0);
    tslib_1.__decorate([
        ContentChild(TemplateRef, { static: false }),
        tslib_1.__metadata("design:type", Object)
    ], RufDynamicMenubarComponent.prototype, "navActions", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], RufDynamicMenubarComponent.prototype, "selectedPath", null);
    RufDynamicMenubarComponent = tslib_1.__decorate([
        Component({
            selector: 'ruf-dynamic-menubar',
            template: "<mat-tab-group rufId [selectedIndex]=\"selectedIndex\" (selectedTabChange)=\"onSelect($event)\" (focusChange)=\"onFocusChange($event)\" (keydown.enter)=\"OnSelectFocusedIndex($event)\" (keydown.space)=\"OnSelectFocusedIndex($event)\">\n  <mat-tab rufId *ngFor=\"let item of items;let currentIndex=index\">\n    <ng-template matTabLabel>\n      <ruf-menu-label #menuLabel rufId [label]=\"item.label\" [icon]=\"item.icon\" [children]=\"item.children\"\n                      (select)=\"onChildSelect($event, item)\"\n                      (toggle)=\"onChildMenuToggle($event)\"\n                      [selectedPath]=\"selectedPath\">\n        <ng-template [ngTemplateOutlet]=\"navActions\" [ngTemplateOutletContext]=\"{item: item}\">\n        </ng-template>\n        <button type=\"button\" mat-icon-button rufId=\"dynamic_menubar_close_icon\" fisStyle class=\"ruf-close\" [attr.tabindex]=\"focusedIndex === currentIndex ? 0 : -1\" *ngIf=\"item.closeable === true\" (keydown)=\"_handleKeydown($event, item)\" (click)=\"close(item)\" role=\"button\" [attr.aria-label]=\"closeAriaLabel\">\n          <mat-icon fisIcon=\"close\" class=\"fis-icon-xs\"></mat-icon>\n        </button>\n      </ruf-menu-label>\n    </ng-template>\n  </mat-tab>\n</mat-tab-group>\n\n",
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: ["ruf-dynamic-menubar{-webkit-box-flex:1;flex-grow:1;overflow:hidden}ruf-dynamic-menubar.ruf-dynamic-menubar-flex-height .mat-tab-labels>.mat-tab-label{height:inherit}ruf-dynamic-menubar .mat-tab-labels>.mat-tab-label{height:2.75rem;min-width:48px;padding-left:.9375rem;padding-right:.9375rem}ruf-dynamic-menubar .mat-tab-header{border:0}ruf-dynamic-menubar .ruf-menu-label-trigger{margin-left:-.9375rem;margin-right:-.9375rem}ruf-menu-label .ruf-close.mat-icon-button[fisStyle]{margin-left:.3125rem;padding:1px 3px;-webkit-transition:text-shadow .1s ease-in,color .1s ease-in;transition:text-shadow .1s ease-in,color .1s ease-in}ruf-menu-label .ruf-close.mat-icon-button[fisStyle]:hover{text-shadow:1px 0 0}"]
        }),
        tslib_1.__metadata("design:paramtypes", [ElementRef,
            Renderer2,
            RufShellIntl,
            ChangeDetectorRef])
    ], RufDynamicMenubarComponent);
    return RufDynamicMenubarComponent;
}(RufMixinBase));
export { RufDynamicMenubarComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy1tZW51YmFyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BydWYvc2hlbGwvIiwic291cmNlcyI6WyJzcmMvZHluYW1pYy1tZW51YmFyL2R5bmFtaWMtbWVudWJhci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFFTCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixTQUFTLEVBQ1QsaUJBQWlCLEVBQ2pCLGlCQUFpQixFQUNqQix1QkFBdUIsRUFDdkIsVUFBVSxFQUNWLFNBQVMsRUFLVCxXQUFXLEVBQ1gsWUFBWSxFQUNaLFlBQVksRUFDWixTQUFTLEVBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDN0QsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNwQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFHbkQsT0FBTyxFQUFnQixZQUFZLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUVuRSxNQUFNLENBQU4sSUFBWSxpQkFHWDtBQUhELFdBQVksaUJBQWlCO0lBQzNCLGdDQUFXLENBQUE7SUFDWCxrQ0FBYSxDQUFBO0FBQ2YsQ0FBQyxFQUhXLGlCQUFpQixLQUFqQixpQkFBaUIsUUFHNUI7QUFTRDtJQUFnRCxzREFBWTtJQTBDMUQsb0NBQW1CLFdBQXVCLEVBQ3BCLFNBQW9CLEVBQ3RCLEtBQW1CLEVBQzNCLGlCQUFvQztRQUhoRCxZQUlJLGtCQUFNLFdBQVcsQ0FBQyxTQUdyQjtRQVBrQixpQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQUNwQixlQUFTLEdBQVQsU0FBUyxDQUFXO1FBQ3RCLFdBQUssR0FBTCxLQUFLLENBQWM7UUExQy9CLHVCQUFpQixHQUFHLEtBQUssQ0FBQztRQUl6QixXQUFLLEdBQTRCLEVBQUUsQ0FBQztRQUc3QyxlQUFT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O0lBakhVLDBCQUEwQjtRQVB0QyxTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUscUJBQXFCO1lBQy9CLHF2Q0FBK0M7WUFFL0MsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7WUFDckMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07O1NBQ2hELENBQUM7aURBMkNnQyxVQUFVO1lBQ1QsU0FBUztZQUNmLFlBQVk7WUFDUixpQkFBaUI7T0E3Q3JDLDBCQUEwQixDQTZOdEM7SUFBRCxpQ0FBQztDQUFBLEFBN05ELENBQWdELFlBQVksR0E2TjNEO1NBN05ZLDBCQUEwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlcixcbiAgQ29tcG9uZW50LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBFbGVtZW50UmVmLFxuICBSZW5kZXJlcjIsXG4gIE9uSW5pdCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIFNpbXBsZUNoYW5nZXMsXG4gIFRlbXBsYXRlUmVmLFxuICBDb250ZW50Q2hpbGQsXG4gIFZpZXdDaGlsZHJlbixcbiAgUXVlcnlMaXN0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBFTlRFUiwgU1BBQ0UsIEVTQ0FQRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFJ1ZlNoZWxsSW50bCB9IGZyb20gJy4uL3V0aWxzL3NoZWxsLWludGwnO1xuaW1wb3J0IHsgUnVmRHluYW1pY01lbnViYXJJdGVtIH0gZnJvbSAnLi9keW5hbWljLW1lbnViYXItaXRlbSc7XG5pbXBvcnQgeyBSdWZNZW51TGFiZWxDb21wb25lbnQgfSBmcm9tICcuLi9tZW51LWxhYmVsL21lbnUtbGFiZWwuY29tcG9uZW50JztcbmltcG9ydCB7ICBSdWZDYW5Db2xvciwgUnVmTWl4aW5CYXNlIH0gZnJvbSAnLi4vY29tbW9uL2NvbG9yL2NvbG9yJztcblxuZXhwb3J0IGVudW0gUnVmRHluYW1pY05hdlR5cGUge1xuICBOYXYgPSAnbmF2JyxcbiAgVGFicyA9ICd0YWJzJ1xufVxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdydWYtZHluYW1pYy1tZW51YmFyJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2R5bmFtaWMtbWVudWJhci5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL2R5bmFtaWMtbWVudWJhci5jb21wb25lbnQuc2NzcyddLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBSdWZEeW5hbWljTWVudWJhckNvbXBvbmVudCBleHRlbmRzIFJ1Zk1peGluQmFzZVxuICAgICAgICAgIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgUnVmQ2FuQ29sb3Ige1xuICBwcml2YXRlIF9pc01lbnVJdGVtQ2xvc2VkID0gZmFsc2U7XG4gIHByaXZhdGUgX2ludGxDaGFuZ2VzOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgX2Nsb3NlQXJpYUxhYmVsOiBzdHJpbmc7XG4gIHByaXZhdGUgX3R5cGU6IFJ1ZkR5bmFtaWNOYXZUeXBlO1xuICBASW5wdXQoKSBpdGVtczogUnVmRHluYW1pY01lbnViYXJJdGVtW10gPSBbXTtcbiAgcHJpdmF0ZSBfc2VsZWN0ZWRQYXRoOiBzdHJpbmc7XG4gIEBWaWV3Q2hpbGRyZW4oJ21lbnVMYWJlbCcpIG1lbnVMYWJlbHM6IFF1ZXJ5TGlzdDxSdWZNZW51TGFiZWxDb21wb25lbnQ+O1xuICB0YWJMYWJlbHMgPSBbXTtcbiAgcHJpdmF0ZSB0YWJTdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG5cbiAgLyogdHNsaW50OmRpc2FibGU6bm8taW5wdXQtcmVuYW1lICovXG4gIEBJbnB1dCgnYWN0aXZlQ29sb3InKSBjb2xvcjtcblxuICBASW5wdXQoKVxuICBnZXQgY2xvc2VBcmlhTGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb3NlQXJpYUxhYmVsIHx8IHRoaXMuX2ludGwuZHluYW1pY21lbnViYXIuYXJpYS5jbG9zZUljb25MYWJlbDtcbiAgfVxuICBzZXQgY2xvc2VBcmlhTGFiZWwodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX2Nsb3NlQXJpYUxhYmVsID0gdmFsdWU7XG4gIH1cbiAgQElucHV0KClcbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gIH1cbiAgc2V0IHR5cGUodmFsdWU6IFJ1ZkR5bmFtaWNOYXZUeXBlKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBgcnVmLWR5bmFtaWMtJHt0aGlzLl90eXBlfWApO1xuICAgIHRoaXMuX3R5cGUgPSB2YWx1ZSB8fCBSdWZEeW5hbWljTmF2VHlwZS5OYXY7XG4gICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBgcnVmLWR5bmFtaWMtJHt0aGlzLl90eXBlfWApXG4gIH1cblxuICBzZWxlY3RlZEluZGV4ID0gMDtcbiAgZm9jdXNlZEluZGV4ID0gMDtcbiAgY2xvc2VkSXRlbUluZGV4TGVzc1RoYW5TZWxlY3RlZEluZGV4ID0gZmFsc2U7XG5cbiAgQE91dHB1dCgpIHNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXI8UnVmRHluYW1pY01lbnViYXJJdGVtPigpO1xuXG4gIC8qIHRzbGludDpkaXNhYmxlOm5vLW91dHB1dC1yZW5hbWUgKi9cbiAgQE91dHB1dCgnY2xvc2UnKSBjbG9zZUVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPFJ1ZkR5bmFtaWNNZW51YmFySXRlbT4oKTtcbiAgQENvbnRlbnRDaGlsZChUZW1wbGF0ZVJlZiwge3N0YXRpYzogZmFsc2V9KSBuYXZBY3Rpb25zO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgcHJvdGVjdGVkIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICAgICAgICBwcml2YXRlIF9pbnRsOiBSdWZTaGVsbEludGwsXG4gICAgICAgICAgICAgIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICAgICAgc3VwZXIoX2VsZW1lbnRSZWYpO1xuICAgICAgdGhpcy5faW50bENoYW5nZXMgPSBfaW50bC5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiBjaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKSk7XG4gICAgICB0aGlzLnR5cGUgPSBSdWZEeW5hbWljTmF2VHlwZS5OYXY7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICAvLyByZW1vdmUgdGhlIGJvZHkgZWxlbWVudCBmcm9tIG1hdFRhYkdyb3VwIHNpbmNlIHdlIGFyZSBuZXZlciBnb2luZyB0byBuZWVkIGl0LlxuICAgIGNvbnN0IG1hdFRhYkdyb3VwRWxlbSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXTtcbiAgICBtYXRUYWJHcm91cEVsZW0ucmVtb3ZlQ2hpbGQobWF0VGFiR3JvdXBFbGVtLmNoaWxkcmVuWzFdKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLnRhYkxhYmVscyA9IHRoaXMubWVudUxhYmVscy50b0FycmF5KCk7XG4gICAgdGhpcy50YWJTdWJzY3JpcHRpb24gPSB0aGlzLm1lbnVMYWJlbHMuY2hhbmdlcy5zdWJzY3JpYmUoICh2YWx1ZSkgPT4ge1xuICAgICAgdGhpcy50YWJMYWJlbHMgPSB2YWx1ZS50b0FycmF5KCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKGNoYW5nZXMuaXRlbXMgJiYgdGhpcy5zZWxlY3RlZEluZGV4ID4gLTEgJiYgdGhpcy5pdGVtc1t0aGlzLnNlbGVjdGVkSW5kZXhdKSB7XG4gICAgICAvLyBhZGRpbmcgYSBzZXRUaW1lb3V0IHRvIGRlbGF5IHRoZSBlbWlsIGNhbGwgaW4gb3JkZXIgdG8gYXZvaWQgRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvclxuICAgICAgLy8gbmVlZCB0byBzZWUgaWYgdGhlcmUgaXMgYSBiZXR0ZXIgc29sdXRpb24gZm9yIHRoaXNcbiAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ0MDcwNzMyL2FuZ3VsYXItNC1leHByZXNzaW9uY2hhbmdlZGFmdGVyaXRoYXNiZWVuY2hlY2tlZGVycm9yLWV4cHJlc3Npb24taGFzLWNoYW5nZWRcbiAgICAgIGNvbnN0IGluZGV4VG9TZXQgPSB0aGlzLmNsb3NlZEl0ZW1JbmRleExlc3NUaGFuU2VsZWN0ZWRJbmRleCA/IHRoaXMuc2VsZWN0ZWRJbmRleCAtIDEgOiB0aGlzLnNlbGVjdGVkSW5kZXg7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5vblNlbGVjdCh7IGluZGV4OiBpbmRleFRvU2V0IH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNsb3NlZEl0ZW1JbmRleExlc3NUaGFuU2VsZWN0ZWRJbmRleCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIEBJbnB1dCgpXG4gIHNldCBzZWxlY3RlZFBhdGgocGF0aDogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRQYXRoID09PSBwYXRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc2VsZWN0ZWRQYXRoID0gcGF0aDtcblxuICAgIC8vIENoZWNrIGlmIHNlbGVjdGVkUGF0aCBtYXRjaCB3aXRoIGFueSBmaXJzdCBsZXZlbCBpdGVtc1xuICAgIGxldCBzZWxlY3RlZCA9IHBhdGggPyB0aGlzLml0ZW1zLmZpbHRlcihpdGVtID0+IHRoaXMubWF0Y2hlcyhwYXRoLCBpdGVtKSkgOiBudWxsO1xuXG4gICAgLy8gSWYgc2VsZWN0ZWRQYXRoIG1hdGNoZXMgd2l0aCBmaXJzdCBsZXZlbCBpdGVtcywgZmlyc3QgbWF0Y2hlZCBpdGVtIHdpbGwgYmUgc2VsZWN0ZWQgKGFuZCBzZWxlY3QgZXZlbnQgZW1pdHRlciB3aWxsIGJlIGVtaXR0ZWQpLlxuICAgIGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ID09PSB0aGlzLml0ZW1zLmluZGV4T2Yoc2VsZWN0ZWRbMF0pKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5vblNlbGVjdCh7IGluZGV4OiB0aGlzLnNlbGVjdGVkSW5kZXggfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdGhpcy5pdGVtcy5pbmRleE9mKHNlbGVjdGVkWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgc2VsZWN0ZWRQYXRoIGRvZXMgbm90IG1hdGNoIHdpdGggYW55IGZpcnN0IGxldmVsIGl0ZW0sIGNoZWNrIGlmIG1hdGNoZXMgd2l0aCBjaGlsZHJlbiBvZiBlYWNoIGZpcnN0IGxldmVsIGl0ZW1cbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgIGlmIChpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNlbGVjdGVkID0gcGF0aCA/IGl0ZW0uY2hpbGRyZW4uZmlsdGVyKGNpdGVtID0+IHRoaXMubWF0Y2hlcyhwYXRoLCBjaXRlbSkpIDogbnVsbDtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgc2VsZWN0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgc2VsZWN0ZWRQYXRoIG1hdGNoIHdpdGggY2hpbGQgbWVudSwgc2V0IHNlbGVjdGVkSW5kZXggdG8gUGFyZW50IGFuZCBzZWxlY3RlZFBhdGggdG8gY2hpbGQgbWVudVxuICAgICAgICAgICAgdGhpcy5vbkNoaWxkU2VsZWN0KHNlbGVjdGVkWzBdLCBpdGVtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgc2VsZWN0ZWRQYXRoIGRvZXMgbm90IG1hdGNoIHdpdGggZmlyc3QgbGV2ZWwgaXRlbXMgYXMgd2VsbCBhcyBjaGlsZCBtZW51LFxuICAgIC8vIHNlbGVjdCBmaXJzdCBpdGVtLlxuICAgIC8vIEZJWE1FOiBUaGUgYG5nT25DaGFuZ2VgIGV2ZW50IHNob3VsZCB0YWtlIGNhcmUgb2YgdGhpcy4gQ3VycmVudGx5IGl0IG9ubHkgY2hlY2tzIGZvciBgaXRlbXNgIGNoYW5nZXMuXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLm9uU2VsZWN0KHsgaW5kZXg6IDAgfSkpO1xuICB9XG5cbiAgZ2V0IHNlbGVjdGVkUGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRQYXRoO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0NoaWxkKHBhcmVudDogUnVmRHluYW1pY01lbnViYXJJdGVtLCBjaGlsZFBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghY2hpbGRQYXRoIHx8IHBhcmVudC5wYXRoID09PSBjaGlsZFBhdGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBwYXJlbnQuY2hpbGRyZW4uZmlsdGVyKGNpdGVtID0+IHRoaXMubWF0Y2hlcyhjaGlsZFBhdGgsIGNpdGVtKSk7XG4gICAgaWYgKHNlbGVjdGVkICYmIHNlbGVjdGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBvblNlbGVjdCgkZXZlbnQpIHtcbiAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAkZXZlbnQuaW5kZXg7XG4gICAgICBsZXQgc2VsZWN0ZWRJdGVtID0gdGhpcy5pdGVtc1skZXZlbnQuaW5kZXhdO1xuICAgICAgLy8gU0RIVE1MLTE4MjgwLCBTREhUTUwtMTgyMzFcbiAgICAgIC8vIEZvY3VzIG9uIHRoZSBuZXh0IGVsZW1lbnQgYWZ0ZXIgbWVudWl0ZW0gaXMgY2xvc2VkLlxuICAgICAgLy8gV2UgZG9udCBuZWVkIHRvIGhhbmRsZSBmb2N1cyBvbiBjbGljayBhbmQgZW50ZXIgYmVjYXVzZSBmb2N1cyBmb3IgdGhvc2UgZXZlbnRzIHdpbGwgYmUgaGFuZGxlZCBieSBtYXQtdGFicy5cbiAgICAgIGlmICh0aGlzLl9pc01lbnVJdGVtQ2xvc2VkKSB7XG4gICAgICAgIHRoaXMuZm9jdXNUYWJPbkluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleCk7XG4gICAgICAgIHRoaXMuX2lzTWVudUl0ZW1DbG9zZWQgPSBmYWxzZTtcbiAgICAgICB9XG4gICAgICAvLyBUaGlzIGNvbmRpdGlvbiBhZGRlZCB0byBhdm9pZCBzZWxlY3QgZW1pdHRlciBmb3IgcGFyZW50IGl0ZW0gb24gc2VsZWN0aW5nIGNoaWxkIGl0ZW1cbiAgICAgIGlmIChzZWxlY3RlZEl0ZW0uY2hpbGRyZW4gJiYgc2VsZWN0ZWRJdGVtLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDaGlsZChzZWxlY3RlZEl0ZW0sIHRoaXMuX3NlbGVjdGVkUGF0aCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0ZWRJdGVtID0gc2VsZWN0ZWRJdGVtLmNoaWxkcmVuWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9zZWxlY3RlZFBhdGggPSBzZWxlY3RlZEl0ZW0ucGF0aDtcbiAgICAgIHRoaXMuc2VsZWN0LmVtaXQoc2VsZWN0ZWRJdGVtKTtcbiAgICB9XG4gIH1cblxuICBvbkZvY3VzQ2hhbmdlKCRldmVudCkge1xuICAgIHRoaXMuZm9jdXNlZEluZGV4ID0gJGV2ZW50LmluZGV4O1xuICB9XG5cbiAgT25TZWxlY3RGb2N1c2VkSW5kZXgoZXZlbnQpIHtcbiAgICB0aGlzLnRhYkxhYmVsc1t0aGlzLmZvY3VzZWRJbmRleF0uaGFuZGxlS2V5ZG93bihldmVudCk7XG4gIH1cblxuICBvbkNoaWxkTWVudVRvZ2dsZShldmVudCkge1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIC8vIHRoaXMuc2VsZWN0ZWRJbmRleCBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IGl0IGdpdmVzIGZvY3VzIHRvIHBhcmVudCBlbGVtZW50XG4gICAgICAvLyB3aGVuIGNoaWxkIGlzIHNlbGVjdGVkIHVzaW5nIG1vdXNlIGNsaWNrLlxuICAgICAgdGhpcy5mb2N1c1RhYk9uSW5kZXgodGhpcy5zZWxlY3RlZEluZGV4KTtcbiAgICB9XG4gIH1cblxuICBvbkNoaWxkU2VsZWN0KCRldmVudCwgaXRlbSkge1xuICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICB0aGlzLl9zZWxlY3RlZFBhdGggPSAkZXZlbnQucGF0aDtcbiAgICB0aGlzLnNlbGVjdC5lbWl0KCRldmVudCk7XG4gIH1cblxuICBwcml2YXRlIG1hdGNoZXMocGF0aDogc3RyaW5nLCBpdGVtOiBSdWZEeW5hbWljTWVudWJhckl0ZW0pIHtcbiAgICBpZiAocGF0aCAmJiBpdGVtLnBhdGgpIHtcbiAgICAgIGlmIChwYXRoID09PSBpdGVtLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNsb3NlKGl0ZW0pIHtcbiAgICAvLyBjaGVjayBpZiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gYmVpbmcgY2xvc2VkIGlzIHNtYWxsZXIgdGhhbiB0aGUgaXRlbSB0aGF0IGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgIC8vIGlmIGl0IGlzLCBhbmQgaWYgdGhlIHVzZXIgYWN0dWFsbHkgY2xvc2VzIHRoZSB0YWIgLSB3ZSdsbCBoYXZlIHRvIHNldCB0aGUgc2VsZWN0ZWRJbmRleCB0byBzZWxlY3RlZEluZGV4IC0gMVxuICAgIC8vIG90aGVyd2lzZSB0aGUgc2VsZWN0ZWRJdGVtIHdpbGwgY2hhbmdlXG4gICAgLy8gU2VlIGh0dHBzOi8vZXRvamlyYS5mbmZpcy5jb20vYnJvd3NlL1NESFRNTC0xNjY4OCBmb3IgZGV0YWlsc1xuICAgIHRoaXMuY2xvc2VkSXRlbUluZGV4TGVzc1RoYW5TZWxlY3RlZEluZGV4ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKSA8IHRoaXMuc2VsZWN0ZWRJbmRleCkge1xuICAgICAgdGhpcy5jbG9zZWRJdGVtSW5kZXhMZXNzVGhhblNlbGVjdGVkSW5kZXggPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9pc01lbnVJdGVtQ2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLmNsb3NlRW1pdHRlci5lbWl0KGl0ZW0pO1xuICB9XG5cbiAgZm9jdXNUYWJPbkluZGV4KGluZGV4KSB7XG4gICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21hdC10YWItbGFiZWwnKVtpbmRleF0uZm9jdXMoKTtcbiAgfVxuXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBpdGVtOiBhbnkpIHtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgRU5URVI6XG4gICAgICBjYXNlIFNQQUNFOlxuICAgICAgICB0aGlzLmNsb3NlKGl0ZW0pO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVTQ0FQRTpcbiAgICAgICAgdGhpcy5mb2N1c1RhYk9uSW5kZXgodGhpcy5mb2N1c2VkSW5kZXgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2ludGxDaGFuZ2VzLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy50YWJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIl19