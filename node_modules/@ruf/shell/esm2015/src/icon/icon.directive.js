import * as tslib_1 from "tslib";
import { MatIcon } from '@angular/material/icon';
import { Directive, Self, Optional, Input, SimpleChange } from '@angular/core';
let RufIconDirective = class RufIconDirective {
    constructor(matIcon) {
        this.matIcon = matIcon;
        this.icon = '';
    }
    set fisIcon(val) {
        this.icon = val || '';
    }
    set rufIcon(val) {
        this.icon = val || '';
    }
    ngOnChanges(changes) {
        // the matIcon is intentionally left unchanged if fisIcon or rufIcon is set to empty:
        // it is assumed that fontSet and fontIcon are changed appropriately.
        if (this.matIcon &&
            ((changes.fisIcon && changes.fisIcon.currentValue) ||
                (changes.rufIcon && changes.rufIcon.currentValue))) {
            const currentIcon = changes.fisIcon ? changes.fisIcon.currentValue : changes.rufIcon.currentValue;
            this.matIcon.fontSet = 'fisfont';
            this.matIcon.fontIcon = 'fis-icon-' + currentIcon;
            const chg = new SimpleChange('', this.matIcon.fontIcon, true);
            this.matIcon.ngOnChanges({ fontIcon: chg });
        }
    }
};
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], RufIconDirective.prototype, "fisIcon", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], RufIconDirective.prototype, "rufIcon", null);
RufIconDirective = tslib_1.__decorate([
    Directive({ selector: '[fisIcon], [rufIcon]' }),
    tslib_1.__param(0, Self()),
    tslib_1.__param(0, Optional()),
    tslib_1.__metadata("design:paramtypes", [MatIcon])
], RufIconDirective);
export { RufIconDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AcnVmL3NoZWxsLyIsInNvdXJjZXMiOlsic3JjL2ljb24vaWNvbi5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQVUsS0FBSyxFQUFFLFlBQVksRUFBNEIsTUFBTSxlQUFlLENBQUM7QUFHakgsSUFBYSxnQkFBZ0IsR0FBN0IsTUFBYSxnQkFBZ0I7SUFhM0IsWUFHVSxPQUFnQjtRQUFoQixZQUFPLEdBQVAsT0FBTyxDQUFTO1FBZjFCLFNBQUksR0FBRyxFQUFFLENBQUM7SUFnQlAsQ0FBQztJQWJKLElBQUksT0FBTyxDQUFDLEdBQVc7UUFDckIsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLElBQUksRUFBRSxDQUFDO0lBQ3hCLENBQUM7SUFHRCxJQUFJLE9BQU8sQ0FBQyxHQUFXO1FBQ3JCLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxJQUFJLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBUUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLHFGQUFxRjtRQUNyRixxRUFBcUU7UUFDckUsSUFBSSxJQUFJLENBQUMsT0FBTztZQUNkLENBQ0UsQ0FBQyxPQUFPLENBQUMsT0FBTyxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDO2dCQUNqRCxDQUFDLE9BQU8sQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FDbEQsRUFBRTtZQUNILE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQztZQUNsRyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUM7WUFDakMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsV0FBVyxHQUFHLFdBQVcsQ0FBQztZQUNsRCxNQUFNLEdBQUcsR0FBRyxJQUFJLFlBQVksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDOUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztTQUM3QztJQUNILENBQUM7Q0FDRixDQUFBO0FBOUJDO0lBREMsS0FBSyxFQUFFOzs7K0NBR1A7QUFHRDtJQURDLEtBQUssRUFBRTs7OytDQUdQO0FBWFUsZ0JBQWdCO0lBRDVCLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxzQkFBc0IsRUFBRSxDQUFDO0lBZTNDLG1CQUFBLElBQUksRUFBRSxDQUFBO0lBQ04sbUJBQUEsUUFBUSxFQUFFLENBQUE7NkNBQ00sT0FBTztHQWhCZixnQkFBZ0IsQ0FrQzVCO1NBbENZLGdCQUFnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdEljb24gfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9pY29uJztcbmltcG9ydCB7IERpcmVjdGl2ZSwgU2VsZiwgT3B0aW9uYWwsIE9uSW5pdCwgSW5wdXQsIFNpbXBsZUNoYW5nZSwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tmaXNJY29uXSwgW3J1Zkljb25dJyB9KVxuZXhwb3J0IGNsYXNzIFJ1Zkljb25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBpY29uID0gJyc7XG5cbiAgQElucHV0KClcbiAgc2V0IGZpc0ljb24odmFsOiBzdHJpbmcpIHtcbiAgICB0aGlzLmljb24gPSB2YWwgfHwgJyc7XG4gIH1cblxuICBASW5wdXQoKVxuICBzZXQgcnVmSWNvbih2YWw6IHN0cmluZykge1xuICAgIHRoaXMuaWNvbiA9IHZhbCB8fCAnJztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIHByaXZhdGUgbWF0SWNvbjogTWF0SWNvblxuICApIHt9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIC8vIHRoZSBtYXRJY29uIGlzIGludGVudGlvbmFsbHkgbGVmdCB1bmNoYW5nZWQgaWYgZmlzSWNvbiBvciBydWZJY29uIGlzIHNldCB0byBlbXB0eTpcbiAgICAvLyBpdCBpcyBhc3N1bWVkIHRoYXQgZm9udFNldCBhbmQgZm9udEljb24gYXJlIGNoYW5nZWQgYXBwcm9wcmlhdGVseS5cbiAgICBpZiAodGhpcy5tYXRJY29uICYmXG4gICAgICAoXG4gICAgICAgIChjaGFuZ2VzLmZpc0ljb24gJiYgY2hhbmdlcy5maXNJY29uLmN1cnJlbnRWYWx1ZSkgfHxcbiAgICAgICAgKGNoYW5nZXMucnVmSWNvbiAmJiBjaGFuZ2VzLnJ1Zkljb24uY3VycmVudFZhbHVlKVxuICAgICAgKSkge1xuICAgICAgY29uc3QgY3VycmVudEljb24gPSBjaGFuZ2VzLmZpc0ljb24gPyBjaGFuZ2VzLmZpc0ljb24uY3VycmVudFZhbHVlIDogY2hhbmdlcy5ydWZJY29uLmN1cnJlbnRWYWx1ZTtcbiAgICAgIHRoaXMubWF0SWNvbi5mb250U2V0ID0gJ2Zpc2ZvbnQnO1xuICAgICAgdGhpcy5tYXRJY29uLmZvbnRJY29uID0gJ2Zpcy1pY29uLScgKyBjdXJyZW50SWNvbjtcbiAgICAgIGNvbnN0IGNoZyA9IG5ldyBTaW1wbGVDaGFuZ2UoJycsIHRoaXMubWF0SWNvbi5mb250SWNvbiwgdHJ1ZSk7XG4gICAgICB0aGlzLm1hdEljb24ubmdPbkNoYW5nZXMoeyBmb250SWNvbjogY2hnIH0pO1xuICAgIH1cbiAgfVxufVxuIl19