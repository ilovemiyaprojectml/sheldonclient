export class RufMDIStrategy {
    constructor(util) {
        this.util = util;
        this.handlers = {};
    }
    /**
     * Decides when the route should be stored
     * @param route the route that the user is currently on
     * @returns boolean indicating whether the route should or should not be stored
     */
    shouldDetach(route) {
        return true;
    }
    /**
     * Stores the complete route path and its component state (as ComponentRef) for later attachment
     * @param route This is stored for later comparison to requested routes, see `this.shouldAttach`
     * @param handle A DetachedRouteHandle which is later retrieved by this.retrieve to restore state
     */
    store(route, handle) {
        const path = this.util.getLeafNodePath(route);
        // path is '' when route has loadChildren.
        if (path) {
            if (route.component) {
                this.handlers[path] = handle;
            }
            // route does not have component. this means it is a parent route like ruf/shell/banner or ruf/shell/layout.
            // In this case, previously stored leaf node handler should be re-stored.
            if (!route.component && handle) {
                // This condition is when parent route is being stored but it's the child route whose reference needs to be stored instead.
                // In this case, retrieve the component ref from RufRouterUtilService and create a new DetachedRouteHandle.
                this.handlers[path] = {
                    componentRef: this.util.getComponentRef(path),
                    route: this.util.getLeafNode(handle['route'])
                };
            }
        }
    }
    /**
     * Determines whether there is a stored route and, if yes, should it be rendered in place of requested route
     * @param route The route the user requested
     * @returns boolean indicating whether or not to render the stored route
     */
    shouldAttach(route) {
        const path = this.util.getLeafNodePath(route);
        return !!route.routeConfig && !!this.handlers[path];
    }
    /**
     * Finds the locally stored instance of the requested route and returns it if it exists
     * @param route New route the user has requested
     * @returns DetachedRouteHandle object which can be used to render the component
     */
    retrieve(route) {
        if (!route.routeConfig) {
            return null;
        }
        if (route.routeConfig.loadChildren) {
            return null;
        }
        return this.handlers[this.util.fullPath(route)];
    }
    /**
     * Determines whether or not the current route should be reused
     * @param future The route the user is navigating to as triggered by the router
     * @param curr The route the user is currently on
     * @returns boolean indicating true if the user intends to leave the current route
     */
    shouldReuseRoute(future, curr) {
        return ((future.routeConfig === curr.routeConfig) &&
            (JSON.stringify(future.params) === JSON.stringify(curr.params)));
    }
    /**
     *  Remove component reference from handlers.
     *  Destroy the route component
     *  @param path The key against which DetachedRouteHandle with component reference is stored for detached route
     */
    destroy(path) {
        if (this.handlers[path] && this.util.getComponentRef(path)) {
            this.util.getComponentRef(path).destroy();
            delete this.handlers[path];
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWRpLXN0cmF0ZWd5LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHJ1Zi9zaGVsbC8iLCJzb3VyY2VzIjpbInNyYy9yb3V0ZXIvbWRpLXN0cmF0ZWd5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUtBLE1BQU0sT0FBTyxjQUFjO0lBR3pCLFlBQXNCLElBQTBCO1FBQTFCLFNBQUksR0FBSixJQUFJLENBQXNCO1FBRnhDLGFBQVEsR0FBMkMsRUFBRSxDQUFDO0lBRVgsQ0FBQztJQUVwRDs7OztPQUlHO0lBQ0gsWUFBWSxDQUFDLEtBQTZCO1FBQ3hDLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsS0FBNkIsRUFBRSxNQUEyQjtRQUM5RCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5QywwQ0FBMEM7UUFDMUMsSUFBSSxJQUFJLEVBQUU7WUFDUixJQUFJLEtBQUssQ0FBQyxTQUFTLEVBQUU7Z0JBQ25CLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDO2FBQzlCO1lBQ0QsNEdBQTRHO1lBQzVHLHlFQUF5RTtZQUN6RSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsSUFBSSxNQUFNLEVBQUU7Z0JBQzlCLDJIQUEySDtnQkFDM0gsMkdBQTJHO2dCQUMzRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHO29CQUNwQixZQUFZLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDO29CQUM3QyxLQUFLLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2lCQUM5QyxDQUFDO2FBQ0g7U0FDRjtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsWUFBWSxDQUFDLEtBQTZCO1FBQ3hDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzlDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxRQUFRLENBQUMsS0FBNkI7UUFDcEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUU7WUFDdEIsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUU7WUFDbEMsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGdCQUFnQixDQUFDLE1BQThCLEVBQUUsSUFBNEI7UUFDM0UsT0FBTyxDQUNILENBQUMsTUFBTSxDQUFDLFdBQVcsS0FBSyxJQUFJLENBQUMsV0FBVyxDQUFDO1lBQ3pDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FDaEUsQ0FBQztJQUNOLENBQUM7SUFFSDs7OztPQUlHO0lBQ0QsT0FBTyxDQUFDLElBQVk7UUFDbEIsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3RELElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzFDLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM1QjtJQUNQLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgRGV0YWNoZWRSb3V0ZUhhbmRsZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBSdWZSb3V0ZVJldXNlU3RyYXRlZ3kgfSBmcm9tICcuL3JvdXRlLXJldXNlLXN0cmF0ZWd5JztcbmltcG9ydCB7IFJ1ZlJvdXRlclV0aWxTZXJ2aWNlIH0gZnJvbSAnLi9yb3V0ZXItdXRpbC5zZXJ2aWNlJztcblxuZXhwb3J0IGNsYXNzIFJ1Zk1ESVN0cmF0ZWd5IGltcGxlbWVudHMgUnVmUm91dGVSZXVzZVN0cmF0ZWd5IHtcbiAgcHJpdmF0ZSBoYW5kbGVyczogeyBba2V5OiBzdHJpbmddOiBEZXRhY2hlZFJvdXRlSGFuZGxlIH0gPSB7fTtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgdXRpbDogUnVmUm91dGVyVXRpbFNlcnZpY2UpIHt9XG5cbiAgLyoqXG4gICAqIERlY2lkZXMgd2hlbiB0aGUgcm91dGUgc2hvdWxkIGJlIHN0b3JlZFxuICAgKiBAcGFyYW0gcm91dGUgdGhlIHJvdXRlIHRoYXQgdGhlIHVzZXIgaXMgY3VycmVudGx5IG9uXG4gICAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSByb3V0ZSBzaG91bGQgb3Igc2hvdWxkIG5vdCBiZSBzdG9yZWRcbiAgICovXG4gIHNob3VsZERldGFjaChyb3V0ZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgY29tcGxldGUgcm91dGUgcGF0aCBhbmQgaXRzIGNvbXBvbmVudCBzdGF0ZSAoYXMgQ29tcG9uZW50UmVmKSBmb3IgbGF0ZXIgYXR0YWNobWVudFxuICAgKiBAcGFyYW0gcm91dGUgVGhpcyBpcyBzdG9yZWQgZm9yIGxhdGVyIGNvbXBhcmlzb24gdG8gcmVxdWVzdGVkIHJvdXRlcywgc2VlIGB0aGlzLnNob3VsZEF0dGFjaGBcbiAgICogQHBhcmFtIGhhbmRsZSBBIERldGFjaGVkUm91dGVIYW5kbGUgd2hpY2ggaXMgbGF0ZXIgcmV0cmlldmVkIGJ5IHRoaXMucmV0cmlldmUgdG8gcmVzdG9yZSBzdGF0ZVxuICAgKi9cbiAgc3RvcmUocm91dGU6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIGhhbmRsZTogRGV0YWNoZWRSb3V0ZUhhbmRsZSk6IHZvaWQge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLnV0aWwuZ2V0TGVhZk5vZGVQYXRoKHJvdXRlKTtcbiAgICAvLyBwYXRoIGlzICcnIHdoZW4gcm91dGUgaGFzIGxvYWRDaGlsZHJlbi5cbiAgICBpZiAocGF0aCkge1xuICAgICAgaWYgKHJvdXRlLmNvbXBvbmVudCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzW3BhdGhdID0gaGFuZGxlO1xuICAgICAgfVxuICAgICAgLy8gcm91dGUgZG9lcyBub3QgaGF2ZSBjb21wb25lbnQuIHRoaXMgbWVhbnMgaXQgaXMgYSBwYXJlbnQgcm91dGUgbGlrZSBydWYvc2hlbGwvYmFubmVyIG9yIHJ1Zi9zaGVsbC9sYXlvdXQuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIHByZXZpb3VzbHkgc3RvcmVkIGxlYWYgbm9kZSBoYW5kbGVyIHNob3VsZCBiZSByZS1zdG9yZWQuXG4gICAgICBpZiAoIXJvdXRlLmNvbXBvbmVudCAmJiBoYW5kbGUpIHtcbiAgICAgICAgLy8gVGhpcyBjb25kaXRpb24gaXMgd2hlbiBwYXJlbnQgcm91dGUgaXMgYmVpbmcgc3RvcmVkIGJ1dCBpdCdzIHRoZSBjaGlsZCByb3V0ZSB3aG9zZSByZWZlcmVuY2UgbmVlZHMgdG8gYmUgc3RvcmVkIGluc3RlYWQuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgcmV0cmlldmUgdGhlIGNvbXBvbmVudCByZWYgZnJvbSBSdWZSb3V0ZXJVdGlsU2VydmljZSBhbmQgY3JlYXRlIGEgbmV3IERldGFjaGVkUm91dGVIYW5kbGUuXG4gICAgICAgIHRoaXMuaGFuZGxlcnNbcGF0aF0gPSB7XG4gICAgICAgICAgY29tcG9uZW50UmVmOiB0aGlzLnV0aWwuZ2V0Q29tcG9uZW50UmVmKHBhdGgpLFxuICAgICAgICAgIHJvdXRlOiB0aGlzLnV0aWwuZ2V0TGVhZk5vZGUoaGFuZGxlWydyb3V0ZSddKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlcmUgaXMgYSBzdG9yZWQgcm91dGUgYW5kLCBpZiB5ZXMsIHNob3VsZCBpdCBiZSByZW5kZXJlZCBpbiBwbGFjZSBvZiByZXF1ZXN0ZWQgcm91dGVcbiAgICogQHBhcmFtIHJvdXRlIFRoZSByb3V0ZSB0aGUgdXNlciByZXF1ZXN0ZWRcbiAgICogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRvIHJlbmRlciB0aGUgc3RvcmVkIHJvdXRlXG4gICAqL1xuICBzaG91bGRBdHRhY2gocm91dGU6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QpOiBib29sZWFuIHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy51dGlsLmdldExlYWZOb2RlUGF0aChyb3V0ZSk7XG4gICAgcmV0dXJuICEhcm91dGUucm91dGVDb25maWcgJiYgISF0aGlzLmhhbmRsZXJzW3BhdGhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBsb2NhbGx5IHN0b3JlZCBpbnN0YW5jZSBvZiB0aGUgcmVxdWVzdGVkIHJvdXRlIGFuZCByZXR1cm5zIGl0IGlmIGl0IGV4aXN0c1xuICAgKiBAcGFyYW0gcm91dGUgTmV3IHJvdXRlIHRoZSB1c2VyIGhhcyByZXF1ZXN0ZWRcbiAgICogQHJldHVybnMgRGV0YWNoZWRSb3V0ZUhhbmRsZSBvYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBjb21wb25lbnRcbiAgICovXG4gIHJldHJpZXZlKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KTogRGV0YWNoZWRSb3V0ZUhhbmRsZSB7XG4gICAgaWYgKCFyb3V0ZS5yb3V0ZUNvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyb3V0ZS5yb3V0ZUNvbmZpZy5sb2FkQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyc1t0aGlzLnV0aWwuZnVsbFBhdGgocm91dGUpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IHJvdXRlIHNob3VsZCBiZSByZXVzZWRcbiAgICogQHBhcmFtIGZ1dHVyZSBUaGUgcm91dGUgdGhlIHVzZXIgaXMgbmF2aWdhdGluZyB0byBhcyB0cmlnZ2VyZWQgYnkgdGhlIHJvdXRlclxuICAgKiBAcGFyYW0gY3VyciBUaGUgcm91dGUgdGhlIHVzZXIgaXMgY3VycmVudGx5IG9uXG4gICAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyB0cnVlIGlmIHRoZSB1c2VyIGludGVuZHMgdG8gbGVhdmUgdGhlIGN1cnJlbnQgcm91dGVcbiAgICovXG4gIHNob3VsZFJldXNlUm91dGUoZnV0dXJlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBjdXJyOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgKGZ1dHVyZS5yb3V0ZUNvbmZpZyA9PT0gY3Vyci5yb3V0ZUNvbmZpZykgJiZcbiAgICAgICAgKEpTT04uc3RyaW5naWZ5KGZ1dHVyZS5wYXJhbXMpID09PSBKU09OLnN0cmluZ2lmeShjdXJyLnBhcmFtcykpXG4gICAgICApO1xuICB9XG5cbi8qKlxuICogIFJlbW92ZSBjb21wb25lbnQgcmVmZXJlbmNlIGZyb20gaGFuZGxlcnMuXG4gKiAgRGVzdHJveSB0aGUgcm91dGUgY29tcG9uZW50XG4gKiAgQHBhcmFtIHBhdGggVGhlIGtleSBhZ2FpbnN0IHdoaWNoIERldGFjaGVkUm91dGVIYW5kbGUgd2l0aCBjb21wb25lbnQgcmVmZXJlbmNlIGlzIHN0b3JlZCBmb3IgZGV0YWNoZWQgcm91dGVcbiAqL1xuICBkZXN0cm95KHBhdGg6IHN0cmluZykgIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyc1twYXRoXSAmJiB0aGlzLnV0aWwuZ2V0Q29tcG9uZW50UmVmKHBhdGgpKSB7XG4gICAgICAgICAgdGhpcy51dGlsLmdldENvbXBvbmVudFJlZihwYXRoKS5kZXN0cm95KCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuaGFuZGxlcnNbcGF0aF07XG4gICAgICAgIH1cbiAgfVxufVxuIl19