import * as tslib_1 from "tslib";
import { Input, Output, EventEmitter, Component, ChangeDetectorRef, ViewEncapsulation, ChangeDetectionStrategy, ElementRef, Renderer2, TemplateRef, ContentChild, ViewChildren, QueryList } from '@angular/core';
import { ENTER, SPACE, ESCAPE } from '@angular/cdk/keycodes';
import { Subscription } from 'rxjs';
import { RufShellIntl } from '../utils/shell-intl';
import { RufMixinBase } from '../common/color/color';
export var RufDynamicNavType;
(function (RufDynamicNavType) {
    RufDynamicNavType["Nav"] = "nav";
    RufDynamicNavType["Tabs"] = "tabs";
})(RufDynamicNavType || (RufDynamicNavType = {}));
let RufDynamicMenubarComponent = class RufDynamicMenubarComponent extends RufMixinBase {
    constructor(_elementRef, _renderer, _intl, changeDetectorRef) {
        super(_elementRef);
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._intl = _intl;
        this._isMenuItemClosed = false;
        this.items = [];
        this.tabLabels = [];
        this.tabSubscription = Subscription.EMPTY;
        this.selectedIndex = 0;
        this.focusedIndex = 0;
        this.closedItemIndexLessThanSelectedIndex = false;
        this.select = new EventEmitter();
        /* tslint:disable:no-output-rename */
        this.closeEmitter = new EventEmitter();
        this._intlChanges = _intl.changes.subscribe(() => changeDetectorRef.markForCheck());
        this.type = RufDynamicNavType.Nav;
    }
    get closeAriaLabel() {
        return this._closeAriaLabel || this._intl.dynamicmenubar.aria.closeIconLabel;
    }
    set closeAriaLabel(value) {
        this._closeAriaLabel = value;
    }
    get type() {
        return this._type;
    }
    set type(value) {
        this._renderer.removeClass(this._elementRef.nativeElement, `ruf-dynamic-${this._type}`);
        this._type = value || RufDynamicNavType.Nav;
        this._renderer.addClass(this._elementRef.nativeElement, `ruf-dynamic-${this._type}`);
    }
    ngOnInit() {
        // remove the body element from matTabGroup since we are never going to need it.
        const matTabGroupElem = this._elementRef.nativeElement.children[0];
        matTabGroupElem.removeChild(matTabGroupElem.children[1]);
    }
    ngAfterViewInit() {
        this.tabLabels = this.menuLabels.toArray();
        this.tabSubscription = this.menuLabels.changes.subscribe((value) => {
            this.tabLabels = value.toArray();
        });
    }
    ngOnChanges(changes) {
        if (changes.items && this.selectedIndex > -1 && this.items[this.selectedIndex]) {
            // adding a setTimeout to delay the emil call in order to avoid ExpressionChangedAfterItHasBeenCheckedError
            // need to see if there is a better solution for this
            // https://stackoverflow.com/questions/44070732/angular-4-expressionchangedafterithasbeencheckederror-expression-has-changed
            const indexToSet = this.closedItemIndexLessThanSelectedIndex ? this.selectedIndex - 1 : this.selectedIndex;
            setTimeout(() => {
                this.onSelect({ index: indexToSet });
            });
            this.closedItemIndexLessThanSelectedIndex = false;
        }
    }
    set selectedPath(path) {
        if (this.selectedPath === path) {
            return;
        }
        this._selectedPath = path;
        // Check if selectedPath match with any first level items
        let selected = path ? this.items.filter(item => this.matches(path, item)) : null;
        // If selectedPath matches with first level items, first matched item will be selected (and select event emitter will be emitted).
        if (selected && selected.length > 0) {
            if (this.selectedIndex === this.items.indexOf(selected[0])) {
                setTimeout(() => this.onSelect({ index: this.selectedIndex }));
            }
            else {
                this.selectedIndex = this.items.indexOf(selected[0]);
            }
            return;
        }
        else {
            // If selectedPath does not match with any first level item, check if matches with children of each first level item
            for (const item of this.items) {
                if (item.children && item.children.length > 0) {
                    selected = path ? item.children.filter(citem => this.matches(path, citem)) : null;
                    if (selected && selected.length > 0) {
                        // If selectedPath match with child menu, set selectedIndex to Parent and selectedPath to child menu
                        this.onChildSelect(selected[0], item);
                        return;
                    }
                }
            }
        }
        // If selectedPath does not match with first level items as well as child menu,
        // select first item.
        // FIXME: The `ngOnChange` event should take care of this. Currently it only checks for `items` changes.
        setTimeout(() => this.onSelect({ index: 0 }));
    }
    get selectedPath() {
        return this._selectedPath;
    }
    isChild(parent, childPath) {
        if (!childPath || parent.path === childPath) {
            return false;
        }
        const selected = parent.children.filter(citem => this.matches(childPath, citem));
        if (selected && selected.length > 0) {
            return true;
        }
        return false;
    }
    onSelect($event) {
        if (this.items.length > 0) {
            this.selectedIndex = $event.index;
            let selectedItem = this.items[$event.index];
            // SDHTML-18280, SDHTML-18231
            // Focus on the next element after menuitem is closed.
            // We dont need to handle focus on click and enter because focus for those events will be handled by mat-tabs.
            if (this._isMenuItemClosed) {
                this.focusTabOnIndex(this.selectedIndex);
                this._isMenuItemClosed = false;
            }
            // This condition added to avoid select emitter for parent item on selecting child item
            if (selectedItem.children && selectedItem.children.length > 0) {
                if (this.isChild(selectedItem, this._selectedPath)) {
                    return;
                }
                else {
                    selectedItem = selectedItem.children[0];
                }
            }
            this._selectedPath = selectedItem.path;
            this.select.emit(selectedItem);
        }
    }
    onFocusChange($event) {
        this.focusedIndex = $event.index;
    }
    OnSelectFocusedIndex(event) {
        this.tabLabels[this.focusedIndex].handleKeydown(event);
    }
    onChildMenuToggle(event) {
        if (!event) {
            // this.selectedIndex is used to ensure that it gives focus to parent element
            // when child is selected using mouse click.
            this.focusTabOnIndex(this.selectedIndex);
        }
    }
    onChildSelect($event, item) {
        this.selectedIndex = this.items.indexOf(item);
        this._selectedPath = $event.path;
        this.select.emit($event);
    }
    matches(path, item) {
        if (path && item.path) {
            if (path === item.path) {
                return true;
            }
        }
        return false;
    }
    close(item) {
        // check if the index of the item being closed is smaller than the item that is currently selected
        // if it is, and if the user actually closes the tab - we'll have to set the selectedIndex to selectedIndex - 1
        // otherwise the selectedItem will change
        // See https://etojira.fnfis.com/browse/SDHTML-16688 for details
        this.closedItemIndexLessThanSelectedIndex = false;
        if (this.items.indexOf(item) < this.selectedIndex) {
            this.closedItemIndexLessThanSelectedIndex = true;
        }
        this._isMenuItemClosed = true;
        this.closeEmitter.emit(item);
    }
    focusTabOnIndex(index) {
        this._elementRef.nativeElement.getElementsByClassName('mat-tab-label')[index].focus();
    }
    _handleKeydown(event, item) {
        switch (event.keyCode) {
            case ENTER:
            case SPACE:
                this.close(item);
                event.stopPropagation();
                break;
            case ESCAPE:
                this.focusTabOnIndex(this.focusedIndex);
                event.stopPropagation();
                break;
            default:
        }
    }
    ngOnDestroy() {
        this._intlChanges.unsubscribe();
        this.tabSubscription.unsubscribe();
    }
};
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Array)
], RufDynamicMenubarComponent.prototype, "items", void 0);
tslib_1.__decorate([
    ViewChildren('menuLabel'),
    tslib_1.__metadata("design:type", QueryList)
], RufDynamicMenubarComponent.prototype, "menuLabels", void 0);
tslib_1.__decorate([
    Input('activeColor'),
    tslib_1.__metadata("design:type", Object)
], RufDynamicMenubarComponent.prototype, "color", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], RufDynamicMenubarComponent.prototype, "closeAriaLabel", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], RufDynamicMenubarComponent.prototype, "type", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", Object)
], RufDynamicMenubarComponent.prototype, "select", void 0);
tslib_1.__decorate([
    Output('close'),
    tslib_1.__metadata("design:type", Object)
], RufDynamicMenubarComponent.prototype, "closeEmitter", void 0);
tslib_1.__decorate([
    ContentChild(TemplateRef, { static: false }),
    tslib_1.__metadata("design:type", Object)
], RufDynamicMenubarComponent.prototype, "navActions", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], RufDynamicMenubarComponent.prototype, "selectedPath", null);
RufDynamicMenubarComponent = tslib_1.__decorate([
    Component({
        selector: 'ruf-dynamic-menubar',
        template: "<mat-tab-group rufId [selectedIndex]=\"selectedIndex\" (selectedTabChange)=\"onSelect($event)\" (focusChange)=\"onFocusChange($event)\" (keydown.enter)=\"OnSelectFocusedIndex($event)\" (keydown.space)=\"OnSelectFocusedIndex($event)\">\n  <mat-tab rufId *ngFor=\"let item of items;let currentIndex=index\">\n    <ng-template matTabLabel>\n      <ruf-menu-label #menuLabel rufId [label]=\"item.label\" [icon]=\"item.icon\" [children]=\"item.children\"\n                      (select)=\"onChildSelect($event, item)\"\n                      (toggle)=\"onChildMenuToggle($event)\"\n                      [selectedPath]=\"selectedPath\">\n        <ng-template [ngTemplateOutlet]=\"navActions\" [ngTemplateOutletContext]=\"{item: item}\">\n        </ng-template>\n        <button type=\"button\" mat-icon-button rufId=\"dynamic_menubar_close_icon\" fisStyle class=\"ruf-close\" [attr.tabindex]=\"focusedIndex === currentIndex ? 0 : -1\" *ngIf=\"item.closeable === true\" (keydown)=\"_handleKeydown($event, item)\" (click)=\"close(item)\" role=\"button\" [attr.aria-label]=\"closeAriaLabel\">\n          <mat-icon fisIcon=\"close\" class=\"fis-icon-xs\"></mat-icon>\n        </button>\n      </ruf-menu-label>\n    </ng-template>\n  </mat-tab>\n</mat-tab-group>\n\n",
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: ["ruf-dynamic-menubar{-webkit-box-flex:1;flex-grow:1;overflow:hidden}ruf-dynamic-menubar.ruf-dynamic-menubar-flex-height .mat-tab-labels>.mat-tab-label{height:inherit}ruf-dynamic-menubar .mat-tab-labels>.mat-tab-label{height:2.75rem;min-width:48px;padding-left:.9375rem;padding-right:.9375rem}ruf-dynamic-menubar .mat-tab-header{border:0}ruf-dynamic-menubar .ruf-menu-label-trigger{margin-left:-.9375rem;margin-right:-.9375rem}ruf-menu-label .ruf-close.mat-icon-button[fisStyle]{margin-left:.3125rem;padding:1px 3px;-webkit-transition:text-shadow .1s ease-in,color .1s ease-in;transition:text-shadow .1s ease-in,color .1s ease-in}ruf-menu-label .ruf-close.mat-icon-button[fisStyle]:hover{text-shadow:1px 0 0}"]
    }),
    tslib_1.__metadata("design:paramtypes", [ElementRef,
        Renderer2,
        RufShellIntl,
        ChangeDetectorRef])
], RufDynamicMenubarComponent);
export { RufDynamicMenubarComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy1tZW51YmFyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BydWYvc2hlbGwvIiwic291cmNlcyI6WyJzcmMvZHluYW1pYy1tZW51YmFyL2R5bmFtaWMtbWVudWJhci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFFTCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixTQUFTLEVBQ1QsaUJBQWlCLEVBQ2pCLGlCQUFpQixFQUNqQix1QkFBdUIsRUFDdkIsVUFBVSxFQUNWLFNBQVMsRUFLVCxXQUFXLEVBQ1gsWUFBWSxFQUNaLFlBQVksRUFDWixTQUFTLEVBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDN0QsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNwQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFHbkQsT0FBTyxFQUFnQixZQUFZLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUVuRSxNQUFNLENBQU4sSUFBWSxpQkFHWDtBQUhELFdBQVksaUJBQWlCO0lBQzNCLGdDQUFXLENBQUE7SUFDWCxrQ0FBYSxDQUFBO0FBQ2YsQ0FBQyxFQUhXLGlCQUFpQixLQUFqQixpQkFBaUIsUUFHNUI7QUFTRCxJQUFhLDBCQUEwQixHQUF2QyxNQUFhLDBCQUEyQixTQUFRLFlBQVk7SUEwQzFELFlBQW1CLFdBQXVCLEVBQ3BCLFNBQW9CLEVBQ3RCLEtBQW1CLEVBQzNCLGlCQUFvQztRQUM1QyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFKSixnQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQUNwQixjQUFTLEdBQVQsU0FBUyxDQUFXO1FBQ3RCLFVBQUssR0FBTCxLQUFLLENBQWM7UUExQy9CLHNCQUFpQixHQUFHLEtBQUssQ0FBQztRQUl6QixVQUFLLEdB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LENBNk50QztTQTdOWSwwQkFBMEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBFdmVudEVtaXR0ZXIsXG4gIENvbXBvbmVudCxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgRWxlbWVudFJlZixcbiAgUmVuZGVyZXIyLFxuICBPbkluaXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBTaW1wbGVDaGFuZ2VzLFxuICBUZW1wbGF0ZVJlZixcbiAgQ29udGVudENoaWxkLFxuICBWaWV3Q2hpbGRyZW4sXG4gIFF1ZXJ5TGlzdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRU5URVIsIFNQQUNFLCBFU0NBUEUgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBSdWZTaGVsbEludGwgfSBmcm9tICcuLi91dGlscy9zaGVsbC1pbnRsJztcbmltcG9ydCB7IFJ1ZkR5bmFtaWNNZW51YmFySXRlbSB9IGZyb20gJy4vZHluYW1pYy1tZW51YmFyLWl0ZW0nO1xuaW1wb3J0IHsgUnVmTWVudUxhYmVsQ29tcG9uZW50IH0gZnJvbSAnLi4vbWVudS1sYWJlbC9tZW51LWxhYmVsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyAgUnVmQ2FuQ29sb3IsIFJ1Zk1peGluQmFzZSB9IGZyb20gJy4uL2NvbW1vbi9jb2xvci9jb2xvcic7XG5cbmV4cG9ydCBlbnVtIFJ1ZkR5bmFtaWNOYXZUeXBlIHtcbiAgTmF2ID0gJ25hdicsXG4gIFRhYnMgPSAndGFicydcbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAncnVmLWR5bmFtaWMtbWVudWJhcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9keW5hbWljLW1lbnViYXIuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9keW5hbWljLW1lbnViYXIuY29tcG9uZW50LnNjc3MnXSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgUnVmRHluYW1pY01lbnViYXJDb21wb25lbnQgZXh0ZW5kcyBSdWZNaXhpbkJhc2VcbiAgICAgICAgICBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIFJ1ZkNhbkNvbG9yIHtcbiAgcHJpdmF0ZSBfaXNNZW51SXRlbUNsb3NlZCA9IGZhbHNlO1xuICBwcml2YXRlIF9pbnRsQ2hhbmdlczogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIF9jbG9zZUFyaWFMYWJlbDogc3RyaW5nO1xuICBwcml2YXRlIF90eXBlOiBSdWZEeW5hbWljTmF2VHlwZTtcbiAgQElucHV0KCkgaXRlbXM6IFJ1ZkR5bmFtaWNNZW51YmFySXRlbVtdID0gW107XG4gIHByaXZhdGUgX3NlbGVjdGVkUGF0aDogc3RyaW5nO1xuICBAVmlld0NoaWxkcmVuKCdtZW51TGFiZWwnKSBtZW51TGFiZWxzOiBRdWVyeUxpc3Q8UnVmTWVudUxhYmVsQ29tcG9uZW50PjtcbiAgdGFiTGFiZWxzID0gW107XG4gIHByaXZhdGUgdGFiU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuXG4gIC8qIHRzbGludDpkaXNhYmxlOm5vLWlucHV0LXJlbmFtZSAqL1xuICBASW5wdXQoJ2FjdGl2ZUNvbG9yJykgY29sb3I7XG5cbiAgQElucHV0KClcbiAgZ2V0IGNsb3NlQXJpYUxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9jbG9zZUFyaWFMYWJlbCB8fCB0aGlzLl9pbnRsLmR5bmFtaWNtZW51YmFyLmFyaWEuY2xvc2VJY29uTGFiZWw7XG4gIH1cbiAgc2V0IGNsb3NlQXJpYUxhYmVsKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9jbG9zZUFyaWFMYWJlbCA9IHZhbHVlO1xuICB9XG4gIEBJbnB1dCgpXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlO1xuICB9XG4gIHNldCB0eXBlKHZhbHVlOiBSdWZEeW5hbWljTmF2VHlwZSkge1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgYHJ1Zi1keW5hbWljLSR7dGhpcy5fdHlwZX1gKTtcbiAgICB0aGlzLl90eXBlID0gdmFsdWUgfHwgUnVmRHluYW1pY05hdlR5cGUuTmF2O1xuICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgYHJ1Zi1keW5hbWljLSR7dGhpcy5fdHlwZX1gKVxuICB9XG5cbiAgc2VsZWN0ZWRJbmRleCA9IDA7XG4gIGZvY3VzZWRJbmRleCA9IDA7XG4gIGNsb3NlZEl0ZW1JbmRleExlc3NUaGFuU2VsZWN0ZWRJbmRleCA9IGZhbHNlO1xuXG4gIEBPdXRwdXQoKSBzZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyPFJ1ZkR5bmFtaWNNZW51YmFySXRlbT4oKTtcblxuICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1vdXRwdXQtcmVuYW1lICovXG4gIEBPdXRwdXQoJ2Nsb3NlJykgY2xvc2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcjxSdWZEeW5hbWljTWVudWJhckl0ZW0+KCk7XG4gIEBDb250ZW50Q2hpbGQoVGVtcGxhdGVSZWYsIHtzdGF0aWM6IGZhbHNlfSkgbmF2QWN0aW9ucztcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgIHByb3RlY3RlZCBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfaW50bDogUnVmU2hlbGxJbnRsLFxuICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgIHN1cGVyKF9lbGVtZW50UmVmKTtcbiAgICAgIHRoaXMuX2ludGxDaGFuZ2VzID0gX2ludGwuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCkpO1xuICAgICAgdGhpcy50eXBlID0gUnVmRHluYW1pY05hdlR5cGUuTmF2O1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBib2R5IGVsZW1lbnQgZnJvbSBtYXRUYWJHcm91cCBzaW5jZSB3ZSBhcmUgbmV2ZXIgZ29pbmcgdG8gbmVlZCBpdC5cbiAgICBjb25zdCBtYXRUYWJHcm91cEVsZW0gPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgbWF0VGFiR3JvdXBFbGVtLnJlbW92ZUNoaWxkKG1hdFRhYkdyb3VwRWxlbS5jaGlsZHJlblsxXSk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy50YWJMYWJlbHMgPSB0aGlzLm1lbnVMYWJlbHMudG9BcnJheSgpO1xuICAgIHRoaXMudGFiU3Vic2NyaXB0aW9uID0gdGhpcy5tZW51TGFiZWxzLmNoYW5nZXMuc3Vic2NyaWJlKCAodmFsdWUpID0+IHtcbiAgICAgIHRoaXMudGFiTGFiZWxzID0gdmFsdWUudG9BcnJheSgpO1xuICAgIH0pO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2VzLml0ZW1zICYmIHRoaXMuc2VsZWN0ZWRJbmRleCA+IC0xICYmIHRoaXMuaXRlbXNbdGhpcy5zZWxlY3RlZEluZGV4XSkge1xuICAgICAgLy8gYWRkaW5nIGEgc2V0VGltZW91dCB0byBkZWxheSB0aGUgZW1pbCBjYWxsIGluIG9yZGVyIHRvIGF2b2lkIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3JcbiAgICAgIC8vIG5lZWQgdG8gc2VlIGlmIHRoZXJlIGlzIGEgYmV0dGVyIHNvbHV0aW9uIGZvciB0aGlzXG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NDA3MDczMi9hbmd1bGFyLTQtZXhwcmVzc2lvbmNoYW5nZWRhZnRlcml0aGFzYmVlbmNoZWNrZWRlcnJvci1leHByZXNzaW9uLWhhcy1jaGFuZ2VkXG4gICAgICBjb25zdCBpbmRleFRvU2V0ID0gdGhpcy5jbG9zZWRJdGVtSW5kZXhMZXNzVGhhblNlbGVjdGVkSW5kZXggPyB0aGlzLnNlbGVjdGVkSW5kZXggLSAxIDogdGhpcy5zZWxlY3RlZEluZGV4O1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMub25TZWxlY3QoeyBpbmRleDogaW5kZXhUb1NldCB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jbG9zZWRJdGVtSW5kZXhMZXNzVGhhblNlbGVjdGVkSW5kZXggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBASW5wdXQoKVxuICBzZXQgc2VsZWN0ZWRQYXRoKHBhdGg6IHN0cmluZykge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkUGF0aCA9PT0gcGF0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbGVjdGVkUGF0aCA9IHBhdGg7XG5cbiAgICAvLyBDaGVjayBpZiBzZWxlY3RlZFBhdGggbWF0Y2ggd2l0aCBhbnkgZmlyc3QgbGV2ZWwgaXRlbXNcbiAgICBsZXQgc2VsZWN0ZWQgPSBwYXRoID8gdGhpcy5pdGVtcy5maWx0ZXIoaXRlbSA9PiB0aGlzLm1hdGNoZXMocGF0aCwgaXRlbSkpIDogbnVsbDtcblxuICAgIC8vIElmIHNlbGVjdGVkUGF0aCBtYXRjaGVzIHdpdGggZmlyc3QgbGV2ZWwgaXRlbXMsIGZpcnN0IG1hdGNoZWQgaXRlbSB3aWxsIGJlIHNlbGVjdGVkIChhbmQgc2VsZWN0IGV2ZW50IGVtaXR0ZXIgd2lsbCBiZSBlbWl0dGVkKS5cbiAgICBpZiAoc2VsZWN0ZWQgJiYgc2VsZWN0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA9PT0gdGhpcy5pdGVtcy5pbmRleE9mKHNlbGVjdGVkWzBdKSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMub25TZWxlY3QoeyBpbmRleDogdGhpcy5zZWxlY3RlZEluZGV4IH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZihzZWxlY3RlZFswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHNlbGVjdGVkUGF0aCBkb2VzIG5vdCBtYXRjaCB3aXRoIGFueSBmaXJzdCBsZXZlbCBpdGVtLCBjaGVjayBpZiBtYXRjaGVzIHdpdGggY2hpbGRyZW4gb2YgZWFjaCBmaXJzdCBsZXZlbCBpdGVtXG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbiAmJiBpdGVtLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZWxlY3RlZCA9IHBhdGggPyBpdGVtLmNoaWxkcmVuLmZpbHRlcihjaXRlbSA9PiB0aGlzLm1hdGNoZXMocGF0aCwgY2l0ZW0pKSA6IG51bGw7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkICYmIHNlbGVjdGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElmIHNlbGVjdGVkUGF0aCBtYXRjaCB3aXRoIGNoaWxkIG1lbnUsIHNldCBzZWxlY3RlZEluZGV4IHRvIFBhcmVudCBhbmQgc2VsZWN0ZWRQYXRoIHRvIGNoaWxkIG1lbnVcbiAgICAgICAgICAgIHRoaXMub25DaGlsZFNlbGVjdChzZWxlY3RlZFswXSwgaXRlbSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIElmIHNlbGVjdGVkUGF0aCBkb2VzIG5vdCBtYXRjaCB3aXRoIGZpcnN0IGxldmVsIGl0ZW1zIGFzIHdlbGwgYXMgY2hpbGQgbWVudSxcbiAgICAvLyBzZWxlY3QgZmlyc3QgaXRlbS5cbiAgICAvLyBGSVhNRTogVGhlIGBuZ09uQ2hhbmdlYCBldmVudCBzaG91bGQgdGFrZSBjYXJlIG9mIHRoaXMuIEN1cnJlbnRseSBpdCBvbmx5IGNoZWNrcyBmb3IgYGl0ZW1zYCBjaGFuZ2VzLlxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5vblNlbGVjdCh7IGluZGV4OiAwIH0pKTtcbiAgfVxuXG4gIGdldCBzZWxlY3RlZFBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkUGF0aDtcbiAgfVxuXG4gIHByaXZhdGUgaXNDaGlsZChwYXJlbnQ6IFJ1ZkR5bmFtaWNNZW51YmFySXRlbSwgY2hpbGRQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIWNoaWxkUGF0aCB8fCBwYXJlbnQucGF0aCA9PT0gY2hpbGRQYXRoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGVkID0gcGFyZW50LmNoaWxkcmVuLmZpbHRlcihjaXRlbSA9PiB0aGlzLm1hdGNoZXMoY2hpbGRQYXRoLCBjaXRlbSkpO1xuICAgIGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgb25TZWxlY3QoJGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gJGV2ZW50LmluZGV4O1xuICAgICAgbGV0IHNlbGVjdGVkSXRlbSA9IHRoaXMuaXRlbXNbJGV2ZW50LmluZGV4XTtcbiAgICAgIC8vIFNESFRNTC0xODI4MCwgU0RIVE1MLTE4MjMxXG4gICAgICAvLyBGb2N1cyBvbiB0aGUgbmV4dCBlbGVtZW50IGFmdGVyIG1lbnVpdGVtIGlzIGNsb3NlZC5cbiAgICAgIC8vIFdlIGRvbnQgbmVlZCB0byBoYW5kbGUgZm9jdXMgb24gY2xpY2sgYW5kIGVudGVyIGJlY2F1c2UgZm9jdXMgZm9yIHRob3NlIGV2ZW50cyB3aWxsIGJlIGhhbmRsZWQgYnkgbWF0LXRhYnMuXG4gICAgICBpZiAodGhpcy5faXNNZW51SXRlbUNsb3NlZCkge1xuICAgICAgICB0aGlzLmZvY3VzVGFiT25JbmRleCh0aGlzLnNlbGVjdGVkSW5kZXgpO1xuICAgICAgICB0aGlzLl9pc01lbnVJdGVtQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgfVxuICAgICAgLy8gVGhpcyBjb25kaXRpb24gYWRkZWQgdG8gYXZvaWQgc2VsZWN0IGVtaXR0ZXIgZm9yIHBhcmVudCBpdGVtIG9uIHNlbGVjdGluZyBjaGlsZCBpdGVtXG4gICAgICBpZiAoc2VsZWN0ZWRJdGVtLmNoaWxkcmVuICYmIHNlbGVjdGVkSXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2hpbGQoc2VsZWN0ZWRJdGVtLCB0aGlzLl9zZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGVjdGVkSXRlbSA9IHNlbGVjdGVkSXRlbS5jaGlsZHJlblswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fc2VsZWN0ZWRQYXRoID0gc2VsZWN0ZWRJdGVtLnBhdGg7XG4gICAgICB0aGlzLnNlbGVjdC5lbWl0KHNlbGVjdGVkSXRlbSk7XG4gICAgfVxuICB9XG5cbiAgb25Gb2N1c0NoYW5nZSgkZXZlbnQpIHtcbiAgICB0aGlzLmZvY3VzZWRJbmRleCA9ICRldmVudC5pbmRleDtcbiAgfVxuXG4gIE9uU2VsZWN0Rm9jdXNlZEluZGV4KGV2ZW50KSB7XG4gICAgdGhpcy50YWJMYWJlbHNbdGhpcy5mb2N1c2VkSW5kZXhdLmhhbmRsZUtleWRvd24oZXZlbnQpO1xuICB9XG5cbiAgb25DaGlsZE1lbnVUb2dnbGUoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAvLyB0aGlzLnNlbGVjdGVkSW5kZXggaXMgdXNlZCB0byBlbnN1cmUgdGhhdCBpdCBnaXZlcyBmb2N1cyB0byBwYXJlbnQgZWxlbWVudFxuICAgICAgLy8gd2hlbiBjaGlsZCBpcyBzZWxlY3RlZCB1c2luZyBtb3VzZSBjbGljay5cbiAgICAgIHRoaXMuZm9jdXNUYWJPbkluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgb25DaGlsZFNlbGVjdCgkZXZlbnQsIGl0ZW0pIHtcbiAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgdGhpcy5fc2VsZWN0ZWRQYXRoID0gJGV2ZW50LnBhdGg7XG4gICAgdGhpcy5zZWxlY3QuZW1pdCgkZXZlbnQpO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXRjaGVzKHBhdGg6IHN0cmluZywgaXRlbTogUnVmRHluYW1pY01lbnViYXJJdGVtKSB7XG4gICAgaWYgKHBhdGggJiYgaXRlbS5wYXRoKSB7XG4gICAgICBpZiAocGF0aCA9PT0gaXRlbS5wYXRoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjbG9zZShpdGVtKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIGluZGV4IG9mIHRoZSBpdGVtIGJlaW5nIGNsb3NlZCBpcyBzbWFsbGVyIHRoYW4gdGhlIGl0ZW0gdGhhdCBpcyBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICAvLyBpZiBpdCBpcywgYW5kIGlmIHRoZSB1c2VyIGFjdHVhbGx5IGNsb3NlcyB0aGUgdGFiIC0gd2UnbGwgaGF2ZSB0byBzZXQgdGhlIHNlbGVjdGVkSW5kZXggdG8gc2VsZWN0ZWRJbmRleCAtIDFcbiAgICAvLyBvdGhlcndpc2UgdGhlIHNlbGVjdGVkSXRlbSB3aWxsIGNoYW5nZVxuICAgIC8vIFNlZSBodHRwczovL2V0b2ppcmEuZm5maXMuY29tL2Jyb3dzZS9TREhUTUwtMTY2ODggZm9yIGRldGFpbHNcbiAgICB0aGlzLmNsb3NlZEl0ZW1JbmRleExlc3NUaGFuU2VsZWN0ZWRJbmRleCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSkgPCB0aGlzLnNlbGVjdGVkSW5kZXgpIHtcbiAgICAgIHRoaXMuY2xvc2VkSXRlbUluZGV4TGVzc1RoYW5TZWxlY3RlZEluZGV4ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5faXNNZW51SXRlbUNsb3NlZCA9IHRydWU7XG4gICAgdGhpcy5jbG9zZUVtaXR0ZXIuZW1pdChpdGVtKTtcbiAgfVxuXG4gIGZvY3VzVGFiT25JbmRleChpbmRleCkge1xuICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtYXQtdGFiLWxhYmVsJylbaW5kZXhdLmZvY3VzKCk7XG4gIH1cblxuICBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgaXRlbTogYW55KSB7XG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIEVOVEVSOlxuICAgICAgY2FzZSBTUEFDRTpcbiAgICAgICAgdGhpcy5jbG9zZShpdGVtKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFU0NBUEU6XG4gICAgICAgIHRoaXMuZm9jdXNUYWJPbkluZGV4KHRoaXMuZm9jdXNlZEluZGV4KTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9pbnRsQ2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMudGFiU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cbiJdfQ==