# RUF Navigation Accelerator
> RUF Naviation Accelarator is a CLI tool to generate Navigation data for an application dynamically.

It reads navigation data, converts navigation items into Routes, and renders them in the application. It also generates a Dummy Component that is attached to each route created.

The accelarator is primarily targeted for teams migrating their navigation data from RUF Classic to RUF. But it can also be used by any RUF based application. The only requirement is to have navigation data defined in a specified format

## Usage

Navigation Accelerator is integrated with ```ruf-wrench```, and can be invoked as a script from ```package.json``` of a RUF CLI generated workspace. 
We will integrate it with ```RUF Tooling``` subsequently.

To invoke navigation accelarator, add the following script to your ```package.json```

```sh
"migrate:navigation": "./node_modules/.bin/ruf-wrench migrate-navigation --app=test-nav-helper --path-to-navigation=apps/test-nav-helper/src/assets/navigation.json --render-in=sidemenu"
```

### Arguments

* *app* - The application on which ```migrate-navigation``` script needs to be invoked

* *path-to-navigation* - Relative path to ```navigation.json```
It is assumed that ```navigation.json``` is statically available in the application.

* *render-in* - Primary navigation rendering strategy. Accepts 2 values: ```sidemenu```, and ```megamenu```. Default value is ```sidemenu``` 

## Invoking Navigation Accelerator
It is expected that the script to invoke the tool will be called immediately after generating the application through Angular CLI.
There are certain files that get overridden by the tool, and any custom code in them will be lost. Here is the sequence of commands that should be invoked in same order as mentioned below:

```
ruf workspace <name-of-workspace>
ng generate application <name-of-app>
npm run migrate-navigation 
```

### Note

It is recommended to invoke the tool from a branch. It would make viewing the difference between the two branches easy. Rolling back the changes in case of any error would be easy too.

## Navigation Data Format

Navigation data is expected to be in the following format:

```json
{
  "main: [
    {
      "label": "Navigation Item Label",
      "id": "Navigation Item Id",
      "children": [
        {
          "label": "Child Label",
          "id": "Child Id",
          "children": [
            {
              "label": "Inner Child Label",
              "id": "Inner Child Id" 
            }
          ]
        }
      ]
    }
  ]
}
```
### Note
We only consider three levels of nesting, as shown in the above format. Child items deeper than third levels are not considered. Applications using this tool should make a note of this.

As of now, the tool reads ```main``` section of the navigation data and processes it.


## Rendering in Side Menu
 
First level children are rendered ```ruf-dynamic-sidemenu``` as the primary navigation items. Second level items are also rendered inside the side menu, and are visible on toggling the parent item. 
If there are third level navigation items present, they are rendered in ```ruf-dynamic-menubar```. They are loaded lazily only when the parent item is clicked on.

For every third level navigaiton items, an angular ```module``` gets created and is lazily loaded in the application's ```app.routing-module.ts```.

Every route is attached to a dummy ```TestComponent``` generated by the tool. It should be replaced by actual component of every route.

## Generated Files and File Structure

Following files are written by the tool:

* app.module.ts
* app.component.ts
* app.component.html
* app-routing.module.ts
* sidenav-item.ts
* test\test.module.ts
* test\test.component.ts
* test\test.component.html
* test\test.component.scss
* test\test.component.spec.ts

For every lazy loaded module:

* module1\module1-routing.module.ts
* module1\module1.module.ts
* module1\module1.tab-routes.ts
* module1\landing.component.ts

## Future Considerations

* Support for primary navigation rendering in Megamenu
* Support for zones other than ```main```. For example ```utility``` navigation items can be rendered in the Banner on the right hand side, as in case of RUF Classic
* Integrate with ```@ruf/multiwin``` for projects using iFrame approach for AngularJS-Angular migration

## Limitations

* Only 3 levels of nesting supported
* Navigation data other than ```label``` and ```id``` not considered
* Does not process items with ```ActionController```

