/*!
 * 
 * @ruf/fis-core-components
 * Version: 4.5.1
 * 
 * © 2018
 * Fidelity National Information Services, Inc. and/or its subsidiaries - All Rights Reserved worldwide.
 * This document is protected under the trade secret and copyright laws as the property of Fidelity National Information Services, Inc. and/or its subsidiaries.
 * Copying, reproduction or distribution should be limited and only to employees with a “need to know” to do their job. Any disclosure of this document to third parties is strictly prohibited.
 * 
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(/*! jquery */ 1);
	
	__webpack_require__(/*! angular */ 2);
	
	var _angularSanitize = __webpack_require__(/*! angular-sanitize */ 3);
	
	var _angularSanitize2 = _interopRequireDefault(_angularSanitize);
	
	var _angularResource = __webpack_require__(/*! angular-resource */ 4);
	
	var _angularResource2 = _interopRequireDefault(_angularResource);
	
	var _angularAnimate = __webpack_require__(/*! angular-animate */ 5);
	
	var _angularAnimate2 = _interopRequireDefault(_angularAnimate);
	
	__webpack_require__(/*! ./fis */ 6);
	
	__webpack_require__(/*! ./fis-angular-decorators */ 7);
	
	var _hook = __webpack_require__(/*! ./hook */ 8);
	
	var _hook2 = _interopRequireDefault(_hook);
	
	var _data = __webpack_require__(/*! ./data */ 11);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _directives = __webpack_require__(/*! ./directives */ 18);
	
	var _directives2 = _interopRequireDefault(_directives);
	
	var _filters = __webpack_require__(/*! ./filters */ 32);
	
	var _filters2 = _interopRequireDefault(_filters);
	
	var _i18n = __webpack_require__(/*! ./i18n */ 36);
	
	var _i18n2 = _interopRequireDefault(_i18n);
	
	var _pubsub = __webpack_require__(/*! ./pubsub */ 43);
	
	var _pubsub2 = _interopRequireDefault(_pubsub);
	
	var _services = __webpack_require__(/*! ./services */ 46);
	
	var _services2 = _interopRequireDefault(_services);
	
	var _utils = __webpack_require__(/*! ./utils */ 55);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _views = __webpack_require__(/*! ./views */ 58);
	
	var _views2 = _interopRequireDefault(_views);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = angular.module('fis.core', [_angularAnimate2.default, _angularSanitize2.default, _angularResource2.default, _hook2.default, _data2.default, _directives2.default, _filters2.default, _i18n2.default, _pubsub2.default, _services2.default, _utils2.default, _views2.default]);
	
	// for backward compatibility
	// making sure jquery gets loaded before angular
	angular.module('fisComponents', [ngModule.name]);
	
	if (false) {
	  // eslint-disable-line
	  require('jasmine-jquery');
	  require('jasmine-ajax');
	  require('angular-mocks');
	  require('@ruf/fis-mocks');
	}
	
	// SDHTML-14222: provide ability to disable angular's debug info while preserving the element.scope function.
	// Code taken from angular's source
	ngModule.decorator('$compile', ['$delegate', function ($delegate) {
	  $delegate.$$addScopeInfo = function $$addScopeInfo($element, scope, isolated, noTemplate) {
	    var dataName = isolated ? noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope' : '$scope';
	    $element.data(dataName, scope);
	  };
	
	  return $delegate;
	}]);
	
	// create an empty controllerArr here, so that any module that has to register a controller can push it to this array
	// TODO: find where this is needed and move this code there.
	ngModule.run(['$rootScope', function ($rootScope) {
	  $rootScope.controllersArr = [];
	}]);
	
	/**
	 * This fix moved from fisInput to prevent multiple invocations of this fix - shown cause memory leak otherwise.
	 *
	 * IE specific fix, IE triggering validation on Focus of inputs
	 * If a placeholder is defined on an input element IE10 fires this event when
	 * the placeholder is set during DOM loading and when it is removed when the user clicks into the input field so that error messages
	 * which depend on the pristine condition are displayed although the user has not yet modified the input's value.
	 */
	ngModule.run(['$sniffer', function ($sniffer) {
	  var msie = parseInt((/msie (\d+)/.exec(navigator.userAgent.toLowerCase()) || [])[1], 10);
	  var _hasEvent = $sniffer.hasEvent;
	  $sniffer.hasEvent = function (event) {
	    if (event === 'input' && msie === 10) {
	      return false;
	    }
	    return _hasEvent.call(this, event);
	  };
	}]);
	
	module.exports = ngModule.name;

/***/ }),
/* 1 */
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ (function(module, exports) {

	module.exports = jQuery;

/***/ }),
/* 2 */
/*!**************************!*\
  !*** external "angular" ***!
  \**************************/
/***/ (function(module, exports) {

	module.exports = angular;

/***/ }),
/* 3 */
/*!*******************************!*\
  !*** external "'ngSanitize'" ***!
  \*******************************/
/***/ (function(module, exports) {

	module.exports = 'ngSanitize';

/***/ }),
/* 4 */
/*!*******************************!*\
  !*** external "'ngResource'" ***!
  \*******************************/
/***/ (function(module, exports) {

	module.exports = 'ngResource';

/***/ }),
/* 5 */
/*!******************************!*\
  !*** external "'ngAnimate'" ***!
  \******************************/
/***/ (function(module, exports) {

	module.exports = 'ngAnimate';

/***/ }),
/* 6 */
/*!****************!*\
  !*** ./fis.js ***!
  \****************/
/***/ (function(module, exports) {

	'use strict';
	
	(function (fis, document) {
	  'use strict';
	
	  var params = null;
	  var cacheQuery = {};
	  var injector = null;
	
	  angular.extend(fis, {
	    // adding version this way so that grunt-bump can automatically update the version
	    version: '4.5.1'
	  });
	
	  // this can be replaced by using applications to change the cache string sent in requests
	  fis.cacheVersion = fis.version;
	
	  /**
	   * @name extend
	   * @description Copies properties of the second object into the first
	   * @param o1 Object to 'extend'. (Target)
	   * @param o2 Object to copy properties from. (Source)
	   * @returns The extended object.
	   */
	  function extend(o1, o2) {
	    for (var itm in o2) {
	      if (itm) {
	        o1[itm] = o2[itm];
	      }
	    }
	    return o1;
	  }
	
	  fis.paths = function () {
	    return {};
	  };
	  fis.shim = function () {
	    return {};
	  };
	
	  /**
	   * @class
	   * @name fis.initParams
	   * @description Get/Set accessor function for initParameters. Would normally be invoked by app-setup.js
	   * @param [opts] String
	   * @returns initParams object populated with appStage, configEndpoint, baseElement, modules etc.
	   * @namespace fis.initParams
	   */
	  fis.initParams = function (opts) {
	    if (opts || params === null) {
	      if (opts) {
	        // Use this syntax over the object notation, otherwise grunt-bump will try to update the object and
	        // destroy the file.
	        cacheQuery = {};
	        cacheQuery.version = fis.cacheVersion;
	        cacheQuery.appStage = opts.appStage;
	      }
	
	      params = extend(params || {
	        appStage: fis.utils.getRequestParam('appStage') || 'P',
	        baseElement: document,
	        modules: []
	      }, opts || {});
	
	      if (params.appStage === 'D') {
	        console.log('- Development mode.');
	      }
	    }
	
	    return params;
	  };
	
	  fis.getCacheQuery = function () {
	    return cacheQuery;
	  };
	
	  // Keep the String Parameter function for backward compatibility
	  fis.cacheQueryParameter = function (args) {
	    console.warn('Please use fisUtilService appendCacheQueryParameter() function for adding cache query parameters to url');
	    var version = cacheQuery.version;
	    if (args) {
	      version = args;
	    }
	    return 'version=' + version + '&appStage=' + cacheQuery.appStage;
	    // 'version=' + version + '&appStage=' + cacheQuery.appStage + '';
	  };
	
	  fis.prefixContext = function (pathObj) {
	    var modifiedPaths = extend({}, pathObj);
	    var context = fis.getLocationPath();
	    // context === / means no context root else context root like /myapp/
	    if (context !== '/') {
	      // check if it ends in resource extension like test.html, test.htm etc. Drop it if that's the case
	      var arrContext = context.split('/');
	      var arrContextLength = arrContext.length;
	      if (arrContext[arrContextLength - 1].indexOf('.') !== -1) {
	        // resource extension present
	        arrContext.splice(arrContextLength - 1, 1); // drop the last part
	      }
	      context = arrContext.join('/');
	
	      // remove the trailing / if it ends with one
	      if (context.match(/\/$/)) {
	        context = context.substr(0, context.length - 1);
	      }
	      for (var prop in modifiedPaths) {
	        if (modifiedPaths[prop].indexOf('/') === 0) {
	          modifiedPaths[prop] = context + modifiedPaths[prop];
	        }
	      }
	    }
	    return modifiedPaths;
	  };
	
	  // Extracting location path logic into separate method for testability
	  fis.getLocationPath = function () {
	    return window.location.pathname;
	  };
	
	  fis.packages = function (arr) {
	    var i;
	    var n = arr.length;
	    var packages = [];
	
	    if (params.appStage !== 'D') {
	      return arr;
	    }
	
	    for (i = 0; i < n; i++) {
	      packages.push({ name: arr[i], main: 'dev' });
	    }
	
	    return packages;
	  };
	
	  fis.bootstrapAngular = function (depModules) {
	    // only bootstrap if it wasn't already done by ng-app
	    if (!fis.utils.getInjector()) {
	      injector = angular.bootstrap(document, depModules);
	    }
	  };
	  /**
	   * @class
	   * @name fis.start
	   * @description Boot starting the framework. Loading the required or necessary script files through this.
	   * @param [init]
	   * @namespace fis.start
	   */
	  fis.start = function (initParams) {
	    if (angular.isObject(initParams)) {
	      initParams = fis.initParams(initParams);
	    } else {
	      initParams = fis.initParams();
	    }
	
	    if (!angular.isObject(initParams)) {
	      throw new Error('Init params need to be provided to fis.start.');
	    }
	
	    if (!angular.isArray(initParams.modules)) {
	      throw new Error('Modules needs to be defined in init parameters.');
	    }
	
	    // apps that are using ng-app will not have a configEndpoint and would use the newer
	    // fisConfig constant approach. For apps using fis.start, keep the old behavior of
	    // providing a default configEndpoint
	    if (!initParams.configEndpoint) {
	      initParams.configEndpoint = 'api/config';
	    }
	
	    angular.element(document).ready(function () {
	      // only bootstrap if it wasn't already done by ng-app
	      fis.bootstrapAngular(initParams.modules);
	    });
	  };
	
	  /**
	   * @namespace fis.utils
	   */
	  fis.utils = {};
	
	  /**
	   * @name getRequestParam
	   * @description Returns a single request parameter for the provided name
	   * @param name The name of the request parameter you are looking for
	   * @returns The value of the parameter if it is present only once or an array of values if it is present multiple times. Null is not found.
	   * @memberOf fis.utils
	   */
	  fis.utils.getRequestParam = function (name) {
	    var isString = function isString(value) {
	      return typeof value === 'string' || value instanceof String;
	    };
	    var re = new RegExp('[?&]' + encodeURIComponent(name) + '=([^&]*)', 'g');
	    var res = [];
	    var search = isString(this) ? this : window.location.search;
	    var match = re.exec(search);
	
	    while (match) {
	      res.push(decodeURIComponent(match[1]));
	      match = re.exec(search);
	    }
	
	    if (res.length === 0) {
	      return null;
	    } else if (res.length === 1) {
	      return res[0];
	    }
	
	    return res;
	  };
	
	  fis.utils.getInjector = function () {
	    return injector;
	  };
	
	  function findRootElement() {
	    var rootElement = document.querySelector && document.querySelector('[ng-app]');
	    if (rootElement) {
	      return angular.element(rootElement);
	    }
	    return null;
	  }
	
	  function findInjector() {
	    var root = findRootElement();
	    if (root) {
	      return root.injector();
	    }
	    return null;
	  }
	
	  angular.element(document).ready(function () {
	    angular.element(document).find('body').removeClass('fis-loading-indicator');
	    injector = findInjector();
	  });
	
	  console.log('  ____  _   _ _____\n' + ' |  _ \\| | | |  ___|\n' + ' | |_) | | | | |_\n' + ' |  _ <| |_| |  _|\n' + ' |_| \\_\\\\___/|_|\n' + ' FIS Responsive UI Framework\n' + ' Version: ' + fis.version + '\n © 2012-' + (new Date().getYear() + 1900) + ', all rights reserved.\n');
	})(window.fis = window.sg = window.fis || window.sg || {}, document);

/***/ }),
/* 7 */
/*!***********************************!*\
  !*** ./fis-angular-decorators.js ***!
  \***********************************/
/***/ (function(module, exports) {

	'use strict';
	
	var fis = window.fis = window.sg = window.fis || window.sg || {};
	
	fis.__angularModule = angular.module;
	
	fis.__controllers = {};
	
	angular.module = function (name, deps) {
	  'use strict';
	
	  var module = fis.__angularModule(name, deps);
	  var origCtrlFn = module.controller;
	
	  module.controller = function (name, constructor) {
	    var entry = constructor;
	
	    if (angular.isArray(constructor)) {
	      entry = constructor[constructor.length - 1];
	    }
	    fis.__controllers[name] = entry;
	
	    return origCtrlFn.apply(this, arguments);
	  };
	  return module;
	};

/***/ }),
/* 8 */
/*!***********************!*\
  !*** ./hook/index.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _hook = __webpack_require__(/*! ./hook.directive */ 9);
	
	var _hook2 = _interopRequireDefault(_hook);
	
	var _hookList = __webpack_require__(/*! ./hook-list.directive */ 10);
	
	var _hookList2 = _interopRequireDefault(_hookList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.hook', []);
	
	ngModule.directive('fisHook', _hook2.default);
	ngModule.directive('fisHookList', _hookList2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 9 */
/*!********************************!*\
  !*** ./hook/hook.directive.js ***!
  \********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "fisConfig", "$templateCache", "$parse", "fisTemplateCacheService", function ($compile, fisConfig, $templateCache, $parse, fisTemplateCacheService) {
	  'ngInject';
	
	  return {
	    restrict: 'E',
	    replace: 'true',
	    scope: true,
	    template: '<div class="hook"></div>',
	    link: function link(scope, elem, attrs) {
	      var setHookData = function setHookData() {
	        var fisHookData = $parse(attrs.fisHookData);
	        scope.fisHookData = fisHookData(scope);
	      };
	
	      if (attrs.fisHookData) {
	        setHookData();
	        attrs.$observe('fisHookData', function () {
	          setHookData();
	        });
	      }
	
	      if (attrs.id) {
	        var templateName = attrs.id;
	        var template = fisTemplateCacheService.getTemplate(templateName);
	
	        if (angular.isDefined(template)) {
	          if (attrs.ngController) {
	            template = addController(template, attrs);
	          }
	          var hook = angular.element(template);
	          elem.append(hook);
	          $compile(hook)(scope);
	        }
	      }
	    }
	  };
	
	  function addController(template, attrs) {
	    var startDiv = '<div ng-controller="' + attrs.ngController + '">';
	    var endDiv = '</div>';
	    return startDiv + template + endDiv;
	  }
	}];

/***/ }),
/* 10 */
/*!*************************************!*\
  !*** ./hook/hook-list.directive.js ***!
  \*************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "fisConfig", function ($compile, fisConfig) {
	  'ngInject';
	
	  return {
	    restrict: 'E',
	    replace: 'true',
	    template: '<div class="hookList" />',
	    link: function link(scope, elem, attrs) {
	      var newTemplate = buildHookListElement(attrs);
	      var hookList = angular.element(newTemplate);
	      elem.append(hookList);
	      $compile(hookList)(scope);
	    }
	  };
	
	  function buildHookListElement(attrs) {
	    var buffer = [];
	    if (fisConfig && fisConfig.hookListConfig) {
	      buffer.push('<div>');
	
	      fisConfig.hookListConfig.forEach(function (configItem) {
	        if (configItem.enabled === 'true') {
	          if (configItem.id === attrs.id) {
	            buffer.push(buildHookElement(configItem));
	          }
	        }
	      });
	      buffer.push('</div>');
	    }
	    return buffer.join('');
	  }
	
	  function buildHookElement(item) {
	    var hooks = item.hooks;
	    var buffer = ['<div'];
	    hooks.forEach(function (hookId) {
	      buffer.push('<div>');
	      buffer.push('<fis-hook id="');
	      buffer.push(hookId);
	      buffer.push('"');
	      buffer.push(' />');
	      buffer.push('</div>');
	    });
	    buffer.push('</div>');
	    return buffer.join('');
	  }
	}];

/***/ }),
/* 11 */
/*!***********************!*\
  !*** ./data/index.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _data = __webpack_require__(/*! ./data.directive */ 12);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _dataVar = __webpack_require__(/*! ./data-var.directive */ 13);
	
	var _dataVar2 = _interopRequireDefault(_dataVar);
	
	var _resourceService = __webpack_require__(/*! ./resource-service.provider */ 14);
	
	var _resourceService2 = _interopRequireDefault(_resourceService);
	
	var _criteriaService = __webpack_require__(/*! ./criteria-service.provider */ 15);
	
	var _criteriaService2 = _interopRequireDefault(_criteriaService);
	
	var _constraintsFactory = __webpack_require__(/*! ./constraints-factory.provider */ 16);
	
	var _constraintsFactory2 = _interopRequireDefault(_constraintsFactory);
	
	var _typeBasedConstraints = __webpack_require__(/*! ./type-based-constraints.value */ 17);
	
	var _typeBasedConstraints2 = _interopRequireDefault(_typeBasedConstraints);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.data', []);
	
	ngModule.directive('fisData', _data2.default);
	ngModule.directive('fisDataVar', _dataVar2.default);
	
	ngModule.provider('fisResourceService', _resourceService2.default);
	ngModule.provider('fisCriteriaService', _criteriaService2.default);
	ngModule.provider('fisConstraintsFactory', _constraintsFactory2.default);
	
	ngModule.value('typeBasedConstraints', _typeBasedConstraints2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 12 */
/*!********************************!*\
  !*** ./data/data.directive.js ***!
  \********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisResourceService", "$q", "$parse", "fisCriteriaService", "fisElementUtils", "$interpolate", "$timeout", "fisUtilService", "fisConfig", "fisScopeUtils", function (fisResourceService, $q, $parse, fisCriteriaService, fisElementUtils, $interpolate, $timeout, fisUtilService, fisConfig, fisScopeUtils) {
	  'ngInject';
	
	  var queryParameterPrefix = 'fisParam';
	
	  return {
	    restrict: 'A',
	    priority: 600,
	    compile: function compile(elem, attrs) {
	      // Save the original parameter expressions for later if required.
	      // We will need them for interpolating the variable values if we're running in an isolated scope.
	      attrs._paramVariables = fisElementUtils.copyProperties(attrs, queryParameterPrefix, {});
	
	      return function () {};
	    },
	    controller: ['$attrs', '$scope', '$element', function ($attrs, $scope, $element) {
	      var self = this;
	
	      var odataV3Adaptor = $attrs.fisAdaptor === 'odatav3' || fisConfig.dataSourceAdaptor === 'odatav3';
	      function isAlwaysFetch() {
	        return angular.isUndefined($attrs.fisFetchVisibleOnly) || !$attrs.fisFetchVisibleOnly;
	      }
	
	      // Only add the visibility watch when the fetching should depend on the visibility of the component
	      if (!isAlwaysFetch()) {
	        /*
	        Adds a watch to the visibility state of the element.
	        If the element is made visible and there was a call to fetchData while it was invisible,
	        the fetch is executed now.
	          scope.allowFetch is used again in fetchData below
	          */
	        var watchFn = function watchFn() {
	          $scope.allowFetch = $element.is(':visible');
	
	          if ($scope.allowFetch) {
	            if ($scope.deferred) {
	              $scope.deferred.resolve(self.fetchData($scope.lastParams));
	              $scope.deferred = undefined;
	              $scope.lastParams = undefined;
	            }
	          }
	        };
	        fisScopeUtils.postDigest($scope, function () {
	          return $element.is(':visible');
	        }, watchFn, $timeout, true);
	      }
	
	      if (!$attrs.fisData) {
	        throw new Error('You must provide a value to the fis-data attribute');
	      }
	
	      var functionExpression = $attrs.fisData.indexOf('(') !== -1;
	      var arrayExpression = $attrs.fisData.indexOf('[') !== -1;
	      var objectExpression = $attrs.fisData.indexOf('{') !== -1;
	      var fixedResourceUrl = !functionExpression && !arrayExpression && !objectExpression && $attrs.fisData.indexOf('/') !== -1;
	      var beforeFetchListeners = [];
	      var afterFetchListeners = [];
	      var dataChangedListeners = [];
	
	      var schema = {
	        // the JSON element that contains the array of data items
	        data: $parse($attrs.fisSchemaData)($scope) !== undefined ? $parse($attrs.fisSchemaData)($scope) : $attrs.fisSchemaData, // eslint-disable-line
	        // the JSON element that contains the total number of records in the entire dataset (useful for widgets that support some kind of pagination)
	        total: $attrs.fisSchemaTotal
	      };
	
	      var Resource;
	
	      // TODO: add fisSharedCriteria to allow providing a criteria that multiple widgets can share.
	      //       It will be merged with the Criteria created by the grid (translated from kendo filters)
	      //       before being sent to fetchData in the params: {crit: mergedCriteria}
	      //       This is needed to be able to provide complex search outside of the grid.
	
	      if (!fixedResourceUrl && !functionExpression) {
	        // watch to see if the provided fisData value changes (checking references, not equality).
	        // this is to determine if the fisData will be handling RESTful fetching
	        var fisDataChangeWatch = $scope.$watch($attrs.fisData, function (newVal, oldVal) {
	          if (!newVal) {
	            // $attrs.fisData doesn't resolve to a value. We keep resource as-is.
	            return;
	          }
	          // when the watch is initialized, this function is called with identical newVal and oldVal
	          if (newVal !== oldVal) {
	            // if a String value, the user may have changed the endpoint of the resource
	            Resource = determineResource($attrs, newVal);
	
	            self.fireDataChanged(newVal);
	          }
	        });
	        $scope.$on('$destroy', function () {
	          if (fisDataChangeWatch) {
	            fisDataChangeWatch();
	          }
	        });
	      }
	
	      /**
	       * @return Returns the schema object to be used
	       */
	      self.getSchema = function () {
	        return schema;
	      };
	
	      /**
	       * Can be used by a widget directive to tell that the data has changed and that the underlying dom widget (kendo or other)
	       * can be notified of that change and be refreshed accordingly (by invoking fetchData again).
	       * Note that fisData will already invoke this if it detects that the reference to the model has changed.
	       */
	      self.fireDataChanged = function (data) {
	        invokeListeners(dataChangedListeners, data);
	      };
	
	      /**
	       * @returns a promise that will resolve into an object with two properties:
	       * The data property will contain an array of objects and the total property will contain the total number
	       * of records available in the dataset, if this information is available. This total is used for pagination, so that
	       * widgets can calculate the total number of pages.
	       */
	      self.fetchData = function (params) {
	        if ($attrs.fisSort) {
	          // check if the attribute specified in fis-sort is assignable (scope object)
	          var fisSort = $parse($attrs.fisSort);
	          if (fisSort.assign && params) {
	            // add params to check to prevent widgets with fis-sort breaking if no params defined for assignable expression
	            // if fis-sort expression is assignable, update the expression whenever user interacts with the grid
	            // (manual sorting by clicking on column headers)
	            var sortExpressionArray = [];
	            if (odataV3Adaptor) {
	              var sortExpr = params.sort;
	              if (sortExpr) {
	                var sortDefs = sortExpr.split(',');
	                angular.forEach(sortDefs, function (sortDef) {
	                  var parts = sortDef.split(' ');
	                  if (parts.length === 2) {
	                    sortExpressionArray.push({ field: parts[0], dir: parts[1] });
	                  }
	                });
	              }
	            } else {
	              angular.forEach(params.sort, function (sortedParam) {
	                // here the param.sort received is in the format ["fieldName,sortOrder","fieldName,sortOrder",..]
	                // Convert it to [{field:fieldName, dir:sortOrder},{field:fieldName, dir:sortOrder}..] format
	                var parts = sortedParam.split(',');
	                sortExpressionArray.push({ field: parts[0], dir: parts[1] });
	              });
	            }
	            // Update the fis-sort assignable expression to the changed value
	            fisSort.assign($scope, sortExpressionArray.length === 1 ? sortExpressionArray[0] : sortExpressionArray);
	          }
	        }
	
	        // If not explicitely set to just fetch when visible the fetch function is always called
	        if (!isAlwaysFetch()) {
	          /*
	          Only fetch the data when the fetching is allowed (since the element is visible) - otherwise
	          enter this if and return just a promise that will be resolved once.
	            */
	          if (!$scope.allowFetch) {
	            // Store any provided parameters for later execution
	            $scope.lastParams = params;
	            if ($scope.deferred) {
	              // There is already a deferred execution of fetchData - return a new promise here as the resolution
	              var newDeferred = $q.defer();
	              $scope.deferred.resolve(newDeferred.promise);
	              $scope.deferred = newDeferred;
	            } else {
	              // This is the first call to fetchData since the element is invisible
	              $scope.deferred = $q.defer();
	            }
	
	            // Return just a promise for now - the watch on the visibility will resolve it later
	            return $scope.deferred.promise;
	          }
	        }
	
	        if ($attrs.fisCriteria) {
	          var mergedCriteria;
	          var mergedOperands;
	          var fisCriteria = fisCriteriaService.newCriteria($parse($attrs.fisCriteria)($scope));
	
	          if (params.crit) {
	            mergedOperands = [];
	            fisCriteria.operands.concat(params.crit.operands).forEach(function (operand) {
	              if (mergedOperands.indexOf(operand) === -1) {
	                mergedOperands.push(operand);
	              }
	            });
	            mergedCriteria = angular.extend(fisCriteria, params.crit);
	            mergedCriteria.operands = mergedOperands;
	          } else {
	            mergedCriteria = fisCriteria;
	          }
	          params.crit = mergedCriteria.toString();
	        }
	
	        Resource = determineResource($attrs);
	        invokeListeners(beforeFetchListeners, params);
	
	        params = fisElementUtils.copyProperties($attrs, queryParameterPrefix, params);
	
	        // When running in isolated scope, e.g. in fisGrid, we don't have access to the outer scope.
	        // Someone using a parameter like fis-param-foo="{{foo}}" would need to use {{$parent.foo}}
	        // to escape the isolated scope of fisGrid. To avoid that, we reevaluate the fis-param-*
	        // expressions against the parent scope. This way, the use doesn't need to care whether
	        // the directive uses isolated scope or not.
	        if ($scope.hasOwnProperty('$$isolateBindings') && $scope) {
	          // Loop over the parameter expressions that we saved in the compile function.
	          // The variables are not interpolated at this stage.
	          angular.forEach($attrs._paramVariables, function (val, key) {
	            // Interpolate the variable ourselves using the $interpolate service
	            // We use the parent scope to resolve the variables.
	            var interpolatedValue = $interpolate(val)($scope);
	
	            // Assign the variable to the respective entry in the params object,
	            // overwriting any value that was previously there.
	            params[key] = interpolatedValue;
	          });
	        }
	
	        if (Resource) {
	          return getDataFromResource(params);
	        }
	        // data retrieval is managed externally (could still come from a server)
	        var getter = $parse($attrs.fisData);
	        var promise;
	
	        if (functionExpression) {
	          // function expression
	          // wrap in a promise, chain promises if function also returns a promise
	          promise = $q.when(getter($scope, { params: params })).then(function (data) {
	            var resultData = invokeListeners(afterFetchListeners, normalizeData(data));
	            if (angular.isFunction(schema.data)) {
	              resultData.data = retrieveDataFromSchemaData(data);
	            }
	            return resultData;
	          }, function () {
	            // TODO: define exceptions
	            throw new Error('fisData could not get data from ' + $attrs.fisData);
	          });
	        } else {
	          var scoped = getter($scope);
	          if (angular.isFunction(scoped)) {
	            var result = scoped(params);
	            promise = $q.when(result).then(function (data) {
	              var resultData = invokeListeners(afterFetchListeners, normalizeData(data));
	              if (angular.isFunction(schema.data)) {
	                resultData.data = retrieveDataFromSchemaData(data);
	              }
	              return resultData;
	            }, function () {
	              throw new Error('fisData could not get data from ' + $attrs.fisData);
	            });
	          } else {
	            var deferred = $q.defer();
	            var resultData = invokeListeners(afterFetchListeners, normalizeData(scoped));
	            if (angular.isFunction(schema.data)) {
	              resultData.data = retrieveDataFromSchemaData(scoped);
	            }
	            deferred.resolve(resultData);
	            promise = deferred.promise;
	          }
	        }
	
	        return promise;
	      };
	
	      function retrieveDataFromSchemaData(data) {
	        var resultData = [];
	        var results = schema.data(data);
	        angular.forEach(results, function (item) {
	          resultData.push(item);
	        });
	        return resultData;
	      }
	
	      self.addDataChangedListener = function (listener) {
	        if (dataChangedListeners.indexOf(listener) === -1) {
	          dataChangedListeners.push(listener);
	        }
	        return function () {
	          var idx = dataChangedListeners.indexOf(listener);
	          if (idx !== -1) {
	            dataChangedListeners.splice(idx, 1);
	          }
	        };
	      };
	
	      self.addBeforeFetchListener = function (listener) {
	        if (beforeFetchListeners.indexOf(listener) === -1) {
	          beforeFetchListeners.push(listener);
	        }
	        return function () {
	          var idx = beforeFetchListeners.indexOf(listener);
	          if (idx !== -1) {
	            beforeFetchListeners.splice(idx, 1);
	          }
	        };
	      };
	
	      self.addAfterFetchListener = function (listener) {
	        if (afterFetchListeners.indexOf(listener) === -1) {
	          afterFetchListeners.push(listener);
	        }
	        return function () {
	          var idx = afterFetchListeners.indexOf(listener);
	          if (idx !== -1) {
	            afterFetchListeners.splice(idx, 1);
	          }
	        };
	      };
	
	      function normalizeData(data) {
	        if (data.data) {
	          return data;
	        }
	
	        if (angular.isArray(data)) {
	          if (data.length > 1) {
	            return {
	              data: data
	            };
	          } else if (data.length === 1) {
	            return {
	              data: data,
	              obj: data[0]
	            };
	          }
	        }
	        if (angular.isArray(data)) {
	          return {
	            data: data
	          };
	        }
	        if (schema && schema.data) {
	          var resultData = {
	            data: []
	          };
	          angular.extend(resultData, data);
	          if (schema.data !== 'data') {
	            var results;
	            if (angular.isString(schema.data)) {
	              results = fisUtilService.extractData(schema.data, data);
	            }
	            angular.forEach(results, function (item) {
	              resultData.data.push(item);
	            });
	          }
	
	          if (schema.total) {
	            resultData.total = data[schema.total];
	          }
	          if (schema.data !== 'data') {
	            delete resultData[schema.data];
	          }
	          if (schema.total !== 'total') {
	            delete resultData[schema.total];
	          }
	          return resultData;
	        }
	        return {
	          data: [data]
	        };
	      }
	
	      function invokeListeners(listeners, data) {
	        angular.forEach(listeners, function (listener) {
	          // invoke the listener and make sure it's returned data is normalized so that all listeners can expect the same format.
	          data = normalizeData(listener(data) || data);
	        });
	        return data;
	      }
	
	      function getDataFromResource(params) {
	        var instance;
	        var deferred = $q.defer();
	        var promise;
	
	        // here you can receive params that are objects but that you may not want to transform to JSON
	        // to pass as query parameters. Make sure they are marshalled to a string that is appropriate
	        // to the backend.
	        // TODO: provide a hook to marshall special objects (decorate params). For now, only translating Criteria to its string form
	        if (params.crit) {
	          params.crit = params.crit.toString();
	        }
	        if (odataV3Adaptor) {
	          if (params.crit) {
	            params.$filter = params.crit.toString();
	            delete params.crit;
	          }
	
	          if (angular.isNumber(params.offset)) {
	            params.$skip = params.offset;
	            delete params.offset;
	          }
	
	          if (angular.isNumber(params.limit)) {
	            params.$top = params.limit;
	            delete params.limit;
	          }
	
	          if (params.sort) {
	            params.$orderby = params.sort;
	            delete params.sort;
	          }
	          // TODO add $inlinecount only when schema.total is defined
	          // params.$inlinecount = 'allpages'; // ask for the total in the response
	          params.$format = 'json';
	        }
	        instance = Resource.getData(params, function () {
	          // don't return just instance.data, send back everything
	          deferred.resolve(invokeListeners(afterFetchListeners, instance));
	        }, function (d) {
	          // TODO: define exceptions (fisException service?)
	          deferred.reject(invokeListeners(afterFetchListeners, d));
	        });
	        promise = deferred.promise;
	        promise.data = instance.data;
	        return promise;
	      }
	
	      function determineResource(attrs, val) {
	        if (functionExpression) {
	          // fisData will not handle invoking the rest resource and will delegate to the function expression
	          return null;
	        }
	        val = val || fixedResourceUrl && attrs.fisData || $parse(attrs.fisData)($scope);
	
	        if (angular.isString(val)) {
	          // the value refers to a $resource URL
	          // fisData will handle RESTful fetching
	          return fisResourceService(val, null, null, schema);
	        } else if (!val) {
	          // $attrs.fisData is not empty but doesn't resolve to a scoped value, consider the string in $attrs.fisData as a $resource URL
	          // fisData will handle RESTful fetching
	          return fisResourceService(attrs.fisData, null, null, schema);
	        }
	        // fisData will not handle RESTful fetching
	        return null;
	      }
	    }]
	
	  };
	}];

/***/ }),
/* 13 */
/*!************************************!*\
  !*** ./data/data-var.directive.js ***!
  \************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$parse", "$timeout", "fisMemoryUtilService", function ($parse, $timeout, fisMemoryUtilService) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    require: 'fisData',
	    link: function link(scope, elem, attrs, fisData) {
	      if (angular.isUndefined(attrs.fisDataVar) || attrs.fisDataVar.length === 0) {
	        throw new Error('The fisDataVar attribute must have a value.');
	      }
	
	      var fisDataVarAttr = attrs.fisDataVar;
	
	      var loadData = function loadData(event) {
	        // do not execute the event if event.preventDefault() has been called before
	        if (event && event.defaultPrevented) {
	          return;
	        }
	        var timeout1 = $timeout(function () {
	          var promise = fisData.fetchData();
	          promise.then(function (result) {
	            var dataVar = $parse(fisDataVarAttr);
	            dataVar.assign(scope, result.data);
	          }, function (result) {
	            console.warn('Problem loading data: ' + result);
	          });
	        });
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, timeout1, $timeout);
	      };
	
	      // Refresh Event
	      if (angular.isDefined(attrs.fisRefresh)) {
	        scope.$on('fisRefresh', loadData);
	      }
	
	      // Adding listener on fisData, so that data is reloaded when fisData's endPoint changes
	      var dataChangeListener = function dataChangeListener() {
	        loadData();
	      };
	      fisData.addDataChangedListener(dataChangeListener);
	
	      // Does initial call to get data
	      loadData();
	    }
	  };
	}];

/***/ }),
/* 14 */
/*!*******************************************!*\
  !*** ./data/resource-service.provider.js ***!
  \*******************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  var self = this;
	
	  self.$get = ['$resource', 'fisUtilService', function ($resource, fisUtilService) {
	    return function (url, paramDefaults, actions, schema) {
	      var localResource = $resource(url, paramDefaults, actions);
	      localResource.getData = function (params, success, failure) {
	        var ret = {
	          data: []
	        };
	        if (schema && schema.data) {
	          localResource.get(params, function (d, headers) {
	            ret.data.length = 0;
	            angular.extend(ret, d);
	
	            if (schema.data !== 'data') {
	              if (schema.data === 'none') {
	                var res = {};
	                angular.forEach(d, function (key, val) {
	                  if (val.toString().indexOf('$') !== 0) {
	                    res[val] = key;
	                  }
	                });
	                ret.data.push(res);
	              } else {
	                var results;
	                if (angular.isString(schema.data)) {
	                  results = fisUtilService.extractData(schema.data, d);
	                } else if (angular.isFunction(schema.data)) {
	                  results = schema.data(d);
	                }
	                angular.forEach(results, function (item) {
	                  ret.data.push(item);
	                });
	              }
	            }
	
	            if (schema.total) {
	              ret.total = d[schema.total];
	            }
	            if (schema.data !== 'data' && schema.data !== 'none') {
	              delete ret[schema.data];
	            }
	            if (schema.total !== 'total') {
	              delete ret[schema.total];
	            }
	            success(ret, headers);
	          }, failure);
	        } else {
	          ret.data = localResource.query(params, function (d, headers) {
	            // send normalized data structure to success callback
	            success(ret, headers);
	          }, failure);
	        }
	        // always returns an object with an empty data array that gets filled when request is successful
	        return ret;
	      };
	
	      return localResource;
	    };
	  }];
	};

/***/ }),
/* 15 */
/*!*******************************************!*\
  !*** ./data/criteria-service.provider.js ***!
  \*******************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  function toInt(str) {
	    return parseInt(str, 10);
	  }
	
	  function parseISODate(value) {
	    var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
	    var match;
	    if (match = value.match(R_ISO8601_STR)) {
	      var date = new Date(0);
	      var tzHour = 0;
	      var tzMin = 0;
	      var dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear;
	      var timeSetter = match[8] ? date.setUTCHours : date.setHours;
	
	      if (match[9]) {
	        tzHour = toInt(match[9] + match[10]);
	        tzMin = toInt(match[9] + match[11]);
	      }
	      dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
	      var h = toInt(match[4] || 0) - tzHour;
	      var m = toInt(match[5] || 0) - tzMin;
	      var s = toInt(match[6] || 0);
	      var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
	      timeSetter.call(date, h, m, s, ms);
	      return date;
	    }
	    return value;
	  }
	
	  var self = this;
	
	  self.$get = [function () {
	    var service = {};
	
	    service.operators = ['and', 'or'];
	    service.operators.AND = service.operators[0];
	    service.operators.OR = service.operators[1];
	
	    service.constraints = ['eq', 'contains', 'ne', 'gt', 'ge', 'lt', 'le', 'startswith', 'endswith', 'is_null', 'not_contains', 'not_endswith', 'not_null', 'in_rel_range', 'not_in_rel_range', 'in_future', 'in_past', 'is_between', 'not_is_between', 'in', 'not_in', 'is_empty', 'not_empty', 'not_startswith'];
	    service.constraints.EQ = service.constraints[0];
	    service.constraints.CONTAINS = service.constraints[1];
	    service.constraints.NE = service.constraints[2];
	    service.constraints.GT = service.constraints[3];
	    service.constraints.GE = service.constraints[4];
	    service.constraints.LT = service.constraints[5];
	    service.constraints.LE = service.constraints[6];
	    service.constraints.STARTS_WITH = service.constraints[7];
	    service.constraints.ENDS_WITH = service.constraints[8];
	    service.constraints.IS_NULL = service.constraints[9];
	    service.constraints.NOT_CONTAINS = service.constraints[10];
	    service.constraints.NOT_ENDS_WITH = service.constraints[11];
	    service.constraints.NOT_NULL = service.constraints[12];
	    service.constraints.IN_REL_RANGE = service.constraints[13];
	    service.constraints.NOT_IN_REL_RANGE = service.constraints[14];
	    service.constraints.IN_FUTURE = service.constraints[15];
	    service.constraints.IN_PAST = service.constraints[16];
	    service.constraints.BETWEEN = service.constraints[17];
	    service.constraints.NOT_BETWEEN = service.constraints[18];
	    service.constraints.IN = service.constraints[19];
	    service.constraints.NOT_IN = service.constraints[20];
	    service.constraints.IS_EMPTY = service.constraints[21];
	    service.constraints.NOT_EMPTY = service.constraints[22];
	    service.constraints.NOT_STARTS_WITH = service.constraints[23];
	
	    var constraintsWithoutValue = [service.constraints.IS_EMPTY, service.constraints.NOT_EMPTY, service.constraints.IS_NULL, service.constraints.NOT_NULL];
	
	    function Criteria(operator) {
	      if (angular.isString(operator)) {
	        this.operator = operator || service.operators.AND;
	        this.operands = [];
	      } else if (angular.isObject(operator)) {
	        var jsonObj = operator;
	        var currentOperator = service.operators.AND;
	        if (jsonObj.operator) {
	          currentOperator = jsonObj.operator;
	        }
	        if (service.operators.indexOf(currentOperator) === -1) {
	          throw new Error('Invalid operator : ' + currentOperator);
	        }
	
	        var newCrit = service.newCriteria(currentOperator);
	
	        if (angular.isArray(jsonObj.operands)) {
	          completeCriteriaFromOperands(jsonObj.operands, newCrit);
	        }
	
	        return newCrit;
	      }
	    }
	
	    function completeCriteriaFromOperands(inputoperands, origCrit) {
	      for (var i = 0; i < inputoperands.length; i++) {
	        var operand = inputoperands[i];
	        if (operand.operator) {
	          var newCrit = service.newCriteria(operand.operator);
	          if (operand.operands) {
	            completeCriteriaFromOperands(operand.operands, newCrit);
	            origCrit.add(newCrit);
	          }
	        } else {
	          origCrit.add(new service.Criterion(operand.property, operand.value, operand.constraint, operand.type, operand.skipValidation));
	        }
	      }
	    }
	
	    Criteria.prototype.setOperator = function (operator) {
	      if (service.operators.indexOf(operator) === -1) {
	        throw new Error('Invalid operator : ' + operator);
	      }
	      this.operator = operator;
	      return this;
	    };
	
	    Criteria.prototype.add = function (operand) {
	      operand.validate();
	      this.operands.push(operand);
	      return this;
	    };
	
	    Criteria.prototype.setOperands = function (operands) {
	      this.operands = operands;
	      return this;
	    };
	
	    Criteria.prototype.isValid = function (isChild) {
	      if (service.operators.indexOf(this.operator) === -1) {
	        return false;
	      }
	      if (isChild && this.operands.length === 0) {
	        return false;
	      }
	      for (var i = 0; i < this.operands.length; i++) {
	        var operand = this.operands[i];
	        if (!angular.isUndefined(operand.skipValidation) && !operand.skipValidation && !operand.isValid(true)) {
	          return false;
	        }
	        var j = i + 1;
	        var nextOperand = this.operands[j];
	        if (nextOperand) {
	          if (!angular.isUndefined(nextOperand.skipValidation) && !nextOperand.skipValidation && !nextOperand.isValid(true)) {
	            return false;
	          }
	          if (service.operators.indexOf(this.operator) === -1) {
	            return false;
	          }
	        }
	      }
	      return true;
	    };
	
	    Criteria.prototype.validate = function () {
	      if (!this.isValid()) {
	        throw new Error('Invalid Criteria: ' + this);
	      }
	    };
	
	    Criteria.prototype.validateWithoutError = function () {
	      console.warn('DEPRECATED: Criteria.validateWithoutError. Use Criteria.isValid.');
	      return this.isValid();
	    };
	
	    Criteria.prototype.toString = function () {
	      var crit = this.getAsString();
	      var finalCrit = '';
	      if (crit) {
	        finalCrit = crit.substring(1);
	        finalCrit = finalCrit.substring(0, finalCrit.length - 1);
	      }
	      return finalCrit;
	    };
	
	    Criteria.prototype.getAsString = function () {
	      var crit = '(';
	      for (var i = 0; i < this.operands.length; i++) {
	        var operand = this.operands[i];
	        crit += operand.getAsString();
	        var j = i + 1;
	        var next = this.operands[j];
	        if (next) {
	          crit += ' ';
	          crit += this.operator;
	          crit += ' ';
	        }
	      }
	      crit += ')';
	
	      return crit;
	    };
	
	    function isNumber(value) {
	      return !isNaN(parseFloat(value)) && isFinite(value);
	    }
	
	    function isValidValue(value, constraint, type) {
	      if ((angular.isUndefined(value) || value === '') && value !== 0) {
	        if (constraintsWithoutValue.indexOf(constraint) === -1) {
	          return false;
	        }
	        return true;
	      } else if (constraintsWithoutValue.indexOf(constraint) > -1) {
	        return false;
	      }
	
	      if ((type === 'integer' || type === 'number' || type === 'double') && !isNumber(value)) {
	        return false;
	      }
	      if (type === 'date' || type === 'datetime' || type === 'time') {
	        if (!value.toISOString) {
	          try {
	            new Date(value).toISOString();
	          } catch (e) {
	            // SDHTML-13812 - IE javascript engine cannot parse date in '2016-06-06T00:16:07+0000' format
	            value = parseISODate(value);
	            if (!angular.isUndefined(value)) {
	              try {
	                return Boolean(angular.isDate(value) ? value.toISOString() : new Date(value).toISOString());
	              } catch (e) {
	                return false;
	              }
	            }
	            return false;
	          }
	        }
	      }
	      if (type === 'boolean') {
	        if (typeof value !== 'boolean' && value !== 'true' && value !== 'false') {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    // criterion object
	    function Criterion(property, value, constraint, type, skipValidation) {
	      this.property = property || null;
	      this.value = angular.isUndefined(value) ? '' : value;
	      this.constraint = constraint || service.constraints.EQ;
	      this.type = type;
	      this.skipValidation = skipValidation;
	    }
	
	    function marshallValue(value, type) {
	      if (type === 'integer' || type === 'boolean' || type && type.substring(0, 6) === 'double' || type === 'number') {
	        return value;
	      }
	      if (type === 'date' || type === 'datetime' || type === 'time') {
	        if (!value.toISOString) {
	          /* eslint-disable no-negated-condition */
	          if (!isNaN(Date.parse(value))) {
	            value = new Date(value);
	          } else {
	            // SDHTML-13812 - IE javascript engine cannot parse date in '2016-06-06T00:16:07+0000' format
	            value = parseISODate(value);
	          }
	          /* eslint-enable no-negated-condition */
	        }
	        return 'datetime\'' + value.toISOString() + '\'';
	      }
	      return '\'' + value.toString().replace(/'/g, '\'\'') + '\'';
	    }
	
	    Criterion.prototype.getAsString = function () {
	      // var spaceWithStarIfCaseInsensitive = this.ignoreCase ? '' : '*';
	      var result = '';
	      switch (this.constraint) {
	        case 'startswith':
	        case 'endswith':
	          result = this.constraint + '(' + this.property + ',' + marshallValue(this.value, this.type) + ')';
	          break;
	        case 'not_startswith':
	        case 'not_endswith':
	          result = 'not ' + this.constraint.substring(this.constraint.indexOf('_') + 1) + '(' + this.property + ',' + marshallValue(this.value, this.type) + ')';
	          break;
	        case 'contains':
	          result = 'substringof(' + marshallValue(this.value, this.type) + ',' + this.property + ') eq true';
	          break;
	        case 'not_contains':
	          result = 'substringof(' + marshallValue(this.value, this.type) + ',' + this.property + ') eq false';
	          break;
	        case 'is_null':
	          result = this.property + ' eq null';
	          break;
	        case 'not_null':
	          result = this.property + ' ne null';
	          break;
	        case 'is_empty':
	          result = this.property + ' eq \'\'';
	          break;
	        case 'not_empty':
	          result = this.property + ' ne \'\'';
	          break;
	        default:
	          if (this.skipValidation || service.constraints.indexOf(this.constraint) < 0) {
	            result = this.property + ' ' + this.constraint + ' ' + this.value;
	          } else {
	            result = this.property + ' ' + this.constraint + ' ' + marshallValue(this.value, this.type);
	          }
	      }
	      return result;
	    };
	
	    Criterion.prototype.isValid = function () {
	      if (!this.property || service.constraints.indexOf(this.constraint) === -1 || !isValidValue(this.value, this.constraint, this.type)) {
	        return false;
	      }
	      return true;
	    };
	
	    Criterion.prototype.validate = function () {
	      if (!angular.isUndefined(this.skipValidation) && !this.skipValidation && !this.isValid()) {
	        throw new Error('Invalid Criterion: ' + this);
	      }
	    };
	
	    Criterion.prototype.validateWithoutError = function () {
	      console.warn('DEPRECATED: Criterion.validateWithoutError. Use Criterion.isValid.');
	      return this.isValid();
	    };
	
	    Criterion.prototype.setProperty = function (property) {
	      if (!property) {
	        throw new Error('Invalid property');
	      }
	      this.property = property;
	      return this;
	    };
	
	    Criterion.prototype.setValue = function (value) {
	      this.value = value;
	      return this;
	    };
	
	    Criterion.prototype.setConstraint = function (constraint) {
	      if (service.constraints.indexOf(constraint) === -1) {
	        throw new Error('Invalid constraint : ' + constraint);
	      }
	      this.constraint = constraint;
	      return this;
	    };
	
	    service.newCriteria = function (operator) {
	      if (!operator) {
	        operator = service.operators.AND;
	      }
	      if (angular.isString(operator)) {
	        if (service.operators.indexOf(operator) === -1) {
	          throw new Error('Invalid operator : ' + operator);
	        }
	      }
	      return new Criteria(operator);
	    };
	
	    service.Criteria = Criteria;
	    service.Criterion = Criterion;
	
	    return service;
	  }];
	};

/***/ }),
/* 16 */
/*!**********************************************!*\
  !*** ./data/constraints-factory.provider.js ***!
  \**********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  self.$get = ['typeBasedConstraints', function (typeBasedConstraints) {
	    var constraintsFactory = {};
	
	    constraintsFactory.getConstraintsByType = function (type) {
	      var result = typeBasedConstraints[type];
	      if (angular.isDefined(result)) {
	        return result;
	      }
	      return typeBasedConstraints.string;
	    };
	
	    return constraintsFactory;
	  }];
	};

/***/ }),
/* 17 */
/*!**********************************************!*\
  !*** ./data/type-based-constraints.value.js ***!
  \**********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var basicConstraints = [{ value: 'eq', label: 'is' }, { value: 'ne', label: 'is not' }, { value: 'is_null', label: 'is null' }, { value: 'not_null', label: 'is not null' }];
	
	var numberConstraints = basicConstraints.concat([{ value: 'gt', label: 'greater than' }, { value: 'ge', label: 'greater than or equal to' }, { value: 'lt', label: 'less than' }, { value: 'le', label: 'less than or equal to' }]);
	
	var defaultConstraints = basicConstraints.concat([{ value: 'contains', label: 'contains' }, { value: 'not_contains', label: 'not contains' }, { value: 'is_empty', label: 'is empty' }, { value: 'not_empty', label: 'is not empty' }, { value: 'startswith', label: 'starts with' }, { value: 'not_startswith', label: 'not starts with' }, { value: 'endswith', label: 'ends with' }, { value: 'not_endswith', label: 'not ends with' }]);
	
	exports.default = {
	    string: defaultConstraints,
	    integer: numberConstraints,
	    currency: numberConstraints,
	    percentage: numberConstraints,
	    number: numberConstraints,
	    double: numberConstraints,
	    date: numberConstraints,
	    datetime: numberConstraints,
	    time: numberConstraints,
	    defaultType: defaultConstraints,
	    boolean: basicConstraints
	};

/***/ }),
/* 18 */
/*!*****************************!*\
  !*** ./directives/index.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _utils = __webpack_require__(/*! ./utils */ 19);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _dragdrop = __webpack_require__(/*! ./dragdrop */ 29);
	
	var _dragdrop2 = _interopRequireDefault(_dragdrop);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.directives', [_utils2.default, _dragdrop2.default]);
	
	exports.default = ngModule.name;

/***/ }),
/* 19 */
/*!***********************************!*\
  !*** ./directives/utils/index.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _elementUtils = __webpack_require__(/*! ./element-utils.factory */ 20);
	
	var _elementUtils2 = _interopRequireDefault(_elementUtils);
	
	var _fieldDirectiveFactory = __webpack_require__(/*! ./field-directive-factory.factory */ 21);
	
	var _fieldDirectiveFactory2 = _interopRequireDefault(_fieldDirectiveFactory);
	
	var _scopeUtils = __webpack_require__(/*! ./scope-utils.factory */ 23);
	
	var _scopeUtils2 = _interopRequireDefault(_scopeUtils);
	
	var _uniqueIdService = __webpack_require__(/*! ./unique-id-service.factory */ 24);
	
	var _uniqueIdService2 = _interopRequireDefault(_uniqueIdService);
	
	var _input = __webpack_require__(/*! ./input.directive */ 25);
	
	var _input2 = _interopRequireDefault(_input);
	
	var _applyClassDirective = __webpack_require__(/*! ./apply-class-directive.directive */ 26);
	
	var _applyClassDirective2 = _interopRequireDefault(_applyClassDirective);
	
	var _triggerDirectives = __webpack_require__(/*! ./trigger-directives.directive */ 27);
	
	var _triggerDirectives2 = _interopRequireDefault(_triggerDirectives);
	
	var _uniqueId = __webpack_require__(/*! ./unique-id.directive */ 28);
	
	var _uniqueId2 = _interopRequireDefault(_uniqueId);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Utilities for component/directive authoring
	
	var ngModule = _angular2.default.module('fis.core.directives.utils', []);
	
	ngModule.factory('fisElementUtils', _elementUtils2.default);
	ngModule.factory('fisFieldDirectiveFactory', _fieldDirectiveFactory2.default);
	ngModule.factory('fisScopeUtils', _scopeUtils2.default);
	ngModule.factory('fisUniqueIdService', _uniqueIdService2.default);
	
	ngModule.directive('fisInput', _input2.default);
	ngModule.directive('fisApplyClassDirective', _applyClassDirective2.default);
	ngModule.directive('fisUniqueId', _uniqueId2.default);
	
	['fisReinit', 'fisRefresh'].forEach(function (directive) {
	  ngModule.directive(directive, (0, _triggerDirectives2.default)(directive));
	});
	
	exports.default = ngModule.name;

/***/ }),
/* 20 */
/*!***************************************************!*\
  !*** ./directives/utils/element-utils.factory.js ***!
  \***************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var service = {};
	
	  /**
	   * @description Allows filtering properties of a provided source object to set them without the provided prefix
	   * on a target object.
	   * @param {Object} sourceObject The object from which the properties should be taken.
	   * @param {String} prefix The not empty prefix applied to filter the properties of the source object.
	   * @param {Object} targetObject The optional target object on which to set the properties. If not provided, a new object is created.
	   */
	  service.copyProperties = function (sourceObject, prefix, targetObject) {
	    if (sourceObject === undefined) {
	      throw 'sourceObject must be provided'; // eslint-disable-line
	    }
	
	    if (prefix === undefined || typeof prefix !== 'string' || prefix.length < 1) {
	      throw 'no not empty string prefix provided. Got ' + prefix; // eslint-disable-line
	    }
	
	    if (targetObject === undefined) {
	      targetObject = {};
	    }
	
	    // Filter all object properties for the prefix
	    var propertyNames = Object.keys(sourceObject).filter(function (property) {
	      return property.substring(0, prefix.length) === prefix;
	    });
	
	    // Add the property values to the target object
	    if (propertyNames !== undefined) {
	      angular.forEach(propertyNames, function (propertyName) {
	        // truncate the name, throw away the prefix
	        var truncatedName = propertyName.substr(prefix.length);
	
	        // Adjust the first letter to be lowerCase
	        truncatedName = truncatedName.substring(0, 1).toLowerCase() + truncatedName.substring(1);
	
	        targetObject[truncatedName] = sourceObject[propertyName];
	      });
	    }
	
	    return targetObject;
	  };
	
	  /**
	   * Helps in migrating attrs.$observe invocations from AngularJS 1.2.x to 1.3+.
	   * 1.2 used to invoke the listener function once if the attribute is undefined.
	   * IT IS PREFERABLE TO REFACTOR YOUR CODE THAN TO USE THIS FUNCTION.
	   */
	  service.invokeAndObserve = function (attrs, key, fn) {
	    // if attribute is present, no need to invoke since observe will.
	    if (!angular.isDefined(attrs[key])) {
	      fn(undefined);
	    }
	    attrs.$observe(key, fn);
	  };
	
	  return service;
	};

/***/ }),
/* 21 */
/*!*************************************************************!*\
  !*** ./directives/utils/field-directive-factory.factory.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisUniqueIdService", "fisScopeUtils", function (fisUniqueIdService, fisScopeUtils) {
	  'ngInject';
	
	  var fieldTemplate = '<div class="fis-field control-group">\n                <%var isExpVal=false;if (field.attrs.fisLabel  || field.attrs.required !== undefined) {if(field.attrs.fisLabel && field.attrs.fisLabel.indexOf("\'") > -1){field.attrs.fisLabel = field.attrs.fisLabel.replace(/\'/g,\'"\');}if(field.attrs.fisLabel && field.attrs.fisLabel.indexOf("{{") > -1){field.attrs.fisLabel = field.attrs.fisLabel.replace(/{|}/g,"");isExpVal=true;}%><label class="control-label"><span><span class="fis-req">*</span><%if(isExpVal){%><span ng-bind-html="<%- field.attrs.fisLabel %>"></span><%} else{%><span ng-bind-html="\'<%- field.attrs.fisLabel %>\'"></span><%}%></span></label><%}%>\n                <div class="controls">\n                    <div ng-show="fisEditMode" class="wrap fis-inputs" fis-unique-id="edit_mode">\n                    <%= field.editTemplate %>\n                    </div>\n                    <div ng-show="!fisEditMode" class="wrap fis-view-value control-label-view" fis-unique-id="not_edit_mode">\n                    <%= field.viewTemplate %>\n                    </div>\n                    <% if (field.attrs.fisInstruct){ %><span ng-show="fisEditMode" class="fis-instruct-message"><%- field.attrs.fisInstruct %></span> <% } %>\n                    <span ng-show="fisEditMode" fis-field-message></span>\n                </div>\n            </div>';
	
	  var FieldController = function FieldController($scope, $element, $attrs, $transclude, $parse) {
	    if ($scope.$parent.fisEditMode !== true && $scope.$parent.fisEditMode !== false) {
	      // set fisEditMode on the parent if it is not already set.
	      // this takes care of fields that are outside of an fisFields directive.
	      $scope.$parent.fisEditMode = true;
	    }
	
	    fisScopeUtils.watch($scope.$parent, $attrs.fisDisabled, function (disabled) {
	      $scope.fisDisabled = disabled;
	
	      var required = $parse($attrs.fisRequired)($scope);
	
	      if (required === true) {
	        if (disabled === true) {
	          // Was required, is now disabled, so remove the required flag
	          $scope.fisRequired = false;
	          $element.removeClass('fis-required');
	        } else {
	          // Was required, the flag might have been removed earlier, so re-add it
	          $scope.fisRequired = true;
	          $element.addClass('fis-required');
	        }
	      }
	    });
	
	    fisScopeUtils.watch($scope.$parent, $attrs.fisRequired, function (required) {
	      $scope.fisRequired = required;
	
	      if (required) {
	        $element.addClass('fis-required');
	      } else if ($attrs.required == null) {
	        // eslint-disable-line
	        $element.removeClass('fis-required');
	      }
	    });
	
	    fisScopeUtils.watch($scope.$parent, $attrs.fisEditMode, function (editMode) {
	      $scope.fisEditMode = editMode;
	    });
	
	    /**
	     * @name registeredInputs
	     * @description Hash of model property to ngModel.
	     * Used by fisFieldMessage to dispatch valid state to ngModel
	     * @methodOf FieldController
	     */
	    $scope.registeredInputs = {};
	
	    var models = [];
	
	    /**
	     * @name registerInput
	     * @description Registers a ngModel controller. Invoked by fisInput controller
	     * @methodOf FieldController
	     */
	    $scope.registerInput = function (ngModel) {
	      if (ngModel.fisProperty) {
	        $scope.registeredInputs[ngModel.fisProperty] = ngModel;
	        models.push(ngModel);
	      }
	    };
	
	    $scope.unregisterInput = function (ngModel) {
	      if (ngModel.fisProperty && $scope.registeredInputs[ngModel.fisProperty] === ngModel) {
	        delete $scope.registeredInputs[ngModel.fisProperty];
	
	        var idx = models.indexOf(ngModel);
	        if (idx > -1) {
	          delete models[idx];
	        }
	      }
	    };
	
	    $scope.fieldValue = function () {
	      // TODO: provide access to fis-input element(s) inside transclusion
	      // scope.fisFieldValueFn is the callback that is provided by the linkWrapper
	      return $scope.fisFieldValueFn($scope, $element, $attrs, models);
	    };
	  };
	
	  // default function used by scope.fieldValue which only takes care of single input fields (single ngModel per field)
	  // the models passed to it will be decorated with fisLabel, fisProperty and fisInput properties (this is done in fisInput directive)
	  function fieldValueFn(scope, element, attrs, models) {
	    return models[0] && models[0].$modelValue || '';
	  }
	
	  /**
	   * @name FieldDirective
	   * @methodOf fis.fis.core.forms
	   */
	  var FieldDirective = function FieldDirective(options) {
	    var self = this;
	    options = options || {};
	
	    // Using default priority of 0, just like any other directive does
	    self.priority = 0;
	
	    // Overwrite it with whatever the user has specified.
	    // Don't use the || approach since it doesn't handle 0 gracefully.
	    if (options.priority !== undefined) {
	      self.priority = options.priority;
	    }
	
	    self.restrict = options.restrict || 'ACE';
	    self.require = options.require; // should merge with this and only return array of required to outside link fn
	    self.transclude = options.transclude || false;
	    self.scope = true;
	    self.editTemplate = options.editTemplate || '';
	    self.viewTemplate = options.viewTemplate || '{{fieldValue()}}';
	    self.fieldValue = options.fieldValue || fieldValueFn;
	
	    self.compiledTemplate = _.template(fieldTemplate);
	
	    self.controller = options.controller || ['$scope', '$element', '$attrs', '$transclude', '$parse', FieldController];
	
	    self.compile = function (element, attrs, transclude) {
	      var context = {
	        editTemplate: self.editTemplate,
	        viewTemplate: self.viewTemplate,
	        attrs: attrs
	      };
	
	      attrs.fisSize = attrs.fisSize || 'large';
	
	      // attaching the editTemplate and viewTemplate to the main fieldTemplate
	      var markup = self.compiledTemplate({ field: context });
	
	      if (markup.indexOf('<%') !== -1) {
	        markup = _.template(markup)({ field: context });
	      }
	
	      var tplElement = angular.element(markup);
	
	      /* Call moveAssignAttributesToInputs to move and assign attributes to inputs element
	        * - If elements have compile function with transclusion then input element added after compilation,
	        *  so in this case move and assign attributes after compilation done.
	        * - If input elements have link function then input element already added,
	        *  so in this case first move and assign attributes to input element and then call link function.
	        */
	      var result;
	
	      if (options.compile) {
	        // if the FieldDirective was provided with a compile function, invoke it.
	        // We pass it the tplElement we just created but also the original element to allow
	        // inspecting it in a provided compile function before it gets replaced below.
	        result = linkWrapper(options.compile(tplElement, attrs, transclude, element), self.fieldValue);
	        moveAssignAttributesToInputs(attrs, tplElement);
	      } else {
	        moveAssignAttributesToInputs(attrs, tplElement);
	        // return the link function
	        result = linkWrapper(options.link || angular.noop, self.fieldValue);
	      }
	
	      // replace the provided element with the newly constructed one.
	      element.replaceWith(tplElement);
	
	      return result;
	    };
	    return self;
	  };
	
	  // Function mo ves and assign attributes to input element
	  function moveAssignAttributesToInputs(attrs, tplElement) {
	    // find the input elements in the assembled template element
	    var inputs = findInputs(tplElement);
	
	    // find the label element in the assembled template element
	    var labels = findLabel(tplElement);
	
	    // move attributes from the template's root element to each input element found, following naming convention
	    moveAttributesToInputs(attrs, tplElement, inputs);
	
	    // assign additional attributes to inputs (e.g. ng-disabled)
	    assignAttributesToInputs(attrs, tplElement, inputs);
	
	    // move attributes from the template's root element to each label element found, following naming convention
	    moveAttributesToLabel(attrs, tplElement, labels);
	  }
	
	  function linkWrapper(linkFn, valueFn) {
	    return function (scope, element, attrs, ctrls) {
	      if (attrs.fisLabel === undefined) {
	        if (attrs.required != null) {
	          // eslint-disable-line
	          element.find('.control-label').addClass('without-fis-label');
	        }
	        element.find('.controls').addClass('without-fis-label');
	      }
	
	      attrs.$observe('ngRequiredInput', function (value) {
	        if (value === 'true') {
	          element.addClass('fis-required');
	        }
	      });
	
	      var editModelName = element.find('input').attr('ng-model');
	
	      if (!editModelName) {
	        editModelName = element.find('select').attr('ng-model');
	      }
	
	      fisUniqueIdService.generateUniqueId(scope, element.find('.fis-view-value'), attrs, 'view_' + editModelName);
	
	      scope.fisFieldValueFn = valueFn;
	      if (linkFn) {
	        linkFn(scope, element, attrs, ctrls);
	      }
	    };
	  }
	
	  /*
	    * @name moveAttributes
	    * @param attrs The angular Attributes object for the directive
	    * @param rootElement The angular decorated root element of the directive
	    * @param inputs A hash of input element name to decorate element.
	    * @private
	    */
	  function moveAttributesToInputs(attrs, rootElement, inputs) {
	    var rootAttrs = attrs;
	
	    // move attributes for each input found
	    angular.forEach(inputs, function (elem, name) {
	      var inputAttrs = getAttributesForInput(attrs, name);
	      // remove the attributes found from the rootAttrs
	      rootAttrs = _.omit(rootAttrs, _.keys(inputAttrs));
	      // Object.keys(inputAttrs).forEach(function (inputAttr){
	      //    rootAttrs[inputAttr] = undefined;
	      // });
	      // copy the attributes minus the ending part (i.e. ng-model-input becomes ng-model for the element marked as 'input')
	      angular.forEach(inputAttrs, function (attr) {
	        elem.attr(attr.name, attr.val);
	      });
	    });
	
	    // rootAttrs now contains only the attributes that were not assigned to inputs
	    // add them to the root element of the directive
	    angular.forEach(rootAttrs, function (val, key) {
	      if (key === 'class') {
	        rootElement.addClass(val);
	      } else {
	        var denormalized = attrs.$attr[key];
	        if (denormalized) {
	          rootElement.attr(denormalized, val);
	        }
	      }
	    });
	  }
	
	  /*
	    * @name moveAttributesToLabel
	    * @param attrs The angular Attributes object for the directive
	    * @param rootElement The angular decorated root element of the directive
	    * @param label A hash of label element name to decorate element.
	    * @private
	    */
	  function moveAttributesToLabel(attrs, rootElement, label) {
	    var rootAttrs = attrs;
	
	    // move attributes for each label found
	    angular.forEach(label, function (elem, name) {
	      var labelAttrs = getAttributesForLabel(attrs, name);
	
	      // remove the attributes found from the rootAttrs
	      rootAttrs = _.omit(rootAttrs, _.keys(labelAttrs));
	      // Object.keys(labelAttrs).forEach(function (labelAttr){
	      //    rootAttrs[labelAttr] = undefined;
	      // });
	
	      // copy the attributes minus the ending part (i.e. class-label becomes class for the element marked as 'label')
	      angular.forEach(labelAttrs, function (attr) {
	        if (attr.name === 'class') {
	          elem.addClass(attr.val);
	        } else {
	          elem.attr(attr.name, attr.val);
	        }
	      });
	    });
	
	    // rootAttrs now contains only the attributes that were not assigned to inputs
	    // add them to the root element of the directive
	    angular.forEach(rootAttrs, function (val, key) {
	      if (key === 'class') {
	        rootElement.addClass(val);
	      } else {
	        var denormalized = attrs.$attr[key];
	
	        if (denormalized) {
	          rootElement.attr(denormalized, val);
	        }
	      }
	    });
	  }
	
	  /*
	    * @description This function will make sure the template elements to be compiled follow our form field conventions
	    * so that widget developers and page developers don't have to know about them.
	    * @param {Object} attrs Angular Attributes object for the root element
	    * @param {Object} root The template's root element
	    * @param {Object} inputs The array of input elements
	    * @private
	    */
	  function assignAttributesToInputs(attrs, root, inputs) {
	    // TODO: if any of the input is marked required by a ng-required-value for example, put fis-required class on root element
	    angular.forEach(inputs, function (elem) {
	      elem.attr('ng-disabled', 'fisDisabled');
	      elem.attr('fis-unique-id', '');
	
	      if (attrs.required != null) {
	        // eslint-disable-line
	        // let's empty string ("") through, DON'T CHANGE TO !== ELSE THINGS BREAK
	        elem.attr('required', true);
	      } else {
	        elem.attr('ng-required', 'fisRequired');
	      }
	    });
	
	    if (attrs.required != null) {
	      // eslint-disable-line
	      // DON'T CHANGE TO !== ELSE THINGS BREAK
	      root.addClass('fis-required');
	    }
	  }
	
	  function getAttributesForInput(attrs, name) {
	    var ret = {};
	    var endsWith = '-' + name;
	    var re = new RegExp(endsWith + '$');
	
	    angular.forEach(attrs, function (val, key) {
	      var denormalized = attrs.$attr[key];
	
	      if (denormalized && denormalized.match(re)) {
	        // remove the last part of the attribute name
	        var attrName = denormalized.substring(0, denormalized.length - endsWith.length);
	        ret[key] = { name: attrName, val: val };
	      }
	    });
	
	    return ret;
	  }
	
	  function getAttributesForLabel(attrs, name) {
	    var ret = {};
	    var endsWith = '-' + name;
	    var re = new RegExp(endsWith + '$');
	
	    angular.forEach(attrs, function (val, key) {
	      var denormalized = attrs.$attr[key];
	
	      if (denormalized && denormalized.match(re)) {
	        // remove the last part of the attribute name
	        if (denormalized !== 'fis-label') {
	          var attrName = denormalized.substring(0, denormalized.length - endsWith.length);
	          ret[key] = { name: attrName, val: val };
	        }
	      }
	    });
	
	    return ret;
	  }
	
	  function findInputs(parent) {
	    var ret = {};
	
	    var nodeList = parent[0].querySelectorAll('[fis-input]');
	    for (var i = 0; i < nodeList.length; ++i) {
	      var elem = angular.element(nodeList[i]);
	      ret[elem.attr('fis-input') || 'input'] = elem;
	    }
	
	    return ret;
	  }
	
	  function findLabel(parent) {
	    var ret = {};
	
	    parent.find('label').each(function (index, n) {
	      var elem = angular.element(n);
	      ret[elem.attr('fis-label') || 'label'] = elem;
	    });
	
	    return ret;
	  }
	
	  return {
	
	    create: function create(options) {
	      return new FieldDirective(options);
	    },
	
	    // TODO: remove this when we have removed requireJS, only needed for tests to be able to access
	    _FieldController: FieldController
	
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 22)))

/***/ }),
/* 22 */
/*!********************!*\
  !*** external "_" ***!
  \********************/
/***/ (function(module, exports) {

	module.exports = _;

/***/ }),
/* 23 */
/*!*************************************************!*\
  !*** ./directives/utils/scope-utils.factory.js ***!
  \*************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var service = {};
	
	  /**
	   * @description Allows setting a watch on a specified scope and invoke a callback with the watched value as an argument
	   * It also treats 'true'/'false' as hardcoded values and will not put a watch in these cases. This is useful when you are watching a directive attribute.
	   * @param {Object} scope The scope on witch to put a watch.
	   * @param {String} watched The scoped model to watch. If 'true' or 'false', the value is converted to a boolean and passed directly to the callback.
	   * @param {function} cb Callback to be invoked when the value changes. Can be invoked many times in the same $digest. Should be idempotent.
	   * @param {Object|String} def If provided, def will be passed to the callback if watched is falsy.
	   */
	  service.watch = function (scope, watched, cb, def) {
	    if (!cb) {
	      throw new Error('No callback provided!');
	    }
	
	    if (!watched) {
	      // check for null and undefined. DON'T CHANGE TO !== ELSE THINGS BREAK.
	      if (def != null) {
	        // eslint-disable-line
	        cb(def);
	      }
	      return;
	    }
	
	    if (watched === 'true') {
	      cb(true);
	    } else if (watched === 'false') {
	      cb(false);
	    } else {
	      scope.$watch(watched, function (value) {
	        cb(value);
	      });
	    }
	  };
	
	  /**
	   * Trigger a watch function once after a digest cycle competed
	   * @param scope scope to create the $watch at
	   * @param listener function returning the property to watch for (similarly to the first parameter you pass to regular scope.$watch)
	   * @param callback function ti be executed after the digest cycle completed
	   * @param $timeout reference to angular $timeout service
	   * @param apply boolean, true if the callback should be wrapped in scope.$apply, false to execute without wrapping
	   */
	  service.postDigest = function (scope, listener, callback, $timeout, apply) {
	    return function () {
	      var unregister;
	      var previous;
	      var timeout;
	
	      // Register some cleanup methods at the scope
	      scope.$on('$destroy', function () {
	        if (timeout) {
	          $timeout.cancel(timeout);
	        }
	        if (unregister) {
	          unregister();
	        }
	      });
	
	      function postDigest(callback) {
	        // Register a $watch with custom function as watchExpression.
	        // A watchExpression will be executed in every digest cycle
	        unregister = scope.$watch(function () {
	          // In the first digest cycle unregister this watch again
	          // to avoid creating multiple timeouts (infinity loop)
	          unregister();
	          // Create a timeout, this timeout will be executed after the digest cycle finished
	          timeout = $timeout(function () {
	            var current = listener();
	            // Check whether our listener changed
	            if (current !== previous) {
	              if (apply) {
	                // Execute callback in $scope.$apply phase
	                (function (current, previous) {
	                  scope.$apply(function () {
	                    callback(current, previous);
	                  });
	                })(current, previous);
	              } else {
	                callback(current, previous);
	              }
	              previous = current;
	            }
	            // Recursive call to register for the next digest cycle
	            postDigest(callback);
	          }, 0, false);
	        });
	      }
	
	      // Start postDigest Cycle
	      postDigest(callback);
	    }();
	  };
	
	  return service;
	};

/***/ }),
/* 24 */
/*!*******************************************************!*\
  !*** ./directives/utils/unique-id-service.factory.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  /**
	   * Replace all non alphanumeric characters by an underscore
	   * @param value which should be cleaned up
	   * @param spacesOnly boolean, whether only spaces should be replaced or all non alphanumeric characters
	   * @returns {String}
	   */
	  function replaceNonAlphaNumeric(value, spacesOnly) {
	    var pattern = /[^\w_\-]+/g;
	    if (spacesOnly) {
	      pattern = /[^\w]+/g;
	    }
	    return value.replace(pattern, '_');
	  }
	
	  /**
	   * Append extend to base, separated by an underscore if base is a string of non-zero length
	   * Otherwise extend gets returned
	   * @param base
	   * @param extend
	   * @returns {String} concatenation of base and extend, separated by underscore
	   */
	  function appendOrReplace(base, extend) {
	    var ret = base;
	    if (angular.isString(extend)) {
	      if (angular.isString(base) && base.length > 0) {
	        ret = base + '_' + extend;
	      } else {
	        ret = extend;
	      }
	    }
	    return ret;
	  }
	
	  var service = {
	
	    generateUniqueId: function () {
	      return function (scope, element, attributes, idBase, allowOverride, seed) {
	        if (angular.isString(idBase) && idBase.indexOf(' ') !== -1) {
	          return service.generateIdWithStaticSeed(scope, element, attributes, undefined, undefined, replaceNonAlphaNumeric(idBase, true), seed);
	        }
	
	        if (fis.initParams().appStage === 'T' || fis.initParams().appStage === 'D') {
	          // test appStage
	          return service.generateUniqueIdForce(scope, element, attributes, idBase, allowOverride, seed);
	        }
	      };
	    }(),
	
	    generateUniqueIdForce: function () {
	      var idCounter = {};
	      var initialized = false;
	
	      return function (scope, element, attributes, idBase, allowOverride, seed) {
	        if (!initialized) {
	          scope.$root.$on('$routeChangeStart', function () {
	            idCounter = {};
	          });
	          initialized = true;
	        }
	
	        // if the element already has an fisid we do not want to change it.
	        if (!allowOverride && element && angular.isDefined(element.attr('fisid'))) {
	          var nonGenId = element.attr('fisid');
	          return nonGenId;
	        }
	
	        var returnValue = idBase || '';
	
	        if (!returnValue) {
	          if (attributes.ngModel) {
	            returnValue = attributes.ngModel;
	          } else if (attributes.ngClick) {
	            if (scope.item && scope.item.path) {
	              returnValue = scope.item.path;
	            } else {
	              returnValue = attributes.ngClick;
	            }
	          } else if (attributes.fisI18n) {
	            returnValue = attributes.fisI18n;
	          }
	        }
	
	        if (seed === undefined) {
	          seed = '';
	        }
	
	        returnValue = replaceNonAlphaNumeric(returnValue) + seed;
	
	        if (idCounter[returnValue]) {
	          idCounter[returnValue] += 1;
	        } else {
	          idCounter[returnValue] = 1;
	        }
	        returnValue = returnValue + '_' + idCounter[returnValue];
	
	        if (element && (allowOverride || !element.attr('fisid'))) {
	          element.attr('fisid', returnValue);
	        }
	
	        return returnValue;
	      };
	    }(),
	
	    generateIdWithStaticSeed: function () {
	      return function (scope, element, attributes, idBase, childIdBase, staticId, seed) {
	        var idPrefix = attributes.fisUniqueIdSeed || idBase || '';
	
	        if (childIdBase) {
	          idPrefix += childIdBase;
	        }
	
	        idPrefix = appendOrReplace(idPrefix, angular.isArray(staticId) ? staticId.join('_') : staticId);
	
	        idPrefix = replaceNonAlphaNumeric(idPrefix);
	
	        if (seed === undefined) {
	          seed = '';
	        }
	        idPrefix += seed;
	
	        if (element && !element.attr('fisid')) {
	          element.attr('fisid', idPrefix);
	        }
	
	        return idPrefix;
	      };
	    }()
	
	  };
	
	  return service;
	};

/***/ }),
/* 25 */
/*!*********************************************!*\
  !*** ./directives/utils/input.directive.js ***!
  \*********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  function extractProperty(path, sep, $scope) {
	    var parts = path.split('.');
	
	    // To handle component case where user provide ng-model like '$ctrl.user.name'
	    if (parts.length > 1 && $scope && $scope.$ctrl && $scope.$ctrl.constructor.name !== 'AppComponentController') {
	      parts.splice(0, 1);
	    }
	
	    if (parts.length > 1) {
	      parts.splice(0, 1);
	    }
	
	    var result;
	    if (sep) {
	      result = parts.join(sep).replace(/[[\]]+/g, sep);
	    } else {
	      result = parts.join('.');
	    }
	    return result;
	  }
	
	  return {
	    restrict: 'AC',
	    priority: 400,
	    require: 'ngModel',
	    controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {
	      // before the ngModel controller is loaded (directive priority is higher),
	      // make sure there's a name assigned to the input so that the ngModel controller
	      // can register itself to the form with that name.
	      if (!$attrs.name && $attrs.ngModel) {
	        $attrs.name = extractProperty($attrs.ngModel, '_', $scope);
	      }
	    }],
	    link: function link(scope, element, attrs, ngModel) {
	      element.addClass('fis-input');
	
	      if (scope.registerInput) {
	        ngModel.fisProperty = extractProperty(attrs.ngModel, undefined, scope);
	        // useful when passed to FieldDirective's fieldValueFn.
	        ngModel.fisInput = attrs.fisInput || 'input';
	        ngModel.fisLabel = attrs.fisLabel;
	        if (attrs.name) {
	          ngModel.fisName = attrs.name;
	        }
	        scope.registerInput(ngModel);
	        element.on('$destroy', function () {
	          scope.unregisterInput(ngModel);
	        });
	      }
	    }
	  };
	};

/***/ }),
/* 26 */
/*!*************************************************************!*\
  !*** ./directives/utils/apply-class-directive.directive.js ***!
  \*************************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", function ($compile) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    priority: 590,
	    terminal: true,
	    compile: function compile() {
	      return function postLink(scope, element, attrs) {
	        element.addClass(scope.$eval(attrs.fisApplyClassDirective));
	
	        $compile(element, null, 590)(scope);
	      };
	    }
	  };
	}];

/***/ }),
/* 27 */
/*!**********************************************************!*\
  !*** ./directives/utils/trigger-directives.directive.js ***!
  \**********************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (directive) {
	  return function () {
	    return {
	      restrict: 'A',
	      controller: ['$scope', '$attrs', function ($scope, $attrs) {
	        var self = this;
	
	        // put a watch on the attribute's expression and invoke the controller's trigger function
	        $scope.$watch($attrs[directive], function (newVal, oldVal) {
	          if (newVal !== oldVal) {
	            self.trigger($scope, newVal, oldVal);
	          }
	        }, true); // uses angular.equals
	
	        // default trigger function $broadcasts an event with the same name as the directive.
	        // Directives that require this directive can override this function and provide their own.
	        // Like this: triggerCtrl.trigger = function(scope, newVal, oldVal) {...}
	        self.trigger = function (scope, newVal, oldVal) {
	          scope.$broadcast(directive, { value: newVal, oldValue: oldVal });
	        };
	      }]
	    };
	  };
	};

/***/ }),
/* 28 */
/*!*************************************************!*\
  !*** ./directives/utils/unique-id.directive.js ***!
  \*************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisUniqueIdService", function (fisUniqueIdService) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    link: function link(scope, element, attributes) {
	      var seed = attributes.fisSeed;
	      if (seed === undefined) {
	        seed = '';
	      }
	      // if test mode, then we build up seeds for unique id's based on parents that contain fis-seed attributes
	      if (fis.initParams().appStage === 'T' || fis.initParams().appStage === 'D') {
	        if (seed.length > 0 && seed.charAt(0) !== '_') {
	          seed = '_' + seed;
	        }
	        var seedArr = element.parents('[fis-seed]');
	        if (seedArr.length > 0) {
	          for (var i = 0; i < seedArr.length; i++) {
	            var elem = angular.element(seedArr[i]);
	            seed = seed + '_' + elem.attr('fis-seed');
	            elem = undefined;
	          }
	        }
	      }
	      if (angular.isDefined(attributes.fisIdNoIncrement) && attributes.fisIdNoIncrement) {
	        fisUniqueIdService.generateIdWithStaticSeed(scope, element, attributes, undefined, undefined, attributes.fisUniqueId, seed);
	      } else if (attributes.fisIdNoIncrement !== '' && attributes.fisIdNoIncrement !== null) {
	        fisUniqueIdService.generateUniqueId(scope, element, attributes, attributes.fisUniqueId, undefined, seed);
	      } else {
	        fisUniqueIdService.generateUniqueId(scope, element, attributes, undefined, undefined, seed);
	      }
	    }
	  };
	}];

/***/ }),
/* 29 */
/*!**************************************!*\
  !*** ./directives/dragdrop/index.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _draggable = __webpack_require__(/*! ./draggable.directive */ 30);
	
	var _draggable2 = _interopRequireDefault(_draggable);
	
	var _dropTarget = __webpack_require__(/*! ./drop-target.directive */ 31);
	
	var _dropTarget2 = _interopRequireDefault(_dropTarget);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.directives.dragdrop', []);
	
	ngModule.directive('fisDraggable', _draggable2.default);
	ngModule.directive('fisDropTarget', _dropTarget2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 30 */
/*!****************************************************!*\
  !*** ./directives/dragdrop/draggable.directive.js ***!
  \****************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisPubSubService", function (fisPubSubService) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    link: function link(scope, element, attrs) {
	      var draggable = attrs.fisDraggable === true || attrs.fisDraggable === 'true';
	      element.attr('draggable', draggable);
	
	      var dragStartEvent = 'fisOnDragStart.' + attrs.fisDragDropType;
	      var dragEvent = 'fisOnDrag.' + attrs.fisDragDropType;
	      var dragEndEvent = 'fisOnDragEnd.' + attrs.fisDragDropType;
	
	      element.get(0).addEventListener('dragstart', function (e) {
	        fisPubSubService.publish(dragStartEvent, { event: e });
	      });
	
	      element.get(0).addEventListener('dragover', function (e) {
	        e.preventDefault();
	      });
	
	      element.get(0).addEventListener('drag', function (e) {
	        fisPubSubService.publish(dragEvent, { event: e });
	      });
	
	      element.get(0).addEventListener('dragend', function (e) {
	        fisPubSubService.publish(dragEndEvent, { event: e });
	      });
	    }
	  };
	}];

/***/ }),
/* 31 */
/*!******************************************************!*\
  !*** ./directives/dragdrop/drop-target.directive.js ***!
  \******************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisPubSubService", function (fisPubSubService) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    link: function link(scope, element, attrs) {
	      var dragEnterEvent = 'fisOnDragEnter.' + attrs.fisDragDropType;
	      var dragLeaveEvent = 'fisOnDragLeave.' + attrs.fisDragDropType;
	      var dropEvent = 'fisOnDrop.' + attrs.fisDragDropType;
	
	      element.get(0).addEventListener('dragover', function (e) {
	        e.preventDefault();
	      });
	
	      element.get(0).addEventListener('dragenter', function (e) {
	        fisPubSubService.publish(dragEnterEvent, { event: e });
	      });
	
	      element.get(0).addEventListener('dragleave', function (e) {
	        fisPubSubService.publish(dragLeaveEvent, { event: e });
	      });
	
	      element.get(0).addEventListener('drop', function (e) {
	        e.preventDefault();
	        fisPubSubService.publish(dropEvent, { event: e });
	      });
	    }
	  };
	}];

/***/ }),
/* 32 */
/*!**************************!*\
  !*** ./filters/index.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _interpolate = __webpack_require__(/*! ./interpolate.filter */ 33);
	
	var _interpolate2 = _interopRequireDefault(_interpolate);
	
	var _search = __webpack_require__(/*! ./search.filter */ 34);
	
	var _search2 = _interopRequireDefault(_search);
	
	var _uncamelcase = __webpack_require__(/*! ./uncamelcase.filter */ 35);
	
	var _uncamelcase2 = _interopRequireDefault(_uncamelcase);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.filters', []);
	
	ngModule.filter('interpolate', _interpolate2.default);
	ngModule.filter('search', _search2.default);
	ngModule.filter('uncamelcase', _uncamelcase2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 33 */
/*!***************************************!*\
  !*** ./filters/interpolate.filter.js ***!
  \***************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                                               * @name interpolate
	                                                                                                                                                                                                                                                                               * @description This filter allows replacing markers in a string with values.
	                                                                                                                                                                                                                                                                               * You can give it an array of string values, a string or an object hash to map a string value to a name.</p>
	                                                                                                                                                                                                                                                                               * <p>For an array or a string, the interpolation markers need to contain the index:</p>
	                                                                                                                                                                                                                                                                               * <pre>'Hello {0}' | interpolate ['World'] => 'Hello World'
	                                                                                                                                                                                                                                                                               * 'Hello {0} | interpolate 'Pierre' => 'Hello Pierre'</pre>
	                                                                                                                                                                                                                                                                               * <p>For an object hash, the interpolation markers need to contain the hash keys:</p>
	                                                                                                                                                                                                                                                                               * <pre>'Hello {firstName} {lastName} | interpolate {firstName: 'Pierre', lastName: 'Asselin'} => Hello Pierre Asselin</pre>
	                                                                                                                                                                                                                                                                               * <p>You can also use this filter inside a service or a controller by injecting the $filter service:</p>
	                                                                                                                                                                                                                                                                               * <pre>$filter('interpolate')('Hello {0}')</pre>
	                                                                                                                                                                                                                                                                               * @param {String} text The text to interpolate the values with
	                                                                                                                                                                                                                                                                               * @param {Object|String[]|String} val The value(s) to use for interpolation
	                                                                                                                                                                                                                                                                               * @methodOf fis.core.filters
	                                                                                                                                                                                                                                                                               */
	
	
	exports.default = function () {
	  'use strict';
	
	  return function (text, val) {
	    if (text) {
	      var str = String(text);
	
	      if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) !== 'object' && typeof val !== 'array') {
	        // eslint-disable-line
	        val = [val];
	      }
	      for (var itm in val) {
	        if (itm) {
	          var re = new RegExp('\\{' + itm + '\\}', 'mg');
	          str = str.replace(re, val[itm]);
	        }
	      }
	      return str;
	    }
	
	    return '';
	  };
	};

/***/ }),
/* 34 */
/*!**********************************!*\
  !*** ./filters/search.filter.js ***!
  \**********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  return function (list, queryObj, property) {
	    var requiredObj;
	    var queryKeys = queryObj ? Object.keys(queryObj) : [];
	    list.some(function (item) {
	      var currentItemMatchesQueryObj = queryKeys.every(function (queryKey) {
	        return queryObj[queryKey] === item[queryKey];
	      });
	      if (currentItemMatchesQueryObj) {
	        requiredObj = item;
	        return true;
	      }
	      return false;
	    });
	    if (requiredObj) {
	      if (property) {
	        return requiredObj[property] || '';
	      }
	      return requiredObj;
	    }
	    return '';
	  };
	};

/***/ }),
/* 35 */
/*!***************************************!*\
  !*** ./filters/uncamelcase.filter.js ***!
  \***************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  return function (text) {
	    if (text) {
	      return text
	      // insert a space between lower & upper
	      .replace(/([a-z])([A-Z])/g, '$1 $2')
	      // space before last upper in a sequence followed by lower
	      .replace(/\b([A-Z]+)([A-Z])([a-z])/, '$1 $2$3')
	      // uppercase the first character
	      .replace(/^\w/, function (str) {
	        return str.toUpperCase();
	      });
	    }
	    return '';
	  };
	};

/***/ }),
/* 36 */
/*!***********************!*\
  !*** ./i18n/index.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _translate = __webpack_require__(/*! ./translate.filter */ 37);
	
	var _translate2 = _interopRequireDefault(_translate);
	
	var _i18n = __webpack_require__(/*! ./i18n.filter */ 38);
	
	var _i18n2 = _interopRequireDefault(_i18n);
	
	var _i18nService = __webpack_require__(/*! ./i18n-service.provider */ 39);
	
	var _i18nService2 = _interopRequireDefault(_i18nService);
	
	var _translate3 = __webpack_require__(/*! ./translate.provider */ 40);
	
	var _translate4 = _interopRequireDefault(_translate3);
	
	var _i18n3 = __webpack_require__(/*! ./i18n.directive */ 41);
	
	var _i18n4 = _interopRequireDefault(_i18n3);
	
	var _translate5 = __webpack_require__(/*! ./translate.directive */ 42);
	
	var _translate6 = _interopRequireDefault(_translate5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.i18n', []);
	
	ngModule.filter('translate', _translate2.default);
	ngModule.filter('i18n', _i18n2.default);
	
	ngModule.provider('fisI18nService', _i18nService2.default);
	ngModule.provider('$translate', _translate4.default);
	
	ngModule.directive('fisI18n', _i18n4.default);
	ngModule.directive('translate', _translate6.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 37 */
/*!**********************************!*\
  !*** ./i18n/translate.filter.js ***!
  \**********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$translate", function ($translate) {
	  'ngInject';
	
	  return function (key, defaultValue) {
	    console.warn('You are using dummy translate filter. Please load and use angular-translate in your application or add a dependency on fis.i18n module');
	    return $translate.instant(key, defaultValue);
	  };
	}];

/***/ }),
/* 38 */
/*!*****************************!*\
  !*** ./i18n/i18n.filter.js ***!
  \*****************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisI18nService", "fisViewPanelService", function (fisI18nService, fisViewPanelService) {
	  'ngInject';
	
	  return function (key, DefalutValue) {
	    if (angular.isDefined(key)) {
	      if (key.indexOf('.') === -1) {
	        var view = fisViewPanelService.activeViewPanel();
	        if (view) {
	          key = [view.module, view.id, key];
	        }
	      }
	      return fisI18nService.translate(key, DefalutValue);
	    }
	  };
	}];

/***/ }),
/* 39 */
/*!***************************************!*\
  !*** ./i18n/i18n-service.provider.js ***!
  \***************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  var self = this;
	  var NOT_FOUND = '__NOT_FOUND__';
	
	  var defaultLocale = 'en';
	  self.setDefaultLocale = function (locale) {
	    defaultLocale = locale;
	  };
	
	  self.$get = ['$rootScope', '$http', '$q', '$location', 'fisPubSubService', 'fisConfig', '$translate', function ($rootScope, $http, $q, $location, fisPubSubService, conf, $translate) {
	    var serv = {};
	
	    var supportedLanguagesDeferred = $q.defer();
	    serv.supportedLanguages = supportedLanguagesDeferred.promise;
	
	    /**
	     * @name defaultLocale
	     * @description Getter function to access the framework default locale
	     * @return the default framework locale
	     * @methodOf angular.module('fis.core').fisI18nService
	     */
	    serv.defaultLocale = function () {
	      return defaultLocale;
	    };
	
	    var cancelTranslateLoadingSuccess = $rootScope.$on('$translateLoadingSuccess', function () {
	      fisPubSubService.publish('shell.i18nReady');
	      cancelTranslateLoadingSuccess();
	    });
	
	    /**
	     * @name locale
	     * @description Getter/setter function to access the current locale
	     *  @param [locale] The locale string to be set (optional).
	     *  @return the current locale
	     *  @methodOf angular.module('fis.core').fisI18nService
	     */
	    serv.locale = function (locale) {
	      if (locale) {
	        // only way to only request a single language is to
	        $translate.use(locale);
	        $http.defaults.headers.common['Accept-Language'] = locale;
	        fisPubSubService.publish('fisLocaleChanged', locale);
	      }
	
	      return locale || $translate.proposedLanguage();
	    };
	
	    serv.isTranslationReady = function () {
	      if ($translate.isReady() && $translate.getTranslationTable($translate.proposedLanguage()) !== null) {
	        return true;
	      }
	      return false;
	    };
	
	    function processLocaleConfiguration(defaultLang) {
	      var initLang = $location.search().lang || serv.defaultLocale();
	      if (initLang !== defaultLang && conf.supportedLanguages) {
	        // First check for actual language code like "de-CH" from supported language list
	        var foundLang;
	        conf.supportedLanguages.some(function (language) {
	          if (angular.equals(language.value, defaultLang)) {
	            foundLang = language;
	            return true;
	          }
	          return false;
	        });
	        // if not found then check for a fallback standard language code
	        // like "de" from supported language list
	        if (angular.isUndefined(foundLang)) {
	          var standardLangCode = defaultLang.split('-');
	          conf.supportedLanguages.some(function (language) {
	            if (angular.equals(language.value, standardLangCode[0])) {
	              foundLang = language;
	              return true;
	            }
	            return false;
	          });
	        }
	        if (angular.isDefined(foundLang)) {
	          initLang = foundLang.value ? foundLang.value : initLang;
	        }
	      }
	
	      $http.defaults.headers.common['Accept-Language'] = initLang;
	
	      $translate.use(initLang);
	
	      // only invoked once on load of the page (once config is loaded)
	      fisPubSubService.publish('fisLocaleSet', initLang);
	
	      supportedLanguagesDeferred.resolve(conf.supportedLanguages);
	      // Put the $location in the rootScope so that we can watch it
	      $rootScope.location = $location;
	
	      // put a watch on the lang request parameter and change the locale according to that parameter
	      $rootScope.$watch('location.search().lang', function (lang) {
	        if (lang && lang !== serv.locale()) {
	          serv.locale(lang);
	          // FIXME: removing the lang param because it screws up routes.
	          $rootScope.location.search('lang', null);
	        }
	      });
	    }
	    processLocaleConfiguration(fetchLocaleFromConfig());
	    // return config locale or fetch locale from browser
	    function fetchLocale() {
	      if (angular.isDefined(conf.locale)) {
	        return conf.locale;
	      }
	      return findBestDefaultLanguage();
	    }
	
	    // Retrieve locale as per configuration provided by user
	    function fetchLocaleFromConfig() {
	      var defaultLang = serv.defaultLocale();
	      if (angular.isDefined(conf.preferredLocale)) {
	        if (conf.preferredLocale === 'browser') {
	          defaultLang = findBestDefaultLanguage();
	        } else {
	          defaultLang = fetchLocale();
	        }
	      } else {
	        defaultLang = fetchLocale();
	      }
	      return defaultLang;
	    }
	
	    // find the closest language we can from what is sent through the "Accept-Language" header.
	    // After invocation of processLocaleConfiguration, we set the Accept-Language headers.
	    // Therefore, the config service's request is made using the browser's Accept-Language so the
	    // server can also return the language it receives.
	    function findBestDefaultLanguage() {
	      // Chrome and Firefox return the Accept-Language languages with navigator.languages.
	      // Not supported in other browsers
	      if (window.navigator.languages) {
	        return window.navigator.languages[0];
	      }
	
	      // Most supported. Returns Accept-Language on older firefox and OS language on IE 11
	      if (window.navigator.language) {
	        return window.navigator.language;
	      }
	
	      // IE specific property. Returns the operating system's natural language setting.
	      // http://msdn.microsoft.com/en-us/library/ie/ms535867(v=vs.85).aspx
	      if (window.navigator.userLanguage) {
	        return window.navigator.userLanguage;
	      }
	
	      // all supported browsers should have returned already
	      return 'en';
	    }
	
	    // This function is used to get the translated values for the specified keys
	    function getTranslatedValues(keysToTranslate, def, key, translations, translation) {
	      for (var i = 0; i < keysToTranslate.length; i++) {
	        // $translate.instant removes white spaces from string so compare trimmed value here as well
	        if (translations[keysToTranslate[i]] !== keysToTranslate[i].trim()) {
	          translation = translations[keysToTranslate[i]];
	          break;
	        }
	      }
	      return translation === NOT_FOUND ? (def === null || def === undefined) && key.join('.') || def : translation;
	    }
	
	    // This function returns the keysToTranslate array
	    function getKeysToTranslate(key) {
	      if (angular.isArray(key)) {
	        var ns = angular.copy(key);
	        var keysToTranslate = [];
	        while (ns.length > 0) {
	          if (ns[0]) {
	            keysToTranslate.push(ns.join('.'));
	          }
	          ns.shift();
	        }
	        return keysToTranslate;
	      }
	    }
	
	    /**
	     * @name translate
	     * @description provides a translation for the provided key
	     * @param {string|string[]} key The key to be translated. If an array, the service will try from the most significant (all elements joined to form a key) to the least significant (only the last element is used as the key)
	     * @param {string} [def] The default string to use if no translations are available
	     * @return The translated text if found, the default string provided or the key itself if nothing else can be returned
	     * @methodOf angular.module('fis.core').fisI18nService
	     */
	
	    // using $translate.instant
	    serv.translate = function (key, def) {
	      var translation = NOT_FOUND;
	      if (angular.isString(key)) {
	        key = key.split('.');
	      }
	      if (angular.isArray(key)) {
	        var keysToTranslate = getKeysToTranslate(key);
	        var translations = $translate.instant(keysToTranslate);
	        return getTranslatedValues(keysToTranslate, def, key, translations, translation);
	      }
	      return def || key;
	    };
	
	    /**
	     * @name translateAsync
	     * @description provides a translation for the provided key when translation data is not yet loaded
	     * @param {string|string[]} key The key to be translated. If an array, the service will try from the most significant (all elements joined to form a key) to the least significant (only the last element is used as the key)
	     * @param {string} [def] The default string to use if no translations are available
	     * @return Promise which will get resolved to the translated text if found, the default string provided or the key itself if nothing else can be returned
	     * @methodOf angular.module('fis.core').fisI18nService
	     */
	    serv.translateAsync = function (key, def) {
	      var translation = NOT_FOUND;
	      var translations;
	      var asyncTranslation = $q.defer();
	      if (angular.isString(key)) {
	        key = key.split('.');
	      }
	      var keysToTranslate = getKeysToTranslate(key);
	      // We have subscribed to '$translateChangeSuccess' event published by angular.translate module.
	      // Once the translation object is available, we will resolve the promise for UI translation of data.
	      var cancelTranslateChangeSuccess = $rootScope.$on('$translateChangeSuccess', function () {
	        translations = $translate.instant(keysToTranslate);
	        var result = getTranslatedValues(keysToTranslate, def, key, translations, translation);
	        asyncTranslation.resolve(result);
	        // un-registering '$translateChangeSuccess' event handler
	        cancelTranslateChangeSuccess();
	      });
	      return asyncTranslation.promise;
	    };
	    return serv;
	  }];
	};

/***/ }),
/* 40 */
/*!************************************!*\
  !*** ./i18n/translate.provider.js ***!
  \************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  var warningPrinted = false;
	  function dummy() {
	    if (!warningPrinted) {
	      warningPrinted = true;
	      console.warn('You are using dummy angular-translate APIs. Please load and use angular-translate in your application or add a dependency on fis.i18n module');
	    }
	  }
	
	  self.preferredLanguage = self.use = self.translations = dummy;
	
	  self.$get = ['$q', function ($q) {
	    var lang = '';
	    var $translate = function $translate(translationId, interpolateParams, interpolationId, defaultTranslationText /* , forceLanguage*/) {
	      dummy();
	      var deferred = $q.defer();
	      if (defaultTranslationText) {
	        deferred.resolve(defaultTranslationText);
	      } else {
	        deferred.resolve($translate.instant(translationId));
	      }
	      return deferred.promise;
	    };
	
	    $translate.instant = function (translationId /* , interpolateParams, interpolationId , forceLanguage*/) {
	      dummy();
	      var result = '';
	      if (angular.isArray(translationId) && translationId.length > 0) {
	        result = {};
	        translationId.forEach(function (key) {
	          result[key] = key;
	        });
	      } else {
	        result = translationId;
	      }
	      return result;
	    };
	
	    $translate.use = function (language) {
	      lang = language;
	      dummy();
	    };
	
	    $translate.proposedLanguage = function () {
	      dummy();
	      return lang;
	    };
	
	    return $translate;
	  }];
	};

/***/ }),
/* 41 */
/*!********************************!*\
  !*** ./i18n/i18n.directive.js ***!
  \********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    restrict: 'A',
	    link: function link(scope, element, attrs) {
	      if (!attrs.fisI18n) {
	        throw new Error('Should provide a value for the fis-i18n attribute');
	      }
	      element.html(scope.i18n(attrs.fisI18n, element.html() || undefined));
	    }
	  };
	};

/***/ }),
/* 42 */
/*!*************************************!*\
  !*** ./i18n/translate.directive.js ***!
  \*************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    restrict: 'AE',
	    link: function link(scope, element, attrs) {
	      console.warn('You are using dummy translate directive. Please load and use angular-translate in your application or add a dependency on fis.i18n module');
	      if (attrs.translate) {
	        element.html(attrs.translate);
	      } else {
	        element.html(element.text());
	      }
	    }
	  };
	};

/***/ }),
/* 43 */
/*!*************************!*\
  !*** ./pubsub/index.js ***!
  \*************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _pubsub = __webpack_require__(/*! ./pubsub.directive */ 44);
	
	var _pubsub2 = _interopRequireDefault(_pubsub);
	
	var _pubsub3 = __webpack_require__(/*! ./pubsub.service */ 45);
	
	var _pubsub4 = _interopRequireDefault(_pubsub3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.pubsub', []);
	
	ngModule.directive('fisPubSub', _pubsub2.default);
	ngModule.service('fisPubSubService', _pubsub4.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 44 */
/*!************************************!*\
  !*** ./pubsub/pubsub.directive.js ***!
  \************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                                               * @name fisPubSub
	                                                                                                                                                                                                                                                                               * @description event handling service for the framework
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               */
	
	
	exports.default = function () {
	  return {
	    restrict: 'A',
	    controller: ['$scope', 'fisPubSubService', function ($scope, fisPubSubService) {
	      var unsubs = [];
	      $scope.subscribe = function (topic, cb) {
	        var unsubscribe = fisPubSubService.subscribe(topic, cb);
	        unsubs.push(unsubscribe);
	        return unsubscribe;
	      };
	
	      $scope.publish = function (topic, payload) {
	        if ((typeof payload === 'undefined' ? 'undefined' : _typeof(payload)) === 'object') {
	          payload.$scope = $scope;
	        }
	
	        if ($scope.$root.$$phase === '$apply' || $scope.$root.$$phase === '$digest') {
	          return fisPubSubService.publish(topic, payload);
	        }
	
	        $scope.$apply(function () {
	          return fisPubSubService.publish(topic, payload);
	        });
	      };
	
	      // unsubscribe events when scope is destroyed
	      $scope.$on('$destroy', function () {
	        while (unsubs.length > 0) {
	          unsubs.pop()(); // pop the unsubscribe function and invoke it.
	        }
	      });
	    }]
	  };
	};

/***/ }),
/* 45 */
/*!**********************************!*\
  !*** ./pubsub/pubsub.service.js ***!
  \**********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$q", function ($q) {
	  'ngInject';
	
	  var listeners = {};
	  var count = 0;
	
	  function addListener(topic, callback, sticky) {
	    var id = count++;
	    if (!callback || !topic) {
	      return;
	    }
	    listeners[topic] = listeners[topic] || {};
	    listeners[topic]._sticky = sticky || listeners[topic]._sticky;
	    listeners[topic][id] = callback;
	
	    if (sticky && listeners[topic]._lastPayload !== undefined) {
	      // invoke callback immediately with the last payload
	      callback.call(listeners[topic]._lastPayload, listeners[topic]._lastPayload, topic);
	    }
	    var ret = function ret() {
	      // handle allows removing the listener
	      if (listeners[topic] && listeners[topic][id]) {
	        delete listeners[topic][id];
	      }
	    };
	    // add properties to function to allow inspecting the topic it is attached to.
	    ret.topic = topic;
	    ret.id = id;
	    return ret;
	  }
	
	  /**
	   * @name publish
	   * @description Publish to a topic
	   * @param [topic, payload] Passing the topic information and payload information.
	   */
	  this.publish = function (topic, payload) {
	    var deferred = $q.defer();
	    var retPromises = [];
	    var l = listeners[topic] || {};
	
	    if (l._sticky) {
	      l._lastPayload = payload;
	    }
	    for (var i in l) {
	      if (i.indexOf('_') !== 0) {
	        // Wrap every returned value into a promise. Non-promise return values will be resolved
	        // immediately.
	        retPromises.push($q.when(l[i].call(payload, payload, topic)));
	      }
	    }
	
	    $q.all(retPromises).then(function (retVals) {
	      if (retVals.indexOf(false) > -1) {
	        deferred.reject();
	      } else {
	        deferred.resolve(retVals);
	      }
	    }, function () {
	      deferred.reject();
	    });
	
	    return deferred.promise;
	  };
	
	  /**
	   * @name subscribe
	   * @description Subscribe to a topic
	   * @param [topic, callback, sticky]
	   * @memberOf sungard.event
	   * @returns Adds the listener and passes the handle.
	   */
	  this.subscribe = function (topic, callback, sticky) {
	    return addListener(topic, callback, sticky);
	  };
	
	  /**
	   * @name unsubscribe
	   * @description Unsubscribe to a topic
	   * @param [handle] Passing the handle to find out the topic information from the handle.
	   * @memberOf sungard.event
	   */
	  this.unsubscribe = function (handle) {
	    if (typeof handle === 'function') {
	      handle();
	    } else if (listeners[handle.topic] && listeners[handle.topic][handle.id]) {
	      delete listeners[handle.topic][handle.id];
	    }
	  };
	}];

/***/ }),
/* 46 */
/*!***************************!*\
  !*** ./services/index.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _exceptionHandler = __webpack_require__(/*! ./exception-handler.decorator */ 47);
	
	var _exceptionHandler2 = _interopRequireDefault(_exceptionHandler);
	
	var _clientStorageService = __webpack_require__(/*! ./client-storage-service.provider */ 48);
	
	var _clientStorageService2 = _interopRequireDefault(_clientStorageService);
	
	var _conditionalLoaderService = __webpack_require__(/*! ./conditional-loader-service.factory */ 49);
	
	var _conditionalLoaderService2 = _interopRequireDefault(_conditionalLoaderService);
	
	var _configServiceProvider = __webpack_require__(/*! ./config-service.provider.js */ 50);
	
	var _configServiceProvider2 = _interopRequireDefault(_configServiceProvider);
	
	var _httpErrorInterceptorProvider = __webpack_require__(/*! ./http-error-interceptor.provider.js */ 51);
	
	var _httpErrorInterceptorProvider2 = _interopRequireDefault(_httpErrorInterceptorProvider);
	
	var _templateCacheServiceProvider = __webpack_require__(/*! ./template-cache-service.provider.js */ 52);
	
	var _templateCacheServiceProvider2 = _interopRequireDefault(_templateCacheServiceProvider);
	
	var _userContextServiceProvider = __webpack_require__(/*! ./user-context-service.provider.js */ 53);
	
	var _userContextServiceProvider2 = _interopRequireDefault(_userContextServiceProvider);
	
	var _httpErrorInterceptorConfig = __webpack_require__(/*! ./http-error-interceptor.config.js */ 54);
	
	var _httpErrorInterceptorConfig2 = _interopRequireDefault(_httpErrorInterceptorConfig);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.services', []);
	
	ngModule.decorator('$exceptionHandler', _exceptionHandler2.default);
	
	ngModule.provider('fisClientStorageService', _clientStorageService2.default);
	ngModule.provider('fisConfigService', _configServiceProvider2.default);
	ngModule.provider('fisHttpErrorInterceptor', _httpErrorInterceptorProvider2.default);
	ngModule.provider('fisTemplateCacheService', _templateCacheServiceProvider2.default);
	ngModule.provider('fisUserContextService', _userContextServiceProvider2.default);
	
	ngModule.factory('fisConditionalLoaderService', _conditionalLoaderService2.default);
	
	ngModule.config(_httpErrorInterceptorConfig2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 47 */
/*!*************************************************!*\
  !*** ./services/exception-handler.decorator.js ***!
  \*************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$delegate", function ($delegate) {
	  'ngInject';
	
	  var doc = '\nSee https://www.csa.sungard.com/wiki/x/9xVMB';
	  var interceptors = {};
	  var ANY = '_any';
	
	  var handler = function exceptionHandler(exception, cause) {
	    var prop;
	    for (prop in interceptors) {
	      if (prop === ANY || exception.hasOwnProperty(prop)) {
	        interceptors[prop](exception, cause);
	      }
	    }
	
	    $delegate(exception, cause);
	  };
	
	  handler.intercept = function intercept(property, cb) {
	    if (!property) {
	      delete interceptors[ANY];
	      return;
	    }
	
	    if (angular.isFunction(property)) {
	      cb = property;
	      property = ANY;
	    }
	
	    if (angular.isString(property)) {
	      if (angular.isFunction(cb)) {
	        interceptors[property] = cb;
	      } else {
	        delete interceptors[property];
	      }
	    }
	  };
	
	  handler.intercept('userMessage', function (exception) {
	    exception.message += doc;
	  });
	
	  return handler;
	}];

/***/ }),
/* 48 */
/*!*****************************************************!*\
  !*** ./services/client-storage-service.provider.js ***!
  \*****************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  self.$get = ['$window', 'fisUserContextService', function ($window, fisUserContextService) {
	    var service = {};
	    var separator = '_';
	    var inited = false;
	    var appId;
	
	    service.init = function (id) {
	      appId = id;
	      inited = true;
	    };
	
	    function createStorageKey(key) {
	      var userKey = fisUserContextService.context() ? fisUserContextService.context().userId : null;
	      if (appId) {
	        if (userKey) {
	          return appId + separator + userKey + separator + key;
	        }
	        return appId + separator + key;
	      } else if (userKey) {
	        return userKey + separator + key;
	      }
	      return key;
	    }
	
	    /**
	     * method to persist data in client storage
	     * @param {String} key    key
	     * @param {Object} val    Object to be stored in client storage
	     * @param {Object|String} opts Optional additional attributes like scope (app or user) and storageType (session or default) | storageType
	     */
	    service.setItem = function (key, val, opts) {
	      if (!inited) {
	        throw new Error('Service not initialized with appId');
	      }
	      var storageKey = createStorageKey(key);
	      if ($window.sessionStorage && $window.localStorage) {
	        if (opts && (opts === 'session' || opts.storageType === 'session')) {
	          // options present, work with it
	          $window.sessionStorage.setItem(storageKey, angular.toJson(val));
	        } else {
	          // Add to localStorage
	          $window.localStorage.setItem(storageKey, angular.toJson(val));
	        }
	      } else {
	        throw new Error('localStorage/sessionStorage not supported by browser');
	      }
	    };
	
	    /**
	     * Method to get item from Client Storage
	     * @param  {String} key   Key
	     * @return {Object}       Object stored in Client storage
	     */
	    service.getItem = function (key) {
	      if (!inited) {
	        throw new Error('Service not initialized with appId');
	      }
	      if ($window.sessionStorage && $window.localStorage) {
	        var storageKey = createStorageKey(key);
	        return angular.fromJson($window.localStorage.getItem(storageKey)) || angular.fromJson($window.sessionStorage.getItem(storageKey));
	      }
	      throw new Error('localStorage/sessionStorage not supported by browser');
	    };
	
	    /**
	     * Method to remove item from Client Storage
	     * @param  {String} key   Key of the item to be removed
	     */
	    service.removeItem = function (key) {
	      if (!inited) {
	        throw new Error('Service not initialized with appId');
	      }
	      if ($window.sessionStorage && $window.localStorage) {
	        var storageKey = createStorageKey(key);
	        $window.localStorage.removeItem(storageKey);
	        $window.sessionStorage.removeItem(storageKey);
	      } else {
	        throw new Error('localStorage/sessionStorage not supported by browser');
	      }
	    };
	
	    return service;
	  }];
	};

/***/ }),
/* 49 */
/*!********************************************************!*\
  !*** ./services/conditional-loader-service.factory.js ***!
  \********************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$resource", "$q", "fisPubSubService", "$injector", function ($resource, $q, fisPubSubService, $injector) {
	  'ngInject';
	
	  function publishEvent(name, value) {
	    if (name) {
	      fisPubSubService.publish(name, value);
	    }
	  }
	
	  function conditionalLoader(constantName, urlTemplate, urlParams, eventName) {
	    var deferred;
	    var event = eventName || constantName && constantName + '.loaded';
	    var value;
	
	    if ($injector.has(constantName)) {
	      value = $injector.get(constantName);
	      publishEvent(event, value);
	      value.then = function syncThen(cb) {
	        return cb(value);
	      };
	      return value;
	    }
	    // return an aync promise
	    deferred = $q.defer();
	
	    if (!urlTemplate) {
	      deferred.reject('No ' + constantName + ' constant found and no URL to GET.');
	      return deferred.promise;
	    }
	
	    $resource(urlTemplate).get(urlParams || {}, function loadSuccess(value) {
	      var prop;
	
	      deferred.resolve(value);
	      publishEvent(event, value);
	
	      for (prop in value) {
	        if (value.hasOwnProperty(prop)) {
	          deferred.promise[prop] = value[prop];
	        }
	      }
	    }, function loadFailure(httpResponse) {
	      deferred.reject(httpResponse);
	    });
	    return deferred.promise;
	  }
	
	  return conditionalLoader;
	}];

/***/ }),
/* 50 */
/*!*********************************************!*\
  !*** ./services/config-service.provider.js ***!
  \*********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  var provider = this;
	  var eventName = 'shell.configReady';
	  var defaultFactory;
	
	  provider.config = function setConfig(cfg) {
	    if (angular.isObject(cfg)) {
	      cfg.then = function (cb) {
	        return cb(cfg);
	      };
	      provider.$get = function () {
	        return cfg;
	      };
	    } else {
	      provider.$get = defaultFactory;
	    }
	  };
	
	  defaultFactory = provider.$get = ['$resource', '$q', 'fisPubSubService', '$injector', 'fisConditionalLoaderService', function ($resource, $q, fisPubSubService, $injector, loader) {
	    var configPromise;
	
	    if (!$injector.has('fisConfig')) {
	      console.warn('DEPRECATED. Use a fisConfig constant instead to improve load speed.', 'https://www.csa.sungard.com/wiki/x/ggfNAg');
	    }
	
	    configPromise = loader('fisConfig', fis.initParams().configEndpoint, {}, eventName);
	
	    configPromise.then(function success() {
	      console.log('- Framework config loaded.');
	    }, function failure(err) {
	      // If err is a http response object, throw an error to notify developer the
	      // config endpoint used is not working.
	      // If not a response object, it means the developer intentionally left the configEnpoint empty
	      // and does not use the config service. This is not possible when using fis.start.
	      if (err.status) {
	        throw new Error('Framework config is required!');
	      }
	    });
	
	    return configPromise;
	  }];
	};

/***/ }),
/* 51 */
/*!*****************************************************!*\
  !*** ./services/http-error-interceptor.provider.js ***!
  \*****************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var provider = this;
	
	  // default HTTP status for firing fisLoginRequired: 403 Forbidden
	  var loginStatuses = [403];
	
	  provider.setLoginRequiredStatus = function (httpStatuses) {
	    var i;
	    loginStatuses = [];
	    if (angular.isNumber(httpStatuses)) {
	      loginStatuses = [httpStatuses];
	    } else if (angular.isArray(httpStatuses)) {
	      for (i = 0; i < httpStatuses.length; i++) {
	        if (angular.isNumber(httpStatuses[i])) {
	          loginStatuses.push(httpStatuses[i]);
	        }
	      }
	    }
	  };
	
	  provider.$get = ['$rootScope', '$q', 'fisPubSubService', function ($rootScope, $q, fisPubSubService) {
	    var successFn = function success(response) {
	      return response;
	    };
	
	    // default strategy is to reject but fire events.
	    // Another strategy could be to allow trying requests again after app confirms login (https://github.com/witoldsz/angular-http-auth)
	    var rejectNoRetry = function error(response) {
	      // check if the received error is in the HTTP statuses configured to $broadcast a fisLoginRequired event
	      if (loginStatuses.indexOf(response.status) !== -1) {
	        $rootScope.$broadcast('fisLoginRequired', response);
	      }
	
	      // publish response to the fisHTTPError topic
	      if (response.status >= 400 || response.status === 0) {
	        fisPubSubService.publish('fisHTTPError', response);
	      }
	      // 3xx range statuses are also going through this error callback but are not errors
	      // A strategy could try to load the location received in the response headers before rejecting the promise.
	
	      // reject the response and continue in chain
	      return $q.reject(response);
	    };
	
	    return {
	      response: successFn,
	      responseError: rejectNoRetry
	    };
	  }];
	};

/***/ }),
/* 52 */
/*!*****************************************************!*\
  !*** ./services/template-cache-service.provider.js ***!
  \*****************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  /**
	  * @private
	  */
	  var self = this;
	
	  /**
	  * @name $get
	  * @methodOf fisTemplateCacheService
	  * @description <p>Factory method to create instance of fisTemplateCacheService.</p>
	  */
	  self.$get = ['$templateCache', function ($templateCache) {
	    var service = {};
	
	    service.getTemplate = function (templateName) {
	      return $templateCache.get(templateName);
	    };
	
	    service.addTemplate = function (templateName, template) {
	      $templateCache.put(templateName, template);
	    };
	
	    service.removeTemplate = function (templateName) {
	      $templateCache.remove(templateName);
	    };
	
	    return service;
	  }];
	};

/***/ }),
/* 53 */
/*!***************************************************!*\
  !*** ./services/user-context-service.provider.js ***!
  \***************************************************/
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  self.$get = [function () {
	    var serv = {};
	
	    var userInContext;
	
	    serv.context = function (user) {
	      if (arguments.length === 1) {
	        userInContext = user;
	      } else {
	        var clonedUser = angular.copy(userInContext);
	        return clonedUser;
	      }
	    };
	    return serv;
	  }];
	};

/***/ }),
/* 54 */
/*!***************************************************!*\
  !*** ./services/http-error-interceptor.config.js ***!
  \***************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$httpProvider", function ($httpProvider) {
	  'ngInject';
	
	  $httpProvider.interceptors.push('fisHttpErrorInterceptor');
	}];

/***/ }),
/* 55 */
/*!************************!*\
  !*** ./utils/index.js ***!
  \************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _memoryUtilService = __webpack_require__(/*! ./memory-util-service.provider */ 56);
	
	var _memoryUtilService2 = _interopRequireDefault(_memoryUtilService);
	
	var _utilService = __webpack_require__(/*! ./util-service.provider */ 57);
	
	var _utilService2 = _interopRequireDefault(_utilService);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.utils', []);
	
	ngModule.provider('fisMemoryUtilService', _memoryUtilService2.default);
	ngModule.provider('fisUtilService', _utilService2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 56 */
/*!***********************************************!*\
  !*** ./utils/memory-util-service.provider.js ***!
  \***********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  self.$get = [function () {
	    var service = {};
	
	    service.enabled = true;
	    service.logging = false;
	
	    if (!service.enabled) {
	      console.warn('fisMemoryUtilService has been disabled!');
	    }
	
	    /**
	     * Convenience method attempty to clean off all references to enable garbage collection
	     * @param node -  the element to be cleaned
	     */
	    service.callCleanAll = function (node) {
	      service.removeListeners(node);
	      service.destroyNode(node);
	    };
	
	    /**
	     * Attempts to remove all listeners from node.
	     * @param domNode
	     */
	    service.removeListeners = function (domNode) {
	      if (angular.isDefined(domNode)) {
	        var node = $(domNode);
	        if (node.length === 1) {
	          var children = node.children();
	          if (angular.isDefined(children) && children.length > 0) {
	            children.get().forEach(function (child) {
	              service.removeListeners(child);
	            });
	          }
	        }
	        if (node.length > 1) {
	          // node is a "jQuery" object
	          node.get().forEach(function (child) {
	            service.removeListeners(child);
	          });
	        } else {
	          if (node.scope()) {
	            node.scope().$destroy(); // in case this is implemented in scope.
	          }
	          node.unbind();
	        }
	      }
	    };
	
	    /**
	     * Utility method to destroy node (html elements like dom nodes)
	     * https://developer.mozilla.org/en-US/docs/Web/API/Node.removeChild
	     * @param node to be destroyed.
	     */
	    service.destroyNode = function (node) {
	      if (node) {
	        service.destroyAllChildNodes(node);
	        if (node.parent) {
	          var parent = node.parent();
	          service.destroyAllChildNodes(parent);
	        }
	        node = null;
	      }
	    };
	
	    /**
	     * Utility method to destroy All Children Nodes (html elements like dom nodes)
	     * https://developer.mozilla.org/en-US/docs/Web/API/Node.removeChild
	     * @param parentNode to be destroyed.
	     */
	    service.destroyAllChildNodes = function (parentNode) {
	      if (angular.isUndefined(parentNode)) {
	        return;
	      }
	      if (parentNode.length && parentNode.length === 1) {
	        if (angular.isDefined(parentNode.children()) && parentNode.children().length > 0) {
	          var child = parentNode.children();
	          child.remove();
	          child = null;
	        }
	      }
	      if (parentNode.length && parentNode.length > 1) {
	        angular.forEach(parentNode, function (child) {
	          service.destroyAllChildNodes(child);
	        });
	      }
	    };
	
	    /**
	     * Utility to cancel timeout
	     * @param scope
	     * @param timeout
	     * @param $timeout
	     */
	    service.cancelTimeoutOnDestroy = function (scope, timeout, $timeout) {
	      if (angular.isDefined(scope)) {
	        scope.$on('$destroy', function () {
	          if (timeout) {
	            $timeout.cancel(timeout);
	          }
	        });
	      } else {
	        console.warn('Memory cleanup failed scope is undefined');
	      }
	    };
	
	    /**
	     * Utility to cancel timeout
	     * @param compCtrl - the component controller instance
	     * @param timeout
	     * @param $timeout
	     */
	    service.cancelTimeoutOnComponentCtrlDestroy = function (compCtrl, timeout, $timeout) {
	      if (compCtrl) {
	        compCtrl.$onDestroy = function () {
	          if (timeout) {
	            $timeout.cancel(timeout);
	          }
	        };
	      }
	    };
	
	    /**
	     * Utility to cancel timeout
	     * @param scope
	     * @param watch
	     */
	    service.cancelWatchOnDestroy = function (scope, watch) {
	      scope.$on('$destroy', function () {
	        if (watch) {
	          watch(); // unbinds watch
	        }
	      });
	    };
	
	    /**
	     * Utility to destroy scope and data
	     * @param scope
	     * @param element
	     */
	    service.destroyScopeAndData = function (scope, element) {
	      if (scope) {
	        scope.$destroy();
	      }
	      if (element) {
	        $(element).removeData('$scope').removeData('$isolateScope').removeData('$isolateScopeNoTemplate').removeClass('ng-scope');
	      }
	    };
	
	    /**
	     * Utility to destroy kendo widgets
	     * @param widgets - kendo widgets to destroy
	     * @param element
	     */
	    // https://github.com/telerik/kendo-ui-core/issues/99
	    // https://github.com/kendo-labs/knockout-kendo/issues/140
	    service.destroyKendoWidgets = function (widgets) {
	      if (widgets) {
	        try {
	          widgets.destroy();
	          widgets = null;
	        } catch (e) {}
	      }
	    };
	
	    service.purgeAttributes = function (elements) {
	      if (elements !== undefined && elements.length > 0) {
	        for (var e = 0; e < elements.length; e++) {
	          var element = elements[e];
	          angular.element(element).removeData().removeAttr(); // try clear jqlite / jquery cache
	          if (element.attributes !== undefined && element.attributes.length > 0) {
	            for (var a = element.attributes.length - 1; a >= 0; a--) {
	              if (element.attributes[a].name !== 'class') {
	                // so kendo doesnt break, we leave the classlist in
	                element.removeAttribute(element.attributes[a].name);
	              }
	            }
	          }
	          if (element.children !== undefined && element.children.length > 0) {
	            service.purgeAttributes(element.children);
	          }
	          a = undefined; // eslint-disable-line
	        }
	      }
	    };
	
	    return service;
	  }];
	};

/***/ }),
/* 57 */
/*!****************************************!*\
  !*** ./utils/util-service.provider.js ***!
  \****************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  self.$get = [function () {
	    var service = {};
	
	    /**
	     *@name calculateContainerWidth
	     *@param {Object} currentTabstrip.
	     *
	     *@description Returns the width of the Div containing the tabstrip.
	     * The extra width ensures there is always some space on the tabstrip.
	     * This method is in fisUtilService because it breaks the unit tests - uses jQuery to calculate the width of component on screen
	     * which is a problem for phantomJS which is headless
	     *
	     */
	    service.calculateContainerWidth = function (component) {
	      return parseFloat(component.width());
	    };
	
	    function queryStringToObject(queryString) {
	      var ret = {};
	      var queryPairs;
	
	      if (angular.isString(queryString)) {
	        queryPairs = queryString.split('&');
	      } else if (angular.isObject(queryPairs)) {
	        queryPairs = queryString;
	      }
	
	      queryPairs.forEach(function (queryElem) {
	        var elemParts = queryElem.split('=');
	        ret[elemParts[0]] = elemParts[1];
	      });
	      return ret;
	    }
	
	    function objectToQueryString(object) {
	      var str = '';
	      Object.keys(object).forEach(function (key) {
	        var val = object[key];
	        if (val !== null) {
	          str += key + '=';
	          if (angular.isDefined(val)) {
	            str += val;
	          }
	          str += '&';
	        }
	      });
	      return str.slice(0, -1);
	    }
	
	    /**
	     * Append custom parameters to a given URL. Already existing parameters will be overridden.
	     * Set the value of key to null to remove it from the url. Keeps existing anchors in the URL.
	     * @param url {String} The URL the parameters should be appended to.
	     * @param params {string|object} Object holding key-value pairs of parameters or query string in format "key=value" separated by &
	     * @returns {String} url enhanced by the parameters
	     */
	    service.appendQueryParameters = function (url, params) {
	      var pathString = url.match(/^([^?#]*)/i);
	      var queryString = url.match(/\?([^#]*)/i);
	      var anchorString = url.match(/(#.*)$/i);
	
	      // Set to empty String of no matches found, otherwise use the first (and hopefully only) match
	      pathString = pathString === null ? '' : pathString[1];
	      anchorString = anchorString === null ? '' : anchorString[1];
	
	      var queryObject = {};
	
	      if (queryString !== null) {
	        queryObject = queryStringToObject(queryString[1]);
	      }
	      if (angular.isString(params)) {
	        params = queryStringToObject(params);
	      }
	      var mergedQueryString = objectToQueryString(angular.extend(queryObject, params));
	      if (mergedQueryString !== '') {
	        pathString += '?';
	      }
	      return pathString + mergedQueryString + anchorString;
	    };
	
	    /**
	     * Append version and appStage parameters to a given URL
	     * @param url The URL the parameters should be appended to
	     * @param customVersion {String} optional Override the version value
	     * @returns {String} url with the cache query parameters added
	     */
	    service.appendCacheQueryParameter = function (url, customVersion) {
	      var cacheQueryObject = fis.getCacheQuery();
	      if (angular.isDefined(customVersion)) {
	        // Clone the object to not change the version setting
	        cacheQueryObject = angular.extend({}, cacheQueryObject);
	        cacheQueryObject.version = customVersion;
	      }
	      return service.appendQueryParameters(url, cacheQueryObject);
	    };
	
	    /**
	     * Extract data from complex JSON for nested path (multi level)
	     * @param schema JSON path
	     * @param data JSON response
	     * @returns extracted data from JSON response
	     */
	    service.extractData = function (schema, data) {
	      var results;
	      var temp = angular.copy(data);
	      var tokens = schema.split(/\.|(\(\))|(\[\d+?])/).filter(function (t) {
	        return t;
	      });
	      if (tokens.length === 1) {
	        results = temp[schema];
	      } else {
	        var isTokenArrayAccess = /^\[\d+\]$/;
	        for (var i = 0; i < tokens.length; i++) {
	          var extractValue;
	          if (isTokenArrayAccess.test(tokens[i])) {
	            extractValue = temp[parseInt(tokens[i].substr(1), 10)];
	          } else {
	            extractValue = temp[tokens[i]];
	          }
	          if (angular.isDefined(extractValue)) {
	            temp = extractValue;
	            results = temp;
	          }
	        }
	      }
	      return results;
	    };
	
	    /*
	    * This function does a proper boolean check and is necessary anywhere
	    * that an angular directive is pulling in an attribute that is meant
	    * to be a boolean. Sometimes the value coming in will be a string,
	    * so the shortcut ways of checking boolean state don't work.
	    */
	    service.booleanCheck = function (actualValue, defaultValue) {
	      if (actualValue === undefined || actualValue === null) {
	        // no value specified, so resort to default value
	        return defaultValue;
	      } else if (typeof actualValue === 'boolean') {
	        // specific check to make sure its boolean
	        return actualValue;
	      }
	      var lowercase = actualValue.toLowerCase();
	      // we have to be specific here, otherwise use the default
	      if (lowercase === 'true') {
	        return true;
	      } else if (lowercase === 'false') {
	        return false;
	      }
	      return defaultValue;
	    };
	
	    /**
	     * Checks whether a given value is NaN.
	     * This is not the same as the native isNaN function, which will
	     * also return true for many other not-number values, such as undefined.
	     *
	     * @param value
	     * @returns {boolean}
	     */
	    service.isNaN = function (value) {
	      return toString.call(value) === '[object Number]' && value !== Number(value);
	    };
	
	    return service;
	  }];
	};

/***/ }),
/* 58 */
/*!************************!*\
  !*** ./views/index.js ***!
  \************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _angularAnimate = __webpack_require__(/*! angular-animate */ 5);
	
	var _angularAnimate2 = _interopRequireDefault(_angularAnimate);
	
	var _angularRoute = __webpack_require__(/*! angular-route */ 59);
	
	var _angularRoute2 = _interopRequireDefault(_angularRoute);
	
	var _views = __webpack_require__(/*! ./views.config */ 60);
	
	var _views2 = _interopRequireDefault(_views);
	
	var _element = __webpack_require__(/*! ./element.directive */ 61);
	
	var _element2 = _interopRequireDefault(_element);
	
	var _views3 = __webpack_require__(/*! ./views.directive */ 62);
	
	var _views4 = _interopRequireDefault(_views3);
	
	var _viewPanelService = __webpack_require__(/*! ./view-panel-service.provider */ 63);
	
	var _viewPanelService2 = _interopRequireDefault(_viewPanelService);
	
	var _viewService = __webpack_require__(/*! ./view-service.provider */ 64);
	
	var _viewService2 = _interopRequireDefault(_viewService);
	
	var _navigationService = __webpack_require__(/*! ./navigation-service.provider */ 65);
	
	var _navigationService2 = _interopRequireDefault(_navigationService);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.views', [_angularAnimate2.default, _angularRoute2.default]);
	
	ngModule.config(_views2.default);
	
	ngModule.directive('fisElement', _element2.default);
	ngModule.directive('fisViews', _views4.default);
	
	ngModule.provider('fisViewPanelService', _viewPanelService2.default);
	ngModule.provider('fisViewService', _viewService2.default);
	ngModule.provider('fisNavigationService', _navigationService2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 59 */
/*!****************************!*\
  !*** external "'ngRoute'" ***!
  \****************************/
/***/ (function(module, exports) {

	module.exports = 'ngRoute';

/***/ }),
/* 60 */
/*!*******************************!*\
  !*** ./views/views.config.js ***!
  \*******************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$routeProvider", "$locationProvider", "fisViewServiceProvider", function ($routeProvider, $locationProvider, fisViewServiceProvider) {
	  'ngInject';
	  // Reset the location hashPrefix to the pre-1.6 default value of empty string for backward compatibility reasons
	  // https://docs.angularjs.org/guide/migration#commit-aa077e8
	  // https://github.com/angular/angular.js/commit/aa077e81129c740041438688dff2e8d20c3d7b52
	
	  $locationProvider.hashPrefix('');
	
	  // Store a reference to the routeProvider for further use once the menu items are loaded.
	  fisViewServiceProvider.$routeProvider = $routeProvider;
	}];

/***/ }),
/* 61 */
/*!************************************!*\
  !*** ./views/element.directive.js ***!
  \************************************/
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return function (scope, element, attrs) {
	    if (attrs.fisElement) {
	      var obj = scope[attrs.fisElement];
	      obj.$element = element;
	    }
	  };
	};

/***/ }),
/* 62 */
/*!**********************************!*\
  !*** ./views/views.directive.js ***!
  \**********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$route", "$anchorScroll", "$compile", "$controller", "$animate", "fisI18nService", "$timeout", function ($route, $anchorScroll, $compile, $controller, $animate, fisI18nService, $timeout) {
	  'ngInject';
	  // Makes a scope "freezable". This means it can be detached and re-attached
	  // to the scope hierarchy. This code is specific to the fisView and can't be reused
	  // for any scope. A frozen scope will not participate in the $apply cycle so
	  // watches inside it will not be checked.
	  // The scope keeps the same prototype so it could still modify models in the parent.
	  // It will not be able to $emit events to the parent and the parent will not be able to $broadcast to it.
	  // The reason we are freezing the scope is to prevent performance degradation when
	  // multiple tabs are opened.
	
	  function makeFreezable(s) {
	    // make sure that when the parent scope is destroyed,
	    // we re-attach the scope so that it can also be destroyed
	    s.$parent.$on('$destroy', function () {
	      if (s.$$frozen) {
	        s.$freeze(false);
	      }
	      // tell fisViews that if the lastSelectedPanel was destroyed, ignore it and lose the reference on it so it can be GC'd
	      s.$$fisGC = true;
	    });
	
	    s.$freeze = function (freeze) {
	      if (freeze && !this.$$frozen) {
	        // let the scope know it is about to be frozen
	        this.$broadcast('fisFreezing');
	
	        // marker to indicate the scope is frozen
	        this.$$frozen = {};
	        // preserve the parent (ngRepeat scope)
	        this.$$frozen.$parent = this.$parent;
	
	        // detach from the parent
	        this.$parent.$$childHead = null;
	        this.$parent.$$childTail = null;
	
	        this.$parent = null;
	        // let the scope know it has been frozen
	        this.$broadcast('fisFrozen');
	      } else if (!freeze && this.$$frozen) {
	        // let the scope know it is about to be unfrozen
	        this.$broadcast('fisUnfreezing');
	
	        // re-attach the scope to its parent
	        this.$parent = this.$$frozen.$parent;
	        this.$parent.$$childHead = this;
	        this.$parent.$$childTail = this;
	        this.$$frozen = null;
	
	        // let the scope know it has been unfrozen
	        this.$broadcast('fisUnfrozen');
	      }
	    };
	
	    return s;
	  }
	
	  return {
	    restrict: 'EA',
	    scope: true, // needed because we now put stuff in the scope
	    replace: true,
	    controller: ['$scope', '$attrs', 'fisPubSubService', function ($scope, $attrs, fisPubSubService) {
	      /**
	       * Provides translation for the view displayed in the view panel.
	       * This overrides the shell controller's i18n function and provides
	       * automatic namespacing based on the current view panel's module and id.
	       * e.g. for a view panel in the "desktop-ui" module and an id of "dashboard", the key,
	       * if it doesn't already contain dots ".", will be prefixed by "desktop-ui.dashboard.".
	       * @param {string} key the i18n key to provide a translation for
	       * @param {string} def t{{item.label}}he default value, if the key can't be found
	       */
	      var unsubscribe = fisPubSubService.subscribe('shell.i18nReady', function () {
	        $scope.i18n = function (key, def) {
	          if (angular.isDefined(key)) {
	            if (key.indexOf('.') === -1) {
	              // TODO: when we allow reuse of viewPanels, the view panel should not be the active view panel
	              //      because this fisViewPanel directive will occur multiple times in the dom (once for each tab).
	              //      If we leave it like that, all strings of all views will get changed each time the active view is changed.
	              var view = $scope.activeViewPanel();
	              if (view) {
	                key = [view.module, view.id, key];
	              }
	            }
	            return fisI18nService.translate(key, def);
	          }
	        };
	        // Un-subscribing shell.i18nReady event
	        unsubscribe();
	      });
	
	      $scope.setTitle = function (value) {
	        $scope.activeViewPanel().setTitle(value);
	      };
	
	      $scope.resetTitle = function () {
	        $scope.activeViewPanel().resetTitle();
	      };
	
	      $scope.setIcon = function (value) {
	        $scope.activeViewPanel().setIcon(value);
	      };
	
	      if ($attrs.fisStacked && $attrs.fisStacked === 'false') {
	        $scope.fisStacked = false;
	      } else {
	        $scope.fisStacked = true;
	      }
	    }],
	    template: '<div fis-message-container>\n                  <div class="fis-info-panel"></div>\n                  <div ng-repeat="panel in panels" class="fis-panel-container ng-hide" fis-element="panel" fis-pub-sub></div>\n                  <div class="default-panel"></div>\n                </div>',
	    link: function link(scope, element, attrs) {
	      // the default panel is used if none of the provided panels are selected or if no panels are provided
	      var defaultPanel;
	      // the previously selected panel
	      var lastSelectedPanel;
	      // expression to evaluate when contents is loaded
	      var onloadExp = attrs.fisOnLoad || '';
	      var updateTimeout;
	      // start with no panels
	      scope.panels = undefined;
	
	      function matchingPathParams(currentParams, panelParams) {
	        if (Object.keys(currentParams).length > 0) {
	          for (var prop in currentParams) {
	            if (currentParams[prop] != panelParams[prop]) {
	              // eslint-disable-line
	              return false;
	            }
	          }
	        }
	        return true;
	      }
	
	      function updatePanel(panel) {
	        lastSelectedPanel = panel;
	        // we need the current route...
	        var current = $route.current;
	        // and the current route's local variables
	        var locals = current && current.locals;
	        // and the template for that route
	        var template = locals && locals.$template;
	
	        var activePanel = scope.activeViewPanel();
	
	        if (current && current.templateUrl && activePanel && current.templateUrl.indexOf(activePanel.partial) !== -1 && matchingPathParams(current.pathParams, activePanel.params)) {
	          // if the selected panel is for the current route, simply unfreeze its scope
	          if (current && panel.$route && panel.$route.originalPath === current.$$route.originalPath) {
	            // detach the scope from the scope hierarchy
	            panel.$scope.$freeze(false);
	            // panel already loaded, just broadcast it
	            panel.$scope.$broadcast('$panelContentLoaded');
	          } else if (template) {
	            // The panel is not for the current route, replace its contents with the route's template
	            // Clear the contents of the selected panel
	            clearContent(panel, false);
	            // associate with the current route
	            panel.$route = current.$$route;
	            // make the route template the panel's content in an animatable way
	            $animate.enter(angular.element('<div></div>').html(template).contents(), panel.$element);
	
	            // compile the panel's content
	            var link = $compile(panel.$element.contents());
	            var controller;
	            // grab a hold of the scope that the ng-repeat created for the panel div
	            var repeatScope = panel.$element.scope();
	            // create a child scope and make it freezable
	            panel.$scope = current.scope = makeFreezable(repeatScope.$new());
	            // if args are present in the item, make it available on the scope as viewArgs
	            if (panel.args) {
	              panel.$scope.viewArgs = panel.args;
	            }
	
	            // if the current route declares a controller
	            if (current.controller) {
	              // add the current panel's scope to the route's local variables
	              locals.$scope = panel.$scope;
	              // add the panel's element to the route's local variables
	              locals.$element = panel.$element;
	              // create the controller with the injectable locals
	              controller = $controller(current.controller, locals);
	              // attach to the panel
	              panel.$element.children().data('$ngControllerController', controller);
	            }
	
	            // link the compiled contents with the panel's scope
	            link(panel.$scope);
	            // emit the $viewContentLoaded event like ng-view does
	            panel.$scope.$emit('$viewContentLoaded');
	
	            // execute the onload handler
	            panel.$scope.$eval(onloadExp);
	
	            // $anchorScroll might listen on event...
	            $anchorScroll();
	          } else if (panel.$scope && panel.args.targetScope.location.$$url) {
	            // check for presence of scope.alert and scope.open: these are defined in the shell
	            // and this could be used outside the shell since it is in fis-components.
	            // no template for this route, display relevant message alert box (if a message is available)
	            var msg;
	            if (scope.alert && (msg = fisI18nService.translate('error-path-not-found', ''))) {
	              scope.alert(msg, { title: fisI18nService.translate('error-dialog-title') });
	            }
	            // open the last open panel
	            if (scope.open) {
	              scope.open(lastSelectedPanel.path);
	            }
	          }
	        }
	      }
	
	      function update() {
	        // find the selected panel
	        var panel = getSelectedPanel();
	        // ensure we are not dealing with a lastSelectedPanel that was destroyed
	        // this can happen when switching menus
	        if (lastSelectedPanel && lastSelectedPanel.$scope && lastSelectedPanel.$scope.$$fisGC) {
	          // the scope (and therefore the panel) was destroyed. Lose the references
	          clearContent(lastSelectedPanel, true);
	          lastSelectedPanel = null;
	        }
	
	        if (lastSelectedPanel !== panel) {
	          // eslint-disable-line
	          // we are changing panel, or the last panel was destroyed...
	          if (lastSelectedPanel) {
	            // hide the previous one if it still exists
	            $animate.addClass(lastSelectedPanel.$element, 'ng-hide');
	            lastSelectedPanel.$element.removeClass('fis-selected');
	
	            if (lastSelectedPanel.saveState === false) {
	              // View doesn't want state saving. Destroy the scope.
	              clearContent(lastSelectedPanel, false);
	            } else if (lastSelectedPanel.$scope) {
	              // freeze the scope on the previous panel
	              // scope may not be there for nav item without partial and secondary menu
	              lastSelectedPanel.$scope.$freeze(true);
	            }
	          }
	          // show the selected one
	          if (panel.$element) {
	            $animate.removeClass(panel.$element, 'ng-hide').then(function () {
	              panel.$element.addClass('fis-selected');
	              if (updateTimeout) {
	                $timeout.cancel(updateTimeout);
	              }
	              updateTimeout = $timeout(function () {
	                updatePanel(panel);
	              }, 0);
	            });
	          }
	        } else {
	          updatePanel(panel);
	        }
	      }
	
	      // This function is invoked when a panel is already opened but
	      // the route it is currently associated to needs to change
	      function clearContent(panel, removeElementRef) {
	        // remove the contents, if any, in an animatable way
	        var contents = panel.$element.contents();
	
	        if (contents.length > 0) {
	          $animate.leave(contents);
	        }
	
	        if (panel.$scope) {
	          // destroy the scope associated to the panel's content
	          panel.$scope.$destroy();
	          // make sure we don't keep a reference on it for GC
	          panel.$scope = null;
	          // make sure no route is associated to this panel
	          panel.$route = null;
	          // make sure no element is associated to this panel
	          if (removeElementRef) {
	            panel.$element = null;
	          }
	        }
	      }
	
	      function getSelectedPanel() {
	        if (angular.isNumber(scope.selectedIndex) && scope.selectedIndex !== -1) {
	          return scope.panels[scope.selectedIndex];
	        }
	
	        return getDefaultPanel();
	      }
	
	      function getDefaultPanel() {
	        if (!defaultPanel) {
	          // initialize default panel since we need it.
	          defaultPanel = {};
	          defaultPanel.$element = angular.element(element[0].getElementsByClassName('default-panel')[0]);
	        }
	        return defaultPanel;
	      }
	
	      if (scope.fisStacked && attrs.fisViews && attrs.fisSelectedIndex) {
	        // if a fisViews attribute is provided, operate in state preservation mode
	        scope.$watchCollection(attrs.fisViews, function (value) {
	          // don't need to find out what was added; scopes will be added if selected and a route is followed
	          scope.panels = value;
	        });
	        scope.$watch(attrs.fisSelectedIndex, function (idx) {
	          scope.selectedIndex = idx;
	        });
	      }
	
	      element.addClass('fis-view-panel');
	
	      scope.$on('$routeChangeSuccess', update);
	    }
	  };
	}];

/***/ }),
/* 63 */
/*!**********************************************!*\
  !*** ./views/view-panel-service.provider.js ***!
  \**********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* jshint maxparams:12 */
	/**
	 * @class
	 * @name fisViewPanelService
	 * @requires $locatio* @requires $timeout
	 * @requires fisViewService
	 * @description
	 <p>Provides ViewPanel management functionality to the application.<p>
	 <p>This service subscribes to <em>shell.navReady</em> event to get a list of
	 top-level Navigation Items with partials configured and opens up non-closeable ViewPanels for these
	 as the landing view for a user.</p>
	 <p>The provider for this service, <em>fisViewPanelServiceProvider</em>, can be configured with View opening
	 strategy during the module configuration phase. This can be a function or string. Possible value for string argument
	 is <em>mdi</em> at the moment, while <em>sdi</em> and <em>hybrid</em> options would be made available in future.</p>
	 */
	
	
	exports.default = function () {
	  'use strict';
	
	  var DEFAULT_OPEN_STRAT = 'mdi';
	  var CUSTOM_OPEN_STRAT = 'custom function';
	
	  var provider = this;
	  var openStratStr = null;
	  var customStrategyFn = null;
	  var preventBrowserNavigation = true;
	
	  /**
	   * @name setViewOpeningStrategy
	   * @methodOf fisViewPanelServiceProvider
	   * @param {String | Function} Function reference of custom view opening strategy or string from enum (only 'mdi' and 'browser' at this point in time)
	   * @description
	   * <p>Configures the provider with a View Panel Opening strategy that is then used by the <em>fisViewPanelService</em> to open
	   * View Panels.</p>
	   */
	  this.setViewOpeningStrategy = function (fn) {
	    if (angular.isFunction(fn)) {
	      openStratStr = CUSTOM_OPEN_STRAT;
	      customStrategyFn = fn;
	    } else if (angular.isString(fn)) {
	      openStratStr = fn;
	    } else {
	      openStratStr = DEFAULT_OPEN_STRAT;
	    }
	  };
	
	  /**
	   * @name getViewOpeningStrategy
	   * @methodOf fisViewPanelServiceProvider
	   * @description
	   * <p>Get the view opening strategy string reference or custom function if one was set.</p>
	   */
	  this.getViewOpeningStrategy = function () {
	    if (openStratStr === null) {
	      return DEFAULT_OPEN_STRAT;
	    } else if (openStratStr === CUSTOM_OPEN_STRAT) {
	      return customStrategyFn;
	    }
	    return openStratStr;
	  };
	
	  /**
	   * @name setPreventBrowserNavigation
	   * @methodOf fisViewPanelServiceProvider
	   * @param {Boolean} True for preventing browser reloading while navigating
	   * @description
	   * <p>Set a flag to prevent browser default navigation while using <em>fisViewPanelService</em>.</p>
	   */
	  this.setPreventBrowserNavigation = function (val) {
	    preventBrowserNavigation = Boolean(val);
	  };
	
	  /**
	   * @name getPreventBrowserNavigation
	   * @methodOf fisViewPanelServiceProvider
	   * @description
	   * <p>Get if the view panel should prevent the default browser navigation.</p>
	   */
	  this.getPreventBrowserNavigation = function () {
	    return preventBrowserNavigation;
	  };
	
	  /**
	   * @name ViewPanel
	   * @methodOf fisViewPanelService
	   * @param {viewDef} navigation Item
	   * @description extends and decorates the nav item with a label and ability to change this via method call.
	   */
	  var ViewPanel = function ViewPanel(viewDef, $filter) {
	    angular.extend(this, viewDef);
	
	    this.$filter = $filter;
	    this.navItem = angular.copy(viewDef);
	    this.title = viewDef.label;
	  };
	
	  ViewPanel.prototype.setTitle = function (stringOrObject) {
	    if ((typeof stringOrObject === 'undefined' ? 'undefined' : _typeof(stringOrObject)) !== 'object') {
	      // eslint-disable-line
	      this.navItem.customTitle = stringOrObject;
	    } else {
	      var tl = '';
	      var sep = '|';
	
	      if (stringOrObject.sep) {
	        sep = stringOrObject.sep;
	      }
	
	      if (stringOrObject.prefix) {
	        tl = stringOrObject.prefix;
	        tl += sep;
	      }
	
	      tl += this.$filter('interpolate')(this.navItem.label, stringOrObject);
	
	      if (stringOrObject.suffix) {
	        tl += sep;
	        tl += stringOrObject.suffix;
	      }
	
	      this.navItem.customTitle = tl;
	    }
	  };
	
	  ViewPanel.prototype.setIcon = function (cssClass) {
	    this.navItem.customIcon = cssClass;
	  };
	
	  ViewPanel.prototype.resetIcon = function () {
	    this.navItem.customIcon = undefined;
	  };
	
	  // Returns the title the view want's to be shown in the tab.
	  // (fisTabsBar may display parentTitle due to config if no customTitle supplied)
	  ViewPanel.prototype.getTitle = function () {
	    if (this.navItem && this.navItem.customTitle) {
	      return this.navItem.customTitle;
	    }
	
	    return this.title;
	  };
	
	  // Returns the icon the view want's to be shown in the tab.
	  // (fisTabsBar may display parentIcon due to config if no customIcon supplied)
	  ViewPanel.prototype.getIcon = function () {
	    if (this.navItem && this.navItem.customIcon) {
	      return this.navItem.customIcon;
	    }
	
	    return this.icon;
	  };
	
	  // we merge properties from the routeParams with the already manually set params.
	  // jQuery.extend(this.params, $routeParams);
	  ViewPanel.prototype.resetTitle = function () {
	    this.navItem.customTitle = undefined;
	  };
	
	  this.ViewPanel = ViewPanel;
	
	  /**
	   * @name $get
	   * @methodOf fisViewPanelServiceProvider
	   * @description
	   * <p>Factory method to create instance of fisViewPanelService.</p>
	   */
	  this.$get = ['$location', '$timeout', 'fisViewService', 'fisConfig', '$filter', '$route', 'fisPubSubService', 'fisI18nService', '$routeParams', '$rootScope', '$q', '$controller', function ($location, $timeout, fisViewService, fisConfig, $filter, $route, fisPubSubService, fisI18nService, $routeParams, $rootScope, $q, $controller) {
	    var service = {};
	    var selectedPanelPath;
	    var selectedPanelUnresolvedPath;
	    var selectedPanelParams;
	    var tabs = [];
	    var navigationUnderWay = false;
	    var changeLocationNavigationUnderway = false;
	    var strategies = {};
	    var keepSameTabsOpenOnReload;
	    var keepTabsOpenVariableLoaded;
	    var tabsAfterNavReadySet;
	    var preventBrowserNavigationSet;
	    var refreshInterval;
	
	    function init() {
	      startAvailableStrategies();
	
	      loadKeepTabsOpenVariable(); // sets keepSameTabsOpenOnReload variable
	
	      setupTabsAfterNavReady();
	
	      setupPreventBrowserNavigation();
	
	      setupLocaleChangeHandle();
	
	      refreshInterval = setInterval(publishNavComplete, 100);
	    }
	
	    function publishNavComplete() {
	      if (keepTabsOpenVariableLoaded && tabsAfterNavReadySet && preventBrowserNavigationSet) {
	        // publish event navigation done...
	        clearInterval(refreshInterval);
	        fisPubSubService.publish('shell.viewPanelReady');
	      }
	    }
	
	    /**
	     * Setup the initially available opening strategies
	     * by placing them in the private strategies object
	     */
	    function startAvailableStrategies() {
	      strategies = {
	        mdi: mdiFunction,
	        browser: browserFunction
	      };
	    }
	
	    function isDuplicatePath(path, items) {
	      return items.some(function (item) {
	        return path === item.path;
	      });
	    }
	
	    function loadKeepTabsOpenVariable() {
	      if (angular.isUndefined(keepSameTabsOpenOnReload)) {
	        if (fisConfig.widgets && fisConfig.widgets.fisTabsBar && angular.isDefined(fisConfig.widgets.fisTabsBar.keepSameTabsOpenOnReload)) {
	          keepSameTabsOpenOnReload = fisConfig.widgets.fisTabsBar.keepSameTabsOpenOnReload;
	        } else {
	          keepSameTabsOpenOnReload = false;
	        }
	        keepTabsOpenVariableLoaded = true;
	        return keepSameTabsOpenOnReload;
	      }
	
	      keepTabsOpenVariableLoaded = true;
	      return keepSameTabsOpenOnReload;
	    }
	
	    function setupTabsAfterNavReady() {
	      fisPubSubService.subscribe('shell.navReady', function (nav) {
	        if (keepSameTabsOpenOnReload) {
	          // Clearing all tabs not in new nav structure
	          if (tabs.length > 0) {
	            for (var i = tabs.length; i-- > 0;) {
	              var tabItem = tabs[i];
	              var item = fisViewService.findNavItem(tabItem.path);
	
	              // remove tab not in new nav structure but do not remove untitled tab (':vmcount')
	              if (!item && tabItem.id !== ':vmCount') {
	                tabs.splice(i, 1);
	              }
	            }
	          }
	        } else {
	          tabs = [];
	        }
	
	        // Get static tabs from nav structure
	        var newTabs = getNewTabs(nav.main);
	
	        // Checks to see which static pages need to be added or which static pages already in tabs
	        newTabs.forEach(function (newTab, index) {
	          // Checks to see if newTab exists in current or new nav structure
	          var item = fisViewService.findNavItem(newTab.path);
	
	          // it exists in nav structure
	          if (item) {
	            // Checking if newTab already in tabs
	            if (!isDuplicatePath(item.path, tabs)) {
	              // Adds static page to tabs
	              var newStaticPage = new provider.ViewPanel(item, $filter);
	              tabs.splice(index, 0, newStaticPage);
	            }
	          }
	        });
	
	        resetSelectedPanelPath();
	        tabsAfterNavReadySet = true;
	      }, true);
	    }
	
	    function getNewTabs(items) {
	      var tabs = [];
	      var count = 0;
	
	      items.forEach(function (item) {
	        item.location = 'main';
	        if (isValidTab(item)) {
	          tabs[count++] = new provider.ViewPanel(item, $filter);
	        }
	      });
	
	      return tabs;
	    }
	
	    function isValidTab(item) {
	      return hasNonCloseableFlag(item) || hasDropdownSecondaryMenu(item);
	    }
	
	    function hasNonCloseableFlag(item) {
	      return angular.isDefined(item.closeable) && !item.closeable;
	    }
	
	    function hasDropdownSecondaryMenu(item) {
	      return item.secondaryNav === 'dropdown';
	    }
	
	    function resetSelectedPanelPath() {
	      // This is important when reloading navigation at runtime.
	      selectedPanelPath = undefined;
	      selectedPanelUnresolvedPath = undefined;
	      selectedPanelParams = undefined;
	    }
	
	    function setupPreventBrowserNavigation() {
	      if (provider.getPreventBrowserNavigation()) {
	        $rootScope.$on('$locationChangeStart', onLocationChangeStart);
	      } else {
	        $rootScope.$on('$locationChangeStart', onLocationChangeStartNavigate);
	      }
	    }
	
	    var shellReady = false;
	
	    function onLocationChangeStartNavigate() {
	      fisPubSubService.subscribe('shell.navReady', function () {
	        shellReady = true;
	      });
	
	      if (!navigationUnderWay && shellReady) {
	        changeLocationNavigationUnderway = true;
	        service.open($location.path());
	      }
	
	      navigationUnderWay = false;
	
	      preventBrowserNavigationSet = true;
	    }
	
	    function onLocationChangeStart(event, newPath, oldPath) {
	      if (!navigationUnderWay) {
	        // eslint-disable-line
	        var newUrl = getUrlWithoutHash(newPath);
	        var oldUrl = getUrlWithoutHash(oldPath);
	
	        if (newUrl !== oldUrl) {
	          // Old and new path are not the same, which means that someone is trying to navigate away from the current page.
	          // prevent the location change (this will revert the url in the address bar to what it was
	          event.preventDefault();
	        }
	      } else {
	        navigationUnderWay = false;
	      }
	
	      preventBrowserNavigationSet = true;
	    }
	
	    function setupLocaleChangeHandle() {
	      fisPubSubService.subscribe('fisLocaleChanged', function () {
	        // Reload the navigation if the locale setting changed
	        var activePanel = service.activeViewPanel();
	        fisViewService.load().then(function () {
	          $timeout(function () {
	            if (activePanel) {
	              // get the path the to take care of unicode path
	              var item = fisViewService.getItemFromPath2Item(activePanel.path);
	              if (item) {
	                service.open(item.path, null, activePanel.params); // Open active one last.
	              } else {
	                // untitled tab
	                service.open(activePanel.path, null, activePanel.params); // Open active one last.
	              }
	            }
	          }, 0);
	        });
	      });
	    }
	
	    function checkAndSetForSecondaryNavItem(navItem, event, params) {
	      var navParent = getSecondaryNavThroughPaths(navItem);
	
	      if (navParent) {
	        // set the parent title for display
	        var paramsToUse = params ? params : navParent.params;
	
	        // check if tab is already present - if it is, do not update parentTitle, as it can mess up with tab title
	        var tabAlreadyPresent = false;
	
	        tabs.forEach(function (tab) {
	          if (tab.path === navItem.path) {
	            tabAlreadyPresent = true;
	          }
	        });
	
	        // change parent title only if tab is not already present and there are parameters
	        if (!tabAlreadyPresent && paramsToUse) {
	          navItem.parentTitle = $filter('interpolate')(navParent.label, paramsToUse);
	        } else if (!tabAlreadyPresent && !paramsToUse && navParent.label && navParent.label.indexOf('{') < 0 && navParent.label.indexOf('}') < 0) {
	          navItem.parentTitle = navParent.label;
	        }
	
	        navItem.parentIcon = navParent.icon ? navParent.icon : null;
	        var newNavItem = openSecNavItem(navItem, event, params);
	        if (newNavItem) {
	          navItem = newNavItem;
	        }
	      }
	    }
	
	    function getSecondaryNavThroughPaths(navItem) {
	      var navParent = null;
	
	      if (navItem !== undefined && navItem !== null) {
	        if (navItem.unresolvedPath) {
	          navParent = getSecondaryNavParent(navItem.unresolvedPath);
	        }
	
	        if (navParent === null) {
	          navParent = getSecondaryNavParent(navItem.path);
	        }
	      }
	      return navParent;
	    }
	
	    function publishViewPanelChange(navItem, previousViewPanel, event) {
	      if (navItem && navItem.params) {
	        navItem.decodedParams = addDecodedParams(navItem.params);
	      }
	
	      fisPubSubService.publish('fisActiveViewPanelChanged', {
	        before: previousViewPanel,
	        after: selectedPanelPath,
	        currentNavItem: navItem,
	        event: event
	      });
	    }
	
	    function addDecodedParams(params) {
	      var decodedParams = {};
	      if (params) {
	        for (var key in params) {
	          if (params.hasOwnProperty(key)) {
	            var paramValue = params[key];
	            // decode only if url contains : or / characters
	            if (paramValue && typeof paramValue === 'string' && (paramValue.indexOf('%2F') > -1 || paramValue.indexOf('%3A') > -1)) {
	              decodedParams[key] = decodeURIComponent(paramValue);
	            }
	          }
	        }
	      }
	      return decodedParams;
	    }
	
	    /**
	     * Call the appropriate opening strategy which decides whether to open
	     * a new tab or reuse the current one
	     * @param navItem object containing information about the view to be opened
	     * @param localEvent
	     */
	    function callRelevantStrategy(navItem, localEvent, parameters) {
	      // Check for boolean values as localEvent to override strategy
	      if (typeof localEvent === 'boolean') {
	        if (localEvent) {
	          openInNewTab(navItem, null, parameters);
	        } else {
	          openInSameTab(navItem, null, parameters);
	        }
	      } else {
	        // No overriding, continue as usual
	        var openingStrategy = provider.getViewOpeningStrategy();
	
	        if (angular.isFunction(customStrategyFn) && openStratStr === CUSTOM_OPEN_STRAT) {
	          // We've got a custom strategy and should use it
	          customStrategyFn.call(service, navItem, localEvent, parameters);
	        } else {
	          // Use one of the framework pre-implemented strategies
	          var stratFn = strategies[openingStrategy];
	
	          if (angular.isFunction(stratFn)) {
	            stratFn.call(service, navItem, localEvent, parameters);
	          } else {
	            // Framework default/Fallback if we do not have a strategy function
	            // matching this name or one at all
	            strategies[DEFAULT_OPEN_STRAT].call(service, navItem, localEvent, parameters);
	            console.warn('Unable to find opening strategy ' + openingStrategy + ', will use default ' + DEFAULT_OPEN_STRAT);
	          }
	        }
	      }
	    }
	
	    function validateNavItem(navItem, navPath) {
	      setPathNotFoundError(navItem, navPath);
	
	      setPartialNotFoundError(navItem);
	    }
	
	    function setPathNotFoundError(navItem, navPath) {
	      // if (hasNoItemButTabs(navItem)) {
	      // we need to display path-not-found error even if there are no tabs open
	      if (!navItem && navPath !== '' && navPath !== '/') {
	        throwNoItemDefinedError(fisI18nService.translate('error-path-not-found', ''));
	      }
	    }
	
	    function hasNoItemButTabs(navItem) {
	      return !navItem && tabs.length > 0;
	    }
	
	    function throwNoItemDefinedError(userMessage) {
	      // TODO: replace with a fisMessageCenterService
	      var err = new Error('No nav item defined for this path');
	      err.userMessage = userMessage;
	      throw err;
	    }
	
	    function setPartialNotFoundError(navItem) {
	      if (hasTabsButNoPartial(navItem)) {
	        throwNoPartialFoundError(navItem, fisI18nService.translate('error-partial-not-found', ''));
	      }
	    }
	
	    function hasTabsButNoPartial(navItem) {
	      return navItem && // item exists
	      !navItem.partial && // but no partial
	      !navItem.secondaryNav && // neither secondary nav
	      !navItem.action && // or action
	      tabs.length > 0; // and the service has tabs
	    }
	
	    function throwNoPartialFoundError(navItem, userMessage) {
	      // TODO: replace with a fisMessageCenterService
	      var err = new Error('Nav item "' + navItem.label + '" does not have a partial to load');
	      err.userMessage = userMessage;
	      throw err;
	    }
	
	    function substituteParams(path, localParams) {
	      while (path.indexOf(':') > -1) {
	        path = getReplacedPath(path, localParams);
	      }
	
	      return path;
	    }
	
	    function removeExtraParamsFromLocalParams(path, localParams) {
	      var localParamsToKeep = {};
	      while (path.indexOf(':') > -1) {
	        var paramStr = path.substring(path.indexOf(':') + 1);
	        var param = paramStr.indexOf('/') > -1 ? paramStr.substring(0, paramStr.indexOf('/')) : paramStr;
	        localParamsToKeep[param] = localParams[param];
	        path = path.substring(path.indexOf(':' + paramStr) + 1);
	      }
	      return localParamsToKeep;
	    }
	
	    function hasSpecialCharacter(paramVal) {
	      return !/^[a-zA-Z0-9-% ]*$/.test(paramVal);
	    }
	
	    function getReplacedPath(path, localParams) {
	      var paramStr = path.substring(path.indexOf(':') + 1);
	      var param = paramStr.indexOf('/') > -1 ? paramStr.substring(0, paramStr.indexOf('/')) : paramStr;
	      var remainingStr = paramStr.substring(param.length);
	
	      var paramValue;
	      var paramValueOrig = localParams[param];
	      if (paramValueOrig && (paramValueOrig.toString().indexOf('/') > -1 || paramValueOrig.toString().indexOf(':') > -1)) {
	        paramValue = encodeURIComponent(paramValueOrig);
	      } else if (hasSpecialCharacter(paramValueOrig)) {
	        paramValue = encodeURIComponent(paramValueOrig);
	        paramValue = decodeURIComponent(paramValue);
	      } else {
	        paramValue = decodeURIComponent(paramValueOrig);
	      }
	
	      if (localParams[param] !== paramValue) {
	        // This Is a reload
	        localParams[param] = paramValue; // Set Local param to decoded value so it can found
	      }
	      return path.substring(0, path.indexOf(':')) + paramValue + remainingStr;
	    }
	
	    // Updating tabs[] array with the data received from the translation object
	    // This is required to update the tab title correctly in case translation data is loading asynchronously
	    function updateTabsArray(path, navItem) {
	      if (tabs) {
	        for (var count = 0; count < tabs.length; count++) {
	          if (tabs[count].path === path) {
	            if (navItem && navItem.label) {
	              tabs[count].label = navItem.label;
	              tabs[count].title = navItem.label;
	            }
	            break;
	          }
	        }
	      }
	    }
	
	    function getSecondaryNavParent(navPath) {
	      var tempPath = navPath;
	      var navItemParent = null;
	      var itemWithSecNav = null;
	
	      while (!itemWithSecNav) {
	        if (tempPath) {
	          navItemParent = fisViewService.findNavItem(tempPath);
	          updateTabsArray(tempPath, navItemParent);
	          itemWithSecNav = getItemParentRefIfValid(navItemParent);
	          tempPath = tempPath.substring(0, tempPath.lastIndexOf('/'));
	        } else {
	          break;
	        }
	      }
	
	      // clear params from the item, since it may contain stale value
	      if (itemWithSecNav) {
	        itemWithSecNav.params = null;
	      }
	      return itemWithSecNav;
	    }
	
	    // Expose getSecondaryNavParent functionality required by breadcrumbs container to check for a tab
	    // whether its a secondary navigation tab or not
	    service._getSecondaryNavParent = getSecondaryNavParent;
	
	    function getItemParentRefIfValid(navItemParent) {
	      var value = null;
	      if (navItemParent && (navItemParent.secondaryNav === 'menubar' || navItemParent.secondaryNav === 'dropdown')) {
	        value = navItemParent;
	      }
	      return value;
	    }
	
	    function openSecNavItem(item, event, params) {
	      var navItem = getNavItemFromViewPanel(item);
	      var parameters = getParamsOrNavItemParams(params, navItem);
	      var substitutedNavItem = getSubstitutedUrlIfContainsParams(parameters, navItem);
	
	      openTestingByGroupOpened(substitutedNavItem, event, parameters);
	
	      if (isValidSecondaryMenuItem(navItem)) {
	        var itemWithSecNav = getSecondaryNavThroughPaths(navItem);
	        var children = getChildrenFromNavItem(navItem, itemWithSecNav);
	        var newNavItem = null;
	
	        updateAllChildren(itemWithSecNav);
	
	        setParamsAcessedBySecondaryMenu(itemWithSecNav, substitutedNavItem);
	
	        newNavItem = getNewNavItem(navItem, itemWithSecNav, children);
	
	        fisPubSubService.publish('fisSecondaryMenuClicked', itemWithSecNav);
	
	        return newNavItem;
	      }
	    }
	
	    function getNavItemFromViewPanel(item) {
	      var navItem = item;
	
	      if (navItem instanceof provider.ViewPanel) {
	        navItem = navItem.navItem;
	        if (navItem.params && navItem.unresolvedPath) {
	          navItem.path = navItem.unresolvedPath;
	        }
	      }
	
	      return navItem;
	    }
	
	    function getParamsOrNavItemParams(params, navItem) {
	      var parameters = params;
	
	      if (!parameters && navItem.params !== null) {
	        parameters = navItem.params;
	      }
	
	      return parameters;
	    }
	
	    function getSubstitutedUrlIfContainsParams(parameters, navItem) {
	      var substitutedNavItem = angular.copy(navItem);
	
	      if (parameters && navItem) {
	        // set the original parameterized path
	        if (!substitutedNavItem.unresolvedPath) {
	          substitutedNavItem.unresolvedPath = navItem.path;
	        }
	        substitutedNavItem.path = substituteParams(navItem.path, parameters);
	        substitutedNavItem.label = $filter('interpolate')(navItem.label, parameters);
	        substitutedNavItem.params = parameters;
	      }
	
	      return substitutedNavItem;
	    }
	
	    function openTestingByGroupOpened(substitutedNavItem, event, parameters) {
	      if ((isTrue(event) || angular.isUndefined(event) || angular.isObject(event)) && !isSecNavItemGroupOpen(substitutedNavItem) && !isPartOfSecondaryNav(getSecondaryNavParent(substitutedNavItem.path), service.activeViewPanel())) {
	        openInNewTab(substitutedNavItem, event);
	      } else {
	        openInSameTab(substitutedNavItem, event, parameters);
	      }
	    }
	
	    function isPartOfSecondaryNav(navItem, currentNavItem) {
	      var containsNavItem = false;
	      if (navItem !== null && currentNavItem !== null) {
	        if (navItem.id === currentNavItem.id) {
	          return true;
	        } else if (angular.isDefined(navItem.children) && angular.isArray(navItem.children)) {
	          navItem.children.forEach(function (childNavItem) {
	            if (containsNavItem !== true) {
	              containsNavItem = isPartOfSecondaryNav(childNavItem, currentNavItem);
	            }
	          });
	        } else {
	          return false;
	        }
	      }
	      return containsNavItem;
	    }
	
	    function isValidSecondaryMenuItem(navItem) {
	      return navItem && (navItem.secondaryNav || getSecondaryNavParent(navItem.path) || getSecondaryNavParent(navItem.unresolvedPath));
	    }
	
	    function getChildrenFromNavItem(navItem, itemWithSecNav) {
	      var children = null;
	
	      if (navItem.secondaryNav) {
	        children = navItem.children;
	      } else if (itemWithSecNav) {
	        children = itemWithSecNav.children;
	      }
	
	      return children;
	    }
	
	    function setParamsAcessedBySecondaryMenu(itemWithSecNav, substitutedNavItem) {
	      if (itemWithSecNav) {
	        itemWithSecNav.params = substitutedNavItem.params;
	      }
	    }
	
	    function getNewNavItem(navItem, itemWithSecNav, children) {
	      var newNavItem = angular.extend({}, navItem);
	      newNavItem.children = children;
	      newNavItem.secondaryNav = itemWithSecNav.secondaryNav;
	
	      return newNavItem;
	    }
	
	    function updateAllChildren(navItem) {
	      if (navItem && navItem.children) {
	        navItem.children.forEach(function (child) {
	          updateChildData(child);
	
	          updateAllChildren(child);
	        });
	      }
	    }
	
	    function updateChildData(child) {
	      if (child.partial) {
	        child.isStatic = true;
	      }
	
	      child.text = child.label;
	      child.items = child.children;
	
	      if (child.partial) {
	        child.url = child.path;
	      }
	    }
	
	    function isSecNavItemGroupOpen(navItem) {
	      var itemWithSecNav = getSecondaryNavThroughPaths(navItem);
	      var secNavItemGroupPresent = false;
	
	      if (itemWithSecNav !== null) {
	        // attach a property secondaryNavParent to the navItem in case the parent secondary navigation item has secondaryNav as dropdown
	        if (hasDropdownSecondaryMenu(itemWithSecNav)) {
	          navItem.secondaryNavParent = itemWithSecNav;
	        }
	
	        for (var i = 0; i < tabs.length; i++) {
	          if (isTabPathValid(tabs[i], navItem, itemWithSecNav)) {
	            secNavItemGroupPresent = true;
	            selectedPanelPath = tabs[i].path;
	            selectedPanelUnresolvedPath = tabs[i].unresolvedPath;
	            selectedPanelParams = tabs[i].params;
	
	            return secNavItemGroupPresent;
	          }
	        }
	      }
	    }
	
	    function isTabPathValid(tab, navItem, itemWithSecNav) {
	      if (navItem.unresolvedPath) {
	        return tabPathHasNavItemParams(tab, navItem, itemWithSecNav);
	      }
	      return tab.path.indexOf(itemWithSecNav.path) > -1;
	    }
	
	    function tabPathHasNavItemParams(tab, navItem /* , itemWithSecNav*/) {
	      var continueLooping = true;
	      var unresolvedPath = navItem.unresolvedPath;
	      var navPathUptoResolvedParam;
	      var paramValue;
	
	      while (continueLooping) {
	        var paramStr = unresolvedPath.substring(unresolvedPath.indexOf(':') + 1);
	        var param = paramStr.indexOf('/') > -1 ? paramStr.substring(0, paramStr.indexOf('/')) : paramStr;
	        var remainingStr = paramStr.substring(param.length);
	        paramValue = navItem.params[param];
	        navPathUptoResolvedParam = unresolvedPath.substring(0, unresolvedPath.indexOf(':')) + paramValue;
	        if (remainingStr.indexOf(':') > -1) {
	          unresolvedPath = unresolvedPath.substring(0, unresolvedPath.indexOf(':')) + paramValue + remainingStr;
	        } else {
	          continueLooping = false;
	        }
	      }
	
	      // check for the token length of navPathUptoResolvedParam and tab.path
	      // if the length of tokens of navPathUptoResolvedParam is greater than tab.path length and navPathUptoResolvedParam begins with tab.path,
	      // it means the current nav item to open is a child of the existing tab),
	      // If the length of tokens is same, it means the current nav item to open is not a child of the existing tab
	      // This check is needed for cases where the name of the new tab to open contains the name of the already open tab, for example Bank_of_Pune and Bank_of_Pune1
	      var navPathUptoResolvedParamTokens = getTokensFromNavPath(navPathUptoResolvedParam);
	      var tabPathTokens = getTokensFromNavPath(tab.path);
	      var navPathContainsTabPath = false;
	      if (navPathUptoResolvedParamTokens.length > tabPathTokens.length && navPathUptoResolvedParam.indexOf(tab.path) > -1) {
	        navPathContainsTabPath = true;
	      }
	
	      return tab.path.indexOf(navPathUptoResolvedParam) > -1 && paramValue === tab.label || navPathContainsTabPath;
	    }
	
	    function openInNewTab(navItem, event, parameters) {
	      if (isFalse(event)) {
	        openInSameTab(navItem, event, parameters);
	      }
	
	      if (navItem) {
	        if (!isAlreadyInTabs(navItem)) {
	          addNewTab(navItem);
	        }
	
	        setPathAndNavigateTo(navItem);
	      }
	    }
	    // Expose opening in a new tab functionality so custom opening strategies may use it
	    /**
	     * @name _openInNewTab
	     * @methodOf fisViewPanelService
	     * @param {Object} Navigation Item to be opened
	     * @param
	     * @description
	     * <p>Configures the provider with a View Panel Opening strategy that is then used by the <em>fisViewPanelService</em> to open
	     * View Panels.</p>
	     */
	    service._openInNewTab = openInNewTab;
	
	    function isAlreadyInTabs(navItem) {
	      return tabs.some(function (tab) {
	        return tab.path === navItem.path;
	      });
	    }
	
	    function addNewTab(navItem) {
	      tabs.push(new provider.ViewPanel(navItem, $filter));
	      publishViewPanelOpened(navItem, getLastTab());
	    }
	
	    function publishViewPanelOpened(navItem, tab) {
	      fisPubSubService.publish('fisViewPanelOpened', {
	        path: navItem.path,
	        viewPanel: tab
	      });
	    }
	
	    function getFirstTab() {
	      return tabs[0];
	    }
	
	    function getLastTab() {
	      return tabs[tabs.length - 1];
	    }
	
	    function openInSameTab(navItem, event, parameters) {
	      if (!isSecNavItemGroupOpen(navItem) && hasItemButNoTabsOrEvent(navItem, event)) {
	        openInNewTab(navItem, event, parameters);
	      } else if (hasItemAndTabs(navItem)) {
	        if (!shouldOpenInSameTab(navItem)) {
	          setPathAndNavigateTo(navItem, parameters);
	        }
	      }
	    }
	    // Expose opening in same tab functionality so custom opening strategies may use it
	    service._openInSameTab = openInSameTab;
	
	    function hasItemButNoTabsOrEvent(navItem, event) {
	      return hasItemButNoTabs(navItem) || isTrue(event);
	    }
	
	    function hasItemButNoTabs(navItem) {
	      return navItem && tabs.length === 0;
	    }
	
	    function hasItemAndTabs(navItem) {
	      return navItem && tabs.length > 0;
	    }
	
	    function shouldOpenInSameTab(navItem, parameters) {
	      var activeViewPanel = service.activeViewPanel();
	      var isOpeningAction = false;
	
	      if (isActiveAndNonCloseable(activeViewPanel, navItem)) {
	        openInNewTab(navItem, parameters);
	        isOpeningAction = true;
	      } else if (shouldReplaceViewPanel(activeViewPanel, navItem, parameters)) {
	        isOpeningAction = true;
	      }
	
	      return isOpeningAction;
	    }
	
	    function isActiveAndNonCloseable(activeViewPanel, navItem) {
	      return activeViewPanel && service.isNonCloseable(activeViewPanel) && !getSecondaryNavParent(navItem.path);
	    }
	
	    function findCurrentlyOpenedTab(activeViewPanel) {
	      if (!activeViewPanel) {
	        return null;
	      }
	
	      var activeViewPanelIndex = null;
	
	      tabs.forEach(function (tab, index) {
	        if (activeViewPanel.path === tab.path) {
	          activeViewPanelIndex = index;
	        }
	      });
	
	      return activeViewPanelIndex;
	    }
	
	    function shouldReplaceViewPanel(activeViewPanel, navItem, parameters) {
	      var navItemInTabs = isNavItemInTabs(navItem);
	      var activeViewPanelIndex = findCurrentlyOpenedTab(activeViewPanel);
	
	      if (activeViewPanel && !navItemInTabs) {
	        replaceViewPanel(activeViewPanel, navItem, parameters, activeViewPanelIndex);
	
	        return true;
	      }
	      return false;
	    }
	
	    function isNavItemInTabs(navItem) {
	      return tabs.some(function (tab) {
	        return tab.path === navItem.path;
	      });
	    }
	
	    function replaceViewPanel(activeViewPanel, navItem, parameters, index) {
	      var promise = publishViewPanelReplaceIntent(navItem, activeViewPanel);
	      promise.then(function () {
	        onViewPanelReplaceIntentSuccess(navItem, parameters, index);
	      }, function () {
	        // publish an event if view panel replacement has been vetoed.
	        fisPubSubService.publish('fisViewPanelReplaceVetoed', {
	          navItem: navItem,
	          viewPanel: activeViewPanel
	        });
	      });
	    }
	
	    function publishViewPanelReplaceIntent(navItem, activeViewPanel) {
	      return fisPubSubService.publish('fisViewPanelReplaceIntent', {
	        path: navItem.path,
	        viewPanel: activeViewPanel
	      });
	    }
	
	    function onViewPanelReplaceIntentSuccess(navItem, parameters, index) {
	      var tab = tabs[index] = new provider.ViewPanel(navItem, $filter);
	
	      publishViewPanelOpened(navItem.path, tab);
	      publishViewReplaced(navItem);
	
	      setPathAndNavigateTo(navItem);
	    }
	
	    function setPathAndNavigateTo(navItem) {
	      selectedPanelPath = navItem.path;
	      selectedPanelUnresolvedPath = navItem.unresolvedPath;
	      selectedPanelParams = navItem.params;
	      navigateTo(navItem);
	    }
	
	    function publishViewReplaced(navItem) {
	      fisPubSubService.publish('fisViewPanelReplaced', { path: navItem.path });
	    }
	
	    function getUrlWithoutHash(url) {
	      // Use the provided URL as the default value,
	      // this will ensure a correct return value even
	      // if it doesn't contain a trailing hash (anchor)
	      var iPound = url.lastIndexOf('#');
	      var iSlash = url.lastIndexOf('/');
	      var noHash = url;
	
	      // Only cut off the hash if the hash sign was
	      // found after the last slash in the path.
	      if (iPound > iSlash) {
	        // Take everything before the hash sign
	        noHash = url.substring(0, iPound);
	      }
	
	      return noHash;
	    }
	
	    function navigateTo(navItem) {
	      // Give time to angular to complete it's $apply cycle and then update path
	      // Reference - https://groups.google.com/d/msg/angular/FJwxJ-XbJaE/584zbwBjbU8J
	      $timeout(function () {
	        // Route change only occurs when $location.path changes
	        // In some cases, we want the route to be refreshed even if the path doesn't change:
	        // 1. The user clicks on a bookmark containing #/welcome for example. In this case,
	        //    open is called with #/welcome but $location.path() is already #/welcome
	        // 2. The navigation structure is changed with fisViewService.load and the current path is
	        //    #/welcome and the new path to open is also #/welcome. In this case, the paths may be the
	        //    same but they are referring to different views so we need to reload.
	        // Note that fisViews will not drop the current view panel and reload the route's template:
	        // it will notice the view panel is for the same route and will not do anything
	        // since it only means the user is navigating to the same page again, in which case we don't
	        // want the view to be reloaded.
	        if ($location.path() === navItem.path) {
	          $route.reload();
	        } else {
	          $location.path(navItem.path);
	        }
	
	        if (!changeLocationNavigationUnderway) {
	          // eslint-disable-line
	          /*
	              This variable is explicitly set to true because it is checked while updating the view
	              The '$locationChangeStart' event handler checks for this flag to be set to true, else it will
	              prevent the location change.
	              Since this function is called by the open method of framework, we want the $location to change
	          */
	          navigationUnderWay = true;
	        } else {
	          changeLocationNavigationUnderway = false;
	        }
	      }, 0);
	    }
	
	    function mdiFunction(navItem, event, parameters) {
	      if (isFalse(event)) {
	        openInSameTab(navItem, event, parameters);
	      } else {
	        openInNewTab(navItem, event, parameters);
	      }
	    }
	
	    function browserFunction(navItem, event, parameters) {
	      if (!event || event && !event.ctrlKey && !event.metaKey) {
	        // to open child page in the current tab.
	        openInSameTab(navItem, null, parameters);
	      } else {
	        // to open child page in new tab.
	        openInNewTab(navItem, null, parameters);
	      }
	    }
	
	    function isTrue(e) {
	      return e === true || e === 'true';
	    }
	
	    function isFalse(e) {
	      return e === false || e === 'false';
	    }
	
	    function resetLocationHash() {
	      // This is done to avoid carrying over the anchor
	      // location (hash, e.g. "#toc_3") to the new tab.
	
	      // We might have to revisit this if we want to
	      // support opening tabs and jumping to a
	      // specific location at the same time.
	      $location.hash('');
	    }
	
	    function getDefaultIfNoPath(navPath) {
	      if (navPath === undefined) {
	        return '';
	      }
	      return navPath;
	    }
	
	    function normalizeOpenArguments(args, event, params) {
	      var localEvent = null;
	      var localParams = {};
	
	      if (args.length === 2) {
	        localEvent = getValidatedEvent(args[1]);
	
	        if (isStrategyOverride(event)) {
	          localEvent = event;
	        } else {
	          // it's a params object, set it to localParams
	          localParams = args[1];
	        }
	      } else if (args.length === 3) {
	        localEvent = event;
	        localParams = params;
	      }
	
	      return {
	        localEvent: localEvent,
	        localParams: localParams
	      };
	    }
	
	    function getValidatedEvent(value) {
	      if (isEvent(value)) {
	        return value;
	      }
	      return null;
	    }
	
	    function isEvent(value) {
	      return value && value.target;
	    }
	
	    function isStrategyOverride(value) {
	      return value === 'true' || value === 'false' || value === true || value === false;
	    }
	
	    function checkIfTabIsAlreadyPresent(navPath, event, params) {
	      var navItem = null;
	      var tabFound = false;
	
	      tabs.forEach(function (tab) {
	        if (tab.path === navPath) {
	          tabFound = true;
	          navItem = tab;
	          checkAndSetForSecondaryNavItem(tab, event, params);
	        }
	      });
	
	      return {
	        navItem: navItem,
	        tabFound: tabFound
	      };
	    }
	
	    function tryOpenViewBasedOnDefaultParams(navItem, navPath, tabFound, event, params, localParams) {
	      if (isNavPathNotDefined(navPath, tabFound)) {
	        navItem = openDefaultView(event, params);
	      } else if (isRelativePath(navPath, tabFound)) {
	        navItem = openRelativeView(navPath, event, params, localParams);
	        if (navItem) {
	          navPath = navItem.path;
	        }
	      } else if (isSecondaryNavigation(navPath, tabFound)) {
	        navItem = openSecondaryView(navPath, event, params);
	      }
	
	      // When navItem has parameterized url, a copy of the navItem is created and processed. Hence, the
	      // isStatic property is not set even if secondary navigation is present.
	      // Hence, setting this property after all the processing is done
	      if (navItem && getSecondaryNavParent(navItem.path) && navItem.partial) {
	        navItem.isStatic = true;
	      }
	
	      return navItem;
	    }
	
	    function openDefaultView(event, params) {
	      // TODO: default if no root tab.
	      // Provide a way to configure default and open tabs if necessary?
	
	      var navItem = getFirstTab();
	
	      if (isNavItemDefined(navItem)) {
	        checkAndSetForSecondaryNavItem(navItem, event, params);
	        return navItem;
	      }
	      return null;
	    }
	
	    function isNavPathNotDefined(navPath, tabFound) {
	      return !navPath && tabFound === false;
	    }
	
	    function isNavItemDefined(navItem) {
	      return navItem && navItem.path;
	    }
	
	    function isRelativePath(navPath, tabFound) {
	      return navPath && navPath.indexOf('/') !== 0 && tabFound === false;
	    }
	
	    function openRelativeView(navPath, event, params, localParams) {
	      var navItemTemp = fisViewService.findNavItem(navPath, selectedPanelPath);
	      var key;
	
	      // if navItemTemp not found, look it up using selectedPanelUnresolvedPath
	      if (!navItemTemp) {
	        navItemTemp = fisViewService.findNavItem(navPath, selectedPanelUnresolvedPath);
	
	        // add the selectedPanelParams to localParams for substitution.
	        for (key in selectedPanelParams) {
	          if (selectedPanelParams.hasOwnProperty(key)) {
	            localParams[key] = selectedPanelParams[key];
	          }
	        }
	      }
	
	      // Add the selectedPanelParams to localParams for substitution in case navItemTemp is found.
	      // In this case add the param only if localParams does not have the key
	      if (navItemTemp) {
	        for (key in selectedPanelParams) {
	          if (selectedPanelParams.hasOwnProperty(key) && !localParams.hasOwnProperty(key)) {
	            localParams[key] = selectedPanelParams[key];
	          }
	        }
	      }
	
	      if (navItemTemp && navItemTemp.params && Object.keys(localParams).length === 0) {
	        localParams = navItemTemp.params;
	      }
	
	      // if no local params are defined, try to use params from the active view panel in this case; since the view to be opened is a relative view.
	      if (angular.isUndefined(localParams) || localParams === null || Object.keys(localParams).length === 0) {
	        if (service.activeViewPanel()) {
	          localParams = service.activeViewPanel().params;
	        }
	      }
	
	      // when a parent page is called from child page without giving any parameters, child page params are also added in localParams
	      // we need to remove such extra params from localParams
	      var navItem = null;
	      if (navItemTemp) {
	        localParams = removeExtraParamsFromLocalParams(navItemTemp.path, localParams);
	
	        var path = substituteParams(navItemTemp.path, localParams);
	
	        navItem = getNavItemForRelativePath(navItemTemp, path, localParams);
	        navItem.unresolvedPath = navItemTemp.path;
	
	        checkAndSetForSecondaryNavItem(navItem, event, params);
	      }
	
	      return navItem;
	    }
	
	    function getNavItemForRelativePath(navItem, path, localParams) {
	      var newItem = {};
	
	      angular.copy(navItem, newItem);
	
	      newItem.path = path;
	      newItem.label = $filter('interpolate')(newItem.label, localParams);
	      newItem.params = localParams;
	
	      return newItem;
	    }
	
	    function isSecondaryNavigation(navPath, tabFound) {
	      return getSecondaryNavParent(navPath) && tabFound === false;
	    }
	
	    function openSecondaryView(navPath, event, params) {
	      var navItem = fisViewService.findNavItem(navPath);
	
	      // case of handling parameterized navigation item with secondary menu
	      if (!navItem) {
	        var relativeData = extractRelativeUrlData(navItem, navPath);
	        params = relativeData.params;
	        navItem = relativeData.navItem;
	      }
	      checkAndSetForSecondaryNavItem(navItem, event, params);
	      if (navItem) {
	        navItem.params = params;
	      }
	      return navItem;
	    }
	
	    function findNavItemIfNotDefined(navItem, navPath) {
	      // TODO: should it instead just call navigation.navigate(navPath) and have tabs handled in view service?
	
	      if (!isNavItemDefined(navItem)) {
	        navItem = fisViewService.findNavItem(navPath, selectedPanelPath);
	      }
	
	      return navItem;
	    }
	
	    function extractRelativeUrlData(navItem, navPath) {
	      var tempPath = navPath;
	      var tokens = getTokensFromNavPath(navPath);
	      var parameters = {};
	      var tempNavPath = navPath;
	      var parsedData = null;
	      var hasMoreTokens = true;
	
	      while (hasMoreTokens) {
	        if (!hasPathToParse(tempNavPath)) {
	          break;
	        }
	
	        tempPath = tempPath.substring(0, tempPath.lastIndexOf('/'));
	        if (tempPath.length === 0) {
	          break;
	        }
	        var tempNavItem = fisViewService.findNavItem(tempPath);
	
	        if (tempNavItem) {
	          var parsedDataCopy = angular.copy(parsedData);
	
	          parsedData = findMatchedChildThroughNavPath({
	            navItem: navItem,
	            tokens: tokens,
	            tempPath: tempPath,
	            tempNavPath: tempNavPath,
	            tempNavItem: tempNavItem,
	            hasMoreTokens: true,
	            parameters: parameters
	          });
	
	          if (parsedData && parsedDataCopy && parsedData.navItem && parsedDataCopy.navItem && parsedData.navItem.id === parsedDataCopy.navItem.id) {
	            hasMoreTokens = false;
	            return {
	              params: null,
	              navItem: null
	            };
	          }
	
	          navItem = parsedData.navItem;
	          tokens = parsedData.tokens;
	          tempPath = parsedData.tempPath;
	          tempNavPath = parsedData.tempNavPath;
	          tempNavItem = parsedData.tempNavItem;
	          parameters = parsedData.parameters;
	
	          if (!parsedData.hasMoreTokens) {
	            break;
	          }
	        } else if (noMoreItems(tempNavItem, tempPath)) {
	          parsedData = findMatchedNoChild(navItem, parameters, tempPath, tempNavPath);
	
	          navItem = parsedData.navItem;
	          parameters = parsedData.parameters;
	
	          break;
	        }
	      }
	
	      var resolvedPath;
	      // compute resolvedPath only for cases when navPath contains tempPath -- this is needed in case there is a parameterized url,
	      // in which case, this navPath will have unresolved path (with ':' character), and tempPath will have resolved path with substituted parameters.
	      if (navItem) {
	        var navItemIdTokens = getTokensFromNavPath(navItem.id) || [];
	        if (navPath.indexOf(tempPath) > -1 && navItemIdTokens.length > 2) {
	          resolvedPath = navPath.substring(tempPath.length + 1);
	        }
	      }
	
	      return {
	        params: parameters,
	        navItem: navItem,
	        resolvedPath: resolvedPath
	      };
	    }
	
	    // exposing this method since it is used internally by breadcrumb widget to extract relative data
	    service._extractRelativeUrlData = extractRelativeUrlData;
	
	    function noMoreItems(tempNavItem, tempPath) {
	      return !tempNavItem && tempPath.lastIndexOf('/') === 0;
	    }
	
	    function hasSomeEquivalentParam(child, childPath) {
	      var childPathWithoutParam = child.id;
	      var withoutParamWord = childPathWithoutParam.substring(0, childPathWithoutParam.indexOf('/'));
	      var originalWord = childPath.substring(0, childPath.indexOf('/'));
	      return withoutParamWord === originalWord;
	    }
	
	    function getTokensFromNavPath(navPath) {
	      var tokens = [];
	
	      if (navPath && navPath.indexOf('/') > -1) {
	        tokens = navPath.split('/');
	      }
	
	      return tokens;
	    }
	
	    function hasPathToParse(path) {
	      return path && path.substring(0, path.lastIndexOf('/'));
	    }
	
	    function getChildTokens(childPath) {
	      return childPath.split('/');
	    }
	
	    function getChildDataFromPath(child, childPath, tokensLength, tempPath, tempNavPath, hasMoreTokens) {
	      var childData = {};
	      var childTokens = getChildTokens(childPath);
	      var itemTokens = child.path.split('/');
	
	      childData.paramName = child.id.substring(child.id.indexOf(':') + 1);
	      childData.paramVal = getParameterValue(child, childPath, childTokens);
	      childData.navItem = angular.copy(child);
	
	      if (tokensLength === itemTokens.length) {
	        childData.hasMoreTokens = false;
	        childData.tempPath = tempPath;
	        childData.tempNavPath = tempNavPath;
	      } else {
	        childData.hasMoreTokens = hasMoreTokens;
	        // remove tokens already resolved
	        spliceChildTokens(child, childTokens);
	        // Add to tempPath the resolved tokens and the unresolved tokens and start again :-)
	        childData.tempPath = tempPath + '/' + child.id + '/' + childTokens.join('/');
	        childData.tempNavPath = childData.tempPath; // start again - but with one token resolved
	      }
	
	      return childData;
	    }
	
	    function spliceChildTokens(child, childTokens) {
	      if (child.id.indexOf(':') === 0) {
	        childTokens.splice(0, 1);
	      } else {
	        childTokens.splice(0, 2);
	      }
	    }
	
	    function findMatchedChildThroughNavPath(defaultData) {
	      var childPath = defaultData.tempNavPath.substring(defaultData.tempPath.length + 1);
	      var cont = true;
	
	      while (cont) {
	        if (!defaultData.tempNavItem.children) {
	          break;
	        }
	
	        var parsedDataCopy = angular.copy(parsedData); // eslint-disable-line
	
	        var parsedData = parseChildDataFrom({
	          cont: cont,
	          navItem: defaultData.navItem,
	          childPath: childPath,
	          tokens: defaultData.tokens,
	          tempPath: defaultData.tempPath,
	          tempNavPath: defaultData.tempNavPath,
	          tempNavItem: defaultData.tempNavItem,
	          hasMoreTokens: defaultData.hasMoreTokens,
	          parameters: defaultData.parameters
	        });
	
	        if (parsedData && parsedDataCopy && parsedData.navItem && parsedDataCopy.navItem && parsedData.navItem.id === parsedDataCopy.navItem.id) {
	          cont = false;
	          return defaultData;
	        }
	
	        cont = parsedData.cont;
	        childPath = parsedData.childPath;
	        defaultData.navItem = parsedData.navItem;
	        defaultData.tokens = parsedData.tokens;
	        defaultData.tempPath = parsedData.tempPath;
	        defaultData.tempNavPath = parsedData.tempNavPath;
	        defaultData.tempNavItem = parsedData.tempNavItem;
	        defaultData.hasMoreTokens = parsedData.hasMoreTokens;
	        defaultData.parameters = parsedData.parameters;
	      }
	
	      return defaultData;
	    }
	
	    function findMatchedNoChild(_navItem, parameters, tempPath, tempNavPath) {
	      var navItem = fisViewService.getItemFromPath2Item(tempPath);
	      var navigationPanelParamValue = createUrlFillingParams(tempPath, tempNavPath);
	      var paramNameString;
	      if (navItem !== null) {
	        paramNameString = findParamName(navItem);
	      }
	
	      parameters[paramNameString] = navigationPanelParamValue;
	
	      return {
	        navItem: navItem,
	        parameters: parameters
	      };
	    }
	
	    function createUrlFillingParams(tempPath, tempNavPath) {
	      return tempNavPath.substring(tempPath.length + 1);
	    }
	
	    function findParamName(navItem) {
	      return navItem.id.substring(navItem.id.indexOf(':') + 1);
	    }
	
	    function parseChildDataFrom(defaultData) {
	      var i = 0;
	      var child = null;
	      var childData = null;
	
	      for (i = 0; i < defaultData.tempNavItem.children.length; i++) {
	        child = defaultData.tempNavItem.children[i];
	
	        if (child && child.id.indexOf(':') !== -1) {
	          var proceed = child.id.indexOf(':') === 0 ? true : hasSomeEquivalentParam(child, defaultData.childPath);
	          if (proceed) {
	            childData = getChildDataFromPath(child, defaultData.childPath, defaultData.tokens.length, defaultData.tempPath, defaultData.tempNavPath, defaultData.hasMoreTokens);
	
	            defaultData.cont = false;
	            defaultData.navItem = childData.navItem;
	            defaultData.hasMoreTokens = childData.hasMoreTokens;
	            defaultData.tempPath = childData.tempPath;
	            defaultData.tempNavPath = childData.tempNavPath;
	            defaultData.parameters[childData.paramName] = childData.paramVal;
	
	            break;
	          }
	        } else {
	          for (var j = 0; j < defaultData.tokens.length; j++) {
	            if (child.id === defaultData.tokens[j]) {
	              var itemTokens = child.path.split('/');
	              // commented below line otherwise it continously loops for the case mentioned in SDHTML-5237
	              // defaultData.tempPath = defaultData.tempPath + '/' + child.path + '/';
	              defaultData.tempNavPath = defaultData.tempPath;
	              if (defaultData.tokens.length === itemTokens.length) {
	                defaultData.hasMoreTokens = false;
	                defaultData.cont = false;
	                defaultData.navItem = angular.copy(child);
	              }
	              break;
	            }
	          }
	          defaultData.cont = false;
	        }
	      }
	      return defaultData;
	    }
	
	    function getParameterValue(child, childPath, childTokens) {
	      var paramVal;
	
	      if (child.id.indexOf(':') === 0) {
	        paramVal = childTokens[0];
	      } else {
	        paramVal = childTokens[1];
	      }
	
	      return paramVal;
	    }
	
	    function getParametersIfUndefined(parameters, params) {
	      if (parameters === null && angular.isDefined(params)) {
	        parameters = params;
	      }
	
	      return parameters;
	    }
	
	    function mergeParametersIfRequired(parameters, params) {
	      if (parameters === null && angular.isDefined(params)) {
	        parameters = params;
	      } else if (angular.isDefined(params)) {
	        $.extend(true, parameters, params);
	      }
	
	      return parameters;
	    }
	
	    function getNavItemCopyIfParams(navItem, parameters, resolvedPath) {
	      if (parameters && navItem) {
	        if (navItem instanceof provider.ViewPanel) {
	          navItem = navItem.navItem;
	        }
	        // if it is a parameterized URL, substitue the params in the navItem's path
	        navItem = angular.copy(navItem);
	        if (!navItem.unresolvedPath) {
	          navItem.unresolvedPath = navItem.path;
	        }
	        navItem.path = substituteParams(navItem.path, parameters);
	        if (navItem.path && navItem.path.indexOf('/undefined/') > -1 && resolvedPath) {
	          navItem = fisViewService.findNavItem(resolvedPath);
	          navItem.path = substituteParams(navItem.path, navItem.params);
	        }
	        navItem.label = $filter('interpolate')(navItem.label, parameters);
	        if (!resolvedPath) {
	          navItem.params = parameters;
	        }
	      }
	
	      return navItem;
	    }
	
	    function getPanelPath(navPath) {
	      var panelPath = null;
	
	      if (angular.isDefined(navPath)) {
	        panelPath = navPath;
	      } else {
	        panelPath = service.activeViewPanel().path;
	      }
	
	      return panelPath;
	    }
	
	    function forceSelectionOfLastPanel(force) {
	      if (hasNoSelectedPanelPathButTabs()) {
	        if (force === undefined || force) {
	          // TODO: is this needed? is it only used when closing a tab? could it be moved there?
	          selectedPanelPath = getLastTab().path;
	        } else {
	          // no opened view panel (tab) available to select and we don't force selection.
	          return null;
	        }
	      }
	    }
	
	    function hasNoSelectedPanelPathButTabs() {
	      return !selectedPanelPath && tabs && tabs.length > 0;
	    }
	
	    function createParamsIfNotDefined(activeViewPanel) {
	      if (activeViewPanel !== null) {
	        if (angular.isUndefined(activeViewPanel.params) || activeViewPanel.params === null) {
	          activeViewPanel.params = {}; // we create a new object
	        } else if (angular.isUndefined(activeViewPanel.decodedParams) || activeViewPanel.decodedParams === null) {
	          activeViewPanel.decodedParams = addDecodedParams(activeViewPanel.params);
	        }
	      }
	    }
	
	    function isSecondaryNavItemReplacingPrimary(item, isNonCloseable) {
	      var primaryItem = getSecondaryNavParent(item.path);
	
	      if (primaryItem === item) {
	        return false;
	      }
	      if (primaryItem) {
	        var stillOpenPrimaryItem = service.viewPanels().filter(function (panel) {
	          return panel.path === primaryItem.path;
	        });
	        if (stillOpenPrimaryItem.length === 0) {
	          // The parent is not open in another tab, the closability depends on the parents closability
	          return service.isNonCloseable(primaryItem);
	        }
	        // The parent is open in another tab, thus we now may close this children tab
	        return false;
	      }
	
	      return isNonCloseable;
	    }
	
	    function getDefaultViewPanelIfNotDefined(viewPanel, navPath) {
	      if (!navPath) {
	        viewPanel = service.activeViewPanel();
	      }
	
	      return viewPanel;
	    }
	
	    function getDefaultNavPathIfNotDefined(navPath) {
	      if (!navPath) {
	        navPath = service.activeViewPanel().path;
	      }
	
	      return navPath;
	    }
	
	    function getDataFromNavPath(viewPanel, navPath) {
	      var tabIndexToRemove = null;
	
	      if (navPath) {
	        for (var i = 0; i < tabs.length; i++) {
	          if (tabs[i].path === navPath) {
	            tabIndexToRemove = i;
	            break;
	          }
	        }
	
	        if (tabIndexToRemove !== undefined) {
	          viewPanel = tabs[tabIndexToRemove];
	        }
	      }
	
	      return {
	        viewPanel: viewPanel,
	        tabIndexToRemove: tabIndexToRemove
	      };
	    }
	
	    function closeViewPanel(viewPanel, navPath, tabIndexToRemove) {
	      var tabToFocus = null;
	      var deferred = $q.defer();
	
	      if (viewPanel) {
	        viewPanel.$isClosing = true;
	
	        var promise = publishViewPanelCloseIntent(viewPanel, navPath);
	
	        promise.then(function () {
	          // handle the case where another close call has been made before the current one ends
	          viewPanel = getDefaultViewPanelIfNotDefined(viewPanel, navPath);
	          navPath = getDefaultNavPathIfNotDefined(navPath);
	
	          tabToFocus = getTabFocusFromNavPath(navPath);
	          tabIndexToRemove = getTabIndexToRemove(tabIndexToRemove, navPath);
	
	          removeTabByIndex(viewPanel, navPath, tabIndexToRemove, tabToFocus);
	
	          deferred.resolve();
	        }, function () {
	          deferred.reject('Pos 3');
	        }).finally(function () {
	          // Had to use $timeout to wrap the publish call. Promises seems to behave in synchronous manner when
	          // resolved with non-promise values (returned by $q.when in fisPubSubService.publish code). Therefore
	          // when fisViewPanelCloseIntent is published, promise.then and promise.always is called immediately called
	          // and the fis-views directive doesn't get a chance to react to viewPanel.$isClosing change and add
	          // a loading indicator.
	          $timeout(function () {
	            viewPanel.$isClosing = false;
	          }, 0);
	        });
	      } else {
	        // The navPath was not open or invalid, so resolve it right away - there's nothing to close.
	        deferred.resolve();
	      }
	
	      return deferred.promise;
	    }
	
	    function getTabFocusFromNavPath(navPath) {
	      var tabToFocus = null;
	
	      if (navPath !== selectedPanelPath) {
	        tabToFocus = selectedPanelPath;
	      }
	
	      return tabToFocus;
	    }
	
	    function getTabIndexToRemove(tabIndexToRemove, navPath) {
	      for (var i = 0; i < tabs.length; i++) {
	        if (tabs[i].path === navPath) {
	          tabIndexToRemove = i;
	          break;
	        }
	      }
	
	      return tabIndexToRemove;
	    }
	
	    function openDefaultEmptyView() {
	      $location.path('');
	      navigationUnderWay = true;
	    }
	
	    function openLastTab() {
	      // TODO: open last activated from a stack
	      var params = getLastTab() ? getLastTab().params : null;
	      service.open(getLastTab().path, null, params);
	    }
	
	    function removeViewPanel(tabIndexToRemove) {
	      tabs.splice(tabIndexToRemove, 1);
	    }
	
	    function openViewAfterClose(tabToFocus) {
	      if (tabs.length === 0) {
	        openDefaultEmptyView();
	      } else if (tabs.length > 0 && tabToFocus === null) {
	        openLastTab();
	      }
	    }
	
	    function copyClosingPanel(viewPanel) {
	      // create a copy of the closed view panel but without any functions
	      // or properties starting with '$' as we do not want the subscriber to modify the
	      // closed view panel
	      var viewPanelCopy = {};
	      Object.keys(viewPanel).forEach(function (key) {
	        if (!key.match(/^\$/)) {
	          var value = viewPanel[key];
	          if (!angular.isFunction(value)) {
	            viewPanelCopy[key] = value;
	          }
	        }
	      });
	      return viewPanelCopy;
	    }
	
	    function removeTabByIndex(viewPanel, navPath, tabIndexToRemove, tabToFocus) {
	      if (tabIndexToRemove !== null) {
	        removeViewPanel(tabIndexToRemove);
	
	        openViewAfterClose(tabToFocus);
	
	        viewPanel = copyClosingPanel(viewPanel);
	
	        publishViewPanelClosed(viewPanel, navPath);
	      }
	    }
	
	    function publishViewPanelCloseIntent(viewPanel, navPath) {
	      return fisPubSubService.publish('fisViewPanelCloseIntent', {
	        path: navPath,
	        viewPanel: viewPanel
	      });
	    }
	
	    function publishViewPanelClosed(viewPanel, navPath) {
	      return fisPubSubService.publish('fisViewPanelClosed', {
	        path: navPath,
	        viewPanel: viewPanel
	      });
	    }
	
	    /**
	     * @name open
	     * @methodOf fisViewPanelService
	     * @param {string} navPath Navigation Path to open. Undefined or empty string will load the default view.
	     * @param {Object} [event] Optional triggering event (For example, click), can be 'true' or 'false' :
	     *         True means we want to force opening in a new tab (and bypass the strategy) and false means we force opening in the same tab.
	     * @param {Object} [params] Optional Additional parameters
	     * @description Opens a ViewPanel using the configured strategy (or framework defaults 'mdi' strategy if none is configured.)
	     */
	    service.open = function (_navPath, event, params) {
	      // Hash must be removed when moving between pages (no event is fired when pages are loaded from a bookmark,
	      // an event is defined when navigating the menu or moving between tabs.
	      if (angular.isDefined(event)) {
	        resetLocationHash();
	      }
	      var relativeData = null;
	      var parameters = null;
	      var navPath = getDefaultIfNoPath(_navPath);
	      var normalized = normalizeOpenArguments(arguments, event, params);
	      var localEvent = normalized.localEvent;
	      var localParams = normalized.localParams;
	      var previousViewPanel = service.activeViewPanel(false);
	      var presentData = checkIfTabIsAlreadyPresent(navPath, event, params);
	      var navItem = presentData.navItem;
	      var tabFound = presentData.tabFound;
	      var navItemExist = false;
	      navigationUnderWay = true;
	      var resolvedPath;
	
	      navItem = tryOpenViewBasedOnDefaultParams(navItem, navPath, tabFound, event, params, localParams);
	
	      navItem = findNavItemIfNotDefined(navItem, navPath);
	
	      if (DEFAULT_OPEN_STRAT === provider.getViewOpeningStrategy() && angular.isDefined(event)) {
	        if (event && event.shiftKey && event.shiftKey === true) {
	          if (angular.isDefined(navItem)) {
	            /* The original code, which only checks whether the "last" item in the array matches in the path property:
	            _.each(tabs,function(tab){
	                navItemExist = tab.path === navItem.path;
	            });
	             During the removal of underscore, the code has been adjusted
	             */
	            navItemExist = tabs.some(function (tab) {
	              return tab.path === navItem.path;
	            });
	            if (navItemExist === false) {
	              tabs.push(new provider.ViewPanel(navItem, $filter));
	              return;
	            }
	          }
	        }
	      }
	
	      // if navItem not found, check for possibility of the navPath having relative url.
	      if (hasNoItemButTabs(navItem)) {
	        relativeData = extractRelativeUrlData(navItem, navPath);
	
	        parameters = relativeData.params;
	        navItem = relativeData.navItem;
	        resolvedPath = relativeData.resolvedPath;
	      }
	
	      parameters = getParametersIfUndefined(parameters, params);
	
	      navItem = getNavItemCopyIfParams(navItem, parameters, resolvedPath);
	
	      if (navItem !== undefined && navItem !== null && navItem.parentTitle !== undefined) {
	        navItem.isStatic = true;
	      }
	
	      validateNavItem(navItem, navPath);
	
	      if (angular.isDefined(navItem) && angular.isUndefined(navItem.partial)) {
	        if (fisConfig.widgets && fisConfig.widgets.fisTabsBar) {
	          var openFirstChildIfEmpty = fisConfig.widgets.fisTabsBar.openFirstChildIfEmpty;
	
	          if (angular.isUndefined(openFirstChildIfEmpty) || openFirstChildIfEmpty) {
	            var firstChildWithPartial = findFirstChildWithPartial(navItem);
	
	            if (firstChildWithPartial !== null) {
	              $timeout(function () {
	                service.open(firstChildWithPartial.path, event, params);
	                fisPubSubService.publish('fisFirstSecondaryItemOpened');
	              });
	            }
	          }
	        }
	      }
	
	      if (!getSecondaryNavParent(navPath)) {
	        callRelevantStrategy(navItem, localEvent, localParams);
	      }
	
	      // Passing the event object through here allows listeners of this to determine the origin of the open
	      // e.g. was it a mega menu link or a tabbar link?
	      publishViewPanelChange(navItem, previousViewPanel, event);
	
	      if (navItem !== undefined && (navItem.closeable === true || navItem.closeable === 'true' || navItem.closeable === undefined)) {
	        // broadcast on the rootscope, so other external modules can listen for this
	        $rootScope.$broadcast('fisTabOpened', { path: _navPath });
	      }
	
	      $timeout(function () {
	        navigationUnderWay = false;
	      });
	    };
	
	    function findFirstChildWithPartial(navItem) {
	      if (angular.isDefined(navItem.children) && navItem.children.length > 0) {
	        if (angular.isUndefined(navItem.children[0].partial)) {
	          return findFirstChildWithPartial(navItem.children[0]);
	        }
	        return navItem.children[0];
	      }
	      return null;
	    }
	
	    /**
	     * @name viewPanels
	     * @methodOf fisViewPanelService
	     * @returns {Array} Open ViewPanels
	     * @description Returns array of open view panels
	     */
	    service.viewPanels = function () {
	      return tabs;
	    };
	
	    /**
	     * @name viewPanelByPath
	     * @methodOf fisViewPanelService
	     * @param {String} Navigation Path of the open View Panel
	     * @returns {Object} View Panel for the navigation path passed in
	     * @description Returns the view panel corresponding to the given nav path
	     */
	    service.viewPanelByPath = function (navPath) {
	      var viewPanel;
	
	      for (var i = 0; i < tabs.length; i++) {
	        if (tabs[i].path === navPath) {
	          viewPanel = tabs[i];
	
	          break;
	        }
	      }
	
	      return viewPanel;
	    };
	
	    /**
	     * @name reloadActiveViewPanel
	     * @methodOf fisViewPanelService
	     * @param {String} Navigation Path of the panel that needs to be reloaded - optional, if not provided, then the current active panel is used
	     * @description Reloads the current active panel
	     */
	    service.reloadActiveViewPanel = function (navPath, params) {
	      var panelPath = getPanelPath(navPath);
	      var parameters = null;
	
	      for (var j = 0; j < tabs.length; j++) {
	        if (tabs[j].path === panelPath) {
	          var navItem = fisViewService.findNavItem(panelPath);
	          // handling parameterized navigation item with resolved path
	          if (!navItem) {
	            var relativeData = extractRelativeUrlData(navItem, panelPath);
	            navItem = relativeData.navItem;
	            parameters = relativeData.params;
	          } else if (angular.isUndefined(params) || params.length === 0) {
	            // if params are undefined, try to use params from the active view panel in this case; since the view to be opened is a relative view.
	            parameters = service.activeViewPanel().params;
	          }
	
	          parameters = mergeParametersIfRequired(parameters, params);
	          navItem = getNavItemCopyIfParams(navItem, parameters);
	          // Replace ViewPanel - ng-repeat will detect change and destroy DOM (div and scope)
	          tabs[j] = new provider.ViewPanel(navItem, $filter);
	
	          service.open(panelPath, null, parameters);
	
	          break;
	        }
	      }
	    };
	
	    /**
	     * @name activeViewPanel
	     * @methodOf fisViewPanelService
	     * @returns {Object} Active View Panel
	     * @description Returns the active View Panel. This will always return an activeViewPanel
	     *      if there are opened view panels because it will select one.
	     * @param force undefined or a truthy value will force selection of the last tab.
	     */
	    service.activeViewPanel = function (force) {
	      var activeViewPanel = null;
	
	      forceSelectionOfLastPanel(force);
	
	      for (var i = 0; i < tabs.length; i++) {
	        if (tabs[i].path === selectedPanelPath) {
	          activeViewPanel = tabs[i];
	
	          break;
	        }
	      }
	
	      createParamsIfNotDefined(activeViewPanel);
	
	      return activeViewPanel;
	    };
	
	    /**
	     * @name activeViewPanelIndex
	     * @methodOf fisViewPanelService
	     * @returns {int} Active View Panel index
	     * @description Returns the active View Panel index
	     */
	    service.activeViewPanelIndex = function () {
	      for (var i = 0; i < tabs.length; i++) {
	        if (tabs[i].path === selectedPanelPath) {
	          return i;
	        }
	      }
	
	      return -1;
	    };
	
	    /**
	     * @name viewPanelParams
	     * @methodOf fisViewPanelService
	     * @returns {Object} params for active view panel
	     * @description Returns the params for active View Panel
	     */
	    service.viewPanelParams = function () {
	      var params = {};
	
	      if (service.activeViewPanel()) {
	        params = service.activeViewPanel().params;
	      }
	
	      return params;
	    };
	
	    /**
	     * @name selectedViewPanelPath
	     * @methodOf fisViewPanelService
	     * @returns {String} Active View Panel path
	     * @description Returns the active View Panel path
	     */
	    service.selectedViewPanelPath = function (path) {
	      if (arguments.length === 0) {
	        return selectedPanelPath;
	      }
	      service.selectedPanelPath = path;
	      service.open(path);
	    };
	
	    /**
	     * @name resetSelectedViewPanelPath
	     * @methodOf fisViewPanelService
	     * @description Removes the selected panel path reference
	     */
	    service.resetSelectedViewPanelPath = function () {
	      selectedPanelPath = undefined;
	    };
	
	    /**
	     * @name isNonCloseable
	     * @methodOf fisViewPanelService
	     * @param {Object} item View Panel
	     * @returns {boolean} true if the View Panel is non-closeable else false
	     * @description Returns if a View Panel is closeable or not. View Panels corresponding to top level
	     * Navigation Items that have partials attached to them are considered non-closeable.
	     */
	    service.isNonCloseable = function (item) {
	      var isNonCloseable = false;
	
	      if (isNavItemDefined(item)) {
	        if (angular.isDefined(item.closeable)) {
	          isNonCloseable = !item.closeable;
	        }
	
	        var parent = getItemParentRefIfValid(item);
	
	        if (parent !== item) {
	          isNonCloseable = isSecondaryNavItemReplacingPrimary(item, isNonCloseable);
	        }
	
	        if (isNavItemDefined(item) && hasDropdownSecondaryMenu(item)) {
	          isNonCloseable = true;
	        }
	      }
	
	      return isNonCloseable;
	    };
	
	    /**
	     * @name close
	     * @methodOf fisViewPanelService
	     * @param {String} _navPath Path corresponding to a View Panel
	     * @description Closes a View Panel associated to the nav Path
	     */
	    service.close = function (_navPath) {
	      var viewPanel = getDefaultViewPanelIfNotDefined(null, _navPath);
	      var navPath = getDefaultNavPathIfNotDefined(_navPath);
	      var navPathData = getDataFromNavPath(viewPanel, navPath);
	      var tabIndexToRemove = navPathData.tabIndexToRemove;
	
	      viewPanel = navPathData.viewPanel;
	
	      // broadcast on the rootscope, so other external modules can listen for this
	      $rootScope.$broadcast('fisTabClosed', { path: _navPath });
	
	      return closeViewPanel(viewPanel, navPath, tabIndexToRemove);
	    };
	
	    function findScopeForEvaluation(context, element) {
	      // check if the context is a scope (that's the case when the service function is invoked from an angular expression)
	      if (context.$eval) {
	        // it quacks like one
	        return context;
	      }
	
	      // no luck try with the element, if present
	      if (element && element.scope) {
	        return element.scope();
	      }
	
	      throw new Error('Cannot find a scope to evaluate expression in.');
	    }
	
	    function findElementFromEvent(event) {
	      return angular.isObject(event) && angular.isDefined(event.target) && angular.element(event.target);
	    }
	
	    function processActionView(context, viewDef, event, params) {
	      var locals;
	      var ret;
	      var destroyScope = false;
	      var element = findElementFromEvent(event);
	      var evalScope = findScopeForEvaluation(context, element);
	
	      if (angular.isObject(params)) {
	        locals = angular.copy(params);
	      } else {
	        locals = {};
	      }
	
	      locals.view = viewDef;
	      locals.$scope = evalScope;
	
	      if (angular.isString(viewDef.actionController)) {
	        // create a new child scope on which to attach the controller
	        locals.$scope = evalScope = evalScope.$new();
	        locals.$element = element;
	        $controller(viewDef.actionController, locals);
	        destroyScope = true;
	      }
	
	      // elements can't be referenced in angualr expressions
	      delete locals.$element;
	      // event put in locals only for the expression evaluation
	      locals.$event = event;
	
	      ret = evalScope.$eval(viewDef.action, locals);
	
	      if (destroyScope) {
	        evalScope.$destroy();
	      }
	
	      return ret;
	    }
	
	    service.openView = function (viewDef, event, params) {
	      var context = this;
	
	      if (viewDef.action) {
	        return processActionView(context, viewDef, event, params);
	      } else if (viewDef.path) {
	        return service.open.call(context, viewDef.path, event, params);
	      } else if (angular.isString(viewDef)) {
	        return service.open.call(context, viewDef, event, params);
	      }
	
	      throw new Error('Cannot open provided view definition object');
	    };
	
	    /* service.setNavigationComplete = function() {
	        $timeout (function () {
	            navigationUnderWay = false;
	        });
	    };*/
	
	    var activePanel;
	
	    fisPubSubService.subscribe('fisBeforeNavItemAdd', function () {
	      activePanel = service.activeViewPanel();
	    });
	
	    fisPubSubService.subscribe('fisAfterNavItemAdd', function (params) {
	      if (params.rootNav === 'main' && params.itemToAdd.partial) {
	        tabs.push(new provider.ViewPanel(params.itemToAdd, $filter));
	      }
	      if (params.openItemAfterAdd) {
	        service.open(params.itemToAdd.path, null, params.openParams);
	      } else {
	        service.open(activePanel.path, null, params.openParams);
	      }
	      fisPubSubService.publish('fisAfterNavItemAdded');
	    });
	
	    fisPubSubService.subscribe('fisBeforeNavItemRemove', function () {
	      activePanel = service.activeViewPanel();
	    });
	
	    fisPubSubService.subscribe('fisAfterNavItemRemove', function (params) {
	      var tabToClose = null;
	      var secondaryNavParent;
	
	      for (var i = 0; i < tabs.length; i++) {
	        if (tabs[i].id === params.itemToRemove.id) {
	          tabToClose = tabs[i];
	          break;
	        }
	      }
	      if (!params.openParentNode && tabToClose) {
	        service.close(tabToClose.path);
	      }
	
	      // see if the item to be removed is part of the currently open secondary menu bar
	      // if it is, the secondary menu bar should refresh irrespective of the openParentNode param value
	      if (params.itemToRemove.id !== service.activeViewPanel().id && service.activeViewPanel() && (service.activeViewPanel().unresolvedPath || service.activeViewPanel().path)) {
	        var activePanelPath = service.activeViewPanel().unresolvedPath ? service.activeViewPanel().unresolvedPath : service.activeViewPanel().path;
	        secondaryNavParent = getSecondaryNavParent(params.itemToRemove.path);
	        var secondaryNavParentForActiveTab = getSecondaryNavParent(activePanelPath);
	        if (secondaryNavParent && secondaryNavParentForActiveTab && secondaryNavParent.path === secondaryNavParentForActiveTab.path) {
	          if (tabToClose) {
	            service.close(tabToClose.path);
	          }
	          service.open(service.activeViewPanel().path, null, params.openParams);
	        }
	      }
	
	      if (params.openParentNode && params.parentItem && params.parentItem.partial) {
	        service.open(params.parentItem.path, null, params.openParams);
	      } else if (params.openParentNode && params.parentItem && !params.parentItem.partial) {
	        secondaryNavParent = getSecondaryNavParent(params.itemToRemove.path);
	        if (secondaryNavParent) {
	          service.open(secondaryNavParent.path, null, params.openParams);
	        } else if (tabToClose) {
	          service.close(tabToClose.path);
	        }
	      }
	
	      fisPubSubService.publish('fisAfterNavItemRemoved');
	    });
	
	    init();
	
	    return service;
	  }];
	};

/***/ }),
/* 64 */
/*!****************************************!*\
  !*** ./views/view-service.provider.js ***!
  \****************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  var self = this;
	  // filters allow modifying the incoming nav structure before it gets
	  // processed. It could be used to define the nav structure on the client
	  // instead of on the server.
	  // filter signature: function( items, params )
	  // item: array of root nav items
	  // params: params sent to navigation.refresh method.
	  var filters = [];
	  self.addFilter = function (filter) {
	    return filters.push(filter);
	  };
	
	  self.removeFilter = function (idx) {
	    delete filters[idx];
	  };
	
	  // set to false to prevent service from invoking the navigation rest endpoint
	  self.remote = true;
	
	  var staticViews = null;
	  self.setViews = function (views) {
	    staticViews = views;
	  };
	
	  // the default RESTful resource endpoint
	  var defaultEndpoint = 'api/navigation.json';
	  var endpoint = null;
	  self.endpoint = function (ep) {
	    if (ep) {
	      endpoint = ep;
	    }
	    return endpoint;
	  };
	
	  // reference to angular's $routeProvider
	  self.$routeProvider = null;
	
	  self.$get = ['$templateCache', '$resource', '$route', '$rootScope', '$log', 'fisConfig', '$q', 'fisPubSubService', 'fisUtilService', '$injector', 'fisNavigationService', 'fisI18nService', function ($templateCache, $resource, $route, $rootScope, $log, fisConfig, $q, fisPubSubService, fisUtilService, $injector, fisNavigationService, fisI18nService) {
	    var nav = null;
	    var path2Item = {};
	    var id2Item = {};
	    var serv = {};
	
	    /**
	     * @name applyFilter
	     * @description Utility function to filter navigation model.
	     * @param model model to apply filters to
	     * @param params filter parameters
	     * @return
	     * @methodOf fisViewService
	     * @private
	     */
	    function applyFilters(model, params) {
	      for (var i = 0; i < filters.length; i++) {
	        filters[i](model, params);
	      }
	    }
	
	    /**
	     * @name traverse
	     * @description Utility function to traverse and process navigation
	     * structure
	     * @param items structure to traverse
	     * @param cb calback to apply during traversal
	     * @param navPath tracks position in structure.
	     * @return
	     * @methodOf fisViewService
	     * @private
	     */
	    function traverse(items, cb, navPath) {
	      var path = navPath || [];
	      angular.forEach(items, function (itm /* , key*/) {
	        var ret = cb.apply(this, [itm, path]);
	        if (ret === false) {
	          return false;
	        }
	        if (itm.children) {
	          path.push(itm);
	          traverse(itm.children, cb, path);
	          path.pop();
	        }
	        if (itm.quickLinks) {
	          angular.forEach(itm.quickLinks, function (quickLinks) {
	            path.push(itm);
	            path.push(quickLinks); // include quicklinks in path
	            traverse(quickLinks.children, cb, path);
	            path.pop();
	            path.pop();
	          });
	        }
	      }, items);
	    }
	
	    /**
	     * @name normalizeLabel
	     * @description Normalises text to acceptable characters
	     * @param label text to normalise
	     * @return normalized text
	     * @methodOf fisViewService
	     * @private
	     */
	    function normalizeLabel(label) {
	      return label.toLowerCase().replace(' ', '-');
	    }
	
	    function updatePath2Item(itm, path) {
	      if (!itm.id) {
	        itm.id = normalizeLabel(itm.label);
	      }
	      if (!itm.path) {
	        var a = [];
	        for (var i = 0; i < path.length; i++) {
	          a.push(path[i].id);
	        }
	        a.push(itm.id);
	        itm.path = '/' + a.join('/');
	        path2Item[itm.path] = itm;
	      }
	      // In case, translation data is loading asynchronously, updating the label and title in path2Item[] array
	      if (path2Item[itm.path] !== undefined) {
	        path2Item[itm.path].label = itm.label;
	        path2Item[itm.path].title = itm.title;
	      }
	    }
	
	    function updateId2Item(itm) {
	      if (itm.id.indexOf('/') > -1) {
	        var isAlreadyIncluded = Object.keys(id2Item).some(function (key) {
	          return id2Item[key] === itm;
	        });
	        if (!isAlreadyIncluded) {
	          id2Item[itm.id] = itm;
	        }
	      }
	    }
	
	    /**
	     * @name normalizeModel
	     * @description Normalizes text to acceptable characters for model
	     * @param model structure with labels to normalize
	     * @methodOf fisViewService
	     * @private
	     */
	    function normalizeModel(model) {
	      angular.forEach(model, function (navItems /* , key*/) {
	        traverse(navItems, function (itm, path) {
	          updatePath2Item(itm, path);
	          updateId2Item(itm);
	
	          // i18n support of navigation item's label and title
	          if (itm.label && itm.label.indexOf('i18n(') === 0) {
	            itm.label = itm.label.substring(itm.label.indexOf('(') + 2, itm.label.indexOf(')') - 1);
	            // In case, translations are available for the selected language then we can directly translate label and titles
	            if (fisI18nService.isTranslationReady()) {
	              itm.label = fisI18nService.translate(itm.label);
	              updatePath2Item(itm, path);
	              updateId2Item(itm);
	            } else {
	              // In case, translations are loading asynchronously, we need to use promise api to update
	              // labels and titles on receiving data for translation
	              fisI18nService.translateAsync(itm.label).then(function (resolvedLabel) {
	                itm.label = resolvedLabel;
	                updatePath2Item(itm, path);
	                updateId2Item(itm);
	              });
	            }
	          }
	          if (itm.title && itm.title.indexOf('i18n(') === 0) {
	            itm.title = itm.title.substring(itm.title.indexOf('(') + 2, itm.title.indexOf(')') - 1);
	            // In case, translations are available for the selected language then we can directly translate label and titles
	            if (fisI18nService.isTranslationReady()) {
	              itm.title = fisI18nService.translate(itm.title);
	              updatePath2Item(itm, path);
	              updateId2Item(itm);
	            } else {
	              // In case, translations are loading asynchronously, we need to use promise api to update
	              // labels and titles on receiving data for translation
	              fisI18nService.translateAsync(itm.title).then(function (resolvedTitle) {
	                itm.title = resolvedTitle;
	                updatePath2Item(itm, path);
	                updateId2Item(itm);
	              });
	            }
	          }
	          // support definitions that only contain a template
	          if (itm.template && !itm.partial) {
	            itm.partial = itm.path + '.tpl.html';
	          }
	        });
	      });
	    }
	
	    /**
	     * @name createRoutes
	     * @description Creates angular routes from navigation structure
	     * @param model navigation structure
	     * @methodOf fisViewService
	     * @private
	     */
	    function createRoutes(model) {
	      angular.forEach(model, function (navItems /* , key*/) {
	        traverse(navItems, function (itm /* , path*/) {
	          if (itm.partial) {
	            var opts = {
	              templateUrl: fisUtilService.appendCacheQueryParameter(itm.partial)
	            };
	
	            if (itm.template) {
	              // prefill $templateCache with provided template
	              $templateCache.put(itm.partial, itm.template);
	            }
	
	            if (itm.controller) {
	              // TODO: Controllers need to be loaded on demand
	              opts.controller = itm.controller;
	            }
	            opts.resolve = createResolveProperty(itm);
	            self.$routeProvider.when(itm.path, opts);
	          } else if (!itm.children && !itm.action) {
	            $log.warn('Leaf nav item without a partial: ' + itm.label);
	          }
	        });
	      });
	    }
	
	    function createResolveProperty(itm) {
	      var ret = {};
	
	      // find the constructor in the registry
	      var ctrl = itm.controller && fis.__controllers[itm.controller];
	
	      angular.forEach(ctrl, function (val, key) {
	        if (key.indexOf('$') !== 0) {
	          ret[key] = createResolveValue(val, itm.args);
	        }
	      });
	
	      if (itm.args) {
	        ret.args = function () {
	          return itm.args;
	        };
	      }
	
	      return ret;
	    }
	
	    function createResolveValue(toResolve, args) {
	      if (angular.isFunction(toResolve) || angular.isArray(toResolve) && angular.isFunction(toResolve[toResolve.length - 1])) {
	        return function resolveFunction() {
	          return $injector.invoke(toResolve, this, { args: args });
	        };
	      }
	      return toResolve; // a simple object/array/native we want to pass
	    }
	
	    /**
	     * @name processMenu
	     * @description Process navigation structure for use in shell
	     * @param model navigation structure
	     * @param params filter parameters
	     * @methodOf fisViewService
	     * @private
	     */
	    function processMenu(model, params) {
	      // TODO: execute all into a single traversal for speed.
	      // add the default workspace
	      applyFilters(model, params);
	      normalizeModel(model);
	      createRoutes(model);
	
	      return model;
	    }
	
	    /**
	     * @name fetchNavigation
	     * @description Fetches navigation structure from backend and processes it
	     * @param endpoint Serverside RESTful endpoint that serves navigation structure
	     * @param params filter parameters
	     * @methodOf fisViewService
	     * @private
	     */
	    function fetchNavigation(endpoint, params) {
	      var deferred = $q.defer();
	      $resource(endpoint).get(params, function (results) {
	        var finalResult = {};
	        for (var key in results) {
	          if (results.hasOwnProperty(key)) {
	            var value = results[key];
	            if (key.indexOf('$') !== 0) {
	              finalResult[key] = value;
	            }
	          }
	        }
	        resolveViews(deferred, finalResult, params);
	      }, function () {
	        deferred.reject('Could not load navigation from ' + endpoint);
	      });
	      return deferred.promise;
	    }
	
	    function resolveViews(deferred, views, params) {
	      // assign the processed views to the internal nav var
	      nav = processMenu(views, params);
	
	      // resolve the deferred object to the processed views
	      deferred.resolve(nav);
	
	      // publish it on the 'shell.navReady' topic so that nav widgets can render the views
	      fisPubSubService.publish('shell.navReady', nav);
	      fisNavigationService.setNavigation(nav);
	      return deferred.promise;
	    }
	
	    /**
	     * @name load
	     * @description Loads and initializes navigation
	     * @param params filter parameters
	     * @param model existing navigation structure(optional)
	     * @methodOf fisViewService
	     */
	    serv.load = function (params, model) {
	      // TODO: use fisConfig to get default params and extend with received params
	      params = params || {};
	      path2Item = params.path2Item || {};
	
	      fisPubSubService.publish('shell.navLoading', true);
	      if (model || staticViews) {
	        // views provided as an argument or at config time; make it the new nav structure
	        return resolveViews($q.defer(), angular.copy(model || staticViews), params);
	      } else if (self.endpoint()) {
	        // an endpoint was provided at config time, it takes precedence over config service
	        return fetchNavigation(self.endpoint(), params);
	      }
	      return fetchNavigation(fisConfig.endpoints && fisConfig.endpoints.navigation || defaultEndpoint, params);
	    };
	
	    serv.loadOnNavChange = function (params, model) {
	      // TODO: use fisConfig to get default params and extend with received params
	      params = params || {};
	      path2Item = params.path2Item || {};
	
	      var deferred = $q.defer();
	
	      // assign the processed views to the internal nav var
	      nav = processMenu(angular.copy(model), params);
	
	      // resolve the deferred object to the processed views
	      deferred.resolve(nav);
	
	      fisPubSubService.publish('shell.navChanged', nav);
	
	      fisNavigationService.setNavigation(nav);
	      return deferred.promise;
	    };
	
	    /**
	     * @name findNavItem
	     * @description Retrieves item at specified path.
	     * @param navPath Navigation Path for required item
	     * @param fromPath Path to search from if navPath is relative (doesn't start with '/').
	     *          If not provided and navPath is relative, the function will return undefined.
	     * @methodOf fisViewService
	     */
	    /* serv.findNavItem = function (navPath, fromPath) {
	     console.log('Processing for navPath...', navPath);
	     console.log('fromPath...', fromPath);
	     fromPath = fromPath || '';
	     if( navPath && navPath.indexOf('/') !== 0 ) {
	     // navPath is relative, search from fromPath
	     var item, idx = fromPath.lastIndexOf('/') + 1;
	     console.log('index...', idx);
	     console.log('path2Item...', path2Item);
	     while(idx > 1) {
	     console.log('path...', fromPath.substring(0, idx) + navPath);
	     item = path2Item[fromPath.substring(0, idx) + navPath];
	     console.log('item...', item);
	     if( item ) {
	     return item;
	     }
	     idx = fromPath.lastIndexOf('/', idx - 2) + 1;
	     console.log('index after...', idx);
	     }
	     }
	     return path2Item[navPath];
	     };*/
	
	    serv.findNavItem = function (navPath, fromPath) {
	      var item = null;
	      fromPath = fromPath || '';
	
	      if (navPath && navPath.indexOf('/') !== 0) {
	        // navPath is relative, search from fromPath
	        // var idx = fromPath.lastIndexOf('/') + 1;
	        // console.log('index...', idx);
	        // console.log('path2Item...', path2Item);
	        // console.log('path...', fromPath.substring(0, idx) + navPath);
	        item = path2Item[fromPath + '/' + navPath];
	        // console.log('item...', item);
	        if (item) {
	          return item;
	        }
	        // item not found relative to fromPath.
	        item = serv.getItemFromPath2Item(navPath);
	        // item still not found. Try to find if the path is just id. check with ids that contain '/' character
	        if (!item) {
	          item = getItemFromId2Item(navPath);
	        }
	        return item;
	      }
	
	      item = path2Item[navPath];
	
	      return item;
	    };
	
	    function getItemFromId2Item(navPath) {
	      var item = null;
	
	      for (var id in id2Item) {
	        // eslint-disable-line
	        var idArr = id.split('/');
	        var navPathArr = navPath.split('/');
	        if (idArr.length === navPathArr.length) {
	          var paramArr = matchTokens(idArr, navPathArr);
	          if (paramArr) {
	            item = id2Item[id];
	            item.params = paramArr;
	            break;
	          }
	        }
	      }
	      return item;
	    }
	
	    function matchTokens(idArr, navPathArr) {
	      var paramArr = {};
	
	      for (var i = 0; i < idArr.length; i++) {
	        if (idArr[i] !== navPathArr[i] && idArr[i].indexOf(':') !== 0) {
	          paramArr = null;
	          return false;
	        } else if (idArr[i] !== navPathArr[i] && idArr[i].indexOf(':') === 0) {
	          var paramName = idArr[i].substring(1);
	          var paramValue = navPathArr[i];
	          paramArr[paramName] = paramValue;
	        }
	      }
	
	      return paramArr;
	    }
	
	    // returns the last part of the navItem, excluding those those which include a ':', in which case the second last part will be returned
	    function getNavPathEnd(navItem) {
	      var parts = navItem.split('/');
	      var size = parts.length;
	
	      if (size < 2) {
	        return navItem;
	      }
	
	      if (parts[size - 1].indexOf(':') === -1) {
	        return parts[size - 1];
	      } else if (parts[size - 2].indexOf(':') === -1) {
	        return parts[size - 2];
	      }
	
	      // more than one parameters in id
	      for (var i = size - 1; i > 0; i--) {
	        if (parts[i].indexOf(':') === -1) {
	          return parts[i];
	        }
	      }
	    }
	
	    serv.getItemFromPath2Item = function (navPath) {
	      var navItem = null;
	
	      for (var path in path2Item) {
	        if (path2Item.hasOwnProperty(path)) {
	          var item = path2Item[path];
	
	          var pathTokenLength = path.split('/').length;
	          var navPathTokenLength = navPath.split('/').length;
	
	          if ((pathTokenLength > 2 && navPathTokenLength > 2 && pathTokenLength === navPathTokenLength || pathTokenLength <= 2 || navPathTokenLength <= 2) && getNavPathEnd(path) === getNavPathEnd(navPath)) {
	            navItem = item;
	            return navItem;
	          }
	        }
	      }
	      return navItem;
	    };
	
	    serv.addDynamicItem = function (item, opts) {
	      path2Item[item.path] = item;
	      self.$routeProvider.when(item.path, opts);
	    };
	
	    /**
	     * @name addItemToMenu
	     * @description Add a node to existing navigation structure dynamically
	     * @param parentItemId id or path of the node to which the new node needs to be appended
	     * @param itemToAdd new node to be added
	     * @methodOf fisViewService
	     */
	    serv.addNavItem = function (parentItemId, itemToAdd, openItemAfterAdd, openParams, addAfterItemId) {
	      if (itemToAdd && itemToAdd.id) {
	        var deferred = $q.defer();
	        openItemAfterAdd = openItemAfterAdd === 'true' || openItemAfterAdd === true;
	        openParams = jQuery.isEmptyObject(openParams) ? undefined : openParams;
	        fisPubSubService.publish('fisBeforeNavItemAdd', true);
	        var parentItem = serv.findNavItem(parentItemId);
	        if (parentItem) {
	          itemToAdd.path = parentItem.path + '/' + itemToAdd.id;
	          path2Item[itemToAdd.path] = itemToAdd;
	          if (!parentItem.children) {
	            parentItem.children = [];
	          }
	
	          if (isItemAlreadyPresentInParent(parentItem.children, itemToAdd)) {
	            deferred.reject();
	          } else {
	            // add item after the specified sibling - if this item is not found, the new item will be added at the end
	            if (addAfterItemId) {
	              var siblingItem = serv.findNavItem(addAfterItemId);
	              if (siblingItem) {
	                var siblingIndex = -1;
	                for (var i = 0; i < parentItem.children.length; i++) {
	                  if (parentItem.children[i].path === siblingItem.path) {
	                    siblingIndex = i;
	                    break;
	                  }
	                }
	                if (siblingIndex > -1) {
	                  parentItem.children.splice(siblingIndex + 1, 0, itemToAdd);
	                }
	              }
	            } else {
	              parentItem.children.push(itemToAdd);
	            }
	            updateModel(parentItem, function (navItems, matchedItem) {
	              matchedItem.children = parentItem.children;
	            });
	
	            serv.loadOnNavChange({ path2Item: path2Item }, nav).then(function () {
	              fisPubSubService.publish('fisAfterNavItemAdd', { nav: nav, itemToAdd: itemToAdd, parentItem: parentItem, openItemAfterAdd: openItemAfterAdd, openParams: openParams });
	              deferred.resolve(nav);
	            });
	          }
	        } else if (!parentItem && nav[parentItemId]) {
	          // if item needs to be added directly at root level (for ex. directly under main, footer etc.)
	          itemToAdd.path = '/' + itemToAdd.id;
	          path2Item[itemToAdd.path] = itemToAdd;
	          if (isItemAlreadyPresentInParent(nav[parentItemId], itemToAdd)) {
	            deferred.reject();
	          } else {
	            nav[parentItemId].push(itemToAdd);
	            serv.loadOnNavChange({ path2Item: path2Item }, nav).then(function () {
	              var rootNav = parentItemId;
	              fisPubSubService.publish('fisAfterNavItemAdd', { nav: nav, itemToAdd: itemToAdd, parentItem: parentItem, openItemAfterAdd: openItemAfterAdd, openParams: openParams, rootNav: rootNav });
	              deferred.resolve(nav);
	            });
	          }
	        }
	        return deferred.promise;
	      }
	    };
	
	    function isItemAlreadyPresentInParent(children, itemToAdd) {
	      return children.some(function (child) {
	        return child.id === itemToAdd.id;
	      });
	    }
	
	    // TODO: There should not be a need for traversing the nav and updating it separately
	    // However in case when we add an item first and then remove it, the changes are not
	    // getting reflected in the model.
	    // Need to look into the cause of this.
	    function updateModel(itemToLookup, cb) {
	      angular.forEach(nav, function (navItems /* , key*/) {
	        traverse(navItems, function (itm) {
	          if (itm.path === itemToLookup.path) {
	            cb.apply(this, [navItems, itm]);
	          }
	        });
	      });
	    }
	
	    function getIndexOfChild(childItem, parentItem) {
	      var index = -1;
	      if (parentItem && parentItem.children) {
	        for (var i = 0; i < parentItem.children.length; i++) {
	          var child = parentItem.children[i];
	          if (child.id === childItem.id) {
	            index = i;
	            break;
	          }
	        }
	      }
	      return index;
	    }
	
	    serv.removeNavItem = function (itemToRemoveId, openParentNode, openParams) {
	      var deferred = $q.defer();
	      var parentItem;
	
	      openParentNode = openParentNode === 'true' || openParentNode === true;
	      fisPubSubService.publish('fisBeforeNavItemRemove', true);
	      var itemToRemove = serv.findNavItem(itemToRemoveId);
	      if (itemToRemove) {
	        var parentPath = itemToRemove.path.substring(0, itemToRemove.path.lastIndexOf('/'));
	        if (parentPath) {
	          parentItem = serv.findNavItem(parentPath);
	
	          // if parent item not found, tokenize the path and try to find the parent
	          if (!parentItem) {
	            var hasMoreTokens = true;
	            var tempPath = parentPath;
	
	            while (hasMoreTokens) {
	              tempPath = tempPath.substring(0, tempPath.lastIndexOf('/'));
	              if (tempPath && tempPath.length === 0) {
	                hasMoreTokens = false;
	              } else {
	                parentItem = serv.findNavItem(tempPath);
	                if (parentItem) {
	                  hasMoreTokens = false;
	                }
	              }
	            }
	          }
	
	          if (parentItem) {
	            var itmToRemIndex = getIndexOfChild(itemToRemove, parentItem);
	            if (itmToRemIndex > -1) {
	              parentItem.children.splice(itmToRemIndex, 1);
	              path2Item[parentItem.path] = parentItem;
	
	              delete path2Item[itemToRemove.path];
	              delete id2Item[itemToRemove.id];
	
	              updateModel(parentItem, function (navItems, matchedItem) {
	                matchedItem.children = parentItem.children;
	              });
	            }
	          }
	        } else {
	          // no parent path means the node is at root level
	          updateModel(itemToRemove, function (navItems, matchedItem) {
	            navItems.splice(navItems.indexOf(matchedItem), 1);
	          });
	        }
	
	        serv.loadOnNavChange({ path2Item: path2Item }, nav).then(function () {
	          fisPubSubService.publish('fisAfterNavItemRemove', { nav: nav, itemToRemove: itemToRemove, parentItem: parentItem, openParentNode: openParentNode, openParams: openParams });
	          deferred.resolve(nav);
	        });
	      } else {
	        deferred.reject();
	      }
	
	      return deferred.promise;
	    };
	
	    return serv;
	  }];
	};

/***/ }),
/* 65 */
/*!**********************************************!*\
  !*** ./views/navigation-service.provider.js ***!
  \**********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  self.$get = ['fisPubSubService', '$q', function (fisPubSubService, $q) {
	    var service = {};
	    var navigation;
	    var deferred = $q.defer();
	
	    /**
	     * since the 'shell.navReady' is fired before this directive is instantiated,
	     * this method is only used when the navigation is updated.
	     * @param nav
	     */
	    fisPubSubService.subscribe('shell.navReady', function (nav) {
	      if (angular.isDefined(nav)) {
	        navigation = nav;
	        deferred.resolve(navigation);
	      }
	    });
	
	    /**
	     * Setter for the Navigation - used to set navigaiton from the View Service.
	     * @param nav
	     */
	    service.setNavigation = function (nav) {
	      navigation = nav;
	      deferred.resolve(navigation);
	    };
	
	    /**
	     * Accessor for the navigation
	     * @returns {*}
	     */
	    service.getNavigation = function () {
	      return deferred.promise;
	    };
	
	    return service;
	  }];
	};

/***/ })
/******/ ]);
//# sourceMappingURL=fis-core-components.js.map;
/*!
 * 
 * @ruf/fis-kendo-components
 * Version: 4.5.1
 * 
 * © 2018
 * Fidelity National Information Services, Inc. and/or its subsidiaries - All Rights Reserved worldwide.
 * This document is protected under the trade secret and copyright laws as the property of Fidelity National Information Services, Inc. and/or its subsidiaries.
 * Copying, reproduction or distribution should be limited and only to employees with a “need to know” to do their job. Any disclosure of this document to third parties is strictly prohibited.
 * 
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _advancedsearch = __webpack_require__(/*! ./advancedsearch */ 4);
	
	var _advancedsearch2 = _interopRequireDefault(_advancedsearch);
	
	var _autocomplete = __webpack_require__(/*! ./autocomplete */ 19);
	
	var _autocomplete2 = _interopRequireDefault(_autocomplete);
	
	var _base = __webpack_require__(/*! ./base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _data = __webpack_require__(/*! ./data */ 9);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _date = __webpack_require__(/*! ./date */ 21);
	
	var _date2 = _interopRequireDefault(_date);
	
	var _dialog = __webpack_require__(/*! ./dialog */ 34);
	
	var _dialog2 = _interopRequireDefault(_dialog);
	
	var _dropdown = __webpack_require__(/*! ./dropdown */ 8);
	
	var _dropdown2 = _interopRequireDefault(_dropdown);
	
	var _grid = __webpack_require__(/*! ./grid */ 40);
	
	var _grid2 = _interopRequireDefault(_grid);
	
	var _language = __webpack_require__(/*! ./language */ 50);
	
	var _language2 = _interopRequireDefault(_language);
	
	var _menubar = __webpack_require__(/*! ./menubar */ 52);
	
	var _menubar2 = _interopRequireDefault(_menubar);
	
	var _number = __webpack_require__(/*! ./number */ 55);
	
	var _number2 = _interopRequireDefault(_number);
	
	var _tabs = __webpack_require__(/*! ./tabs */ 60);
	
	var _tabs2 = _interopRequireDefault(_tabs);
	
	var _treeview = __webpack_require__(/*! ./treeview */ 63);
	
	var _treeview2 = _interopRequireDefault(_treeview);
	
	var _util = __webpack_require__(/*! ./util */ 22);
	
	var _util2 = _interopRequireDefault(_util);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo', [_advancedsearch2.default, _autocomplete2.default, _base2.default, _data2.default, _date2.default, _dialog2.default, _dropdown2.default, _grid2.default, _language2.default, _menubar2.default, _number2.default, _tabs2.default, _treeview2.default, _util2.default]);
	
	if (false) {
	  // eslint-disable-line
	  require('angular-mocks');
	  require('@ruf/fis-mocks');
	  // require(imports?define=>false!@ruf/kendo-ui/src/js/kendo.core');
	  require('imports?define=>false!@ruf/kendo-ui/src/js/cultures/kendo.culture.en');
	  require('imports?define=>false!@ruf/kendo-ui/src/js/cultures/kendo.culture.de');
	  require('imports?define=>false!@ruf/kendo-ui/src/js/cultures/kendo.culture.fr');
	  require('imports?define=>false!@ruf/kendo-ui/src/js/cultures/kendo.culture.es');
	  require('imports?define=>false!@ruf/kendo-ui/src/js/cultures/kendo.culture.en-GB');
	  require('imports?define=>false!@ruf/kendo-ui/src/js/cultures/kendo.culture.en-IN');
	}
	
	exports.default = ngModule.name;

/***/ }),
/* 1 */
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ (function(module, exports) {

	module.exports = jQuery;

/***/ }),
/* 2 */
/*!**************************!*\
  !*** external "angular" ***!
  \**************************/
/***/ (function(module, exports) {

	module.exports = angular;

/***/ }),
/* 3 */
/*!************************!*\
  !*** external "kendo" ***!
  \************************/
/***/ (function(module, exports) {

	module.exports = kendo;

/***/ }),
/* 4 */
/*!*********************************!*\
  !*** ./advancedsearch/index.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _base = __webpack_require__(/*! ../base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _dropdown = __webpack_require__(/*! ../dropdown */ 8);
	
	var _dropdown2 = _interopRequireDefault(_dropdown);
	
	var _advancedSearch = __webpack_require__(/*! ./advanced-search.directive */ 18);
	
	var _advancedSearch2 = _interopRequireDefault(_advancedSearch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.advancedsearch', [_base2.default, _dropdown2.default]);
	
	ngModule.directive('fisAdvancedSearch', _advancedSearch2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 5 */
/*!***********************!*\
  !*** ./base/index.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _fisWidgets = __webpack_require__(/*! @ruf/fis-widgets */ 6);
	
	var _fisWidgets2 = _interopRequireDefault(_fisWidgets);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _resource = __webpack_require__(/*! ./resource.decorator */ 7);
	
	var _resource2 = _interopRequireDefault(_resource);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.base', [_fisWidgets2.default, 'kendo.directives']);
	
	ngModule.decorator('$resource', _resource2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 6 */
/*!********************************!*\
  !*** external "'fis.widgets'" ***!
  \********************************/
/***/ (function(module, exports) {

	module.exports = 'fis.widgets';

/***/ }),
/* 7 */
/*!************************************!*\
  !*** ./base/resource.decorator.js ***!
  \************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$delegate", function ($delegate) {
	  'ngInject';
	
	  function invokeDownstreamToJSON(obj, res) {
	    var proto = Object.getPrototypeOf(obj);
	    // if its an angular resource object, skip the toJSON call
	    if (proto.constructor !== res && angular.isFunction(proto.toJSON)) {
	      return proto.toJSON.call(obj);
	    }
	    return obj;
	  }
	
	  function resourceToJSONDecorator() {
	    var Resource = $delegate.apply($delegate, arguments);
	
	    Resource.prototype.toJSON = function () {
	      var data = invokeDownstreamToJSON(this, Resource);
	
	      delete data.$promise;
	      delete data.$resolved;
	
	      return data;
	    };
	
	    return Resource;
	  }
	
	  return resourceToJSONDecorator;
	}];

/***/ }),
/* 8 */
/*!***************************!*\
  !*** ./dropdown/index.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _base = __webpack_require__(/*! ../base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _data = __webpack_require__(/*! ../data */ 9);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _comboBoxField = __webpack_require__(/*! ./combo-box-field.directive */ 12);
	
	var _comboBoxField2 = _interopRequireDefault(_comboBoxField);
	
	var _dropdownKeyHandler = __webpack_require__(/*! ./dropdown-key-handler.provider */ 13);
	
	var _dropdownKeyHandler2 = _interopRequireDefault(_dropdownKeyHandler);
	
	var _dropdownUtil = __webpack_require__(/*! ./dropdown-util.provider */ 14);
	
	var _dropdownUtil2 = _interopRequireDefault(_dropdownUtil);
	
	var _multiSelectField = __webpack_require__(/*! ./multi-select-field.directive */ 15);
	
	var _multiSelectField2 = _interopRequireDefault(_multiSelectField);
	
	var _selectField = __webpack_require__(/*! ./select-field.directive */ 16);
	
	var _selectField2 = _interopRequireDefault(_selectField);
	
	var _selectField3 = __webpack_require__(/*! ./select-field.provider */ 17);
	
	var _selectField4 = _interopRequireDefault(_selectField3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.dropdown', [_base2.default, _data2.default]);
	
	ngModule.directive('fisComboBoxField', _comboBoxField2.default);
	ngModule.provider('fisDropdownKeyHandlerService', _dropdownKeyHandler2.default);
	ngModule.provider('fisDropdownUtilService', _dropdownUtil2.default);
	ngModule.directive('fisMultiSelectField', _multiSelectField2.default);
	ngModule.directive('fisSelectField', _selectField2.default);
	ngModule.provider('fisSelectFieldService', _selectField4.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 9 */
/*!***********************!*\
  !*** ./data/index.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _base = __webpack_require__(/*! ../base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _kendoDsFactory = __webpack_require__(/*! ./kendo-ds-factory.provider */ 10);
	
	var _kendoDsFactory2 = _interopRequireDefault(_kendoDsFactory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.data', [_base2.default]);
	
	ngModule.provider('fisKendoDataSourceFactory', _kendoDsFactory2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 10 */
/*!*******************************************!*\
  !*** ./data/kendo-ds-factory.provider.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var self = this;
	
	  self.$get = ['$parse', '$rootScope', function ($parse, $rootScope) {
	    var dataSourceFactory = {};
	
	    /*
	     * Translates kendo's options object to the expected fetchFn params (maps to request parameters for remote calls)
	     */
	    function translateOptions(options, expect) {
	      var params = {};
	      var val;
	
	      angular.forEach(expect, function (mapTo, param) {
	        if (angular.isString(mapTo)) {
	          val = $parse(mapTo)(options.data);
	        } else if (angular.isNumber(mapTo)) {
	          val = $parse(mapTo.toString())(options.data);
	        } else if (angular.isFunction(mapTo)) {
	          val = mapTo(options.data, params);
	        }
	
	        if (val !== undefined && val !== null) {
	          params[param] = stringify(val);
	        }
	      });
	      return params;
	    }
	
	    function stringify(val) {
	      if (val instanceof Date) {
	        // angular recognizes an ISO string as a date
	        return val.toISOString();
	      }
	      return val;
	    }
	
	    /**
	     * Creates a kendo DataSource that is meant for retrieving a collection of data items
	     * @param {Object} fetchFn Function that returns a promise on an object of containing a data and a total property.
	     * @param {Object} expect Object containing mappings that allow translating kendo options to fetchFn expected options
	     */
	    dataSourceFactory.createListDataSource = function (fetchFn, expect, opts, additionalOpts) {
	      return new kendo.data.DataSource(angular.extend({
	        transport: {
	          read: function read(options) {
	            options.data.additionalOpts = additionalOpts;
	
	            // do not invoke translateOptions if params are ready to use
	            var params = {};
	            if (additionalOpts && additionalOpts.paramsReady) {
	              params = additionalOpts.resolvedParams;
	              additionalOpts.paramsReady = false;
	            } else {
	              params = translateOptions(options, expect);
	            }
	
	            var promise = fetchFn(params);
	            promise.then(function (data) {
	              if (data.total === undefined) {
	                data.total = data.data.length;
	              }
	              if (additionalOpts && additionalOpts.successCb) {
	                additionalOpts.successCb(data);
	              }
	
	              // $timeout(function(){
	              options.success(data);
	              // }, 0);
	            }, function (data) {
	              if (additionalOpts && additionalOpts.errorCb) {
	                additionalOpts.errorCb({ data: data.data, status: data.status, errorType: 'fisData' });
	              }
	              options.error(data);
	            });
	            // don't execute $apply if we are already in angular's lifecycle
	            // sometimes, like in the grid, kendo calls datasource.read synchronously when the grid is initialized so we are in the lifecycle.
	            // other times, like in the autocomplete, datasource.read is always called asynchronously
	            // Another solution could be to invoke apply in a 0 milliseconds timeout so that it is always invoked from outside the lifecycle.
	            if (!$rootScope.$$phase) {
	              $rootScope.$apply();
	            }
	          }
	        },
	        requestStart: function requestStart(e) {
	          if (additionalOpts && additionalOpts.requestStart) {
	            additionalOpts.requestStart(e);
	          }
	        },
	        schema: {
	          data: 'data',
	          total: 'total'
	        },
	        getAdditionalOptions: function getAdditionalOptions() {
	          return additionalOpts;
	        },
	        setAdditionalOptions: function setAdditionalOptions(addOpts) {
	          additionalOpts = addOpts;
	        }
	      }, opts || {}));
	    };
	
	    dataSourceFactory.createHierarchicalDataSource = function (fetchFn, expect, opts, attrs) {
	      var lazyLoading = isLazyLoading(attrs);
	      var hasChildren = hasChildrenAttr(attrs);
	
	      var schemaObj;
	
	      if (lazyLoading) {
	        schemaObj = {
	          data: 'data',
	          total: 'total',
	          model: {
	            id: 'id',
	            hasChildren: hasChildren,
	            fields: {
	              checked: {
	                from: 'checked',
	                type: 'boolean'
	              }
	            }
	          }
	        };
	      } else {
	        schemaObj = {
	          data: 'data',
	          total: 'total',
	          model: {
	            hasChildren: function hasChildren(item) {
	              return item.items && item.items.length > 0;
	            },
	            fields: {
	              checked: {
	                from: 'checked',
	                type: 'boolean'
	              }
	            },
	            children: 'items'
	          }
	        };
	      }
	
	      return new kendo.data.HierarchicalDataSource(angular.extend({
	        transport: {
	          read: function read(options) {
	            var promise = fetchFn(translateOptions(options, expect));
	            promise.then(function (data) {
	              if (data.total === undefined) {
	                data.total = data.data.length;
	              }
	              options.success(data);
	            });
	            // don't execute $apply if we are already in angular's lifecycle
	            // sometimes, like in the grid, kendo calls datasource.read synchronously when the grid is initialized so we are in the lifecycle.
	            // other times, like in the autocomplete, datasource.read is always called asynchronously
	            // Another solution could be to invoke apply in a 0 milliseconds timeout so that it is always invoked from outside the lifecycle.
	            if (!$rootScope.$$phase) {
	              $rootScope.$apply();
	            }
	          }
	        },
	
	        schema: schemaObj
	
	      }, opts || {}));
	    };
	
	    function isLazyLoading(attrs) {
	      var lazyLoading = false;
	      if (!_.isUndefined(attrs.fisLazyLoading)) {
	        if (attrs.fisLazyLoading === 'true') {
	          lazyLoading = true;
	        }
	      }
	      return lazyLoading;
	    }
	
	    function hasChildrenAttr(attrs) {
	      var hasChildren = 'hasItems';
	      if (!_.isUndefined(attrs.fisHasChildren)) {
	        if (attrs.fisHasChildren.length > 0) {
	          hasChildren = attrs.fisHasChildren;
	        }
	      }
	      return hasChildren;
	    }
	
	    return dataSourceFactory;
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 11 */
/*!********************!*\
  !*** external "_" ***!
  \********************/
/***/ (function(module, exports) {

	module.exports = _;

/***/ }),
/* 12 */
/*!***********************************************!*\
  !*** ./dropdown/combo-box-field.directive.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisKendoDataSourceFactory", "$parse", "$timeout", "fisFieldDirectiveFactory", "fisUniqueIdService", "fisElementUtils", "fisDropdownUtilService", "fisMemoryUtilService", function (fisKendoDataSourceFactory, $parse, $timeout, fisFieldDirectiveFactory, fisUniqueIdService, fisElementUtils, fisDropdownUtilService, fisMemoryUtilService) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	    // eslint-disable-next-line no-multi-str
	    editTemplate: '<span data-placeholder="<%- field.attrs.placeholderInput %>">\
	                    <input class="<% if(field.attrs.fisSize) {%>input-<%=field.attrs.fisSize%><% } else {%>input-large<% }%>" fis-input="input" ng-transclude />\
	                    <span class="add-on"><%- field.attrs.fisSuffix %></span>\
	                </span>',
	    transclude: true,
	
	    require: ['?fisData', '?fisReinit'],
	
	    link: function link(scope, element, attrs, ctrls) {
	      var isRendered = false;
	      var isDropDownListUpdated = false;
	      var dropdownlist;
	      var kendoDropDownList;
	      var dataTextFieldVal = 'label';
	      var dataValueField = 'value';
	      var fisData = ctrls[0];
	      var fisReinit = ctrls[1];
	      var isResetPrevData = true;
	      var prevData = [];
	      var prevDataFieldValue = '';
	      var valueAsObj = false;
	      var isNgModelInitialized = false;
	
	      element.find('.controls').addClass('dropdown');
	
	      dropdownlist = element.find('input');
	      dropdownlist.find('span').remove('.ng-scope');
	
	      var options = {};
	      options.attrs = attrs;
	      options.dropdownlist = dropdownlist;
	      options.dataSourceFactory = fisKendoDataSourceFactory;
	      options.scope = scope;
	      options.isRendered = isRendered;
	      options.kendoDropDownList = kendoDropDownList;
	      options.valueAsObj = valueAsObj;
	      options.fisData = fisData;
	      options.isDropDownListUpdated = isDropDownListUpdated;
	      options.isResetPrevData = isResetPrevData;
	      options.prevData = prevData;
	      options.prevDataFieldValue = prevDataFieldValue;
	      options.dataTextField = dataTextFieldVal;
	      options.dataValueField = dataValueField;
	      options.kendoListType = 'kendoComboBox';
	      options.element = element;
	      options.isNgModelInitialized = isNgModelInitialized;
	      options.isModelInitialized = false;
	
	      // adding callback functionality that fires after load
	      if (!_.isUndefined(scope.callback)) {
	        options.callback = scope.callback;
	      }
	
	      scope.$evalAsync(function () {
	        if (fisData) {
	          options.fisDataData = fisData.fetchData;
	        }
	        fisDropdownUtilService.initSelectField(options);
	      });
	
	      if (fisReinit) {
	        fisReinit.trigger = function () {
	          var reinitTimeout = $timeout(function () {
	            var isInvalid = false;
	            if (options.kendoDropDownList.text() !== '') {
	              isInvalid = options.handleInvalidValue(options.kendoDropDownList.text(), true);
	            }
	            if (!isInvalid) {
	              fisDropdownUtilService.reInitializeData(options);
	            }
	          }, 0);
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, reinitTimeout, $timeout);
	        };
	      }
	
	      var params = {};
	      params = fisElementUtils.copyProperties(attrs, 'fisParam', params);
	      _.each(params, function (val, key) {
	        var capitalKey = key.charAt(0).toUpperCase() + key.slice(1);
	        var attrToObserve = 'fisParam' + capitalKey;
	        attrs.$observe(attrToObserve, function () {
	          fisDropdownUtilService.reInitializeData(options);
	        });
	      });
	
	      // add a watch on fisData when it does not contain a ':' character (meaning when it is not parameterized)
	      // If fis-data contains a ':', it cannot be watched on since angular does not allow special character in watch experssion
	      // For such cases, we should instead observe the fis-param attribute. And fire reInitializeData on change of that.
	      if (attrs.fisData && attrs.fisData.indexOf(':') < 0) {
	        try {
	          var fisDataWatch = scope.$watch(attrs.fisData, function (newValue, oldValue) {
	            if (!_.isNaN(newValue) && newValue !== oldValue && newValue !== undefined) {
	              if (options.isRendered === true) {
	                fisDropdownUtilService.reInitializeData(options);
	              }
	            }
	          });
	          fisMemoryUtilService.cancelWatchOnDestroy(scope, fisDataWatch);
	        } catch (e) {
	          console.warn('Cannot watch on fis-data expression ', attrs.fisData);
	        }
	      }
	
	      var editWatch = scope.$watch('fisEditMode', function () /* formEditMode*/{
	        // when the field is invisible for the first time, eg. if ng-show is used, then initialize the
	        // ngModel when field is visible.
	        var ngModel = dropdownlist.controller('ngModel');
	        options.ngModel = ngModel;
	        if (!ngModel.$viewValue && isRendered === true && !options.isModelInitialized) {
	          fisDropdownUtilService.initializeModel(options, false); // Initialize model to handle new item creation
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, editWatch);
	
	      attrs.$observe('placeholderInput', function (newVal) {
	        if (!_.isUndefined(newVal)) {
	          fisDropdownUtilService.updatePlaceholder(options, newVal);
	        }
	      });
	
	      var matchFound;
	      options.handleInvalidValue = function (val, isTextFieldValue) {
	        var isInvalid = false;
	
	        // handle grouped data where grouping has been performed on more than 1 field
	        // this needs to be done since in case of grouping on multiple fields, dataTextField and dataValueField have to be specified as 'valu',
	        // since that is how Kendo creates the data. Hence it needs separate processing to ascertain if the selected value is valid or not.
	        if (options.attrs.fisGroup && options.kendoDropDownList.dataSource.group() && options.kendoDropDownList.dataSource.group().length > 1) {
	          var groupedData = options.kendoDropDownList.dataSource.view();
	          var groupField = options.kendoDropDownList.dataSource.group()[options.kendoDropDownList.dataSource.group().length - 1].field;
	
	          matchFound = false;
	          matchFound = iterateGroupedData(groupedData, groupField, val);
	          if (!matchFound) {
	            isInvalid = true;
	            options.ngModel.$setViewValue(null);
	          }
	        } else {
	          var items = options.kendoDropDownList.dataSource.data();
	          if (items && items.length > 0) {
	            var valueField;
	            if (isTextFieldValue) {
	              valueField = options.kendoDropDownList.options.dataTextField;
	            } else {
	              valueField = options.kendoDropDownList.options.dataValueField;
	            }
	            var foundVal = _.find(items, function (value) {
	              if (_.isEqual(value[valueField], val)) {
	                return value;
	              }
	            });
	            if (_.isUndefined(foundVal)) {
	              isInvalid = true;
	              if (!_.isEmpty(val) || val) {
	                options.kendoDropDownList.dataSource.filter({});
	                options.kendoDropDownList.value(null);
	              }
	              options.ngModel.$setViewValue(null);
	            } else {
	              if (_.isEqual(foundVal[valueField], val) && val === '') {
	                // eslint-disable-line no-lonely-if
	                isInvalid = true;
	                options.ngModel.$setViewValue(null);
	              }
	            }
	          }
	        }
	
	        return isInvalid;
	      };
	
	      function iterateGroupedData(groupedData, groupField, valueToMatch) {
	        if (!matchFound) {
	          for (var i = 0; i < groupedData.length; i++) {
	            var group = groupedData[i];
	            if (group.field === groupField && group.value === valueToMatch) {
	              matchFound = true;
	            } else {
	              if (group.hasSubgroups && !matchFound) {
	                // eslint-disable-line no-lonely-if
	                iterateGroupedData(group.items, groupField, valueToMatch);
	              }
	            }
	          }
	        }
	        return matchFound;
	      }
	
	      options.element.on('focusout', function () {
	        var _focusoutHandler = function _focusoutHandler() {
	          options.handleInvalidValue(options.kendoDropDownList.text(), true);
	          if (options.kendoDropDownList && options.kendoDropDownList.dataSource.view().length === 0) {
	            options.kendoDropDownList.dataSource.filter({});
	          }
	        };
	        if (scope.$$phase === '$apply' || scope.$$phase === '$digest') {
	          _focusoutHandler();
	        } else {
	          scope.$apply(_focusoutHandler());
	        }
	      });
	
	      options.updateKendoDropDownListValue = function (val) {
	        if (options.isRendered && options.kendoDropDownList !== undefined && !options.isDropDownListUpdated && options.attrs.fisServerFiltering !== 'true' && !options.attrs.fisGroup) {
	          if (angular.isObject(val) && attrs.fisUpdateObject === 'true') {
	            options.kendoDropDownList.value(val[options.kendoDropDownList.options.dataValueField]);
	          } else {
	            options.kendoDropDownList.value(val);
	          }
	
	          // The following 'keydown' handler will only be called when user will try to change the value of combobox option field using arrow-keys
	          element.on('keydown', function () {
	            var optionsElem = isOptionsListVisible();
	            // If the Select field's Options list is not visible only then call the model change function on keydown event
	            if (!_.isUndefined(optionsElem) && optionsElem === false) {
	              fisDropdownUtilService.changeModelValueForSelectField(options);
	            }
	          });
	        } else {
	          options.isDropDownListUpdated = false;
	        }
	        fisDropdownUtilService.addTooltipToSelectedOptions(options);
	      };
	
	      // This function is used to check whether the Combo Box field's Option list is currently visible on the screen
	      function isOptionsListVisible() {
	        var optsList = $('.k-animation-container');
	
	        if (optsList.is(':visible')) {
	          return true;
	        }
	        return false;
	      }
	
	      var inputWatch = scope.$watch(attrs.ngModelInput, function (val) {
	        if (!_.isUndefined(val)) {
	          options.updateKendoDropDownListValue(val);
	        }
	      }, true);
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, inputWatch);
	
	      var disabledWatch = scope.$watch('fisDisabled', function (disabled) {
	        if (options.isRendered && options.kendoDropDownList) {
	          options.kendoDropDownList.enable(!disabled);
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, disabledWatch);
	
	      /**
	       * @name fieldValue
	       * @methodOf fisComboBoxField
	       * @description
	       * <p>Returns the current value of the select in viewing mode. </p>
	       */
	      scope.fieldValue = function () {
	        if (options.kendoDropDownList !== undefined && options.kendoDropDownList.text() !== undefined) {
	          return options.kendoDropDownList.text();
	        } else {
	          // eslint-disable-line no-else-return
	          return '';
	        }
	      };
	
	      /**
	       * @name resizeDropDown
	       * @methodOf fisComboBoxField
	       * @description
	       * <p>Resizes the width of the drop down list to match the combo box </p>
	       */
	      scope.resize = function (width) {
	        var kendoDropDownList = options.kendoDropDownList;
	        options.element.find('.k-dropdown-wrap').css('width', width);
	        kendoDropDownList.element.css('width', width);
	
	        // var comboWidth = options.kendoDropDownList.element.width();
	        // eslint-disable-next-line radix, no-unused-vars
	        var diff = parseInt(options.element.find('.k-dropdown-wrap').css('padding-left')) + parseInt(options.element.find('.k-dropdown-wrap').css('padding-right')); // accounts difference in padding
	        kendoDropDownList.list.css('min-width', '');
	        kendoDropDownList.list.css('width', 'auto');
	      };
	    }
	  });
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 13 */
/*!***************************************************!*\
  !*** ./dropdown/dropdown-key-handler.provider.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var self = this;
	  var _mods = { 16: false, 18: false, 17: false, 91: false };
	  var _modifierMap = {
	    16: 'shiftKey',
	    18: 'altKey',
	    17: 'ctrlKey',
	    91: 'metaKey'
	  };
	  var _keyNotAllowed = {
	    3: ['cancel'],
	    9: ['tab'],
	    12: ['clear'],
	    13: ['enter'],
	    16: ['shift'],
	    17: ['ctrl'],
	    18: ['alt', 'menu'],
	    19: ['pause', 'break'],
	    20: ['capslock'],
	    27: ['escape', 'esc'],
	    33: ['pageup'],
	    34: ['pagedown'],
	    35: ['end'],
	    36: ['home'],
	    41: ['select'],
	    42: ['printscreen'],
	    43: ['execute'],
	    44: ['snapshot'],
	    45: ['insert', 'ins'],
	    46: ['delete', 'del'],
	    47: ['help'],
	    91: ['command', 'windows', 'meta'],
	    92: ['command', 'windows', 'meta'],
	    93: ['command', 'windows', 'meta'],
	    144: ['numlock', 'num'],
	    145: ['scrolllock', 'scroll'],
	    112: ['f1'],
	    113: ['f2'],
	    114: ['f3'],
	    115: ['f4'],
	    116: ['f5'],
	    117: ['f6'],
	    118: ['f7'],
	    119: ['f8'],
	    120: ['f9'],
	    121: ['f10'],
	    122: ['f11'],
	    123: ['f12']
	  };
	
	  self.$get = [function () {
	    var service = {}; // to be returned
	    var isFistItemInList = false;
	    service.isModifierKeyPressed = function () {
	      var isModifierKeyPressed = false;
	      _.each(_mods, function (value) {
	        if (value) {
	          isModifierKeyPressed = true;
	        }
	      });
	      return isModifierKeyPressed;
	    };
	
	    service.processKey = function (keycode) {
	      var command;
	      var isKeyAllowed = false;
	      if (keycode === 39 || keycode === 40) {
	        command = 'open'; // down and right key
	        if (keycode === 40 && isFistItemInList) {
	          isFistItemInList = false;
	        }
	      } else if (keycode === 37 || keycode === 38) {
	        command = 'close'; // up and left key
	      } else if (!_.isUndefined(_modifierMap[keycode])) {
	        if (_mods[keycode]) {
	          _mods[keycode] = false;
	        } else {
	          _mods[keycode] = true;
	        }
	      } else if (_.isUndefined(_keyNotAllowed[keycode]) && !service.isModifierKeyPressed()) {
	        isKeyAllowed = true;
	      }
	      return { command: command, isKeyAllowed: isKeyAllowed };
	    };
	
	    service.isDropdownOpened = function (dropdownlist) {
	      if (dropdownlist.popup.visible()) {
	        return true;
	      }
	      return false;
	    };
	
	    service.isDropdownToClose = function (dropdownlist, keycode) {
	      if (keycode === 37) {
	        return true;
	      } else {
	        // eslint-disable-line no-else-return
	        if (!isFistItemInList) {
	          // eslint-disable-line no-lonely-if, no-negated-condition
	          if (dropdownlist.dataSource && dropdownlist.dataSource.indexOf(dropdownlist.dataItem(dropdownlist.current())) === 0) {
	            isFistItemInList = true;
	            return false;
	          }
	        } else {
	          isFistItemInList = false;
	          return true;
	        }
	      }
	    };
	    return service;
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 14 */
/*!********************************************!*\
  !*** ./dropdown/dropdown-util.provider.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var self = this;
	  var filtersObj = {};
	
	  self.$get = ['$parse', '$timeout', '$q', 'fisUniqueIdService', 'fisMemoryUtilService', 'fisDropdownKeyHandlerService', function ($parse, $timeout, $q, fisUniqueIdService, fisMemoryUtilService, fisDropdownKeyHandlerService) {
	    var service = {}; // to be returned
	
	    var evaluatedPlaceholder = function evaluatedPlaceholder(elem) {
	      var ret;
	      var placeHolder = elem.find('[data-placeholder]').data('placeholder');
	      if (placeHolder !== '\'\'') {
	        // eslint-disable-line no-negated-condition
	        ret = placeHolder;
	      } else {
	        ret = ' ';
	      }
	      return ret;
	    };
	
	    function evaluatePlaceholder(options) {
	      if (options.attrs.placeholderInput) {
	        var isEval = options.attrs.placeholderInput.toLowerCase().indexOf('i18n') >= 0; // check if it must be $eval
	        if (isEval) {
	          options.fisPlaceholder = options.scope.$eval(options.attrs.placeholderInput.replace('{{', '').replace('}}', '')) || '';
	        } else {
	          options.fisPlaceholder = options.attrs.placeholderInput || '';
	        }
	      }
	    }
	
	    function addSgIdsToItems(options) {
	      $timeout(function () {
	        // Add fisIDs to list-items
	        if (!_.isUndefined(options.kendoDropDownList) && !_.isUndefined(options.kendoDropDownList.list)) {
	          var parentSdId = options.kendoDropDownList.element.attr('fisid');
	          var dropdownItems = options.kendoDropDownList.list.find('li');
	          for (var i = 0; i < dropdownItems.length; i++) {
	            dropdownItems.eq(i).attr('fisid', parentSdId + '_entry_' + i);
	          }
	        }
	      });
	    }
	
	    service.initSelectField = function (options) {
	      options.ngModel = options.dropdownlist.controller('ngModel');
	      var dataSource;
	      // evaluate placeholder for multiselect field here.....
	      evaluatePlaceholder(options);
	
	      if (options.attrs.fisData && options.attrs.fisOptions) {
	        createSgDataAndOptionsDS(options);
	      } else if (options.attrs.fisData && !options.attrs.fisOptions) {
	        dataSource = createSgData(options);
	        callCreateKendoList(dataSource, options);
	      } else if (options.attrs.fisOptions && !options.attrs.fisData) {
	        dataSource = createSgOptionsData(options);
	        callCreateKendoList(dataSource, options);
	      } else {
	        // Static options used for dropdown list
	        dataSource = new kendo.data.DataSource({ data: options.element.find('option') });
	        callCreateKendoList(dataSource, options);
	
	        // This code is required to remove the unknownOption added by angular while rendering the Multiselect/Select/Combobox fields( with static options)
	        var dataSourceVal = options.kendoDropDownList.dataSource.data();
	        if (dataSourceVal.length > 0 && dataSourceVal[0].value.indexOf('?') === 0 && dataSourceVal[0].value.lastIndexOf('?') > 0 && dataSourceVal[0].text === '') {
	          var dataItem = dataSourceVal[0];
	          options.kendoDropDownList.dataSource.remove(dataItem);
	        }
	      }
	
	      var globalWatch = options.scope.$watch(function () {
	        if ($(options.element).is(':visible') && !options.isNgModelInitialized) {
	          if (!options.ngModel.$modelValue && !options.attrs.placeholderInput) {
	            service.initializeModel(options, false);
	          } else {
	            if (options.kendoDropDownList && !_.isEqual(options.kendoDropDownList.value(), options.ngModel.$modelValue)) {
	              // eslint-disable-line no-lonely-if
	              if (!_.isUndefined(options.ngModel.$modelValue)) {
	                // eslint-disable-line no-negated-condition
	                if (angular.isArray(options.ngModel.$modelValue) && options.attrs.fisUpdateObject === 'true') {
	                  var arr = options.ngModel.$modelValue;
	                  var arrToSet = [];
	                  for (var j = 0; j < arr.length; j++) {
	                    arrToSet.push(arr[j][options.kendoDropDownList.options.dataValueField]);
	                  }
	                  options.kendoDropDownList.value(arrToSet);
	                } else if (angular.isObject(options.ngModel.$modelValue) && options.attrs.fisUpdateObject === 'true') {
	                  options.kendoDropDownList.value(options.ngModel.$modelValue[options.kendoDropDownList.options.dataValueField]);
	                } else {
	                  options.kendoDropDownList.value(options.ngModel.$modelValue);
	                }
	              } else {
	                if (options.kendoListType === 'kendoMultiSelect') {
	                  // eslint-disable-line no-lonely-if
	                  options.kendoDropDownList.value([]);
	                } else {
	                  options.kendoDropDownList.value(null);
	                }
	              }
	              options.isNgModelInitialized = true;
	            }
	          }
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(options.scope, globalWatch);
	    };
	
	    service.updatePlaceholder = function (options, placeholder) {
	      if (placeholder === '\'\'') {
	        placeholder = ' ';
	      }
	      if (options.kendoDropDownList) {
	        // Kendo Widget has been initiliazed
	        if (options.kendoListType === 'kendoDropDownList') {
	          options.kendoDropDownList.options.optionLabel = placeholder;
	          // options.kendoDropDownList.refresh();
	          if (!_.isUndefined(options.fisPlaceholder)) {
	            options.fisPlaceholder = placeholder;
	          }
	        } else if (options.kendoListType === 'kendoMultiSelect') {
	          options.element.find('input[role="listbox"]').val(placeholder);
	          // Changing the placeholder property of the widget options object
	          // does not update the DOM placeholder for some reason. For consistency
	          // change it nevertheless
	          options.kendoDropDownList.options.placeholder = placeholder;
	          // options.kendoDropDownList.refresh();
	        } else if (options.kendoListType === 'kendoComboBox') {
	          options.element.find('input').attr('placeholder', placeholder);
	          options.kendoDropDownList.options.placeholder = placeholder;
	        }
	      }
	    };
	
	    function createSgDataAndOptionsDS(options) {
	      var deferred = $q.defer();
	      var result; // eslint-disable-line no-unused-vars
	      var ds;
	
	      // for server side filtering
	      var dataSourceOptions = {};
	      dataSourceOptions.serverFiltering = options.attrs.fisServerFiltering === 'true';
	      var parameters = {};
	      if (dataSourceOptions.serverFiltering) {
	        options.isDropDownListUpdated = true;
	        parameters.q = 'filter.filters[0].value';
	        parameters.operator = 'filter.filters[0].operator';
	      }
	
	      dataSourceOptions.group = processGroupAndSort(options).group;
	      dataSourceOptions.sort = processGroupAndSort(options).sort;
	
	      ds = createKendoDataSource(options.fisDataData, parameters, dataSourceOptions, options);
	      ds.fetch().then(function () {
	        if (options.ngModel && !options.isRendered) {
	          callCreateKendoList(ds, options);
	        }
	        if (options.ngModel.$modelValue && options.updateKendoDropDownListValue && !options.isDropDownListUpdated) {
	          var modelValue = options.ngModel.$modelValue;
	          if (options.kendoListType === 'kendoMultiSelect') {
	            modelValue = [];
	            if (!angular.isArray(options.ngModel.$modelValue)) {
	              // eslint-disable-line no-negated-condition
	              angular.forEach(options.ngModel.$modelValue, function (value) {
	                modelValue.push(value);
	              });
	            } else {
	              modelValue = options.ngModel.$modelValue;
	            }
	          }
	          options.updateKendoDropDownListValue(modelValue);
	        }
	      });
	      deferred.resolve(ds);
	      return deferred.promise;
	    }
	
	    function createKendoDataSource(fetchFn, expect, opts, options) {
	      var ds = new kendo.data.DataSource(angular.extend({
	        transport: {
	          read: function read(readOptions) {
	            var params = translateOptions(readOptions, expect);
	
	            if (options.attrs.fisServerFiltering === 'true' && options.ngModel.$viewValue && !options.kendoDropDownList) {
	              parseAndNormalizeSgOptions(options, []);
	              if (angular.isArray(options.ngModel.$modelValue) && options.attrs.fisUpdateObject === 'true') {
	                var arr = options.ngModel.$modelValue;
	                var arrToSet = [];
	                for (var j = 0; j < arr.length; j++) {
	                  arrToSet.push(arr[j][options.dataValueField]);
	                }
	                params.q = arrToSet.join();
	              } else if (angular.isObject(options.ngModel.$modelValue) && options.attrs.fisUpdateObject === 'true') {
	                params.q = options.ngModel.$modelValue[options.dataValueField];
	              } else {
	                params.q = options.ngModel.$modelValue;
	                if (angular.isArray(params.q)) {
	                  params.q = params.q.join();
	                }
	              }
	            }
	
	            fetchFn(params).then(function (result) {
	              var collection = parseCollection(result, options);
	              var normalizedData = parseAndNormalizeSgOptions(options, collection);
	              result.data = normalizedData;
	              readOptions.success(result);
	            }, function (data) {
	              readOptions.error(data);
	            });
	          }
	        },
	        requestStart: function requestStart(e) {
	          var readArgs = e.sender.read.arguments;
	          if (!readArgs && options.attrs.fisServerFiltering === 'true') {
	            e.preventDefault();
	          }
	        },
	        schema: {
	          data: 'data',
	          total: 'total'
	        }
	      }, opts || {}));
	
	      return ds;
	    }
	
	    function parseCollection(result, options) {
	      var res = {};
	      var collection;
	      var callback = function callback(key, val) {
	        if (val.toString().indexOf('data') !== 0) {
	          res[val] = key;
	        }
	      };
	
	      // if (result && Object.keys(result).length !== 1 && result.data && result.data.length === 1) {
	      if (result && result.data && result.data.length === 1 && !result.obj) {
	        // Note: The below check has been made because minification converts the constructor name to a minified name
	        // which is not equal to 'Resource'. Hence the below condition fails in appStage=P
	        // if(result.data[0].constructor.name === 'Resource') {
	        // Since any instance of Resource is bound to have '$get' property attached to it, we have made the check for it.
	        if (result.data[0].$get || !_.isUndefined(options.attrs.fisSchemaData) && options.attrs.fisSchemaData !== 'none') {
	          res = [];
	          res.push(result.data[0]);
	          collection = res;
	        } else {
	          collection = result.data[0];
	        }
	      } else if (result && result.data && result.data.length === 0 && (_.isUndefined(options.attrs.fisSchemaData) || options.attrs.fisSchemaData === 'none')) {
	        _.each(result, callback);
	        collection = res;
	      } else if (result && result.data && result.data.length > 0) {
	        for (var i = 0; i < result.data.length; i++) {
	          var propLength = Object.keys(result.data[i]).length;
	          if (propLength === 1) {
	            _.each(result.data[i], callback);
	          } else if (propLength > 1) {
	            res = result.data;
	          }
	        }
	        collection = res;
	      } else if (result && result.obj) {
	        res = [];
	        res.push(result.obj);
	        collection = res;
	      } else {
	        collection = [];
	      }
	      return collection;
	    }
	
	    /*
	     * Translates kendo's options object to the expected fetchFn params (maps to request parameters for remote calls)
	     */
	    function translateOptions(options, expect) {
	      var params = {};
	      var val;
	      angular.forEach(expect, function (mapTo, param) {
	        if (angular.isString(mapTo)) {
	          val = $parse(mapTo)(options.data);
	        } else if (angular.isNumber(mapTo)) {
	          val = $parse(mapTo.toString())(options.data);
	        } else if (angular.isFunction(mapTo)) {
	          val = mapTo(options.data, params);
	        }
	
	        if (val !== undefined && val !== null) {
	          params[param] = stringify(val);
	        }
	      });
	      return params;
	    }
	
	    function stringify(val) {
	      if (val instanceof Date) {
	        // angular recognizes an ISO string as a date
	        return val.toISOString();
	      }
	      return val;
	    }
	
	    function createSgData(options) {
	      var dataSourceOptions = {};
	      var parameters = {};
	      var requestStart;
	      var additionalOpts = {};
	
	      dataSourceOptions.serverFiltering = options.attrs.fisServerFiltering === 'true';
	      if (dataSourceOptions.serverFiltering) {
	        options.isDropDownListUpdated = true;
	        parameters.q = 'filter.filters[0].value';
	        parameters.operator = 'filter.filters[0].operator';
	
	        requestStart = function requestStart(e) {
	          var readArgs = e.sender.read.arguments;
	          if (!readArgs) {
	            e.preventDefault();
	          }
	        };
	
	        additionalOpts.requestStart = requestStart;
	
	        var resolvedParams = {};
	
	        if (options.ngModel.$viewValue && !options.kendoDropDownList) {
	          if (angular.isArray(options.ngModel.$modelValue) && options.attrs.fisUpdateObject === 'true') {
	            var arr = options.ngModel.$modelValue;
	            var arrToSet = [];
	            for (var j = 0; j < arr.length; j++) {
	              arrToSet.push(arr[j][options.dataValueField]);
	            }
	            resolvedParams.q = arrToSet.join();
	          } else if (angular.isObject(options.ngModel.$modelValue) && options.attrs.fisUpdateObject === 'true') {
	            resolvedParams.q = options.ngModel.$modelValue[options.dataValueField];
	          } else {
	            resolvedParams.q = options.ngModel.$modelValue;
	            if (angular.isArray(resolvedParams.q)) {
	              resolvedParams.q = resolvedParams.q.join();
	            }
	          }
	          resolvedParams.operator = options.attrs.fisFilter || 'contains';
	          additionalOpts.resolvedParams = resolvedParams;
	          additionalOpts.paramsReady = true;
	        } else {
	          additionalOpts.paramsReady = false;
	        }
	      }
	
	      dataSourceOptions.group = processGroupAndSort(options).group;
	      dataSourceOptions.sort = processGroupAndSort(options).sort;
	
	      return options.dataSourceFactory.createListDataSource(options.fisDataData, parameters, dataSourceOptions, additionalOpts);
	    }
	
	    /**
	     * @name createSgOptionsData
	     * @methodOf fisSelectField
	     * @description
	     * <p>This function creates the data needed to populate an fisOptions dropdown.</p>
	     */
	    function createSgOptionsData(options, col) {
	      var data = parseAndNormalizeSgOptions(options, col);
	      var group = processGroupAndSort(options).group;
	      var sort = processGroupAndSort(options).sort;
	      return new kendo.data.DataSource({ data: data, group: group, sort: sort });
	    }
	
	    function parseAndNormalizeSgOptions(options, col) {
	      // if fisOptions are provided, parse the fisOptions value
	      var SG_OPTIONS_REGEXP_WITH_COLLECTION = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*)$/;
	      var SG_OPTIONS_REGEXP_WITHOUT_COLLECTION = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))/;
	      var match;
	      if (col) {
	        match = options.attrs.fisOptions.match(SG_OPTIONS_REGEXP_WITHOUT_COLLECTION);
	      } else {
	        match = options.attrs.fisOptions.match(SG_OPTIONS_REGEXP_WITH_COLLECTION);
	      }
	      if (!match) {
	        throw new Error('Expected fisOptions in form of \'_select_ (as _label_)? for (_key_,)?_value_ in _collection_\'' + '\' but got \'' + options.attrs.fisOptions + '.');
	      }
	
	      var displayField = match[2] || match[1];
	      var valueName = match[4] || match[6];
	      var keyName = match[5];
	      var valueField = match[2] ? match[1] : valueName;
	      var data = [];
	
	      var collection = col ? col : $parse(match[7])(options.scope) || [];
	
	      if (displayField) {
	        if (displayField.indexOf('.') > -1) {
	          options.dataTextField = displayField.substring(displayField.indexOf('.') + 1);
	        } else {
	          options.dataTextField = displayField;
	        }
	      }
	
	      if (valueField !== 'select') {
	        // eslint-disable-line no-negated-condition
	        if (valueField.indexOf('.') > -1) {
	          options.dataValueField = valueField.substring(valueField.indexOf('.') + 1);
	        } else {
	          options.dataValueField = valueField;
	        }
	      } else {
	        options.dataValueField = valueName;
	      }
	      data = normalizeCollection(options, collection, keyName, valueName);
	      return data;
	    }
	
	    function callCreateKendoList(dataSource, options) {
	      createKendoList(dataSource, options);
	
	      if (options.kendoListType === 'kendoDropDownList') {
	        options.kendoDropDownList = options.dropdownlist.data('kendoDropDownList');
	      } else if (options.kendoListType === 'kendoMultiSelect') {
	        options.kendoDropDownList = options.dropdownlist.data('kendoMultiSelect');
	      } else if (options.kendoListType === 'kendoComboBox') {
	        options.kendoDropDownList = options.dropdownlist.data('kendoComboBox');
	      }
	
	      if (!options.ngModel.$viewValue) {
	        // eslint-disable-line no-negated-condition
	        if (!options.isModelInitialized) {
	          service.initializeModel(options, false);
	        }
	      } else {
	        // setting the value of "isNgModelInitialized=true" in case $viewValue already have some value assigned to it.
	        options.isNgModelInitialized = true;
	      }
	
	      if (options.kendoListType === 'kendoComboBox' || options.kendoListType === 'kendoMultiSelect') {
	        if (options.kendoListType === 'kendoComboBox') {
	          options.kendoDropDownList.input.on('click', function () {
	            if (!fisDropdownKeyHandlerService.isDropdownOpened(options.kendoDropDownList)) {
	              options.kendoDropDownList.open();
	            }
	          });
	          options.kendoDropDownList.bind('open', function () {
	            if (options.kendoDropDownList.dataItem() && options.attrs.fisServerFiltering !== 'true') {
	              options.kendoDropDownList.dataSource.filter({});
	            }
	          });
	        }
	        options.kendoDropDownList.input.on('keyup', function (e) {
	          var keyInfo = fisDropdownKeyHandlerService.processKey(e.keyCode);
	          if (options.attrs.fisColumns && options.kendoListType !== 'kendoMultiSelect') {
	            if (keyInfo.isKeyAllowed) {
	              var columns = $parse(options.attrs.fisColumns)(options.scope);
	              if (columns) {
	                var filters = [];
	                filtersObj = { logic: 'or', filters: filters };
	                for (var i = 0; i < columns.length; i++) {
	                  var col = columns[i];
	                  var field = col.field;
	                  if (col.filterable === 'true' || col.filterable === true) {
	                    filters.push({ field: field, operator: 'contains', value: e.target.value });
	                  }
	                }
	              }
	              options.kendoDropDownList.value(e.target.value);
	              if (e.target.value !== '') {
	                // eslint-disable-line no-negated-condition
	                options.kendoDropDownList.dataSource.filter(filtersObj);
	              } else {
	                options.kendoDropDownList.options.value = '';
	                options.kendoDropDownList.dataSource.filter({});
	              }
	              if (options.kendoDropDownList.dataSource.view().length > 0) {
	                options.kendoDropDownList.open();
	              } else {
	                options.kendoDropDownList.popup.open();
	              }
	            }
	          }
	          if (keyInfo.command) {
	            if (keyInfo.command === 'open') {
	              if (!fisDropdownKeyHandlerService.isDropdownOpened(options.kendoDropDownList)) {
	                options.kendoDropDownList.open();
	              }
	            }
	            if (keyInfo.command === 'close') {
	              if (fisDropdownKeyHandlerService.isDropdownOpened(options.kendoDropDownList) && fisDropdownKeyHandlerService.isDropdownToClose(options.kendoDropDownList, e.keyCode)) {
	                options.kendoDropDownList.close();
	              }
	            }
	          }
	        });
	      }
	      // close dropdowns on escape
	      // set event.stopPropagation so that if the parent container is a modal dialog it does not close when escape is pressed
	      if (options.kendoListType === 'kendoComboBox' || options.kendoListType === 'kendoMultiSelect') {
	        options.kendoDropDownList.input.on('keydown', function (e) {
	          if (options.attrs.fisColumns && options.kendoListType !== 'kendoMultiSelect') {
	            fisDropdownKeyHandlerService.processKey(e.keyCode);
	          }
	          // close on escape
	          if (e.keyCode === 27) {
	            options.kendoDropDownList.popup.close();
	            // [SDHTML-7912]: Need to add preventDefault for IE browser, since the selected value is getting cleared if Esc key is pressed multiple times
	            e.preventDefault();
	            e.stopImmediatePropagation();
	          }
	        });
	      }
	
	      if (options.kendoListType === 'kendoDropDownList') {
	        var clickableElement = angular.element(options.element).find('.k-widget.k-dropdown');
	        clickableElement.on('keydown', function (e) {
	          if (e.keyCode === 27) {
	            options.kendoDropDownList.popup.close();
	            e.stopPropagation();
	          }
	        });
	      }
	
	      if (fis.initParams().appStage === 'T') {
	        // Add fisID to list-container
	        fisUniqueIdService.generateUniqueId(options.scope, options.kendoDropDownList.list, {}, options.attrs.ngModelInput + '_list-container');
	        // Items will get fisID inside the DataBound Callback
	      }
	
	      // initialize the kendo Dropdown list according to the value present in ngModel
	      if (!_.isUndefined(options.ngModel.$modelValue) && !_.isNaN(options.ngModel.$modelValue)) {
	        if (angular.isArray(options.ngModel.$modelValue) && options.attrs.fisUpdateObject === 'true') {
	          var arr = options.ngModel.$modelValue;
	          var arrToSet = [];
	          for (var j = 0; j < arr.length; j++) {
	            arrToSet.push(arr[j][options.kendoDropDownList.options.dataValueField]);
	          }
	          options.kendoDropDownList.value(arrToSet);
	        } else {
	          options.kendoDropDownList.value(options.ngModel.$modelValue);
	        }
	      }
	
	      // for select field
	      /* refreshing is necessary to get rid of Angular added empty option in case of no model.
	       * When the widget is initialized, the model may not be initialized like for
	       * Master-Details scenario and Angular select directive adds an empty option.
	       */
	      /* if(!options.attrs.fisData && !options.attrs.fisOptions){
	          $timeout(function(){
	              options.kendoDropDownList.refresh();
	          },0);
	      }*/
	
	      // for multiselect field
	      /* refreshing is necessary to get rid of Angular added empty option in case of no model.
	       * When the widget is initialized, the model may not be initialized like for
	       * Master-Details scenario and Angular select directive adds an empty option.
	       */
	      /* if (!options.fisPlaceholder) {
	          options.kendoDropDownList.refresh();
	      }*/
	
	      applyStyles(options, true);
	
	      options.isRendered = true;
	
	      // $destroy event, broadcasted when a parent scope is being destroyed
	      options.scope.$on('$destroy', function () {
	        fisMemoryUtilService.destroyKendoWidgets(options.kendoDropDownList);
	        options = {};
	      });
	    }
	
	    service.changeModelValueForSelectField = function (options) {
	      options.isChangedCalled = true;
	      var _changeModelValueForSelectField = function _changeModelValueForSelectField() {
	        var listType = options.kendoListType === 'kendoDropDownList' ? 'kendoDropDownList' : 'kendoComboBox';
	        var list = options.dropdownlist.data(listType);
	        var data = angular.copy(list.dataSource.data());
	
	        if (list.selectedIndex !== -1) {
	          if (options.attrs.fisUpdateObject === 'true') {
	            if (listType === 'kendoDropDownList') {
	              options.ngModel.$setViewValue(data[options.attrs.placeholderInput ? list.selectedIndex - 1 : list.selectedIndex]);
	            } else {
	              options.ngModel.$setViewValue(list.dataItem());
	            }
	          } else {
	            if (list.dataItem() && !_.isUndefined(list.dataItem()[options.dataValueField])) {
	              // eslint-disable-line no-lonely-if
	              options.ngModel.$setViewValue(list.dataItem()[options.dataValueField]);
	            }
	          }
	        }
	
	        service.addTooltipToSelectedOptions(options);
	
	        // options.isDropDownListUpdated = true;
	      };
	      if (options.scope.$$phase === '$apply' || options.scope.$$phase === '$digest') {
	        // $apply or $digest already in progress
	        _changeModelValueForSelectField();
	      } else {
	        options.scope.$apply(_changeModelValueForSelectField);
	      }
	    };
	
	    function changeModelValueForMultiSelect(options) {
	      options.isChangedCalled = true;
	      options.scope.$apply(function () {
	        var list = options.dropdownlist.data('kendoMultiSelect');
	        options.dropdownlist.val(options.dropdownlist.data('kendoMultiSelect').value());
	        var dropdownVal = options.dropdownlist.data('kendoMultiSelect').value();
	        if (!options.attrs.ngChangeInput) {
	          if (dropdownVal.length !== 0) {
	            // eslint-disable-line no-negated-condition
	            if (options.attrs.fisUpdateObject === 'true') {
	              $timeout(function () {
	                options.ngModel.$setViewValue(list.dataItems());
	              }, 0);
	            } else {
	              options.ngModel.$setViewValue(dropdownVal);
	            }
	          } else {
	            // this needs to be in a timeout since the model value changes to empty string otherwise
	            $timeout(function () {
	              options.ngModel.$setViewValue(null);
	            });
	          }
	        }
	        service.addTooltipToSelectedOptions(options);
	        options.isDropDownListUpdated = true;
	      });
	    }
	
	    function createKendoList(dataSource, options) {
	      if (options.kendoListType === 'kendoDropDownList') {
	        options.dropdownlist.kendoDropDownList(getDataSourceOptions(options, dataSource));
	      } else if (options.kendoListType === 'kendoMultiSelect') {
	        options.dropdownlist.kendoMultiSelect(getDataSourceOptions(options, dataSource));
	      } else if (options.kendoListType === 'kendoComboBox') {
	        options.dropdownlist.kendoComboBox(getDataSourceOptions(options, dataSource));
	      }
	    }
	
	    function getDataSourceOptions(options, dataSource) {
	      var changeModelValue;
	      if (options.kendoListType === 'kendoDropDownList') {
	        changeModelValue = service.changeModelValueForSelectField;
	      } else if (options.kendoListType === 'kendoMultiSelect') {
	        changeModelValue = changeModelValueForMultiSelect;
	      } else if (options.kendoListType === 'kendoComboBox') {
	        changeModelValue = service.changeModelValueForSelectField;
	      }
	
	      var dataBound = function dataBound() {
	        /* Add a tooltip displaying the content. Useful when the content is longer than
	         what the field can accomodate*/
	        $(this.items()).each(function (index, item) {
	          if ($(item).length === 1 && $(item).children().length === 0) {
	            var content = $(item).contents()[0]; // eslint-disable-line block-scoped-var
	            if (content) {
	              // eslint-disable-line block-scoped-var
	              $(item).attr('title', content.textContent); // eslint-disable-line block-scoped-var
	            }
	          } else if ($(item).children().length === 1) {
	            var content = $(item).children().contents()[0]; // eslint-disable-line block-scoped-var, no-redeclare
	            if (content) {
	              // eslint-disable-line block-scoped-var
	              $(item).attr('title', content.textContent); // eslint-disable-line block-scoped-var
	            }
	          } else {
	            $(item).children().each(function (childIndex, childItem) {
	              var childContent = $(childItem).contents()[0];
	              if (childContent) {
	                $(childItem).attr('title', childContent.textContent);
	              }
	            });
	          }
	        });
	
	        service.addTooltipToSelectedOptions(options);
	
	        if (fis.initParams().appStage === 'T') {
	          addSgIdsToItems(options);
	        }
	      };
	
	      var columns = options.attrs.fisColumns;
	      columns = $parse(columns)(options.scope);
	      var headerTemp;
	      var template;
	      var valueTemp;
	      var filtersObj; // eslint-disable-line no-unused-vars
	      var filters = [];
	      if (columns) {
	        filtersObj = { logic: 'or', filters: filters };
	        headerTemp = '<div class="dropdown-header">';
	        template = '';
	        valueTemp = '';
	        for (var i = 0; i < columns.length; i++) {
	          var col = columns[i];
	          if (options.kendoListType === 'kendoMultiSelect') {
	            if (col.filterable === true || col.filterable === 'true') {
	              options.dataTextField = col.field;
	            }
	          }
	
	          var field = col.field;
	          var width = col.width ? col.width + '%' : 100 / columns.length + '%';
	          if (columns.length > 1) {
	            headerTemp = headerTemp + '<span class="k-widget k-header" style="width: ' + width + '">' + col.title + '</span>';
	          }
	
	          if (!angular.isUndefined(col.template)) {
	            // eslint-disable-line no-negated-condition
	            template += col.template;
	          } else {
	            template = template + '<span class=' + col.cls + ' style="width: ' + width + '">#= data.' + field + ' || ""#</span>';
	          }
	
	          if (col.display === true || col.display === 'true') {
	            valueTemp = valueTemp + '${data.' + field + '}';
	          }
	
	          filters.push({ field: field, operator: 'contains' });
	        }
	        headerTemp += '</div>';
	      }
	
	      var optionsForComboBoxWithDataSource = {
	        dataSource: dataSource,
	        headerTemplate: headerTemp,
	
	        close: function close() {
	          changeModelValue(options, dataSource);
	        },
	        filter: options.attrs.fisFilter || 'contains',
	        dataTextField: options.dataTextField,
	        dataValueField: options.dataValueField,
	        placeholder: evaluatedPlaceholder(options.element),
	        template: template ? template : '<dd class="fis-select-dd">${ ' + options.dataTextField + ' }</dd>',
	        dataBound: dataBound,
	        autoBind: options.attrs.kAutoBind === 'false' || options.attrs.kAutoBind === false ? false : true, // eslint-disable-line no-unneeded-ternary
	        suggest: options.attrs.fisSelectMode === 'true' || options.attrs.fisSelectMode === true ? true : false // eslint-disable-line no-unneeded-ternary
	      };
	
	      var optionsForComboBoxWithoutDataSource = {
	        close: function close() {
	          changeModelValue(options, dataSource);
	        },
	        dataBound: dataBound
	      };
	
	      var optionsForSelectWithDataSource = {
	        dataSource: dataSource,
	        close: function close() {
	          changeModelValue(options, dataSource);
	        },
	        dataTextField: options.dataTextField,
	        dataValueField: options.dataValueField,
	        optionLabel: evaluatedPlaceholder(options.element),
	        template: template ? template : '<dd class="fis-select-dd">${ ' + options.dataTextField + ' }</dd>',
	        dataBound: dataBound
	      };
	
	      var optionsForSelectWithoutDataSource = {
	        close: function close() {
	          changeModelValue(options, dataSource);
	        },
	        optionLabel: evaluatedPlaceholder(options.element),
	        dataBound: dataBound
	      };
	
	      var optionsForMultiWithDataSource = {
	        headerTemplate: headerTemp,
	        placeholder: evaluatedPlaceholder(options.element),
	        autoClose: options.attrs.fisAutoClose !== 'false',
	        dataSource: dataSource,
	        filter: options.attrs.fisFilter || 'contains',
	        // Called when the value changes, this then sets the value in the Angular model
	        change: function change() {
	          changeModelValue(options, dataSource);
	        },
	        dataTextField: options.dataTextField,
	        dataValueField: options.dataValueField,
	        itemTemplate: template ? template : '<dd class="fis-select-dd">${ ' + options.dataTextField + ' }</dd>',
	        tagTemplate: valueTemp,
	        dataBound: dataBound,
	        autoBind: options.attrs.kAutoBind === 'false' || options.attrs.kAutoBind === false ? false : true // eslint-disable-line no-unneeded-ternary
	      };
	
	      var optionsForMultiWithoutDataSource = {
	        placeholder: options.fisPlaceholder,
	        autoClose: options.attrs.fisAutoClose !== 'false',
	        // Called when the value changes, this then sets the value in the Angular model
	        change: function change() {
	          changeModelValue(options, dataSource);
	        },
	        dataBound: dataBound
	      };
	
	      var ret;
	      if (!dataSource) {
	        // eslint-disable-line no-negated-condition
	        if (options.kendoListType === 'kendoDropDownList') {
	          ret = optionsForSelectWithoutDataSource;
	        } else if (options.kendoListType === 'kendoMultiSelect') {
	          ret = optionsForMultiWithoutDataSource;
	        } else if (options.kendoListType === 'kendoComboBox') {
	          ret = optionsForComboBoxWithoutDataSource;
	        }
	      } else {
	        if (options.kendoListType === 'kendoDropDownList') {
	          // eslint-disable-line no-lonely-if
	          ret = optionsForSelectWithDataSource;
	        } else if (options.kendoListType === 'kendoMultiSelect') {
	          ret = optionsForMultiWithDataSource;
	        } else if (options.kendoListType === 'kendoComboBox') {
	          ret = optionsForComboBoxWithDataSource;
	        }
	      }
	      return ret;
	    }
	
	    function normalizeCollection(options, collection, keyName, valueName) {
	      var keys = keyName ? _.keys(collection) : collection;
	      var data = [];
	      if (angular.isArray(collection)) {
	        for (var i = 0; i < collection.length; i++) {
	          if (!angular.isObject(collection[i])) {
	            var obj1 = {};
	            obj1[options.dataTextField] = collection[i];
	            collection.splice(i, 1, obj1);
	          }
	        }
	        data = collection;
	        if (data[0] && !_.has(data[0], options.dataValueField)) {
	          // This is the case where object is expected as value for the dropdownlist.
	          // Example: fis-options="color.name for color in colorsObj"
	
	          // options.valueAsObj = true;
	
	          options.dataValueField = options.dataTextField;
	        }
	      } else if (angular.isObject(collection)) {
	        var index;
	        var length;
	        for (index = 0; length = keys.length, index < length; index++) {
	          // eslint-disable-line no-sequences
	          var obj2 = {};
	          obj2[valueName] = collection[keyName ? obj2[keyName] = keys[index] : index];
	          data[index] = obj2;
	        }
	      }
	      return data;
	    }
	
	    function applyStyles(options, removePreviousStyle) {
	      var sizeClass = 'fis-selectField-large';
	      if (options.attrs.fisSize !== undefined) {
	        sizeClass = 'fis-selectField-' + options.attrs.fisSize;
	      }
	      if (!options.attrs.fisData && !options.attrs.fisOptions) {
	        // apply same styling as template
	        options.kendoDropDownList.ul.find('li').wrapInner('<dd class="fis-select-dd"></dd>');
	      }
	      if (removePreviousStyle && options.kendoDropDownList.ul) {
	        options.kendoDropDownList.ul[0].removeAttribute('style');
	      }
	
	      options.dropdownlist.addClass(sizeClass);
	
	      var selectWidth = parseFloat(options.dropdownlist.width());
	      if (selectWidth > 0) {
	        if (options.kendoListType !== 'kendoMultiSelect') {
	          options.dropdownlist.closest('.k-widget').width(selectWidth);
	        }
	        options.kendoDropDownList.list.css('white-space', 'nowrap').css('min-width', selectWidth);
	      } else {
	        options.dropdownlist.closest('.k-widget').width('160px');
	        options.kendoDropDownList.list.css('min-width', '160px');
	      }
	
	      if (options.kendoListType === 'kendoDropDownList' || options.kendoListType === 'kendoComboBox') {
	        // Add framework CSS class for combobox and multiselect popups
	        if (options.kendoListType === 'kendoComboBox') {
	          options.kendoDropDownList.list.addClass('fis-combobox-popup');
	        } else {
	          options.kendoDropDownList.list.css('width', 'auto');
	        }
	      } else if (options.kendoListType === 'kendoMultiSelect') {
	        // set size of widget override size
	        options.dropdownlist.closest('.k-widget').addClass(sizeClass);
	        options.dropdownlist.closest('.k-widget').css('min-width', selectWidth);
	        // set width to same as widget to accomodate placeholder
	        options.kendoDropDownList.input.width(selectWidth);
	        var loadingIndicator = options.dropdownlist.closest('.k-widget').find('.k-i-loading');
	        loadingIndicator.removeClass('k-hidden').removeClass('k-icon').addClass('k-i-arrow-60-down');
	        // Add framework CSS class for combobox and multiselect popups
	        options.kendoDropDownList.list.addClass('fis-multiselect-popup');
	      }
	      if (options.kendoListType === 'kendoComboBox' || options.kendoListType === 'kendoMultiSelect') {
	        if (options.attrs.fisListContentWidth) {
	          var contentWidth = parseInt(options.attrs.fisListContentWidth, 10);
	          options.kendoDropDownList.list.css('min-width', contentWidth);
	          options.kendoDropDownList.list.width(contentWidth);
	        } else {
	          options.kendoDropDownList.list.css('min-width', selectWidth);
	          options.kendoDropDownList.list.css('width', 'auto');
	        }
	      }
	
	      if (!_.isUndefined(options.callback)) {
	        // fire function after styles are applied
	        $timeout(function () {
	          options.callback(options);
	        });
	      }
	    }
	
	    /**
	     * @name initializeModel
	     * @methodOf fisSelectField
	     * @description
	     * <p>This function determines what is displayed in the model.
	     * Do not show a placeholder (if there is one), instead show
	     * an empty string.
	     * </p>
	     */
	    service.initializeModel = function (options, isResetRequired) {
	      // The ngModel is initialized only when the field is visible. If the field is invisible and ngModel's
	      // $viewValue is set, the change in ngModel never reflected, i.e. the watch for ngModelInput is never fired.
	      // $timeout(function () {
	      // if ($(options.element).is(':visible')) {
	      if (!options.attrs.placeholderInput && options.kendoDropDownList) {
	        // if there is no placeholder and the model is undefined
	        var listItems = options.kendoDropDownList.dataSource.data();
	        var value = options.kendoDropDownList.options.dataValueField;
	        for (var counter = 0; counter < listItems.length; counter++) {
	          if (listItems[counter][value] !== '? undefined:undefined ?') {
	            if (options.attrs.fisUpdateObject === 'true') {
	              options.ngModel.$setViewValue(listItems[counter]);
	            } else {
	              options.ngModel.$setViewValue(listItems[counter][value]);
	            }
	            options.isNgModelInitialized = true;
	            break;
	          }
	        }
	      } else {
	        if (isResetRequired) {
	          // eslint-disable-line no-lonely-if
	          options.ngModel.$setViewValue(null); // else there is a placeholder so show an empty string instead
	          options.isNgModelInitialized = true;
	        }
	      }
	      // options.isModelInitialized = true;
	      // }
	      // }, 0);
	    };
	
	    service.reInitializeData = function (options) {
	      options.isChangedCalled = false;
	      if (options.kendoDropDownList) {
	        if (options.isResetPrevData) {
	          var listItem = options.kendoDropDownList.dataSource.data();
	          if (listItem.length !== 0) {
	            options.prevData = angular.copy(options.kendoDropDownList.dataSource.data());
	            options.prevDataFieldValue = angular.copy(options.kendoDropDownList.options.dataValueField);
	            options.isResetPrevData = false;
	          }
	        }
	        if (options.attrs.fisOptions && !options.attrs.fisData) {
	          $timeout(function () {
	            options.kendoDropDownList.setDataSource(createSgOptionsData(options));
	          }, 0);
	        } else if (options.attrs.fisData && !options.attrs.fisOptions) {
	          options.kendoDropDownList.setDataSource(createSgData(options));
	        } else if (options.attrs.fisData && options.attrs.fisOptions) {
	          createSgDataAndOptionsDS(options).then(function (ds) {
	            options.kendoDropDownList.setDataSource(ds);
	          });
	        }
	
	        options.kendoDropDownList.bind('dataBound', function () {
	          var ngModel = options.dropdownlist.controller('ngModel');
	          if (ngModel.$modelValue || options.prevData) {
	            if (options.prevData && options.prevData.length !== 0) {
	              var currentData = options.kendoDropDownList.dataSource.data();
	              var currentFieldValue = options.kendoDropDownList.options.dataValueField;
	              if (_.intersection(_.pluck(currentData, currentFieldValue), _.pluck(options.prevData, options.prevDataFieldValue)).length === 0) {
	                var foundVal = _.find(currentData, function (value) {
	                  if (_.isEqual(value[currentFieldValue], ngModel.$modelValue)) {
	                    return value;
	                  }
	                });
	                if (_.isUndefined(foundVal)) {
	                  service.initializeModel(options, true);
	                } else {
	                  service.initializeModel(options, false);
	                }
	                options.isResetPrevData = true;
	                options.prevData = [];
	                options.prevDataFieldValue = '';
	              }
	            } else {
	              if (!options.isChangedCalled) {
	                // eslint-disable-line no-lonely-if
	                options.isChangedCalled = true;
	                options.kendoDropDownList.value(ngModel.$modelValue);
	              }
	            }
	          } else {
	            service.initializeModel(options, false);
	          }
	          applyStyles(options, false);
	        });
	
	        options.kendoDropDownList.bind('cascade', addSgIdsToItems);
	        addSgIdsToItems(options);
	      }
	    };
	
	    function processGroupAndSort(options) {
	      var groupAndSortObj = {};
	      var group;
	      var sort = [];
	      if (options.attrs.fisGroup) {
	        var displayField = 'value';
	        if (options.attrs.fisOptions) {
	          displayField = getDisplayField(options);
	        }
	
	        if (options.attrs.fisGroup.indexOf(',') === -1) {
	          group = $parse(options.attrs.fisGroup)(options.scope);
	        }
	
	        // if group is not defined as an object in partial, or in scope, it could be specified just as a field.
	        // in that case, create a group object and pass to datasource
	        if (!group) {
	          var groups = options.attrs.fisGroup.split(',');
	          group = [];
	          for (var i = 0; i < groups.length; i++) {
	            // eslint-disable-line block-scoped-var
	            group.push({ field: groups[i] }); // eslint-disable-line block-scoped-var
	          }
	        }
	
	        if (angular.isArray(group)) {
	          for (var i = 0; i < group.length; i++) {
	            // eslint-disable-line block-scoped-var, no-redeclare
	            sort.push({ field: group[i].field, dir: group[i].dir ? group[i].dir : 'asc' }); // eslint-disable-line block-scoped-var
	          }
	          if (group.length === 1) {
	            sort.push({ field: displayField, dir: group[0].dir ? group[0].dir : 'asc' });
	          }
	        } else {
	          var dir = group.dir ? group.dir : 'asc';
	          sort.push({ field: group.field, dir: dir });
	
	          sort.push({ field: displayField, dir: dir });
	        }
	
	        groupAndSortObj.group = group;
	        groupAndSortObj.sort = sort;
	      }
	      return groupAndSortObj;
	    }
	
	    function getDisplayField(options) {
	      var SG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))/;
	      var match = options.attrs.fisOptions.match(SG_OPTIONS_REGEXP);
	
	      var displayField;
	
	      var dispField = match[2] || match[1];
	      if (dispField) {
	        if (dispField.indexOf('.') > -1) {
	          displayField = dispField.substring(displayField.indexOf('.') + 1);
	        } else {
	          displayField = dispField;
	        }
	      }
	
	      return displayField;
	    }
	
	    service.addTooltipToSelectedOptions = function (options) {
	      if (options.kendoListType === 'kendoMultiSelect') {
	        var ulElm = options.element.find('ul[role="listbox"]');
	        var parentWidth = parseFloat($(ulElm).parent().width());
	        $(ulElm.find('li')).each(function (index, item) {
	          adjustWidthOfSelectedOptions(parentWidth, item);
	
	          if ($(item).children().length === 1) {
	            var content = $(item).children().contents()[0];
	            if (content) {
	              $(item).attr('title', content.textContent);
	            }
	          } else {
	            $(item).children().each(function (childIndex, childItem) {
	              var childContent = $(childItem).contents()[0];
	              if (childContent && !$(childContent).hasClass('k-i-close')) {
	                $(childItem).attr('title', childContent.textContent);
	              }
	            });
	          }
	        });
	      } else {
	        if (options.element.find('.k-input')[0]) {
	          // eslint-disable-line no-lonely-if
	          options.element.find('.k-input').attr('title', options.element.find('.k-input')[0].value);
	        }
	      }
	    };
	
	    function adjustWidthOfSelectedOptions(parentWidth, item) {
	      // this function is used to reduce the width of options that are exceeding the size of the text box
	      var itemWidth = parseFloat($(item).width());
	      // 25  pixels added to adjust padding
	      if (itemWidth + 25 > parentWidth) {
	        $(item).find('span:first').width(parentWidth - 50);
	      }
	    }
	
	    return service;
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 15 */
/*!**************************************************!*\
  !*** ./dropdown/multi-select-field.directive.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* global _, kendo */
	
	
	exports.default = ["fisKendoDataSourceFactory", "$parse", "$timeout", "fisFieldDirectiveFactory", "fisDropdownUtilService", "fisElementUtils", "fisMemoryUtilService", function (fisKendoDataSourceFactory, $parse, $timeout, fisFieldDirectiveFactory, fisDropdownUtilService, fisElementUtils, fisMemoryUtilService) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	    // eslint-disable-next-line no-multi-str
	    editTemplate: '<span data-placeholder="<%- field.attrs.placeholderInput %>">\
	                    <input fis-input="input" ng-transclude/>\
	                    <span class="add-on"><%= field.attrs.fisSuffix %></span>\
	                </span>',
	
	    transclude: true,
	
	    require: ['?fisData', '?fisReinit'],
	    link: function link(scope, element, attrs, ctrls) {
	      var isRendered = false;
	      var dropdownlist = element.find('input');
	      var kendoDropDownList;
	      var dataTextField = 'label';
	      var dataValueField = 'value';
	      var fisPlaceholder = '';
	      var fisData = ctrls[0];
	      var fisReinit = ctrls[1];
	      var isResetPrevData = true;
	      var prevData = [];
	      var prevDataFieldValue = '';
	      var isDropDownListUpdated = false;
	      var isNgModelInitialized = false;
	
	      element.find('.controls').addClass('dropdown');
	      dropdownlist.find('span').remove('.ng-scope');
	
	      var options = {};
	      options.attrs = attrs;
	      options.element = element;
	      options.kendoDropDownList = kendoDropDownList;
	      options.dataTextField = dataTextField;
	      options.dataValueField = dataValueField;
	      options.fisPlaceholder = fisPlaceholder;
	      options.dropdownlist = dropdownlist;
	      options.dataSourceFactory = fisKendoDataSourceFactory;
	      options.scope = scope;
	      options.fisData = fisData;
	      options.isResetPrevData = isResetPrevData;
	      options.prevData = prevData;
	      options.prevDataFieldValue = prevDataFieldValue;
	      options.isDropDownListUpdated = isDropDownListUpdated;
	      options.isRendered = isRendered;
	      options.kendoListType = 'kendoMultiSelect';
	      options.isNgModelInitialized = isNgModelInitialized;
	      options.isModelInitialized = false;
	
	      scope.$evalAsync(function () {
	        if (fisData) {
	          options.fisDataData = fisData.fetchData;
	        }
	        fisDropdownUtilService.initSelectField(options);
	      });
	
	      if (fisReinit) {
	        fisReinit.trigger = function (scope, newValue, oldValue) {
	          if (angular.isDefined(newValue) && newValue !== oldValue) {
	            var reinitTimeout = $timeout(function () {
	              fisDropdownUtilService.reInitializeData(options);
	            }, 0);
	            fisMemoryUtilService.cancelTimeoutOnDestroy(scope, reinitTimeout, $timeout);
	          }
	        };
	      }
	
	      var params = {};
	      params = fisElementUtils.copyProperties(attrs, 'fisParam', params);
	      _.each(params, function (val, key) {
	        var capitalKey = key.charAt(0).toUpperCase() + key.slice(1);
	        var attrToObserve = 'fisParam' + capitalKey;
	        attrs.$observe(attrToObserve, function () {
	          fisDropdownUtilService.reInitializeData(options);
	        });
	      });
	
	      // add a watch on fisData when it does not contain a ':' character (meaning when it is not parameterized)
	      // If fis-data contains a ':', it cannot be watched on since angular does not allow special character in watch experssion
	      // For such cases, we should instead observe the fis-param attribute. And fire reInitializeData on change of that.
	      if (attrs.fisData && attrs.fisData.indexOf(':') < 0) {
	        try {
	          var fisDataWatch = scope.$watch(attrs.fisData, function (newValue, oldValue) {
	            if (!_.isNaN(newValue) && newValue !== oldValue) {
	              if (options.isRendered === true) {
	                fisDropdownUtilService.reInitializeData(options);
	              }
	            }
	          });
	          fisMemoryUtilService.cancelWatchOnDestroy(scope, fisDataWatch);
	        } catch (e) {
	          console.warn('Cannot watch on fis-data expression ', attrs.fisData);
	        }
	      }
	
	      var editWatch = scope.$watch('fisEditMode', function () /* formEditMode*/{
	        // when the field is invisible for the first time, eg. if ng-show is used, then initialize the
	        // ngModel when field is visible.
	        var ngModel = options.dropdownlist.controller('ngModel');
	        if (!ngModel.$modelValue && options.isRendered === true && !options.isModelInitialized) {
	          fisDropdownUtilService.initializeModel(options); // Initialize model to handle new item creation
	          // initializeModel(ngModel); //Initialize model to handle new item creation
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, editWatch);
	
	      attrs.$observe('placeholderInput', function (newVal) {
	        if (!_.isUndefined(newVal)) {
	          fisDropdownUtilService.updatePlaceholder(options, newVal);
	        }
	      });
	
	      options.updateKendoDropDownListValue = function (val) {
	        if (options.isRendered && options.kendoDropDownList !== undefined && !options.isDropDownListUpdated && options.attrs.fisServerFiltering !== 'true' && !options.attrs.fisGroup) {
	          // If initial items are lost in attempt to set new values, probably the widget is filtered by the end user,
	          // but no value has been selected. You will need to remove applied filter, before calling value method
	          // http://docs.telerik.com/kendo-ui/api/web/multiselect#methods-value
	          // clear filter
	          options.kendoDropDownList.dataSource.filter({});
	          if (val !== undefined) {
	            if (val === null) {
	              options.kendoDropDownList.value(val);
	            } else {
	              var typeOfVal = determineType(val);
	              var valueToSet;
	              if (typeOfVal === 'objArray' || val instanceof kendo.data.ObservableArray) {
	                var arr = options.ngModel.$modelValue || val;
	                var arrToSet = [];
	                if (options.attrs.fisUpdateObject === 'true') {
	                  for (var j = 0; j < arr.length; j++) {
	                    // eslint-disable-line block-scoped-var
	                    arrToSet.push(arr[j][options.kendoDropDownList.options.dataValueField]); // eslint-disable-line block-scoped-var
	                  }
	                } else if (typeOfVal === 'objArray') {
	                  for (var j = 0; j < arr.length; j++) {
	                    // eslint-disable-line block-scoped-var, no-redeclare
	                    arrToSet.push(arr[options.kendoDropDownList.options.dataValueField]);
	                  }
	                } else {
	                  arrToSet = _.toArray(val);
	                }
	                options.kendoDropDownList.value(arrToSet);
	                valueToSet = arrToSet;
	              } else if (typeOfVal === 'primitiveArray') {
	                options.kendoDropDownList.value(_.toArray(val));
	                valueToSet = _.toArray(val);
	              } else if (typeOfVal === 'string') {
	                if (val.split(',').length > 1) {
	                  options.kendoDropDownList.value(val.split(','));
	                  valueToSet = val.split(',');
	                } else {
	                  options.kendoDropDownList.value(val);
	                  valueToSet = val;
	                }
	              } else {
	                valueToSet = val;
	              }
	
	              // if the value is not set, try using timeout.
	              // This condition will occur when data coming from server takes a bit longer to load
	              if (options.kendoDropDownList.value()) {
	                var updateKendoDDListTimeout = $timeout(function () {
	                  if (options.kendoDropDownList.value().length === 0 || angular.isArray(valueToSet) && options.kendoDropDownList.value().length !== valueToSet.length) {
	                    options.kendoDropDownList.value(valueToSet);
	                  }
	                }, 0);
	                fisMemoryUtilService.cancelTimeoutOnDestroy(scope, updateKendoDDListTimeout, $timeout);
	              }
	            }
	          }
	        } else {
	          // to Fix SDHTML-17952
	          if (options.attrs.fisServerFiltering === 'true') {
	            if (!val || val.length === 0) {
	              if (options.kendoDropDownList) {
	                options.kendoDropDownList.value('');
	              }
	            }
	          }
	          options.isDropDownListUpdated = false;
	        }
	        fisDropdownUtilService.addTooltipToSelectedOptions(options);
	      };
	
	      var inputWatch = scope.$watch(attrs.ngModelInput, function (val) {
	        if (val === undefined) {
	          val = '';
	        }
	        // need to add this since kendo change is triggered twice, once for the dropdown element, and another time for the textbox
	        // when it is triggered for the textbox, the value is sent as comma separated string, instead of array.
	        // when this is the case, we need to convert the model to array
	        if (typeof val === 'string' && val.length > 0) {
	          if (options.ngModel) {
	            options.ngModel.$setViewValue(val.split(','));
	          }
	        }
	        options.updateKendoDropDownListValue(val);
	      }, true);
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, inputWatch);
	
	      function determineType(val) {
	        if (angular.isArray(val)) {
	          if (_typeof(val[0]) === 'object') {
	            return 'objArray';
	          } else {
	            // eslint-disable-line no-else-return
	            return 'primitiveArray';
	          }
	        } else if (typeof val === 'string') {
	          return 'string';
	        }
	      }
	
	      var disabledWatch = scope.$watch('fisDisabled', function (disabled) {
	        if (options.isRendered && options.kendoDropDownList) {
	          options.kendoDropDownList.enable(!disabled);
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, disabledWatch);
	
	      scope.fieldValue = function () {
	        if (options.kendoDropDownList !== undefined) {
	          // eslint-disable-line no-negated-condition
	          var data = options.kendoDropDownList.dataItems();
	          if (data.length !== 0) {
	            var text = options.kendoDropDownList.options.dataTextField;
	            return _.pluck(data, text).join(', ');
	          }
	        } else {
	          return '';
	        }
	      };
	    }
	  });
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 16 */
/*!********************************************!*\
  !*** ./dropdown/select-field.directive.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$q", "$parse", "$timeout", "$rootScope", "fisFieldDirectiveFactory", "fisSelectFieldService", "fisMemoryUtilService", "fisElementUtils", "fisUniqueIdService", "fisPubSubService", function ($q, $parse, $timeout, $rootScope, fisFieldDirectiveFactory, fisSelectFieldService, fisMemoryUtilService, fisElementUtils, fisUniqueIdService, fisPubSubService) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	    // eslint-disable-next-line no-multi-str
	    editTemplate: '<span data-placeholder="<%- field.attrs.placeholderInput %>">\
	                    <input kendo-drop-down-list k-options="dropdownOptions" fis-input="input" <% if (field.attrs.fisUpdateObject === "true" && !field.attrs.ngModelOptions) { %> ng-model-options="{debounce: 150}" <% } %> ng-transclude />\
	                    <span class="add-on"><%- field.attrs.fisSuffix %></span>\
	                </span>',
	    transclude: true,
	    require: ['?fisData', '?fisReinit'],
	    link: function link(scope, element, attrs, ctrls) {
	      // scope.activeViewPanel().$element.hide();
	      var fisData = ctrls[0];
	      var fisReinit = ctrls[1];
	
	      var ngModel;
	      var callback;
	      var fisPlaceholder;
	      var template;
	      var headerTemplate;
	      var kendoDropDownList;
	
	      var initializePlaceholderInput = true;
	      var isResetPrevData = true;
	      var prevData = []; // eslint-disable-line no-unused-vars
	      var prevDataFieldValue = ''; // eslint-disable-line no-unused-vars
	
	      var dataTextField = attrs.kDataTextField ? attrs.kDataTextField : 'label';
	      var dataValueField = attrs.kDataValueField ? attrs.kDataValueField : 'value';
	      scope.dropdownOptions = undefined;
	
	      // find the dropdown list
	      var dropdownlist = element.find('input');
	      dropdownlist.find('span').remove('.ng-scope');
	
	      // create service options object, to be passed to fisSelectFieldService
	      var serviceOptions = {};
	      serviceOptions.element = element;
	      serviceOptions.attrs = attrs;
	      serviceOptions.dropdownlist = dropdownlist;
	      serviceOptions.scope = scope;
	      serviceOptions.fisData = fisData;
	      serviceOptions.dataTextField = dataTextField;
	      serviceOptions.dataValueField = dataValueField;
	
	      element.find('.controls').addClass('dropdown');
	      ngModel = dropdownlist.controller('ngModel');
	
	      var itemChanged = false;
	
	      // set default for fisIsEllipsed
	      if (_.isUndefined(attrs.fisEllipsed)) {
	        attrs.fisEllipsed = 'false';
	      }
	
	      if (fisData) {
	        serviceOptions.fisDataData = fisData.fetchData;
	      }
	
	      // adding callback functionality that fires after load - needed for styling
	      if (!_.isUndefined(scope.callback)) {
	        callback = scope.callback;
	      }
	
	      // edit watch
	      var editWatch = scope.$watch('fisEditMode', function () /* formEditMode*/{
	        // when the field is invisible for the first time, eg. if ng-show is used, then initialize the
	        // ngModel when field is visible.
	        ngModel = dropdownlist.controller('ngModel');
	
	        // in case user has defined ngModelOptions, and there is no debounce property defined, we set it to 150 for cases with updateObject as true
	        // this is to ensure smooth keyboard interaction in the said case.
	        if (attrs.fisUpdateObject === 'true' && ngModel.$options && !ngModel.$options.debounce) {
	          ngModel.$options.debounce = 150;
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, editWatch);
	
	      attrs.$observe('placeholderInput', function (newVal) {
	        if (initializePlaceholderInput) {
	          $timeout(function () {
	            initializePlaceholderInput = false;
	          });
	        } else {
	          executeAfterWidgetCreation(function () {
	            if (!_.isUndefined(newVal)) {
	              updatePlaceholder(newVal);
	            }
	          });
	        }
	      });
	
	      // Bug SDHTML-12474, please see SDHTML-12467 & SDHTML-13224
	      // When the Kendo Dropdown loads, it selects the first value (position 0)
	      $timeout(function () {
	        if (attrs.placeholderInput && !_.isUndefined(kendoDropDownList) && attrs.fisUpdateObject !== 'true' && kendoDropDownList.selectedIndex == -1) {
	          // eslint-disable-line eqeqeq
	          kendoDropDownList.select(0);
	        }
	      });
	
	      var inputWatch = scope.$watch(attrs.ngModelInput, function (val) {
	        if (val === undefined) {
	          val = '';
	        }
	        // need to have for cases with fisUpdateObject true and initial value bound from model
	        executeAfterWidgetCreation(function () {
	          addTooltipToSelectedOptions();
	          if (attrs.fisUpdateObject === 'true' || itemChanged) {
	            updateKendoDropDownListValue(val);
	          }
	        });
	      }, true);
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, inputWatch);
	
	      function updateKendoDropDownListValue(val) {
	        if (kendoDropDownList) {
	          if (angular.isObject(val) && attrs.fisUpdateObject === 'true') {
	            $timeout(function () {
	              kendoDropDownList.value(val[kendoDropDownList.options.dataValueField]);
	              addTooltipToSelectedOptions();
	            });
	          } else if (itemChanged) {
	            $timeout(function () {
	              kendoDropDownList.value(val);
	              itemChanged = false;
	            });
	          }
	        }
	      }
	
	      var disabledWatch = scope.$watch('fisDisabled', function (disabled) {
	        if (kendoDropDownList) {
	          kendoDropDownList.enable(!disabled);
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, disabledWatch);
	
	      function executeAfterWidgetCreation(callbackFn) {
	        kendoDropDownList = dropdownlist.data('kendoDropDownList');
	        if (kendoDropDownList) {
	          callbackFn(kendoDropDownList);
	        } else {
	          var kendoCreatedDeregister = scope.$on('kendoWidgetCreated', function (event, widget) {
	            if (widget && widget.ns === '.kendoDropDownList') {
	              kendoDropDownList = dropdownlist.data('kendoDropDownList');
	              callbackFn(widget);
	            }
	            kendoCreatedDeregister();
	          });
	        }
	      }
	
	      function processColumns() {
	        var columns = attrs.fisColumns;
	        columns = $parse(columns)(scope);
	        if (columns) {
	          headerTemplate = '<div class="dropdown-header">';
	          template = '';
	          for (var i = 0; i < columns.length; i++) {
	            var col = columns[i];
	            var field = col.field;
	            var width = col.width ? col.width + '%' : 100 / columns.length + '%';
	            if (columns.length > 1) {
	              headerTemplate = headerTemplate + '<span class="k-widget k-header" style="width: ' + width + '">' + col.title + '</span>';
	            }
	            template = template + '<span class=' + col.cls + ' style="width: ' + width + '">{{dataItem.' + field + '}}</span>';
	          }
	          headerTemplate += '</div>';
	        }
	      }
	
	      // create datasource
	      function prepareDataSource() {
	        var deferred = $q.defer();
	        var dataSource; // eslint-disable-line no-unused-vars
	        if (attrs.fisData && !attrs.fisOptions) {
	          $timeout(function () {
	            fisSelectFieldService.createSgData(serviceOptions).then(function (dataSource) {
	              deferred.resolve(dataSource);
	            });
	          });
	        } else if (!attrs.fisData && attrs.fisOptions) {
	          $timeout(function () {
	            fisSelectFieldService.createSgOptionsData(serviceOptions).then(function (dataSource) {
	              deferred.resolve(dataSource);
	            });
	          });
	        } else if (attrs.fisData && attrs.fisOptions) {
	          fisSelectFieldService.createSgDataAndOptionsDS(serviceOptions).then(function (dataSource) {
	            deferred.resolve(dataSource);
	          });
	        } else {
	          fisSelectFieldService.createStaticOptionsData(serviceOptions).then(function (dataSource) {
	            deferred.resolve(dataSource);
	          });
	        }
	        return deferred.promise;
	      }
	
	      function applyStyles(removePreviousStyle) {
	        executeAfterWidgetCreation(function () {
	          var sizeClass = 'fis-selectField-large';
	          if (attrs.fisSize !== undefined) {
	            sizeClass = 'fis-selectField-' + attrs.fisSize;
	          }
	          if (!attrs.fisData && !attrs.fisOptions) {
	            // apply same styling as template
	            kendoDropDownList.ul.find('li').wrapInner('<dd class="fis-select-dd"></dd>');
	          }
	          if (removePreviousStyle && kendoDropDownList.ul) {
	            kendoDropDownList.ul[0].removeAttribute('style');
	          }
	
	          dropdownlist.addClass(sizeClass);
	
	          var selectWidth = parseFloat(dropdownlist.width());
	          if (selectWidth > 0) {
	            dropdownlist.closest('.k-widget').width(selectWidth);
	            kendoDropDownList.list.css('white-space', 'nowrap').css('min-width', selectWidth);
	          } else {
	            dropdownlist.closest('.k-widget').width('160px');
	            kendoDropDownList.list.css('min-width', '160px');
	          }
	
	          kendoDropDownList.list.css('width', 'auto');
	
	          if (attrs.fisMaxListHeight) {
	            kendoDropDownList.list.find('.k-list').css('height', attrs.fisMaxListHeight);
	          }
	
	          kendoDropDownList.ul.parent().css('height', kendoDropDownList.list.css('height'));
	
	          if (!_.isUndefined(callback)) {
	            // fire function after styles are applied
	            $timeout(function () {
	              callback(serviceOptions);
	            });
	          }
	        });
	      }
	
	      scope.$watch(function () {
	        return angular.element(element).is(':hidden');
	      }, function (value) {
	        if (value === false && kendoDropDownList && (attrs.kAutoBind === 'false' || attrs.kAutoBind === false)) {
	          kendoDropDownList.dataSource.trigger('change');
	        }
	      });
	
	      // subscribed from masterDetailController - this is to detect that an item has changed
	      // so that the widget can set the value to index 0
	      fisPubSubService.subscribe('fisItemChanged', function (item) {
	        $timeout(function () {
	          if (ngModel && kendoDropDownList && !item[ngModel.fisProperty] && !ngModel.$viewValue) {
	            itemChanged = true;
	            kendoDropDownList.select(0);
	            kendoDropDownList.trigger('change');
	          }
	        });
	      });
	
	      function initializeModel() {
	        executeAfterWidgetCreation(function () {
	          var elementHidden = angular.element(element).is(':hidden');
	          if (!attrs.placeholderInput && kendoDropDownList && !ngModel.$viewValue && !elementHidden) {
	            // if there is no placeholder and the model is undefined
	            var listItems = kendoDropDownList.dataSource.data();
	            var value = kendoDropDownList.options.dataValueField;
	            for (var counter = 0; counter < listItems.length; counter++) {
	              if (listItems[counter][value] !== '? undefined:undefined ?') {
	                if (attrs.fisUpdateObject === 'true') {
	                  ngModel.$setViewValue(listItems[counter]);
	                } else {
	                  ngModel.$setViewValue(listItems[counter][value]);
	                }
	                break;
	              }
	            }
	          } else if (attrs.placeholderInput && !ngModel.$viewValue && (attrs.kAutoBind === 'false' || attrs.kAutoBind === false || scope.dropdownOptions.autoBind === false)) {
	            // SDHTML-11348 This $evalAsync is required because in case of static options with placeholder, kendo is internally
	            // picking up the first option from the static options list and binds it to the model.
	            if (attrs.ngChangeInput) {
	              scope.$evalAsync(function () {
	                ngModel.$setViewValue(''); // else there is a placeholder so show an empty string instead
	              });
	            } else {
	              scope.$evalAsync(function () {
	                ngModel.$setViewValue(null); // else there is a placeholder so show an empty string instead
	              });
	            }
	          }
	        });
	      }
	
	      function changeModelValue() {
	        var list = dropdownlist.data('kendoDropDownList');
	        if (list) {
	          var data = angular.copy(list.dataSource.data()); // eslint-disable-line no-unused-vars
	
	          if (list.selectedIndex !== -1) {
	            if (attrs.fisUpdateObject === 'true') {
	              if (list.selectedIndex === 0 && serviceOptions.attrs.placeholderInput) {
	                ngModel.$setViewValue(undefined);
	              } else {
	                ngModel.$setViewValue(list.dataItem());
	              }
	            } else {
	              if (list.dataItem() && !_.isUndefined(list.dataItem()[scope.dropdownOptions.dataValueField])) {
	                // eslint-disable-line no-lonely-if
	                ngModel.$setViewValue(list.dataItem()[scope.dropdownOptions.dataValueField]);
	              }
	            }
	          }
	          addTooltipToSelectedOptions();
	        }
	      }
	
	      function prepareOptions(dataSource) {
	        evaluatePlaceholder();
	
	        var hasMultiFieldGrouping = false;
	        if (attrs.fisGroup && (attrs.fisGroup.indexOf(',') > -1 || angular.isArray($parse(attrs.fisGroup)(scope)))) {
	          hasMultiFieldGrouping = true;
	        }
	        var templateStr = hasMultiFieldGrouping ? '<dd class="fis-select-dd">${ ' + serviceOptions.dataTextField + ' }</dd>' : '<dd class="fis-select-dd">{{dataItem.' + serviceOptions.dataTextField + '}}</dd>';
	
	        scope.dropdownOptions = {
	          headerTemplate: headerTemplate,
	          template: template ? template : templateStr,
	          valueTemplate: '{{dataItem.' + serviceOptions.dataTextField + '}}',
	          dataSource: dataSource,
	          dataTextField: serviceOptions.dataTextField,
	          dataValueField: serviceOptions.dataValueField,
	          optionLabel: fisSelectFieldService.evaluatedPlaceholder(element),
	          change: function change() {
	            changeModelValue(serviceOptions, dataSource);
	          },
	          autoBind: attrs.kAutoBind === 'false' || attrs.kAutoBind === false ? false : true, // eslint-disable-line no-unneeded-ternary
	          dataBound: dataBound
	        };
	        // SDHTML-11348 In case of Static options list k-auto-bind value needs to be set to false
	        // otherwise, on initial loading, the select field shows first option selected even with placeholder
	        if (!attrs.fisData && !attrs.fisOptions && ngModel && ngModel.$modelValue === undefined) {
	          scope.dropdownOptions.autoBind = false;
	        }
	
	        if (attrs.fisMaxListHeight) {
	          scope.dropdownOptions.height = attrs.fisMaxListHeight;
	        }
	      }
	
	      if (attrs.kNgDelay) {
	        scope.$parent.$watch(attrs.kNgDelay, function (newValue) {
	          if (newValue === true) {
	            callPrepareOptions();
	          }
	        });
	      } else {
	        callPrepareOptions();
	      }
	
	      function callPrepareOptions() {
	        var data;
	        var dataSource = prepareDataSource().then(function (ds) {
	          // eslint-disable-line no-unused-vars
	          if (attrs.fisData && !attrs.fisOptions) {
	            if (ds && ds.data()) {
	              data = ds.data()[0];
	            }
	            // check if data is a promise object - works only in case of fis-data right now...
	            if (data && data.then && typeof data.then === 'function') {
	              data.then(function (promisedData) {
	                prepareOptions(promisedData);
	              }, function (err) {
	                console.error('error...', err);
	              });
	            } else {
	              prepareOptions(ds);
	            }
	          } else {
	            prepareOptions(ds);
	          }
	        });
	      }
	
	      processColumns();
	      initializeModel();
	      performKeyboardNavigation();
	      callGenerateUniqueId();
	      applyStyles(true);
	
	      if (fisReinit) {
	        fisReinit.trigger = function () {
	          // needed in case of fis-options only. When fis-data is defined, fis-data watch gets fired.
	          // But when it is not present, and only fis-options is present, reinit timeout will be needed.
	          reInitializeData(true);
	        };
	      }
	
	      function evaluatePlaceholder() {
	        if (attrs.placeholderInput) {
	          var isEval = attrs.placeholderInput.toLowerCase().indexOf('i18n') >= 0; // check if it must be $eval
	          if (isEval) {
	            fisPlaceholder = scope.$eval(attrs.placeholderInput.replace('{{', '').replace('}}', '')) || '';
	          } else {
	            fisPlaceholder = attrs.placeholderInput || '';
	          }
	        }
	      }
	
	      function dataBound() {
	        /* Add a tooltip displaying the content. Useful when the content is longer than
	         what the field can accomodate*/
	        $(this.items()).each(function (index, item) {
	          if ($(item).children().length === 1) {
	            $timeout(function () {
	              var content = $(item).children().contents();
	              if (content) {
	                $(item).attr('title', content.text());
	              }
	            });
	          } else {
	            $(item).children().each(function (childIndex, childItem) {
	              $timeout(function () {
	                var childContent = $(childItem).contents();
	                if (childContent) {
	                  $(childItem).attr('title', childContent.text());
	                }
	              });
	            });
	          }
	        });
	        addTooltipToSelectedOptions();
	        if (fis.initParams().appStage === 'T') {
	          addSgIdsToItems();
	        }
	      }
	
	      function addSgIdsToItems() {
	        $timeout(function () {
	          // Add fisIDs to list-items
	          if (!_.isUndefined(kendoDropDownList) && !_.isUndefined(kendoDropDownList.list)) {
	            var parentSdId = kendoDropDownList.element.attr('fisid');
	            var dropdownItems = kendoDropDownList.list.find('li');
	            for (var i = 0; i < dropdownItems.length; i++) {
	              dropdownItems.eq(i).attr('fisid', parentSdId + '_entry_' + i);
	            }
	          }
	        });
	      }
	
	      function reInitializeData(isReinitCalled) {
	        if (kendoDropDownList) {
	          if (isResetPrevData) {
	            var listItem = kendoDropDownList.dataSource.data();
	            if (listItem.length !== 0) {
	              prevData = angular.copy(kendoDropDownList.dataSource.data());
	              prevDataFieldValue = angular.copy(kendoDropDownList.options.dataValueField);
	              isResetPrevData = false;
	            }
	          }
	          prepareDataSource().then(function (ds) {
	            kendoDropDownList.setDataSource(ds);
	            if (isReinitCalled) {
	              // Broadcast an event whenever widget gets reinitialized
	              // User can listen to this event in the controller
	              scope.$emit('sgSelectFieldReinitialized', { modelname: attrs.ngModelInput });
	            }
	          });
	        }
	      }
	
	      var params = {};
	      params = fisElementUtils.copyProperties(attrs, 'fisParam', params);
	      _.each(params, function (val, key) {
	        var capitalKey = key.charAt(0).toUpperCase() + key.slice(1);
	        var attrToObserve = 'fisParam' + capitalKey;
	        attrs.$observe(attrToObserve, function () {
	          reInitializeData();
	        });
	      });
	
	      // add a watch on fisData when it does not contain a ':' character (meaning when it is not parameterized)
	      // If fis-data contains a ':', it cannot be watched on since angular does not allow special character in watch experssion
	      // For such cases, we should instead observe the fis-param attribute. And fire reInitializeData on change of that.
	      if (attrs.fisData && attrs.fisData.indexOf(':') < 0) {
	        try {
	          var fisDataWatch = scope.$watch(attrs.fisData, function (newValue, oldValue) {
	            if (!_.isNaN(newValue) && newValue !== oldValue) {
	              reInitializeData();
	            }
	          });
	          fisMemoryUtilService.cancelWatchOnDestroy(scope, fisDataWatch);
	        } catch (e) {
	          console.warn('Cannot watch on fis-data expression ', attrs.fisData);
	        }
	      }
	
	      function updatePlaceholder(placeholder) {
	        if (placeholder === '\'\'') {
	          placeholder = ' ';
	        }
	        if (kendoDropDownList && scope.dropdownOptions) {
	          kendoDropDownList.options.optionLabel = placeholder;
	          scope.dropdownOptions.optionLabel = placeholder;
	          kendoDropDownList.optionLabel.text(placeholder);
	          if (kendoDropDownList.select() <= 0) {
	            kendoDropDownList.text(placeholder);
	          }
	          addTooltipToSelectedOptions();
	          if (!_.isUndefined(fisPlaceholder)) {
	            fisPlaceholder = placeholder;
	          }
	        }
	      }
	
	      function performKeyboardNavigation() {
	        executeAfterWidgetCreation(function () {
	          var clickableElement = angular.element(element).find('.k-widget.k-dropdown');
	          clickableElement.keydown(function (e) {
	            if (e.keyCode === 27) {
	              kendoDropDownList.popup.close();
	              e.stopPropagation();
	            }
	          });
	        });
	      }
	
	      function callGenerateUniqueId() {
	        executeAfterWidgetCreation(function () {
	          if (fis.initParams().appStage === 'T') {
	            // Add fisID to list-container
	            fisUniqueIdService.generateUniqueId(scope, kendoDropDownList.list, {}, attrs.ngModelInput + '_list-container');
	            // Items will get fisID inside the DataBound Callback
	          }
	        });
	      }
	
	      function addTooltipToSelectedOptions() {
	        $timeout(function () {
	          var titleAttr = element.attr('title');
	          if (angular.isUndefined(titleAttr)) {
	            element.find('.k-input').attr('title', kendoDropDownList.text());
	          } else {
	            element.find('.k-input').attr('title', titleAttr);
	          }
	        });
	      }
	
	      /**
	       * @name fieldValue
	       * @methodOf fisSelectField
	       * @description
	       * <p>Returns the current value of the select in viewing mode. </p>
	       */
	      scope.fieldValue = function () {
	        if (kendoDropDownList !== undefined && kendoDropDownList.text() !== undefined) {
	          if (!_.isUndefined(fisPlaceholder) && fisPlaceholder === kendoDropDownList.text()) {
	            return ''; // If placeholder value is selected then return ''
	          }
	          return kendoDropDownList.text();
	        } else {
	          // eslint-disable-line no-else-return
	          return '';
	        }
	      };
	
	      /**
	       * @name resizeDropDown
	       * @methodOf fisComboBoxField
	       * @description
	       * <p>Resizes the width of the drop down list to match the select field </p>
	       */
	      scope.resize = function (width) {
	        element.find('.k-dropdown-wrap').css('width', width);
	        kendoDropDownList.element.css('width', width);
	
	        // var comboWidth = kendoDropDownList.element.width();
	        kendoDropDownList.list.css('min-width', '');
	        kendoDropDownList.list.css('width', 'auto');
	      };
	    }
	  });
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 17 */
/*!*******************************************!*\
  !*** ./dropdown/select-field.provider.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var self = this;
	  var filtersObj = {}; // eslint-disable-line no-unused-vars
	
	  self.$get = ['$parse', '$q', 'fisDropdownKeyHandlerService', 'fisKendoDataSourceFactory', function ($parse, $q, fisDropdownKeyHandlerService, fisKendoDataSourceFactory) {
	    var service = {};
	
	    service.evaluatedPlaceholder = function (elem) {
	      var ret;
	      var placeHolder = elem.find('[data-placeholder]').data('placeholder');
	      if (placeHolder !== '\'\'') {
	        // eslint-disable-line no-negated-condition
	        ret = placeHolder;
	      } else {
	        ret = ' ';
	      }
	      return ret;
	    };
	
	    // fis-data only
	    service.createSgData = function (options) {
	      var deferred = $q.defer();
	      var dataSourceOptions = {};
	      var parameters = {};
	      var requestStart;
	
	      dataSourceOptions.serverFiltering = options.attrs.fisServerFiltering === 'true';
	      var additionalOpts = {};
	
	      if (dataSourceOptions.serverFiltering) {
	        options.isDropDownListUpdated = true;
	        parameters.q = 'filter.filters[0].value';
	        parameters.operator = 'filter.filters[0].operator';
	
	        requestStart = function requestStart(e) {
	          var readArgs = e.sender.read.arguments;
	          if (!readArgs) {
	            e.preventDefault();
	          }
	        };
	
	        additionalOpts.requestStart = requestStart;
	      }
	
	      dataSourceOptions.group = processGroupAndSort(options).group;
	      dataSourceOptions.sort = processGroupAndSort(options).sort;
	
	      var ds = fisKendoDataSourceFactory.createListDataSource(options.fisDataData, parameters, dataSourceOptions, additionalOpts);
	
	      ds.fetch().then(function () {
	        deferred.resolve(ds);
	      }, function () {
	        deferred.resolve(ds);
	      });
	      return deferred.promise;
	    };
	
	    service.createStaticOptionsData = function (options) {
	      var deferred = $q.defer();
	      var ds = createInlineOptionsDataSource(options);
	      ds.fetch().then(function () {
	        deferred.resolve(ds);
	      }, function () {
	        deferred.resolve(ds);
	      });
	      return deferred.promise;
	    };
	
	    function createInlineOptionsDataSource(options) {
	      var inlineOptions = options.element.find('option');
	      var data = [];
	      if (inlineOptions && inlineOptions.length > 0) {
	        for (var i = 0; i < inlineOptions.length; i++) {
	          data[i] = { label: inlineOptions[i].label, value: inlineOptions[i].value };
	        }
	      }
	      return new kendo.data.DataSource({ data: data });
	    }
	
	    /**
	     * @name createSgOptionsData
	     * @methodOf fisSelectField
	     * @description
	     * <p>This function creates the data needed to populate an fisOptions dropdown.</p>
	     */
	    service.createSgOptionsData = function (options, col) {
	      var deferred = $q.defer();
	      var data = parseAndNormalizeSgOptions(options, col);
	      var group = processGroupAndSort(options).group;
	      var sort = processGroupAndSort(options).sort;
	
	      var ds = new kendo.data.DataSource({ data: data, group: group, sort: sort });
	      ds.fetch().then(function () {
	        deferred.resolve(ds);
	      }, function () {
	        deferred.resolve(ds);
	      });
	      return deferred.promise;
	    };
	
	    function parseAndNormalizeSgOptions(options, col) {
	      // if fisOptions are provided, parse the fisOptions value
	      var SG_OPTIONS_REGEXP_WITH_COLLECTION = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*)$/;
	      var SG_OPTIONS_REGEXP_WITHOUT_COLLECTION = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))/;
	      var match;
	      if (col) {
	        match = options.attrs.fisOptions.match(SG_OPTIONS_REGEXP_WITHOUT_COLLECTION);
	      } else {
	        match = options.attrs.fisOptions.match(SG_OPTIONS_REGEXP_WITH_COLLECTION);
	      }
	      if (!match) {
	        throw new Error('Expected fisOptions in form of \'_select_ (as _label_)? for (_key_,)?_value_ in _collection_\'' + '\' but got \'' + options.attrs.fisOptions + '.');
	      }
	
	      var displayField = match[2] || match[1];
	      var valueName = match[4] || match[6];
	      var keyName = match[5];
	      var valueField = match[2] ? match[1] : valueName;
	      var data = [];
	
	      var collection = col ? col : $parse(match[7])(options.scope.$parent) || [];
	
	      if (displayField) {
	        if (displayField.indexOf('.') > -1) {
	          options.dataTextField = displayField.substring(displayField.indexOf('.') + 1);
	        } else {
	          options.dataTextField = displayField;
	        }
	      }
	
	      if (valueField !== 'select') {
	        // eslint-disable-line no-negated-condition
	        if (valueField.indexOf('.') > -1) {
	          options.dataValueField = valueField.substring(valueField.indexOf('.') + 1);
	        } else {
	          options.dataValueField = valueField;
	        }
	      } else {
	        options.dataValueField = valueName;
	      }
	      data = normalizeCollection(options, collection, keyName, valueName);
	      return data;
	    }
	
	    function normalizeCollection(options, collection, keyName, valueName) {
	      var keys = keyName ? _.keys(collection) : collection;
	      var data = [];
	      if (angular.isArray(collection)) {
	        for (var i = 0; i < collection.length; i++) {
	          if (!angular.isObject(collection[i])) {
	            var obj1 = {};
	            obj1[options.dataTextField] = collection[i];
	            collection.splice(i, 1, obj1);
	          }
	        }
	        data = collection;
	        if (data[0] && !_.has(data[0], options.dataValueField)) {
	          // This is the case where object is expected as value for the dropdownlist.
	          // Example: fis-options="color.name for color in colorsObj"
	
	          // options.valueAsObj = true;
	
	          options.dataValueField = options.dataTextField;
	        }
	      } else if (angular.isObject(collection)) {
	        var index;
	        var length;
	        for (index = 0; length = keys.length, index < length; index++) {
	          // eslint-disable-line no-sequences
	          var obj2 = {};
	          obj2[valueName] = collection[keyName ? obj2[keyName] = keys[index] : index];
	          data[index] = obj2;
	        }
	      }
	      return data;
	    }
	
	    service.createSgDataAndOptionsDS = function (options) {
	      var deferred = $q.defer();
	
	      // for server side filtering
	      var dataSourceOptions = {};
	      dataSourceOptions.serverFiltering = options.attrs.fisServerFiltering === 'true';
	      var parameters = {};
	      if (dataSourceOptions.serverFiltering) {
	        options.isDropDownListUpdated = true;
	        parameters.q = 'filter.filters[0].value';
	        parameters.operator = 'filter.filters[0].operator';
	      }
	
	      dataSourceOptions.group = processGroupAndSort(options).group;
	      dataSourceOptions.sort = processGroupAndSort(options).sort;
	
	      var ds = createKendoDataSource(options.fisDataData, parameters, dataSourceOptions, options);
	      ds.fetch().then(function () {
	        deferred.resolve(ds);
	      }, function () {
	        deferred.resolve(ds);
	      });
	      return deferred.promise;
	    };
	
	    function createKendoDataSource(fetchFn, expect, opts, options) {
	      return new kendo.data.DataSource(angular.extend({
	        transport: {
	          read: function read(readOptions) {
	            var params = translateOptions(readOptions, expect);
	            fetchFn(params).then(function (result) {
	              var collection = parseCollection(result, options);
	              var normalizedData = parseAndNormalizeSgOptions(options, collection);
	              result.data = normalizedData;
	              readOptions.success(result);
	            }, function (data) {
	              readOptions.error(data);
	            });
	          }
	        },
	        requestStart: function requestStart(e) {
	          var readArgs = e.sender.read.arguments;
	          if (!readArgs && options.attrs.fisServerFiltering === 'true') {
	            e.preventDefault();
	          }
	        },
	        schema: {
	          data: 'data',
	          total: 'total'
	        }
	      }, opts || {}));
	    }
	
	    function parseCollection(result, options) {
	      var res = {};
	      var collection;
	      var callback = function callback(key, val) {
	        if (val.toString().indexOf('data') !== 0) {
	          res[val] = key;
	        }
	      };
	
	      // if (result && Object.keys(result).length !== 1 && result.data && result.data.length === 1) {
	      if (result && result.data && result.data.length === 1 && !result.obj) {
	        // Note: The below check has been made because minification converts the constructor name to a minified name
	        // which is not equal to 'Resource'. Hence the below condition fails in appStage=P
	        // if(result.data[0].constructor.name === 'Resource') {
	        // Since any instance of Resource is bound to have '$get' property attached to it, we have made the check for it.
	        if (result.data[0].$get || !_.isUndefined(options.attrs.fisSchemaData) && options.attrs.fisSchemaData !== 'none') {
	          res = [];
	          res.push(result.data[0]);
	          collection = res;
	        } else {
	          collection = result.data[0];
	        }
	      } else if (result && result.data && result.data.length === 0 && (_.isUndefined(options.attrs.fisSchemaData) || options.attrs.fisSchemaData === 'none')) {
	        _.each(result, callback);
	        collection = res;
	      } else if (result && result.data && result.data.length > 0) {
	        for (var i = 0; i < result.data.length; i++) {
	          var propLength = Object.keys(result.data[i]).length;
	          if (propLength === 1) {
	            _.each(result.data[i], callback);
	          } else if (propLength > 1) {
	            res = result.data;
	          }
	        }
	        collection = res;
	      } else if (result && result.obj) {
	        res = [];
	        res.push(result.obj);
	        collection = res;
	      } else {
	        collection = [];
	      }
	      return collection;
	    }
	
	    /*
	     * Translates kendo's options object to the expected fetchFn params (maps to request parameters for remote calls)
	     */
	    function translateOptions(options, expect) {
	      var params = {};
	      var val;
	      angular.forEach(expect, function (mapTo, param) {
	        if (angular.isString(mapTo)) {
	          val = $parse(mapTo)(options.data);
	        } else if (angular.isNumber(mapTo)) {
	          val = $parse(mapTo.toString())(options.data);
	        } else if (angular.isFunction(mapTo)) {
	          val = mapTo(options.data, params);
	        }
	
	        if (val !== undefined && val !== null) {
	          params[param] = stringify(val);
	        }
	      });
	      return params;
	    }
	
	    function stringify(val) {
	      if (val instanceof Date) {
	        // angular recognizes an ISO string as a date
	        return val.toISOString();
	      }
	      return val;
	    }
	
	    function processGroupAndSort(options) {
	      var groupAndSortObj = {};
	      var group;
	      var sort = [];
	      if (options.attrs.fisGroup) {
	        var displayField = options.dataTextField;
	        if (options.attrs.fisOptions) {
	          displayField = getDisplayField(options);
	        }
	
	        if (options.attrs.fisGroup.indexOf(',') === -1) {
	          group = $parse(options.attrs.fisGroup)(options.scope);
	        }
	
	        // if group is not defined as an object in partial, or in scope, it could be specified just as a field.
	        // in that case, create a group object and pass to datasource
	        if (!group) {
	          var groups = options.attrs.fisGroup.split(',');
	          group = [];
	          for (var i = 0; i < groups.length; i++) {
	            // eslint-disable-line block-scoped-var
	            group.push({ field: groups[i] }); // eslint-disable-line block-scoped-var
	          }
	        }
	
	        if (angular.isArray(group)) {
	          for (var i = 0; i < group.length; i++) {
	            // eslint-disable-line block-scoped-var, no-redeclare
	            sort.push({ field: group[i].field, dir: group[i].dir ? group[i].dir : 'asc' }); // eslint-disable-line block-scoped-var
	          }
	          if (group.length === 1) {
	            sort.push({ field: displayField, dir: group[0].dir ? group[0].dir : 'asc' });
	          }
	        } else {
	          var dir = group.dir ? group.dir : 'asc';
	          sort.push({ field: group.field, dir: dir });
	
	          sort.push({ field: displayField, dir: dir });
	        }
	
	        groupAndSortObj.group = group;
	        groupAndSortObj.sort = sort;
	      }
	      return groupAndSortObj;
	    }
	
	    function getDisplayField(options) {
	      var SG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))/;
	      var match = options.attrs.fisOptions.match(SG_OPTIONS_REGEXP);
	
	      var displayField;
	
	      var dispField = match[2] || match[1];
	      if (dispField) {
	        if (dispField.indexOf('.') > -1) {
	          displayField = dispField.substring(displayField.indexOf('.') + 1);
	        } else {
	          displayField = dispField;
	        }
	      }
	
	      return displayField;
	    }
	
	    return service;
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 18 */
/*!*****************************************************!*\
  !*** ./advancedsearch/advanced-search.directive.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$timeout", "fisCriteriaService", "fisConstraintsFactory", "$compile", "fisMemoryUtilService", function ($timeout, fisCriteriaService, fisConstraintsFactory, $compile, fisMemoryUtilService) {
	  'ngInject';
	
	  return {
	    restrict: 'AE',
	    // eslint-disable-next-line no-multi-str
	    template: '<div ng-form name="advancedSearchForm" class="form-inline fisAdvancedSearch">\
	                <div fis-select-field fis-size="mini" ng-model-input="criteria.operator" fis-suffix=" of the following are true" fis-data="operators" ng-change-input="conjunctionChanged(criteria)">\
	                </div> \
	                <div class="btn-group">\
	                    <button class="dropdown-toggle" aria-label="Add" fis-unique-id="renderMenuButton" data-toggle="dropdown" ng-click="renderMenu($event)"><i class="glyphicon glyphicon-plus"></i></button>\
	                    <ul class="dropdown-menu" ng-show="displayMenu">\
	                        <li fis-unique-id="addSingleConstraint" ng-click="addNewCriterion(criteria)">\
	                            <a href="">Add Single Constraint</a>\
	                        </li>\
	                        <li fis-unique-id="addAnyOrAllGroupConstraint" ng-click="addNewCriteria(criteria)">\
	                            <a href="">Add Any/All Group</a>\
	                        </li>\
	                    </ul>\
	                </div>\
	                <div>\
	                    <ul>\
	                        <li fis-hierarchy="item in criteria.operands" class="fis-criteria-operands">\
	                            <div>\
	                                <div ng-if="!!item.operands" class="fis-item-operand">\
	                                    <span>{{item.conjunction}}</span>\
	                                    <div fis-select-field fis-size="mini" ng-model-input="item.operator" fis-suffix=" of the following are true" ng-change-input="conjunctionChanged(item)" fis-data="operators">\
	                                    </div> \
	                                    <div class="btn-group">\
	                                        <button fis-unique-id="renderMenuButton" class="dropdown-toggle" data-toggle="dropdown" ng-click="renderMenu($event)"><i class="glyphicon glyphicon-plus"></i></button>\
	                                        <ul class="dropdown-menu" ng-show="displayMenu">\
	                                            <li fis-unique-id="addSingleConstraint" ng-click="addNewCriterion(item)">\
	                                                <a href="">Add Single Constraint</a>\
	                                            </li>\
	                                            <li fis-unique-id="addAnyOrAllGroupConstraint" ng-click="addNewCriteria(item)">\
	                                                <a href="">Add Any/All Group</a>\
	                                            </li>\
	                                        </ul>\
	                                    </div>\
	                                    <span>\
	                                        <button class="pull-right" fis-unique-id ng-click="remove(item)"><i class="glyphicon glyphicon-remove"></i> remove</button>\
	                                    </span>\
	                                </div>\
	                                <div ng-if="item.property !== undefined" class="fis-advanced-search-criterion">\
	                                    <span>{{item.conjunction}}</span>\
	                                    <div fis-select-field fis-size="medium" \
	                                        fis-unique-id="propertyField" ng-model-input="item.property" fis-options="title for field in possibleFields.data" placeholder-input="Choose a property">\
	                                    </div>\
	                                    <div fis-select-field fis-unique-id="constraintField" ng-model-input="item.constraint" fis-size="medium" tabindex="-1" ng-click="setEventTarget($event)" ng-change-input="constraintChanged(item)" ng-show="item.constraints.length > 0" fis-data="item.constraints || []">\
	                                    </div>\
	                                    <div fis-text-field fis-unique-id="valueField" ng-model-input="item.value" class="fis-advanced-search-value-field" ng-show-input="displayValueField(item)" fis-size="medium" ng-show-input="item.constraints.length > 0">\
	                                    </div>\
	                                    <span>\
	                                        <button class="pull-right" fis-unique-id  ng-click="remove(item)"><i class="glyphicon glyphicon-remove"></i> remove</button>\
	                                    </span>\
	                                </div>\
	                            </div>\
	                            <ul></ul>\
	                        </li>\
	                    </ul>\
	                </div>\
	            </div>',
	    scope: {
	      ngModel: '=',
	      fisImmediate: '@'
	    },
	    controller: ['$scope', '$element', '$attrs', function ($scope, $element, attrs) {
	      $scope.immediate = $scope.fisImmediate ? $scope.fisImmediate !== 'false' : true;
	
	      var constraintsWithoutValue = [fisCriteriaService.constraints.IS_EMPTY, fisCriteriaService.constraints.NOT_EMPTY, fisCriteriaService.constraints.IS_NULL, fisCriteriaService.constraints.NOT_NULL];
	
	      $scope.displayMenu = false;
	      $scope.possibleFields = null;
	      $scope.operators = [{ value: 'and', label: 'All' }, { value: 'or', label: 'Any' }];
	      var valueField;
	      var constraintValidateObj = {};
	
	      var fisData = $element.controller('fisData');
	
	      function setupDocumentClick() {
	        $(document).on('click', function ($ev) {
	          $scope.renderMenu($ev);
	        });
	      }
	
	      var loadedEventHandlers = false;
	      $scope.renderMenu = function ($ev) {
	        $scope.displayMenu = true;
	        if ($ev) {
	          var source = $($ev.currentTarget);
	          var sibling = source.next(); // dropdown
	          if ($ev && source.hasClass('dropdown-toggle') && !sibling.is(':visible')) {
	            sibling.show();
	            if (!loadedEventHandlers) {
	              setupDocumentClick();
	              loadedEventHandlers = true;
	            }
	          } else if ($ev && source.hasClass('dropdown-toggle') && sibling.is(':visible')) {
	            sibling.hide();
	          }
	          if (!$($ev.target).closest('.dropdown-toggle').length && !$(event.target).is('.dropdown-toggle')) {
	            // eslint-disable-line no-restricted-globals
	            var dropdown = $element.find('.dropdown-menu');
	            dropdown.hide();
	          }
	        }
	      };
	
	      function getEditorTemplate(property) {
	        if (property) {
	          var field = _.find($scope.possibleFields.data, function (possibleField) {
	            return possibleField.field === property;
	          });
	          if (field) {
	            return field.editorTemplate;
	          }
	        }
	        return null;
	      }
	
	      function changeValueType(arg) {
	        // This function is called initially for all rendered fields (for the case when criteria is already provided
	        // in ng-model) and is also called on any change event of the property fields. So argument can be either a
	        // jQuery event (called on change) or input type (called initially)
	        var target = {};
	        if (arg instanceof jQuery.Event) {
	          target = arg.target;
	        } else {
	          target = arg;
	        }
	        // retrieve the corresponding value field of the Criterion whose property was changed
	        valueField = angular.element(target).parents('div.fis-advanced-search-criterion').find('.fis-advanced-search-value-field');
	        var item = angular.element(valueField).scope().item;
	        var tempConstraints = _.pluck(item.constraints, 'value');
	        var editorTemplate = item.constraints[tempConstraints.indexOf(item.constraint)].template;
	        if (!constraintValidateObj[item.constraint]) {
	          constraintValidateObj[item.constraint] = {};
	        }
	        if (editorTemplate) {
	          constraintValidateObj[item.constraint].skipValidation = true;
	        } else {
	          constraintValidateObj[item.constraint].skipValidation = false;
	          editorTemplate = getEditorTemplate(item.property);
	        }
	
	        if (editorTemplate) {
	          changeEditorTemplate(editorTemplate, item);
	        } else {
	          // if editorTemplate is not provided, replace the value field with a simple text field
	          var compiledTextElement = $compile('<form name="valueForm" class="fis-advanced-search-value-field"><div fis-text-field ng-model-input="item.value" ng-show-input="displayValueField(item)" fis-size="medium"></form>')($scope.$parent.$new());
	          compiledTextElement.scope().item = item;
	          compiledTextElement.scope().displayValueField = $scope.displayValueField;
	          compiledTextElement.attr('style', 'display:inline');
	          angular.element(valueField).scope().$destroy();
	          angular.element(valueField).replaceWith(compiledTextElement);
	        }
	      }
	
	      // This function is used to update the editor template for the widget
	      function changeEditorTemplate(editorTemplate, item) {
	        // add additional attributes required to make it compliant with the fisAdvancedSearch widget
	        editorTemplate = angular.element(angular.element(editorTemplate).attr('ng-show', 'displayValueField(item)').attr('ng-model-input', 'item.value'));
	        // wrap the element with <form> tag so the the template of the control is compiled correctly
	        editorTemplate = editorTemplate.wrap('<form name="valueForm" class="fis-advanced-search-value-field"></form>').parent().prop('outerHTML');
	
	        // compile the template provided by user against a new (inherited) scope of parent scope
	        // this is done so that attributes like fisData are resolved against parent scope
	        var compiledElement = $compile(editorTemplate)($scope.$parent.$new());
	        // add additional styles to the value field to make it compliant with the fisAdvancedSearch widget
	        compiledElement.attr('ng-show', 'displayValueField(item)');
	        compiledElement.attr('style', 'display:inline');
	        compiledElement.scope().item = item;
	        compiledElement.scope().displayValueField = $scope.displayValueField;
	        // replace the previous value element with the newly compiled element
	        angular.element(valueField).replaceWith(compiledElement);
	      }
	
	      function addChangeListeners() {
	        // add change listeners for all property dropdrowns
	        var inputs = $element.find('div[fis-select-field][ng-model-input="item.property"]').find('input');
	        var inputsWithoutMarkerClass = _.find(inputs, function (input) {
	          return !angular.element(input).hasClass('fis-advanced-search-change-listener-added');
	        });
	        if (inputsWithoutMarkerClass) {
	          inputs.off('change', changeValueType);
	          inputs.on('change', changeValueType);
	          // add a marker class to indicate that listener has already been added (to avoid duplicate listeners)
	          inputs.addClass('fis-advanced-search-change-listener-added');
	          // change value fields depending on the type of property field
	          angular.forEach(inputs, function (input) {
	            changeValueType(input);
	          });
	        }
	      }
	
	      function applyConjunction(parent) {
	        if (parent.operands) {
	          for (var i = 0; i < parent.operands.length; i++) {
	            var operand = parent.operands[i];
	            if (i > 0 && angular.isUndefined(operand.conjunction) || operand.operands) {
	              operand.conjunction = parent.operator;
	              applyConjunction(operand);
	            }
	          }
	        }
	      }
	
	      // initialize and add the change listeners for the first time
	      var changeListenersTimeout = $timeout(addChangeListeners, 0);
	      fisMemoryUtilService.cancelTimeoutOnDestroy($scope, changeListenersTimeout, $timeout);
	
	      $scope.displayValueField = function (item) {
	        if (!item.constraints || item.constraints.length === 0) {
	          return false;
	        }
	        return !_.contains(constraintsWithoutValue, item.constraint);
	      };
	
	      $scope.constraintChanged = function (item) {
	        var tempConstraints = _.pluck(item.constraints, 'value');
	        var newEditorTemplate = item.constraints[tempConstraints.indexOf(item.constraint)].template;
	        if (!constraintValidateObj[item.constraint]) {
	          constraintValidateObj[item.constraint] = {};
	        }
	        if (newEditorTemplate) {
	          constraintValidateObj[item.constraint].skipValidation = true;
	          changeEditorTemplate(newEditorTemplate, item);
	        } else {
	          constraintValidateObj[item.constraint].skipValidation = false;
	          var originalEditorTemplate = getEditorTemplate(item.property);
	          if (originalEditorTemplate) {
	            changeEditorTemplate(originalEditorTemplate, item);
	          }
	        }
	        if (_.contains(constraintsWithoutValue, item.constraint)) {
	          item.value = '';
	        }
	      };
	
	      // This function is used to get the valueField element when user clicks on the constraints list select field widget
	      $scope.setEventTarget = function ($event) {
	        valueField = angular.element($event.target).parents('div.fis-advanced-search-criterion').find('.fis-advanced-search-value-field');
	      };
	
	      fisData.fetchData().then(function (result) {
	        $scope.possibleFields = result;
	      }, function (result) {
	        console.warn('Problem loading data: ' + result);
	      });
	
	      var criteriaWatch = $scope.$watch('criteria', function (changedCriteria) {
	        if (changedCriteria && changedCriteria.isValid) {
	          setConstraintsAndDataType(changedCriteria);
	          for (var count = 0; count < changedCriteria.operands.length; count++) {
	            var tempOperand = changedCriteria.operands[count];
	            if (constraintValidateObj[tempOperand.constraint]) {
	              tempOperand.skipValidation = constraintValidateObj[tempOperand.constraint].skipValidation;
	            }
	          }
	          // if scope.immediate is true, then only apply the current criteria to the model
	          if ($scope.immediate && changedCriteria.isValid()) {
	            $scope.ngModel = angular.copy(changedCriteria);
	          }
	        }
	      }, true);
	      fisMemoryUtilService.cancelWatchOnDestroy($scope, criteriaWatch);
	
	      if (!$scope.ngModel) {
	        $scope.criteria = fisCriteriaService.newCriteria();
	      }
	
	      var modelWatch = $scope.$watch('ngModel', function (newVal) {
	        // this check is made so that the criteria object is not recreated every time model is changed
	        // when scope.criteria and ngModel's value is different, it means that it was triggered by changing the
	        // ngModel directly (from user's controller)
	        if (JSON.stringify(newVal) !== JSON.stringify($scope.criteria)) {
	          var newCriteria = newVal;
	          if (!(newCriteria instanceof fisCriteriaService.Criteria)) {
	            newCriteria = fisCriteriaService.newCriteria(newVal);
	          }
	          if (newCriteria.isValid()) {
	            applyConjunction(newCriteria);
	            $scope.criteria = angular.copy(newCriteria);
	          }
	          var changeListenersTimeout = $timeout(addChangeListeners, 0);
	          fisMemoryUtilService.cancelTimeoutOnDestroy($scope, changeListenersTimeout, $timeout);
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy($scope, modelWatch);
	
	      $scope.addNewCriterion = function (parent) {
	        var criterion = new fisCriteriaService.Criterion();
	        criterion.property = $scope.possibleFields.data[0].field;
	        $scope.displayMenu = false;
	        parent.operands.push(criterion);
	        if (parent.operands.length > 1) {
	          criterion.conjunction = parent.operator;
	        }
	        // add the change listener and change value field for the newly added criterion
	        var newCriterionTimeout = $timeout(function () {
	          var inputs = $element.find('div[fis-select-field][ng-model-input="item.property"]').find('input');
	          angular.forEach(inputs, function (input) {
	            input = angular.element(input);
	            // add the listener only for property fields which do not have listener added
	            if (!input.hasClass('fis-advanced-search-change-listener-added')) {
	              input.on('change', changeValueType);
	              input.addClass('fis-advanced-search-change-listener-added');
	              changeValueType(input);
	            }
	          });
	        }, 0);
	        fisMemoryUtilService.cancelTimeoutOnDestroy($scope, newCriterionTimeout, $timeout);
	      };
	
	      $scope.addNewCriteria = function (parent) {
	        var critGrp = fisCriteriaService.newCriteria();
	        $scope.displayMenu = false;
	        parent.operands.push(critGrp);
	        if (parent.operands.length > 1) {
	          critGrp.conjunction = parent.operator;
	        }
	      };
	
	      $scope.conjunctionChanged = function (parent) {
	        angular.forEach(parent.operands, function (operand) {
	          if (operand.conjunction) {
	            operand.conjunction = parent.operator;
	          }
	        });
	      };
	
	      $scope.remove = function (item) {
	        findAndRemoveItem(item, $scope.criteria);
	      };
	
	      function getDataType(property) {
	        for (var j = 0; j < $scope.possibleFields.data.length; j++) {
	          if (property === $scope.possibleFields.data[j].field) {
	            return $scope.possibleFields.data[j].dataType;
	          }
	        }
	        return null;
	      }
	
	      function setCorrectConstraint(operand) {
	        var validConstraint = _.find(operand.constraints, function (constraint) {
	          return constraint.value === operand.constraint;
	        });
	        if (!validConstraint) {
	          operand.constraint = operand.constraints[0].value;
	        }
	      }
	
	      function setConstraintsAndDataType(criteria) {
	        if (criteria && criteria.operands) {
	          for (var i = 0; i < criteria.operands.length; i++) {
	            var operand = criteria.operands[i];
	            if (constraintValidateObj[operand.constraint] && constraintValidateObj[operand.constraint].skipValidation) {
	              operand.skipValidation = true;
	            } else {
	              operand.skipValidation = false;
	            }
	
	            setConstraintsAndDataType(operand);
	            var property = operand.property;
	            if (property) {
	              var dataType = null;
	              if ($scope.possibleFields) {
	                dataType = getDataType(property);
	              }
	              operand.type = dataType || 'string';
	              operand.constraints = fisConstraintsFactory.getConstraintsByType(operand.type);
	              setCorrectConstraint(operand);
	            } else {
	              operand.constraints = [];
	            }
	            var k = i + 1;
	            var nextOperand = criteria.operands[k];
	            if (nextOperand) {
	              setConstraintsAndDataType(nextOperand);
	            }
	          }
	        }
	      }
	
	      function findAndRemoveItem(item, parent) {
	        var indexToSplice = -1;
	        for (var i = 0; i < parent.operands.length; i++) {
	          if (item === parent.operands[i]) {
	            indexToSplice = i;
	            break;
	          }
	        }
	        if (indexToSplice > -1) {
	          parent.operands.splice(indexToSplice, 1);
	        } else {
	          for (var j = 0; j < parent.operands.length; j++) {
	            if (parent.operands[j].operands) {
	              findAndRemoveItem(item, parent.operands[j]);
	            }
	          }
	        }
	      }
	
	      if (!$scope.immediate) {
	        $scope.$on('fisAdvancedSearch.apply', function () {
	          $scope.applySearch();
	        });
	      }
	
	      $scope.applySearch = function () {
	        $scope.criteria.validate();
	        $scope.ngModel = angular.copy($scope.criteria);
	
	        // TODO need to add timeout to invoke an apply cycle, since the value of fisCriteria gets changed in
	        // the next apply cycle. If removed, fisCriteria changes are reflected on first event after clicking on
	        // the apply button.
	        var searchTimeout = $timeout(function () {
	          // only invoke an apply cycle...
	        }, 0);
	        fisMemoryUtilService.cancelTimeoutOnDestroy($scope, searchTimeout, $timeout);
	      };
	
	      function resetCriteria(data) {
	        if (data) {
	          $scope.possibleFields = data;
	          $scope.criteria = fisCriteriaService.newCriteria();
	          $scope.ngModel = angular.copy($scope.criteria);
	        }
	      }
	
	      // Handle runtime fisData change
	      var dataWatch = $scope.$watch(attrs.fisData, function (data, oldData) {
	        if (!_.isEqual(data, oldData) && oldData) {
	          resetCriteria(data);
	        }
	      }, true);
	      fisMemoryUtilService.cancelWatchOnDestroy($scope, dataWatch);
	
	      fisData.addDataChangedListener(function (data) {
	        resetCriteria(data);
	      });
	    }]
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 19 */
/*!*******************************!*\
  !*** ./autocomplete/index.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _base = __webpack_require__(/*! ../base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _data = __webpack_require__(/*! ../data */ 9);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _autoCompleteField = __webpack_require__(/*! ./auto-complete-field.directive */ 20);
	
	var _autoCompleteField2 = _interopRequireDefault(_autoCompleteField);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.autocomplete', [_base2.default, _data2.default]);
	
	ngModule.directive('fisAutocompleteField', _autoCompleteField2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 20 */
/*!*******************************************************!*\
  !*** ./autocomplete/auto-complete-field.directive.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* global $, _, kendo, fis */
	/**
	 * @name fisAutocomplete
	 * @description Defining directive the autocomplete selection. Requires the input data to be specified in a precise manner eg [{id:'id1',name:'Blurb1',description:'Describe blurb1'},{id:'id2',name:'Blurb2',description:'Describe blurb2'}]
	 */
	
	
	exports.default = ["fisKendoDataSourceFactory", "fisFieldDirectiveFactory", "fisMemoryUtilService", "$timeout", "$window", "$sanitize", "$parse", function (fisKendoDataSourceFactory, fisFieldDirectiveFactory, fisMemoryUtilService, $timeout, $window, $sanitize, $parse) {
	  'ngInject';
	  /**
	   * Function to highlight fisAutocomplete suggestion option list
	   * Function definition required in window scope due to kendo autocompelete widget option list present in window scope
	   */
	
	  var highlightSgAutoCompleteSuggestions = function highlightSgAutoCompleteSuggestions(itemText, element) {
	    var text = element.val();
	    var widget = element.data('kendoAutoComplete');
	    var textMatcher = new RegExp(text, 'ig');
	    if (!_.isUndefined(widget) && !_.isUndefined(widget.options.filter) && widget.options.filter === 'startswith') {
	      textMatcher = new RegExp('^' + text, 'i');
	    }
	    var sanitizedItemText = $sanitize(itemText);
	    return sanitizedItemText.replace(textMatcher, function (match) {
	      return '<strong>' + match + '</strong>';
	    });
	  };
	
	  $window.highlightSgAutoCompleteSuggestions = highlightSgAutoCompleteSuggestions;
	
	  // eslint-disable-next-line no-multi-str
	  var templateText = '<div><div class="fis-autocomplete-item"><table class="fis-autocomplete-list-item-table"><tr> \
	                <td class="fis-autocomplete-spacer"></td>\
	                <td class="fis-autocomplete-first">\
	                    # if (data.<%= fisFilterField %>) { # \
	                            #= highlightSgAutoCompleteSuggestions(data.<%= fisDisplayField %>, this) # \
	                        # } else {# \
	                            #= highlightSgAutoCompleteSuggestions(data, this) # \
	                        # }# \
	                    </td> \
	                    <%= markup %> \
	                    <td class="fis-autocomplete-spacer"></td>\
	                    <tr></table></div>\
	                </div></div>';
	  // eslint-disable-next-line no-multi-str
	  var fisDescSimpleTemplate = '# if (data.<%= fisDescriptionField %>) { # \
	                    <td class="fis-autocomplete-spacer"></td>\
	                    <td class="fis-autocomplete-second">\
	                        #= highlightSgAutoCompleteSuggestions(data.<%= fisDescriptionField %>, this) # \
	                    </td> \
	                # }# \
	            ';
	  // eslint-disable-next-line no-multi-str, no-useless-escape
	  var fisDescExpressionTemplate = '\<td class="fis-autocomplete-spacer"></td>\
	              <td class="fis-autocomplete-second">\
	                #= highlightSgAutoCompleteSuggestions(data.<%= firstField %>, this) # - #= highlightSgAutoCompleteSuggestions(data.<%= secondField %>, this) # \
	              </td> \
	             ';
	  var templateFn = _.template(templateText);
	  var fisDescSimpleTemplateFn = _.template(fisDescSimpleTemplate);
	  var expressionTemplateFn = _.template(fisDescExpressionTemplate);
	
	  return fisFieldDirectiveFactory.create({
	    // eslint-disable-next-line no-multi-str
	    editTemplate: '<div class="fis-autocomplete <% if(field.attrs.fisSize) {%>fis-autocomplete-<%=field.attrs.fisSize%><% } else {%>fis-autocomplete-large<% }%>">\
	                <% if (field.attrs.fisPrefix){ %><span class="add-on"><%- field.attrs.fisPrefix %></span> <% } %>\
	                <input fis-input="input" ng-model-options="{ updateOn:\'submit change\', debounce:{  submit:0, change:1 } }" type="text" class="<% if(field.attrs.fisSize) {%>fis-autocomplete-<%=field.attrs.fisSize%><% } else {%>fis-autocomplete-large<% }%>"/>\
	                <% if (field.attrs.fisSuffix){ %><span class="add-on"><%- field.attrs.fisSuffix %></span> <% } %></div>',
	    // eslint-disable-next-line no-multi-str
	    viewTemplate: '<% if (field.attrs.fisPrefix){ %><span class="add-on"><%- field.attrs.fisPrefix %></span> <% } %>\
	                {{fieldValue()}}\
	          <% if (field.attrs.fisSuffix){ %><span class="add-on"><%- field.attrs.fisSuffix %></span> <% } %>',
	    fieldValue: function fieldValue(scope, element, attrs, models) {
	      if (models[0] !== undefined) {
	        if (typeof models[0].$modelValue === 'string') {
	          return models[0] && models[0].$modelValue || '';
	        }
	      }
	
	      return models[0] && models[0].$modelValue && models[0].$modelValue[attrs.fisDisplayField] || '';
	    },
	    require: ['fisData', '?fisRefresh'],
	    link: function link(scope, element, attrs, ctrls) {
	      var fisData = ctrls[0];
	      var fisRefresh = ctrls[1];
	      addClasses(element, attrs);
	
	      var input = element.find('input');
	      var ngModel;
	      // provide a default value for the minimum length
	      var fisMinLength = attrs.fisMinLength ? parseInt(attrs.fisMinLength, 10) : 3;
	      // set select to default to single selection
	      scope.fisSeparator = '';
	
	      // set on which field to search on
	      var fisFilterField = attrs.fisFilterField || 'name';
	      var fisDisplayField = attrs.fisDisplayField || fisFilterField;
	      var fisUpdateObject = attrs.fisUpdateObject && attrs.fisUpdateObject === 'true';
	      var fisDescriptionField = attrs.fisDescriptionField || 'description';
	      // set mode to default to restrict selection datalist options
	      // fisSelectMode defaults to true
	      scope.fisSelectMode = attrs.fisSelectMode && attrs.fisSelectMode === 'true' || !attrs.fisSelectMode;
	
	      ngModel = getNgModel(input, attrs, scope);
	
	      // provide a default placeholder value for the input textboxes
	      var fisPlaceholder = attrs.placeholderInput || '';
	
	      // provide a default value for the filter option
	      var fisFilter = attrs.fisFilter || 'contains';
	
	      var fisLowerCase = attrs.fisLowerCase || 'true';
	
	      // fisColumns implementation starts here
	      var columns = attrs.fisColumns;
	      columns = $parse(columns)(scope);
	      var headerTemp;
	      var template;
	      var inlineTemplate;
	      if (columns) {
	        headerTemp = '<div class="dropdown-header"><table style="width: 100%;"><tbody><tr>';
	
	        template = '<table style="width: 100%;"><tbody><tr>';
	        for (var count = 0; count < columns.length; count++) {
	          var col = columns[count];
	
	          var field = col.field;
	          var width = col.width ? col.width + '%' : 100 / columns.length + '%';
	          if (columns.length > 1) {
	            headerTemp = headerTemp + '<td class="k-widget k-header autocomplete-columns-header" style="width: ' + width + ';">' + col.title + '</td>';
	          }
	
	          if (!angular.isUndefined(col.template)) {
	            // eslint-disable-line no-negated-condition
	            template = template + '<td class="autocomplete-columns-items ' + col.cls + '" style="width: ' + width + ';">' + col.template + '</td>';
	          } else {
	            template = template + '<td class="autocomplete-columns-items ' + col.cls + '" style="width: ' + width + ';">#= data.' + field + ' || ""#</td>';
	          }
	        }
	        template += '</tr></tbody></table>';
	        headerTemp += '</tr></tbody></table></div>';
	      } else {
	        // define a special template that, depending on the parameters specified for each data element, adjusts itself appropriately
	        inlineTemplate = createItemTemplate(fisFilterField, fisDisplayField, fisDescriptionField, input);
	      }
	      // fisColumns implementation ends here
	
	      var dataSourceOptions = {};
	
	      dataSourceOptions.serverFiltering = attrs.fisServerFiltering === 'true';
	
	      var parameters = {};
	
	      if (dataSourceOptions.serverFiltering) {
	        parameters.q = 'filter.filters[0].value';
	      }
	
	      var dataSource = fisKendoDataSourceFactory.createListDataSource(fisData.fetchData, parameters, dataSourceOptions);
	
	      // Setup loading indicator
	      fisData.addBeforeFetchListener(function () {
	        input.addClass('fis-working-indicator');
	      });
	
	      fisData.addAfterFetchListener(function () {
	        input.removeClass('fis-working-indicator');
	      });
	      var selectedDataItem; // eslint-disable-line no-unused-vars
	      var blurAndCloseOptions = {
	        input: input,
	        scope: scope,
	        ngModel: ngModel,
	        dataSource: dataSource,
	        fisFilterField: fisFilterField,
	        fisUpdateObject: fisUpdateObject,
	        fisDisplayField: fisDisplayField,
	        fisMinLength: fisMinLength,
	        ignoreCase: fisLowerCase !== 'false',
	        filter: fisFilter
	      };
	
	      input.kendoAutoComplete({
	        filter: fisFilter,
	        dataSource: dataSource,
	        minLength: fisMinLength,
	        placeholder: fisPlaceholder,
	        headerTemplate: headerTemp ? headerTemp : undefined,
	        separator: scope.fisSeparator,
	        dataTextField: fisFilterField,
	        template: template ? template : inlineTemplate,
	        ignoreCase: fisLowerCase !== 'false',
	        select: function select(e) {
	          // Indicate that a value has been selected. This is required for only updating the model
	          // in select mode once a value has been selected by the user.
	          scope.valueWasSelected = true;
	          if (e && e.item) {
	            blurAndCloseOptions.selectedDataItem = this.dataItem(e.item.index());
	          }
	        },
	        close: getCloseCallback(blurAndCloseOptions)
	      });
	
	      // the above style manipulation removes unwanted styling, so we are left with just enough to suit camino
	      var autocomplete = input.data('kendoAutoComplete');
	
	      var refresh = function refresh(event) {
	        // do not execute the event if event.preventDefault() has been called before
	        if (event && event.defaultPrevented) {
	          return;
	        }
	
	        // Need to add a timeout here to ensure any digest operations on the scope happened before
	        var refreshTimeout = $timeout(function () {
	          // set oldData to  undefined
	          delete scope.oldData;
	          dataSource.read();
	        });
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, refreshTimeout, $timeout);
	      };
	
	      // listen for the fisRefresh event
	      scope.$on('fisRefresh', refresh);
	
	      // redefine the fisRefresh function if it is put on the same element
	      if (fisRefresh) {
	        fisRefresh.trigger = refresh;
	      }
	      // Apply stylesheet/css when element gets rendered and stylesheet loaded
	      $timeout(function () {
	        // We have to set the width programmatically on the kendo component
	        var wrapperWidth = parseFloat(autocomplete.wrapper.width()); // get widgets width
	        autocomplete.list.css('width', 'auto').css('min-width', wrapperWidth);
	        // add class to allow styling of animation container specifically for autocomplete
	        autocomplete.list.find('ul').addClass('fis-autocomplete-ul-animation');
	      }, 0);
	      var idTimeout = $timeout(function () {
	        if (autocomplete && fis.initParams().appStage === 'T') {
	          var parentSdId = autocomplete.element.attr('fisid');
	          autocomplete.list.find('ul').attr('fisid', parentSdId + '_list_');
	        }
	      }, 0);
	      fisMemoryUtilService.cancelTimeoutOnDestroy(scope, idTimeout, $timeout);
	      // add blur callback
	      input.on('blur', getOnBlurCallback(blurAndCloseOptions));
	      /**
	       * @name resize
	       * @methodOf fisAutocompleteField
	       * @description
	       * <p>Resizes the width of the drop down list to match the autocomplete </p>
	       */
	      scope.resize = function (width) {
	        var container = $(autocomplete.parentElement).removeAttr('class'); // remove kendo autocomplete styling
	        container.css('width', width);
	        var autoInput = $(autocomplete.element[0]); // get input
	        autoInput.removeAttr('class'); // remove kendo autocomplete styling
	        autoInput.css('width', width); // autocomplete
	        // autocomplete.list.css('min-width', ''); // SDHTML-10094. Only input re-sizes, not the list
	        // eslint-disable-next-line radix
	        var diff = parseInt(autoInput.css('padding-left')) + parseInt(autoInput.css('padding-right')); // accounts difference in padding
	        autocomplete.wrapper.css('width', width + diff);
	        autocomplete.list.css('width', width + diff);
	      };
	      // $destroy event, broadcasted when a parent scope is being destroyed
	      scope.$on('$destroy', function () {
	        fisMemoryUtilService.destroyKendoWidgets(autocomplete);
	      });
	
	      function initializeModel(ngModel) {
	        // initialize ngModel and autoComplete element
	        if (fisDisplayField) {
	          var models = scope.$parent.$eval(ngModel);
	          if ((typeof models === 'undefined' ? 'undefined' : _typeof(models)) === 'object') {
	            input.val(models[fisDisplayField]);
	            updateModel(models, blurAndCloseOptions);
	          }
	        }
	      }
	
	      var watch1 = scope.$watch(attrs.ngModelInput, function () {
	        var modelValue = ngModel.$modelValue;
	        if (!modelValue) {
	          // eslint-disable-line no-negated-condition
	          initializeModel(ngModel);
	        } else {
	          if ((typeof modelValue === 'undefined' ? 'undefined' : _typeof(modelValue)) === 'object') {
	            // eslint-disable-line no-lonely-if
	            input.val(modelValue[fisDisplayField]);
	          }
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, watch1);
	    }
	  });
	
	  function addClasses(element, attrs) {
	    var wrap = element.find('.fis-inputs');
	    if (attrs.fisPrefix) {
	      wrap.addClass('input-prepend');
	    }
	    if (attrs.fisSuffix) {
	      wrap.addClass('input-append');
	    }
	    element.find('.controls').addClass('fis-autocomplete-fixed-height');
	  }
	
	  function getNgModel(input, attrs, scope) {
	    var ngModel = input.controller('ngModel');
	    if (!ngModel) {
	      throw new Error('ngModel required on autocomplete.');
	    }
	
	    ngModel.$parsers.unshift(function (value) {
	      // parsers: DOM -> Model
	
	      // In select mode: Only update the model once the user has actually selected a value.
	      // If the user is still typing, the model shouldn't be updated.
	      if (scope.fisSelectMode) {
	        // Check whether the user has selected a value
	        // Or if the value is empty, which means that the user has completely erased the text.
	        if (scope.valueWasSelected || !value) {
	          // If a value has been selected, return it (it's in the provided value parameter) at the end
	          // of the method.
	          // Reset the flag to make sure we're ready for the next selection
	          scope.valueWasSelected = false;
	        } else {
	          // If he hasn't done so, simply return the existing model value, nothing has changed.
	          value = ngModel.$modelValue;
	        }
	      }
	
	      // if its single - leave it as string, if its multi split on the separator
	      // preventing multi functionality SDHTML-1616
	      // eslint-disable-next-line no-constant-condition
	      if (false) {
	        // attrs.fisMulti && attrs.fisMulti === 'true' && value !== '') {
	        // now update the datamodel with an array of values
	        if (value.split) {
	          value = value.split(',');
	        }
	      }
	      return value;
	    });
	    return ngModel;
	  }
	
	  function createItemTemplate(fisFilterField, fisDisplayField, fisDescriptionField, input) {
	    var finalTemplateMarkup;
	    if (fisDescriptionField.indexOf('#=') !== -1) {
	      // eslint-disable-line no-negated-condition
	      var parts = fisDescriptionField.split('- ');
	      var firstField = parts[0].substr(parts[0].indexOf('#=') + 2, parts[0].indexOf(' #') - 2);
	      var secondField = parts[1].substr(parts[1].indexOf('#=') + 2, parts[1].indexOf(' #') - 2);
	      finalTemplateMarkup = templateFn({
	        markup: expressionTemplateFn({
	          firstField: firstField,
	          secondField: secondField
	        }),
	        fisFilterField: fisFilterField,
	        fisDisplayField: fisDisplayField
	      });
	    } else {
	      var markup = fisDescSimpleTemplateFn({
	        fisDescriptionField: fisDescriptionField
	      });
	      finalTemplateMarkup = templateFn({
	        markup: markup,
	        fisFilterField: fisFilterField,
	        fisDisplayField: fisDisplayField
	      });
	    }
	
	    return $.proxy(kendo.template(finalTemplateMarkup), input);
	  }
	
	  // switch between updating model with value or object - depending on fisUpdateObject attribute
	  function updateModel(item, options) {
	    if (options.fisUpdateObject || item === '' || _.isUndefined(item)) {
	      options.scope.valueWasSelected = true;
	      // if we updating the object, we update to '' rather than undefined
	      if (_.isUndefined(item)) {
	        item = '';
	      }
	      options.ngModel.$setViewValue(item);
	      options.ngModel.$commitViewValue();
	    } else if (item) {
	      if (typeof item === 'string' && !options.scope.fisSelectMode) {
	        options.scope.valueWasSelected = true;
	
	        options.ngModel.$setViewValue(item);
	        options.ngModel.$commitViewValue();
	      } else {
	        options.scope.valueWasSelected = true;
	
	        options.ngModel.$setViewValue(item[options.fisDisplayField]);
	        options.ngModel.$commitViewValue();
	      }
	    }
	
	    applyScope(options.scope);
	  }
	
	  function getModelValue(options) {
	    // eslint-disable-line no-unused-vars
	    return options.ngModel.$viewValue;
	  }
	
	  function applyScope(scope) {
	    if (!scope.$$phase) {
	      scope.$apply();
	    }
	  }
	
	  function findItems(searchValue, filterField, data) {
	    var returnValues = [];
	    angular.forEach(data, function (listItem) {
	      if (searchValue === listItem[filterField].toString()) {
	        returnValues.push(listItem);
	      }
	    });
	    return returnValues;
	  }
	
	  function validateInputLength(value, minLength) {
	    if (value.length < minLength) {
	      return '';
	    }
	
	    return value;
	  }
	
	  function getValueToDisplay(value, fisDisplayField) {
	    if (value === undefined) {
	      return '';
	    }
	
	    if (typeof value === 'string') {
	      return value;
	    } else {
	      // eslint-disable-line no-else-return
	      return value[fisDisplayField];
	    }
	  }
	
	  /* We need to provide the field here since this method is called from onBlur and onClose.
	   When called from onBlur it is called with the display field - because the value already contains the display
	   field value.
	   When called from onClose it is called with the search field - since this is what has just been entered
	    */
	  function getValueObject(value, options, field) {
	    var totalMatches = options.dataSource.view().length;
	    var result;
	    var selectedObject = options.selectedDataItem;
	
	    if (options.scope.fisSelectMode) {
	      if (totalMatches > 1) {
	        // Someone could have manually selected an item in the list -> search for one perfect match
	        var matchedItems = findItems(value, field, options.dataSource.view());
	
	        if (matchedItems.length === 1) {
	          result = matchedItems[0];
	        } else {
	          // more than one match. return selectedObject.
	          // need to check why this needs to be done in 'close' callback and why 'select' callback is not used right from the start
	          result = selectedObject;
	        }
	      } else if (totalMatches === 1) {
	        result = options.dataSource.view()[0];
	      } else {
	        // In select mode and no matches - set to undefined
	        result = undefined;
	      }
	    } else {
	      if (totalMatches > 0) {
	        // eslint-disable-line no-lonely-if
	        var perfectMatch = findItems(value, field, options.dataSource.view());
	        if (perfectMatch && perfectMatch.length === 1) {
	          // Suggest mode - When there is a perfect match - it must be used
	          result = perfectMatch[0];
	        } else {
	          // Suggest mode - no perfect match - take what was entered
	          result = value;
	        }
	      } else {
	        // Suggest mode - Nothing matched so use what was entered
	        result = value;
	      }
	    }
	
	    return result;
	  }
	
	  function filterAgain(value, options) {
	    // Avoid side effects of changing the filter by saving and restoring it
	    var filterSave = options.dataSource.filter();
	    var newFilter = {
	      value: options.ignoreCase ? value.toLowerCase() : value,
	      operator: options.filter,
	      field: options.fisFilterField
	    };
	    if (options.fisDisplayField !== options.fisFilterField) {
	      // If displayField and filterField are different, we can not be sure whether
	      // the user searched for something and tabbed out too quickly (value is filterField property)
	      // or whether the user just focused an already populated autocomplete and #
	      // tabbed out (value is displayField property)
	      // Thus we need to filter for both
	      newFilter = {
	        logic: 'or', filters: [newFilter, {
	          value: value,
	          operator: 'equals',
	          field: options.fisDisplayField
	        }]
	      };
	    }
	
	    options.dataSource.filter(newFilter);
	
	    // dataSource filtering occurs asynchronously
	    // i.e. we need to use the fetch function to
	    // update model after the dataSource is populated.
	    options.dataSource.fetch(function () {
	      var valueObject = getValueObject(value, options, options.fisDisplayField);
	      var valueToDisplay = getValueToDisplay(valueObject, options.fisDisplayField);
	      options.input.val(valueToDisplay);
	      updateModel(valueObject, options);
	      options.dataSource.view().length = 0;
	      options.dataSource.filter(filterSave); // Reset the filter, so kendo autocomplete doesn't notice
	    });
	  }
	
	  function getOnBlurCallback(options) {
	    if (options.scope.fisSelectMode) {
	      // Select Mode
	      return function () {
	        var value = options.input.val();
	
	        value = validateInputLength(value, options.fisMinLength);
	        var valueObject = value; // eslint-disable-line block-scoped-var
	
	        if (value.indexOf('{{') >= 0 && value.indexOf('}}') >= 0) {
	          // IE 9 fix placeholder(expression) being evaluated/set as value
	          value = '';
	        }
	
	        if (value && value !== '') {
	          if (options.dataSource.view().length === 0) {
	            /*
	            This can happen when the user typed to quickly for the popup to open and
	            then tabbed out or when he just clicked into the element again - so let's filter again
	             */
	            filterAgain(value, options);
	          } else {
	            var valueObject = getValueObject(value, options, options.fisDisplayField); // eslint-disable-line no-redeclare
	            var valueToDisplay = getValueToDisplay(valueObject, options.fisDisplayField);
	            options.input.val(valueToDisplay);
	            updateModel(valueObject, options);
	            options.dataSource.view().length = 0;
	          }
	        } else {
	          options.input.val(value);
	          updateModel(value, options);
	          options.dataSource.view().length = 0;
	        }
	      };
	    } else {
	      // eslint-disable-line no-else-return
	      return function () {
	        var value = options.input.val();
	
	        var valueObject = getValueObject(value, options, options.fisDisplayField);
	
	        if (valueObject) {
	          updateModel(valueObject, options);
	        } else {
	          options.ngModel.$setViewValue(value);
	          options.ngModel.$commitViewValue();
	        }
	
	        applyScope(options.scope);
	
	        options.dataSource.view().length = 0;
	      };
	    }
	  }
	
	  function getCloseCallback(options) {
	    // The close event is triggered when the autocomplete search result window closes after
	    // A - the user tabbed out
	    // B - the user selected one item from the list
	    // C - the user typed too much and no item matches anymore
	    return function () {
	      var value = options.input.val();
	
	      if (options.scope.fisSelectMode) {
	        value = validateInputLength(value, options.fisMinLength);
	      }
	
	      var valueObject = value;
	
	      if (value && value !== '') {
	        valueObject = getValueObject(value, options, options.fisFilterField);
	      }
	
	      if (valueObject) {
	        var valueToDisplay = getValueToDisplay(valueObject, options.fisDisplayField);
	
	        options.input.val(valueToDisplay);
	
	        updateModel(valueObject, options);
	      } else {
	        options.ngModel.$setViewValue(value);
	        options.ngModel.$commitViewValue();
	      }
	    };
	  }
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 21 */
/*!***********************!*\
  !*** ./date/index.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _base = __webpack_require__(/*! ../base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _util = __webpack_require__(/*! ../util */ 22);
	
	var _util2 = _interopRequireDefault(_util);
	
	var _dateFormat = __webpack_require__(/*! ./date-format.directive */ 26);
	
	var _dateFormat2 = _interopRequireDefault(_dateFormat);
	
	var _dateFormat3 = __webpack_require__(/*! ./date-format.filter */ 27);
	
	var _dateFormat4 = _interopRequireDefault(_dateFormat3);
	
	var _datePickerField = __webpack_require__(/*! ./date-picker-field.directive */ 28);
	
	var _datePickerField2 = _interopRequireDefault(_datePickerField);
	
	var _dateTimeFormat = __webpack_require__(/*! ./date-time-format.directive */ 29);
	
	var _dateTimeFormat2 = _interopRequireDefault(_dateTimeFormat);
	
	var _dateTimeFormat3 = __webpack_require__(/*! ./date-time-format.provider */ 30);
	
	var _dateTimeFormat4 = _interopRequireDefault(_dateTimeFormat3);
	
	var _dateTimePickerField = __webpack_require__(/*! ./date-time-picker-field.directive */ 31);
	
	var _dateTimePickerField2 = _interopRequireDefault(_dateTimePickerField);
	
	var _date = __webpack_require__(/*! ./date.filter */ 32);
	
	var _date2 = _interopRequireDefault(_date);
	
	var _year = __webpack_require__(/*! ./year.filter */ 33);
	
	var _year2 = _interopRequireDefault(_year);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.date', [_base2.default, _util2.default]);
	
	ngModule.directive('fisDateFormat', _dateFormat2.default);
	ngModule.filter('getDateFormatForKendo', _dateFormat4.default);
	ngModule.directive('fisDatePickerField', _datePickerField2.default);
	ngModule.directive('fisDateTimeFormat', _dateTimeFormat2.default);
	ngModule.provider('fisDateTimeFormatService', _dateTimeFormat4.default);
	ngModule.directive('fisDateTimePickerField', _dateTimePickerField2.default);
	ngModule.filter('fisDate', _date2.default);
	ngModule.filter('padYear', _year2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 22 */
/*!***********************!*\
  !*** ./util/index.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _base = __webpack_require__(/*! ../base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _kendoUtil = __webpack_require__(/*! ./kendo-util.controller */ 23);
	
	var _kendoUtil2 = _interopRequireDefault(_kendoUtil);
	
	var _kendoUtil3 = __webpack_require__(/*! ./kendo-util.provider */ 24);
	
	var _kendoUtil4 = _interopRequireDefault(_kendoUtil3);
	
	var _util = __webpack_require__(/*! ./util.run */ 25);
	
	var _util2 = _interopRequireDefault(_util);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.util', [_base2.default]);
	
	ngModule.controller('fis.kendo.UtilController', _kendoUtil2.default);
	ngModule.provider('fisKendoUtilService', _kendoUtil4.default);
	
	ngModule.run(_util2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 23 */
/*!***************************************!*\
  !*** ./util/kendo-util.controller.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$scope", "$timeout", "fisKendoUtilService", "fisPubSubService", function ($scope, $timeout, fisKendoUtilService, fisPubSubService) {
	  'ngInject';
	
	  var unsubscribes = [];
	
	  unsubscribes.push(fisPubSubService.subscribe('fisLocaleChanged', function (locale) {
	    // call function to update all existing kendo widgets
	    fisKendoUtilService.updateKendoLocale(locale);
	  }));
	
	  $scope.$on('$destroy', function () {
	    // Unsubscribe all fisPubSubService Listeners
	    _.each(unsubscribes, function (unsubscibe) {
	      // eslint-disable-line no-undef
	      unsubscibe();
	    });
	    // Cancel the resizeTimeout
	    $timeout.cancel(resizeTimeout); // eslint-disable-line no-undef
	  });
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 24 */
/*!*************************************!*\
  !*** ./util/kendo-util.provider.js ***!
  \*************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var self = this;
	
	  self.$get = [function () {
	    var serv = {};
	
	    /**
	     * Loop over all existing date/time/number instances in the DOM  update accordingly with locale
	     * @param locale
	     */
	    serv.updateKendoLocale = function (locale) {
	      var widgets = $('[data-role=datepicker],[data-role=timepicker],[data-role=datetimepicker],[data-role=numerictextbox]');
	      var idx = 0;
	      var length = widgets.length;
	      var widget;
	      var value;
	      // Switch locale for Kendo widgets
	      kendo.culture(locale);
	
	      for (; idx < length; idx++) {
	        widget = kendo.widgetInstance(widgets.eq(idx), kendo.ui);
	
	        if (widget) {
	          value = widget.value();
	
	          if (widget.options.name.indexOf('Picker') !== -1) {
	            widget.options.format = undefined;
	            widget.options.timeFormat = undefined;
	          }
	
	          widget.setOptions(widget.options);
	          widget.value(value);
	        }
	      }
	    };
	
	    /**
	     * This function is used to check whether given object is a promise object or not
	     * @param obj
	     */
	    serv.isPromiseObject = function (obj) {
	      return !!obj.then && typeof obj.then === 'function'; // eslint-disable-line no-implicit-coercion
	    };
	
	    return serv;
	  }];
	
	  // Extending the existing JQuery selectors object and adding new selector :focusable
	  // which will return all the focusable elements for a particular group of elements
	  jQuery.extend($.expr[':'], {
	    focusable: function focusable(element, isTabIndexNotNaN) {
	      var map;
	      var mapName;
	      var img;
	      var nodeName = element.nodeName.toLowerCase();
	      if (nodeName === 'area') {
	        map = element.parentNode;
	        mapName = map.name;
	        if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
	          return false;
	        }
	        img = $('img[usemap=\'#' + mapName + '\']')[0];
	        return !!img && visible(img); // eslint-disable-line no-implicit-coercion
	      }
	      return (/^(input|select|textarea|button|object)$/.test(nodeName) ? !element.disabled : nodeName === 'a' ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) &&
	      // the element and all of its ancestors must be visible
	      visible(element);
	    }
	  });
	
	  // This function is used by the custom JQuery selector :focusable to return all the focusable elements
	  // which are currently visible() on the page
	  function visible(element) {
	    return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
	      return $.css(this, 'visibility') === 'hidden';
	    }).length;
	  }
	};

/***/ }),
/* 25 */
/*!**************************!*\
  !*** ./util/util.run.js ***!
  \**************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$rootScope", "fisPubSubService", "fisKendoUtilService", function ($rootScope, fisPubSubService, fisKendoUtilService) {
	  'ngInject';
	
	  if ($rootScope.controllersArr) {
	    $rootScope.controllersArr.push('fis.kendo.UtilController');
	  }
	
	  var unsub = fisPubSubService.subscribe('fisLocaleSet', function (locale) {
	    // TODO: shouldn't this also happen on fisLocaleChanged? Right now preserving same behaviour.
	    fisKendoUtilService.updateKendoLocale(locale);
	    unsub();
	    unsub = null;
	  });
	}];

/***/ }),
/* 26 */
/*!***************************************!*\
  !*** ./date/date-format.directive.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$filter", "fisDateTimeFormatService", function ($filter, fisDateTimeFormatService) {
	  'ngInject';
	
	  var validatePreconditions = function validatePreconditions(ngModel) {
	    if (!ngModel) {
	      throw new Error('ngModel required in order to format the date.');
	    }
	  };
	
	  return {
	    link: function link(scope, element, attributes) {
	      var inputElem = element.find('input');
	      if (inputElem.length === 0) {
	        inputElem = element;
	      }
	      var ngModel = inputElem.controller('ngModel');
	      if (!ngModel) {
	        ngModel = element.controller('ngModel');
	      }
	      validatePreconditions(ngModel);
	      var isKendoDatePicker = !angular.isUndefined(inputElem.data('kendoDatePicker'));
	      if (!isKendoDatePicker) {
	        var fisLocale = attributes.fisLocale;
	        var dateFormat = attributes.fisDateFormat;
	        var isIgnoreLocaleFormatting = true; // eslint-disable-line no-unused-vars
	        if (angular.isUndefined(dateFormat) || _.isEmpty(dateFormat)) {
	          dateFormat = fisDateTimeFormatService.getDateFormat(fisLocale);
	          isIgnoreLocaleFormatting = false;
	          dateFormat = fisDateTimeFormatService.formatPlaceHolder(dateFormat);
	        }
	        inputElem.attr('placeholder', dateFormat.toUpperCase());
	
	        var isMidnightUTC = fisDateTimeFormatService.isMidnightUTC(attributes);
	        var supportTwoDigitYear = false;
	        var cutOffYear = fisDateTimeFormatService.getConfigCutoff(); // initialize to default value from config or framework default if nothing set in config
	        if (!angular.isUndefined(attributes.fisTwoDigitYear) && attributes.fisTwoDigitYear !== false) {
	          supportTwoDigitYear = true;
	          // eslint-disable-next-line no-negated-condition
	          cutOffYear = attributes.fisTwoDigitYear !== '' ? parseInt(attributes.fisTwoDigitYear, 10) : cutOffYear; // Overwrite default with value from attribute if present
	          attributes.$observe('fisTwoDigitYear', function (value) {
	            if (value !== '') {
	              // eslint-disable-next-line no-negated-condition
	              cutOffYear = value !== '' ? parseInt(value, 10) : cutOffYear; // Overwrite default with value from attribute if present
	            }
	          });
	          inputElem.blur(function () {
	            var formattedDate = getFormattedDate(); // eslint-disable-line no-use-before-define
	            if (!angular.isUndefined(formattedDate) && !_.isEmpty(formattedDate)) {
	              inputElem.val(formattedDate);
	            } else {
	              inputElem.val(ngModel.$modelValue);
	            }
	          });
	        }
	
	        var getFormattedDate = function getFormattedDate() {
	          var dateTime = fisDateTimeFormatService.getDateAsDateObject(ngModel.$modelValue, fisLocale, false, isMidnightUTC, attributes.fisDateOnly);
	          if (!_.isUndefined(dateTime)) {
	            return kendo.toString(dateTime, dateFormat, fisLocale);
	          }
	        };
	
	        if (!angular.isUndefined(attributes.fisCustomValidate) && !angular.isUndefined(scope[attributes.fisCustomValidate])) {
	          scope.fisCustomValidateFn = scope[attributes.fisCustomValidate];
	        }
	
	        var validateDate = attributes.fisValidateDate !== 'false';
	        // Add date validator to validate date
	        if (validateDate) {
	          ngModel.$validators.date = function (value) {
	            if (!angular.isUndefined(scope.fisCustomValidateFn)) {
	              // eslint-disable-line no-negated-condition
	              return scope.fisCustomValidateFn(value);
	            } else {
	              // eslint-disable-line no-else-return
	              if (fisDateTimeFormatService.isValid(value) || angular.equals(value, '')) {
	                // eslint-disable-line no-lonely-if
	                return true;
	              }
	            }
	            return false;
	          };
	        }
	
	        // Create options required for date extraction
	        var createOptions = function createOptions(viewValue) {
	          var options = {};
	          options.scope = scope;
	          options.attributes = attributes;
	          options.isMidnightUTC = isMidnightUTC;
	          options.supportTwoDigitYear = supportTwoDigitYear;
	          options.cutOffYear = cutOffYear;
	          options.dateFormat = dateFormat;
	          options.viewValue = viewValue;
	          options.fisLocale = fisLocale;
	          return options;
	        };
	
	        // Add model formatters
	        ngModel.$formatters.push(function (modelValue) {
	          var retVal = modelValue;
	          if (modelValue) {
	            if (!isNaN(modelValue) && !angular.isDate(modelValue)) {
	              modelValue = new Date(parseInt(modelValue, 10));
	            } else {
	              modelValue = fisDateTimeFormatService.extractDateFromModelValue(createOptions(modelValue));
	            }
	            if (!angular.isUndefined(modelValue)) {
	              retVal = kendo.toString(modelValue, dateFormat, fisLocale);
	            }
	          }
	          return retVal;
	        });
	
	        // Add model parsers
	        ngModel.$parsers.unshift(function (viewValue) {
	          var retVal = viewValue;
	          if (viewValue) {
	            if (!isNaN(viewValue) && !angular.isDate(viewValue)) {
	              viewValue = new Date(parseInt(viewValue, 10));
	            } else {
	              viewValue = fisDateTimeFormatService.extractDateFromViewValue(createOptions(viewValue));
	            }
	            if (!angular.isUndefined(viewValue)) {
	              retVal = viewValue;
	            }
	          }
	          return retVal;
	        });
	
	        var updateDateFormat = function updateDateFormat(format) {
	          inputElem.attr('placeholder', fisDateTimeFormatService.formatPlaceHolder(format).toUpperCase());
	        };
	
	        var updateLocale = function updateLocale() {
	          dateFormat = fisDateTimeFormatService.getDateFormat(fisLocale);
	          updateDateFormat(dateFormat);
	        };
	
	        attributes.$observe('fisLocale', function (value) {
	          fisLocale = value;
	          var options = {
	            format: dateFormat,
	            locale: value
	          };
	          updateDateBasedOnFormatAndLocale(options); // eslint-disable-line no-use-before-define
	        });
	
	        attributes.$observe('fisDateFormat', function (value) {
	          var options = {
	            format: value,
	            locale: fisLocale
	          };
	          updateDateBasedOnFormatAndLocale(options); // eslint-disable-line no-use-before-define
	        });
	
	        var updateDateBasedOnFormatAndLocale = function updateDateBasedOnFormatAndLocale(options) {
	          if (!angular.isUndefined(attributes.fisDateFormat) && !_.isEmpty(attributes.fisDateFormat)) {
	            dateFormat = options.format;
	            updateDateFormat(dateFormat);
	          } else {
	            updateLocale();
	          }
	          if (ngModel.$modelValue) {
	            // ngModel.$setViewValue(fisDateTimeFormatService.extractDateFromViewValue(createOptions(ngModel.$modelValue)));
	            ngModel.$modelValue = new Date(ngModel.$modelValue);
	          }
	        };
	      }
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 27 */
/*!************************************!*\
  !*** ./date/date-format.filter.js ***!
  \************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$locale", "fisDateTimeFormatService", function ($locale, fisDateTimeFormatService) {
	  'ngInject';
	
	  return function (format) {
	    var retStrFormat;
	
	    // Swallow the two formats that are no longer used
	    if (format === 'small' || format === 'full') {
	      console.warn('Using deprecated date format "' + format + '" - please remove it!');
	      format = undefined;
	    }
	
	    retStrFormat = fisDateTimeFormatService.getDateFormat();
	
	    return retStrFormat;
	  };
	}];

/***/ }),
/* 28 */
/*!*********************************************!*\
  !*** ./date/date-picker-field.directive.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "$filter", "$timeout", "$parse", "fisDateTimeFormatService", "fisFieldDirectiveFactory", "fisMemoryUtilService", function ($compile, $filter, $timeout, $parse, fisDateTimeFormatService, fisFieldDirectiveFactory, fisMemoryUtilService) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	
	    editTemplate: '<% if(field.attrs.ngModelInput) {%>' + '<input fis-input="input" ' + 'class="<% if(field.attrs.fisSize) {%>input-<%=field.attrs.fisSize%><% } else {%>input-large<% }%><%if(field.attrs.fisReadonlyInput === "true") {%> date-ready-only<% }%>"></input>' + '<% } else{%>' + '<input fis-input="input" ng-model="<%= field.attrs.ngModelDate  %>" ' + 'class="<% if(field.attrs.fisSize) {%>input-<%=field.attrs.fisSize%><% } else {%>input-large<% }%><%if(field.attrs.fisReadonlyInput === "true") {%> date-ready-only<% }%>">' + '<% if(field.attrs.ngModelYear) {%>  <div tabindex="-1" ng-model="<%= field.attrs.ngModelYear %>"   class="year"></div><% }%>' + '<% if(field.attrs.ngModelMonth) {%> <div tabindex="-1" ng-model="<%= field.attrs.ngModelMonth %>"  class="month"></div><% }%>' + '<% if(field.attrs.ngModelDay) {%>   <div tabindex="-1" ng-model="<%= field.attrs.ngModelDay %>"    class="day"></div><% }%>' + '</input>' + '<% }%>',
	
	    viewTemplate: '{{fieldValue()}}',
	
	    link: function link(scope, element, attrs) {
	      var datepickerElem = element.find('input');
	      var yearElem = element.find('.year');
	      var monthElem = element.find('.month');
	      var dayElem = element.find('.day');
	
	      var ngModel = datepickerElem.controller('ngModel');
	      var ngModelYear = yearElem.controller('ngModel');
	      var ngModelMonth = monthElem.controller('ngModel');
	      var ngModelDay = dayElem.controller('ngModel');
	      var multiModel = !(!ngModelYear && !ngModelMonth && !ngModelDay);
	
	      var fisLocale = attrs.fisLocale;
	      var dateFormat = attrs.fisDateFormat;
	      var isIgnoreLocaleFormatting = true;
	      if (angular.isUndefined(dateFormat) || _.isEmpty(dateFormat)) {
	        dateFormat = fisDateTimeFormatService.getDateFormat(fisLocale);
	        isIgnoreLocaleFormatting = false;
	      }
	      var isMidnightUTC = fisDateTimeFormatService.isMidnightUTC(attrs);
	
	      var supportTwoDigitYear = false;
	      var cutOffYear = fisDateTimeFormatService.getConfigCutoff(); // initialize to default value from config or framework default if nothing set in config
	      if (!angular.isUndefined(attrs.fisTwoDigitYear) && attrs.fisTwoDigitYear !== false) {
	        supportTwoDigitYear = true;
	        // eslint-disable-next-line no-negated-condition
	        cutOffYear = attrs.fisTwoDigitYear !== '' ? parseInt(attrs.fisTwoDigitYear, 10) : cutOffYear; // Overwrite default with value from attribute if present
	        attrs.$observe('fisTwoDigitYear', function (value) {
	          if (value !== '') {
	            // eslint-disable-next-line no-negated-condition
	            cutOffYear = value !== '' ? parseInt(value, 10) : cutOffYear; // Overwrite default with value from attribute if present
	          }
	        });
	
	        datepickerElem.blur(function () {
	          updateDatePicker(); // eslint-disable-line no-use-before-define
	        });
	      }
	
	      // Create options required for date extraction
	      var createOptions = function createOptions(viewValue) {
	        var options = {};
	        options.scope = scope;
	        options.attributes = attrs;
	        options.isMidnightUTC = isMidnightUTC;
	        options.supportTwoDigitYear = supportTwoDigitYear;
	        options.cutOffYear = cutOffYear;
	        options.dateFormat = dateFormat;
	        options.viewValue = viewValue;
	        options.fisLocale = fisLocale;
	        return options;
	      };
	
	      var getDate = function getDate() {
	        var dateTime = fisDateTimeFormatService.getDateAsDateObject(ngModel.$modelValue, fisLocale, false, isMidnightUTC, attrs.fisDateOnly);
	        if (!_.isUndefined(scope.fisCustomValidateFn) && _.isNull(dateTime)) {
	          dateTime = ngModel.$modelValue;
	        }
	        return dateTime;
	      };
	
	      var getFormattedDate = function getFormattedDate() {
	        var dateTime = getDate();
	        if (dateTime) {
	          return kendo.toString(dateTime, dateFormat, fisLocale);
	        }
	      };
	
	      var updateDatePicker = function updateDatePicker() {
	        var formattedDateTime = getFormattedDate();
	        if (!_.isUndefined(formattedDateTime)) {
	          // eslint-disable-line no-negated-condition
	          datepickerElem.val(formattedDateTime);
	        } else {
	          datepickerElem.val(ngModel.$modelValue);
	        }
	      };
	
	      var updateDateFormat = function updateDateFormat(options) {
	        var widget = datepickerElem.data('kendoDatePicker');
	        widget.setOptions(options);
	        datepickerElem.attr('placeholder', fisDateTimeFormatService.formatPlaceHolder(options.format).toUpperCase());
	      };
	
	      var updateLocale = function updateLocale() {
	        var options = fisDateTimeFormatService.getDatePickerOptions(fisLocale);
	        dateFormat = fisDateTimeFormatService.getDateFormat(fisLocale);
	        updateDateFormat(options);
	        if (ngModel.$modelValue) {
	          // ngModel.$setViewValue(fisDateTimeFormatService.extractDateFromViewValue(createOptions(ngModel.$modelValue)));
	          ngModel.$modelValue = new Date(ngModel.$modelValue);
	        }
	      };
	
	      var getMultiModelDate = function getMultiModelDate() {
	        var date = null;
	        var year = ngModelYear.$viewValue;
	        var month = ngModelMonth.$viewValue;
	        var day = ngModelDay.$viewValue;
	        if (year && month && day) {
	          date = new Date(year, month - 1, day);
	        }
	        return date;
	      };
	
	      var setMinDate = function setMinDate() {
	        var widget = datepickerElem.data('kendoDatePicker');
	        if (!angular.isUndefined(widget) && !angular.isUndefined(scope.minDate)) {
	          widget.min(scope.minDate);
	        }
	      };
	
	      var setMaxDate = function setMaxDate() {
	        var widget = datepickerElem.data('kendoDatePicker');
	        if (!angular.isUndefined(widget) && !angular.isUndefined(scope.maxDate)) {
	          widget.max(scope.maxDate);
	        }
	      };
	
	      var createKendoDatePicker = function createKendoDatePicker(change, open) {
	        var widget = datepickerElem.data('kendoDatePicker');
	        if (widget) {
	          widget.destroy();
	        }
	
	        datepickerElem.kendoDatePicker({
	          change: change,
	          open: open,
	          month: {
	            // template for dates in month view add fisid
	            content: '<div fisid="day_#=data.dateString.split("/").join("_")#">' + // unique by day and month
	            '#= data.value #' + '</div>'
	          },
	          footer: '<div fisid="today_#=kendo.toString(data, "dd") #">' + '#=kendo.toString(data, "D") #' + '</div>'
	        });
	        var calendarContainer = datepickerElem.data('kendoDatePicker').dateView.div;
	        scope.$on('$destroy', function () {
	          calendarContainer.remove();
	        });
	        setMinDate();
	        setMaxDate();
	      };
	
	      var propagateToMultiAttr = function propagateToMultiAttr(value) {
	        var newYear = null;
	        var newMonth = null;
	        var newDay = null;
	
	        if (angular.isDate(value)) {
	          datepickerElem.data('kendoDatePicker').value(value);
	          newYear = isNaN(value.getFullYear()) ? undefined : value.getFullYear().toString();
	          newMonth = isNaN(value.getMonth()) ? undefined : (value.getMonth() + 1).toString();
	          newDay = isNaN(value.getDate()) ? undefined : value.getDate().toString();
	          ngModelYear.$setViewValue(newYear);
	          ngModelMonth.$setViewValue(newMonth);
	          ngModelDay.$setViewValue(newDay);
	          ngModel.$setViewValue(value);
	        } else if (value === null) {
	          ngModelYear.$setViewValue('');
	          ngModelMonth.$setViewValue('');
	          ngModelDay.$setViewValue('');
	          ngModel.$setViewValue('');
	        }
	      };
	
	      var initializeDatePicker = function initializeDatePicker() {
	        // eslint-disable-next-line no-negated-condition
	        if (!multiModel) {
	          // Handling for single date objects
	          createKendoDatePicker(function () {
	            ngModel.$dirty = true;
	            scope.$evalAsync(function () {
	              if (datepickerElem.data('kendoDatePicker').value()) {
	                if (!$.isEmptyObject(ngModel.$error)) {
	                  // In case of invalid date, set the view value from kendo date picker.
	                  ngModel.$setViewValue(datepickerElem.data('kendoDatePicker').value());
	                }
	              }
	            });
	          }, function () {
	            // SDHTML-5820: This issue due to kendo default behavior.
	            // Set calendar view value to current date value so that datepicker value should
	            // be highlighted with current date shown in footer template also set calendar
	            // local variable _value as null so that user can select current value
	            var kendoDatePicker = datepickerElem.data('kendoDatePicker');
	            if (!kendoDatePicker.value()) {
	              kendoDatePicker.dateView.calendar.value(new Date());
	              kendoDatePicker.dateView.calendar._value = null;
	            }
	          });
	        } else {
	          // Handling for multi part dates
	          var render = function render() {
	            var date = getMultiModelDate();
	
	            if (date && !isNaN(date.getMonth())) {
	              ngModel.$setViewValue(date);
	              datepickerElem.data('kendoDatePicker').value(date);
	            }
	          };
	
	          ngModelYear.$render = render;
	          ngModelMonth.$render = render;
	          ngModelDay.$render = render;
	          ngModel.$render = render;
	          createKendoDatePicker(function () {
	            ngModelYear.$dirty = true;
	            ngModelMonth.$dirty = true;
	            ngModelDay.$dirty = true;
	            scope.$apply(function () {
	              propagateToMultiAttr(datepickerElem.data('kendoDatePicker').value());
	            });
	          }, function () {
	            // SDHTML-5820: This issue due to kendo default behavior.
	            // Set calendar view value to current date value so that datepicker value should
	            // be highlighted with current date shown in footer template also set calendar
	            // local variable _value as null so that user can select current value
	            var kendoDatePicker = datepickerElem.data('kendoDatePicker');
	            if (!kendoDatePicker.value()) {
	              kendoDatePicker.dateView.calendar.value(new Date());
	              kendoDatePicker.dateView.calendar._value = null;
	            }
	          });
	          datepickerElem.attr('style', '');
	        }
	
	        // Validate datepicker based on condition provided
	        var validateDate = attrs.fisValidateDate !== 'false';
	        if (!angular.isUndefined(attrs.fisCustomValidate) && !angular.isUndefined(scope[attrs.fisCustomValidate])) {
	          scope.fisCustomValidateFn = scope[attrs.fisCustomValidate];
	        }
	
	        // Add date validator to validate date
	        if (validateDate) {
	          ngModel.$validators.date = function (value) {
	            if (!angular.isUndefined(scope.fisCustomValidateFn)) {
	              // eslint-disable-line no-negated-condition
	              return scope.fisCustomValidateFn(value);
	            } else {
	              // eslint-disable-line no-else-return
	              if (fisDateTimeFormatService.isValid(value, attrs.fisDateOnly) || angular.equals(value, '')) {
	                // eslint-disable-line no-lonely-if
	                return true;
	              }
	            }
	            return false;
	          };
	        }
	
	        // Add date-range validator to validate min/max
	        if (attrs.fisMinDate || attrs.fisMaxDate) {
	          // This means that date range should be validated
	          ngModel.$validators['date-range'] = function (value) {
	            if (fisDateTimeFormatService.isValid(value)) {
	              var widget = datepickerElem.data('kendoDatePicker');
	              if (!_.isUndefined(widget)) {
	                return fisDateTimeFormatService.isValidDateRange(new Date(value), widget.min(), widget.max(), true);
	              }
	            }
	            return true;
	          };
	        }
	
	        // Add model formatters
	        ngModel.$formatters.push(function (modelValue) {
	          var retVal = modelValue;
	          if (modelValue) {
	            modelValue = fisDateTimeFormatService.extractDateFromModelValue(createOptions(modelValue));
	            if (!angular.isUndefined(modelValue)) {
	              var datePicker = datepickerElem.data('kendoDatePicker');
	              if (!_.isUndefined(datePicker)) {
	                datePicker.value(modelValue);
	                retVal = kendo.toString(modelValue, dateFormat, fisLocale);
	              }
	            }
	          }
	          return retVal;
	        });
	
	        // Add model parsers
	        ngModel.$parsers.unshift(function (viewValue) {
	          var retVal = viewValue;
	          if (viewValue) {
	            viewValue = fisDateTimeFormatService.extractDateFromViewValue(createOptions(viewValue));
	            if (!angular.isUndefined(viewValue)) {
	              retVal = viewValue;
	            }
	          }
	          if (retVal instanceof Date) {
	            return !isNaN(retVal) ? retVal : undefined; // eslint-disable-line no-negated-condition
	          } else {
	            // eslint-disable-line no-else-return
	            return retVal;
	          }
	        });
	
	        if (!isIgnoreLocaleFormatting) {
	          updateLocale();
	        }
	
	        // Add fisid for testing
	        if (fis.initParams().appStage === 'T') {
	          element.find('.k-icon').attr('fisid', datepickerElem.attr('fisid') + '_openWidgetButton');
	          $(datepickerElem.data('kendoDatePicker').dateView.div).attr('fisid', datepickerElem.attr('fisid') + '_calendar');
	        }
	      };
	
	      // This overwrites the field value function used in the view template
	      scope.fieldValue = function () {
	        var dateTime = getDate();
	        if (!angular.isUndefined(dateTime) && isMidnightUTC) {
	          if (fisDateTimeFormatService.isValid(dateTime)) {
	            dateTime = fisDateTimeFormatService.adjustDateViewValueForTimeZone(dateTime);
	          }
	        }
	        if (!angular.isUndefined(dateTime)) {
	          // eslint-disable-line no-negated-condition
	          return kendo.toString(dateTime, dateFormat, fisLocale);
	        } else {
	          // eslint-disable-line no-else-return
	          return '';
	        }
	      };
	
	      var disabledWatch = scope.$watch('fisDisabled', function (disabled) {
	        var kendoDatePicker = datepickerElem.data('kendoDatePicker');
	        if (kendoDatePicker) {
	          kendoDatePicker.enable(!disabled);
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, disabledWatch);
	
	      // $destroy event, broadcasted when a parent scope is being destroyed
	      scope.$on('$destroy', function () {
	        var widget = datepickerElem.data('kendoDatePicker');
	        fisMemoryUtilService.destroyKendoWidgets(widget);
	      });
	
	      function resetDatePicker(newDate) {
	        if (newDate === undefined || newDate === null || newDate === '') {
	          var datePicker = datepickerElem.data('kendoDatePicker');
	          if (datePicker) {
	            if (multiModel && (newDate === null || newDate === '')) {
	              propagateToMultiAttr(null);
	            }
	            datePicker.value(newDate);
	            if (datePicker.dateView.calendar) {
	              datePicker.dateView.calendar.element.find('td.k-state-focused').removeClass('k-state-focused');
	            }
	          }
	        }
	      }
	
	      if (attrs.ngModelInput) {
	        var modelInputWatch = scope.$watch(attrs.ngModelInput, function (newDate, oldDate) {
	          if (+newDate !== +oldDate) {
	            // eslint-disable-line no-implicit-coercion
	            resetDatePicker(newDate);
	          }
	        });
	        fisMemoryUtilService.cancelWatchOnDestroy(scope, modelInputWatch);
	      }
	
	      var ngModelDateWatch = scope.$watch(attrs.ngModelDate, function (newDate, oldDate) {
	        if (+newDate !== +oldDate) {
	          // eslint-disable-line no-implicit-coercion
	          resetDatePicker(newDate);
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, ngModelDateWatch);
	
	      attrs.$observe('fisLocale', function (value) {
	        fisLocale = value;
	        var options = {
	          locale: value,
	          format: dateFormat
	        };
	        updateDateBasedOnFormatAndLocale(options); // eslint-disable-line no-use-before-define
	      });
	
	      attrs.$observe('fisDateFormat', function (value) {
	        var options = {
	          format: value,
	          locale: fisLocale
	        };
	        updateDateBasedOnFormatAndLocale(options); // eslint-disable-line no-use-before-define
	      });
	
	      var updateDateBasedOnFormatAndLocale = function updateDateBasedOnFormatAndLocale(options) {
	        if (!angular.isUndefined(attrs.fisDateFormat) && !_.isEmpty(attrs.fisDateFormat)) {
	          dateFormat = options.format;
	          updateDateFormat(options);
	          if (ngModel.$modelValue) {
	            // ngModel.$setViewValue(fisDateTimeFormatService.extractDateFromViewValue(createOptions(ngModel.$modelValue)));
	            ngModel.$modelValue = new Date(ngModel.$modelValue);
	          }
	        } else {
	          updateLocale();
	        }
	      };
	
	      var getMinDate = function getMinDate() {
	        // AngularJS v1.4 does not call $observe if the attribute is not specified. Hence default values need to be assigned.
	        var minDate = $parse(attrs.fisMinDate)(scope) || new Date(1900, 0, 1);
	        if (!angular.isDate(minDate)) {
	          minDate = fisDateTimeFormatService.getDateAsDateObject(minDate, fisLocale, true, isMidnightUTC, attrs.fisDateOnly);
	        }
	        scope.minDate = minDate;
	        setMinDate();
	        return scope.minDate;
	      };
	
	      var getMaxDate = function getMaxDate() {
	        // AngularJS v1.4 does not call $observe if the attribute is not specified. Hence default values need to be assigned.
	        var maxDate = $parse(attrs.fisMaxDate)(scope) || new Date(2099, 11, 31);
	        if (!angular.isDate(maxDate)) {
	          maxDate = fisDateTimeFormatService.getDateAsDateObject(maxDate, fisLocale, true, isMidnightUTC, attrs.fisDateOnly);
	        }
	        scope.maxDate = maxDate;
	        setMaxDate();
	        return scope.maxDate;
	      };
	
	      attrs.fisMinDate = getMinDate();
	      attrs.fisMaxDate = getMaxDate();
	
	      attrs.$observe('fisMinDate', function (value) {
	        // Sets min if user cleared minDate
	        if (angular.isUndefined(value) || value === '') {
	          value = new Date(1900, 0, 1);
	        }
	        if (!angular.isDate(value)) {
	          value = fisDateTimeFormatService.getDateAsDateObject(value, fisLocale, true, isMidnightUTC, attrs.fisDateOnly);
	        }
	        // if(fisDateTimeFormatService.isValid(value)){
	        scope.minDate = value;
	        setMinDate();
	        // }
	      });
	
	      attrs.$observe('fisMaxDate', function (value) {
	        // Sets max if user cleared maxDate
	        if (angular.isUndefined(value) || value === '') {
	          value = new Date(2099, 11, 31);
	        }
	        if (!angular.isDate(value)) {
	          value = value = fisDateTimeFormatService.getDateAsDateObject(value, fisLocale, true, isMidnightUTC, attrs.fisDateOnly);
	        }
	        // if(fisDateTimeFormatService.isValid(value)){
	        scope.maxDate = value;
	        setMaxDate();
	        // }
	      });
	
	      // Clear model for readonly mode
	      var clearModal = function clearModal() {
	        if (multiModel) {
	          propagateToMultiAttr(null);
	        } else {
	          ngModel.$setViewValue('');
	        }
	      };
	
	      attrs.$observe('fisReadonlyInput', function (readonly) {
	        if (readonly === 'true') {
	          var clearIcon = $compile('<span unselectable="on" class="date-clear-button" role="button"><span unselectable="on" class="clear-icon"></span></span>')(scope);
	          if (clearIcon.on('click') !== undefined) {
	            clearIcon.on('click', clearModal);
	          }
	          datepickerElem.after(clearIcon);
	          datepickerElem.attr('autocomplete', 'off'); // disable auto-fill for Edge browser
	        } else if (readonly === 'false') {
	          datepickerElem.attr('autocomplete', 'on'); // enable auto-fill for Edge browser
	        }
	        fisDateTimeFormatService.makeWidgetAsReadOnly(readonly, datepickerElem);
	      });
	
	      var editWatch = scope.$watch('fisEditMode', function (formEditMode) {
	        if (formEditMode === true) {
	          var editTimeOut = $timeout(function () {
	            updateDatePicker();
	          }, 0);
	          scope.$on('$destroy', function () {
	            $timeout.cancel(editTimeOut);
	          });
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, editWatch);
	
	      /**
	       * @name resize
	       * @methodOf fisDatePickerField
	       * @description
	       * <p>Resizes the width of the datepicker input </p>
	       */
	      scope.resize = function (width) {
	        var kendoDatePicker = datepickerElem.data('kendoDatePicker');
	        var datapicker = kendoDatePicker._inputWrapper;
	        datapicker.removeClass('fis-input'); // this is being applied twice, only need it on the actual input
	        datapicker.css('width', width);
	        datapicker.find('input').css('width', width);
	      };
	      // Initialize it once
	      initializeDatePicker();
	    }
	  });
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 29 */
/*!********************************************!*\
  !*** ./date/date-time-format.directive.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$filter", "$timeout", "fisDateTimeFormatService", function ($filter, $timeout, fisDateTimeFormatService) {
	  'ngInject';
	
	  var validatePreconditions = function validatePreconditions(ngModel) {
	    if (!ngModel) {
	      throw new Error('ngModel required in order to format the date time.');
	    }
	  };
	
	  return {
	    link: function link(scope, element, attrs) {
	      var inputElem = element.find('input');
	      if (inputElem.length === 0) {
	        inputElem = element;
	      }
	      var ngModel = inputElem.controller('ngModel');
	      if (!ngModel) {
	        ngModel = element.controller('ngModel');
	      }
	      validatePreconditions(ngModel);
	      var isKendoDateTimePicker = !angular.isUndefined(inputElem.data('kendoDateTimePicker'));
	      if (!isKendoDateTimePicker) {
	        var fisLocale = attrs.fisLocale;
	        var timeFormat = '12';
	        if (!angular.isUndefined(attrs.fisTimeFormat) && !_.isEmpty(attrs.fisTimeFormat)) {
	          timeFormat = attrs.fisTimeFormat;
	        }
	        var dateTimeFormat = attrs.fisDateTimeFormat;
	        var isIgnoreLocaleFormatting = true; // eslint-disable-line no-unused-vars
	        if (angular.isUndefined(dateTimeFormat) || _.isEmpty(dateTimeFormat)) {
	          isIgnoreLocaleFormatting = false;
	          dateTimeFormat = fisDateTimeFormatService.getDateTimeFormat(fisLocale, timeFormat);
	        }
	        inputElem.attr('placeholder', fisDateTimeFormatService.formatPlaceHolder(dateTimeFormat).toUpperCase());
	
	        var getFormattedDateTime = function getFormattedDateTime() {
	          var dateTime;
	          if (!isNaN(ngModel.$modelValue) && !angular.isDate(ngModel.$modelValue)) {
	            dateTime = new Date(parseInt(ngModel.$modelValue, 10));
	          } else {
	            dateTime = fisDateTimeFormatService.extractDateTimeFromModelValue(createOptions(ngModel.$modelValue)); // eslint-disable-line no-use-before-define
	          }
	          if (!_.isUndefined(dateTime) && fisDateTimeFormatService.isValidDate(dateTime)) {
	            // check for the invalid date
	            return kendo.toString(dateTime, dateTimeFormat, fisLocale);
	          }
	        };
	
	        var updateDateTimePicker = function updateDateTimePicker() {
	          var formattedDateTime = getFormattedDateTime();
	          if (!_.isUndefined(formattedDateTime)) {
	            inputElem.val(formattedDateTime);
	          }
	        };
	
	        inputElem.blur(function () {
	          if (!scope.$$phase && !scope.$root.$$phase) {
	            scope.$apply(function () {
	              updateDateTimePicker();
	            });
	          } else {
	            updateDateTimePicker();
	          }
	        });
	
	        if (!_.isUndefined(attrs.fisCustomValidate) && !_.isUndefined(scope[attrs.fisCustomValidate])) {
	          scope.fisCustomValidateFn = scope[attrs.fisCustomValidate];
	        }
	
	        var validateDate = attrs.fisValidateDate !== 'false';
	        // Add date validator to validate date
	        if (validateDate) {
	          ngModel.$validators.date = function (value) {
	            if (!angular.isUndefined(scope.fisCustomValidateFn)) {
	              // eslint-disable-line no-negated-condition
	              return scope.fisCustomValidateFn(value);
	            } else {
	              // eslint-disable-line no-else-return
	              if (fisDateTimeFormatService.isValid(value) || angular.equals(value, '')) {
	                // eslint-disable-line no-lonely-if
	                return true;
	              }
	            }
	            return false;
	          };
	        }
	
	        var createOptions = function createOptions(viewValue) {
	          var options = {};
	          options.scope = scope;
	          options.attributes = attrs;
	          options.dateFormat = dateTimeFormat;
	          options.viewValue = viewValue;
	          options.fisLocale = fisLocale;
	          return options;
	        };
	
	        // Add model formatters
	        ngModel.$formatters.push(function (modelValue) {
	          var retVal = modelValue;
	          if (modelValue) {
	            if (!isNaN(modelValue) && !angular.isDate(modelValue)) {
	              modelValue = new Date(parseInt(modelValue, 10));
	            } else {
	              modelValue = fisDateTimeFormatService.extractDateTimeFromModelValue(createOptions(modelValue));
	            }
	            if (!angular.isUndefined(modelValue)) {
	              retVal = kendo.toString(modelValue, dateTimeFormat, fisLocale);
	            }
	          }
	          return retVal;
	        });
	
	        // Add model parsers
	        ngModel.$parsers.unshift(function (viewValue) {
	          var retVal = viewValue;
	          if (viewValue) {
	            if (!isNaN(viewValue) && !angular.isDate(viewValue)) {
	              viewValue = new Date(parseInt(viewValue, 10));
	            } else {
	              viewValue = fisDateTimeFormatService.extractDateTimeFromViewValue(createOptions(viewValue));
	            }
	            if (!angular.isUndefined(viewValue)) {
	              retVal = viewValue;
	            }
	          }
	          return retVal;
	        });
	
	        var updateDateTimeFormat = function updateDateTimeFormat(format) {
	          inputElem.attr('placeholder', fisDateTimeFormatService.formatPlaceHolder(format).toUpperCase());
	        };
	
	        var updateLocale = function updateLocale() {
	          dateTimeFormat = fisDateTimeFormatService.getDateTimeFormat(fisLocale);
	          updateDateTimeFormat(dateTimeFormat);
	        };
	
	        attrs.$observe('fisLocale', function (value) {
	          fisLocale = value;
	          var options = {
	            locale: value,
	            format: dateTimeFormat
	          };
	          updateDateBasedOnFormatAndLocale(options); // eslint-disable-line no-use-before-define
	        });
	
	        attrs.$observe('fisDateTimeFormat', function (value) {
	          var options = {
	            format: value,
	            locale: fisLocale
	          };
	          updateDateBasedOnFormatAndLocale(options); // eslint-disable-line no-use-before-define
	        });
	
	        var updateDateBasedOnFormatAndLocale = function updateDateBasedOnFormatAndLocale(options) {
	          if (!angular.isUndefined(attrs.fisDateTimeFormat) && !_.isEmpty(attrs.fisDateTimeFormat)) {
	            dateTimeFormat = options.format;
	            updateDateTimeFormat(options.format);
	            if (ngModel.$modelValue) {
	              ngModel.$modelValue = new Date(ngModel.$modelValue);
	            }
	          } else {
	            updateLocale();
	          }
	        };
	      }
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 30 */
/*!*******************************************!*\
  !*** ./date/date-time-format.provider.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var self = this;
	
	  self.$get = ['fisPubSubService', 'fisConfig', '$filter', 'fisI18nService', function (fisPubSubService, fisConfig, $filter, fisI18nService) {
	    var service = {};
	    var configCutoff;
	    var timezone;
	
	    if (!angular.isUndefined(fisConfig.widgets && fisConfig.widgets.fisDatePicker) && !angular.isUndefined(fisConfig.widgets && fisConfig.widgets.fisDatePicker.cutOffYear)) {
	      configCutoff = fisConfig.widgets.fisDatePicker.cutOffYear;
	    } else {
	      configCutoff = 45; // framework default cutoff year
	    }
	
	    if (!angular.isUndefined(fisConfig.widgets && fisConfig.widgets.fisDatePicker) && !angular.isUndefined(fisConfig.widgets && fisConfig.widgets.fisDatePicker.timezone)) {
	      timezone = fisConfig.widgets.fisDatePicker.timezone;
	    } else {
	      timezone = 'midnight-utc'; // framework default
	    }
	
	    service.getConfigCutoff = function () {
	      return configCutoff;
	    };
	
	    service.getTimezone = function () {
	      return timezone;
	    };
	
	    service.isMidnightUTC = function (attrs) {
	      if (angular.isUndefined(attrs.fisTimezone) || _.isEmpty(attrs.fisTimezone)) {
	        if (service.getTimezone() === 'browser') {
	          return false;
	        } else {
	          // eslint-disable-line no-else-return
	          return true;
	        }
	      } else {
	        // eslint-disable-line no-else-return
	        if (attrs.fisTimezone === 'browser') {
	          // eslint-disable-line no-lonely-if
	          return false;
	        } else {
	          // eslint-disable-line no-else-return
	          return true;
	        }
	      }
	    };
	
	    function _getCulture(locale) {
	      if (locale) {
	        return kendo.cultures[locale];
	      }
	      return kendo.culture();
	    }
	
	    function _getSupportedDateFormat(locale) {
	      var culture = _getCulture(locale);
	      return culture.calendars.standard.patterns.d;
	    }
	
	    function _getSupportedTimeFormat(locale, timeFormat) {
	      return service.getTimeFormat(locale, timeFormat);
	    }
	
	    function _getSupportedDateTimeFormat(locale, timeFormat, currentDateTimeFormat) {
	      var supportedDateTimeFormat = [];
	      var culture = _getCulture(locale);
	      supportedDateTimeFormat.push(service.getDateTimeFormat(locale, timeFormat));
	      for (var key in culture.calendars.standard.patterns) {
	        if (currentDateTimeFormat === culture.calendars.standard.patterns[key]) {
	          supportedDateTimeFormat.push(culture.calendars.standard.patterns[key]);
	        }
	      }
	      return supportedDateTimeFormat;
	    }
	
	    service.validateDate = function (date, locale) {
	      var supportedFormat = _getSupportedDateFormat(locale);
	      var parseDate = kendo.parseDate(date ? date.toString() : date, supportedFormat);
	      if (!_.isNull(parseDate)) {
	        // eslint-disable-line no-negated-condition
	        return true;
	      } else {
	        // eslint-disable-line no-else-return
	        return false;
	      }
	    };
	
	    service.validateTime = function (time, locale, timeFormat) {
	      var supportedFormat = _getSupportedTimeFormat(locale, timeFormat);
	      var parseDate = kendo.parseDate(time ? time.toString() : time, supportedFormat);
	      if (!_.isNull(parseDate)) {
	        // eslint-disable-line no-negated-condition
	        return true;
	      } else {
	        // eslint-disable-line no-else-return
	        return false;
	      }
	    };
	
	    service.validateDateTime = function (dateTime, locale, timeFormat) {
	      var supportedFormat = _getSupportedDateTimeFormat(locale, timeFormat);
	      var parseDate = kendo.parseDate(dateTime ? dateTime.toString() : dateTime, supportedFormat);
	      if (!_.isNull(parseDate)) {
	        // eslint-disable-line no-negated-condition
	        return true;
	      } else {
	        // eslint-disable-line no-else-return
	        return false;
	      }
	    };
	
	    service.getCulture = function (locale) {
	      return _getCulture(locale);
	    };
	
	    service.getDateFormat = function (locale) {
	      var culture = _getCulture(locale);
	      if (culture && culture.name !== 'en' && culture.name !== 'en-US') {
	        return culture.calendars.standard.patterns.d;
	      } else {
	        // eslint-disable-line no-else-return
	        return 'MM/dd/yyyy';
	      }
	    };
	
	    service.getTimeFormat = function (locale, timeFormat) {
	      var culture = _getCulture(locale);
	      if (timeFormat === '24') {
	        if (culture && culture.name !== 'en' && culture.name !== 'en-US') {
	          return culture.calendars.standard.patterns.t;
	        } else {
	          // eslint-disable-line no-else-return
	          return 'HH:mm';
	        }
	      } else {
	        // eslint-disable-line no-else-return
	        return culture.calendars.standard.patterns.T;
	      }
	    };
	
	    service.getDateTimeFormat = function (locale, timeFormat) {
	      var culture = _getCulture(locale);
	      if (timeFormat === '24') {
	        if (culture && culture.name !== 'en' && culture.name !== 'en-US') {
	          return culture.calendars.standard.patterns.g;
	        } else {
	          // eslint-disable-line no-else-return
	          return 'MM/dd/yyyy HH:mm';
	        }
	      } else {
	        // eslint-disable-line no-else-return
	        if (culture && culture.name !== 'en' && culture.name !== 'en-US') {
	          // eslint-disable-line no-lonely-if
	          return culture.calendars.standard.patterns.G;
	        } else {
	          // eslint-disable-line no-else-return
	          return 'MM/dd/yyyy h:mm:ss tt';
	        }
	      }
	    };
	
	    service.formatDate = function (date, locale) {
	      if (!angular.isDate(date)) {
	        return '';
	      }
	      return kendo.toString(date, service.getDateFormat(locale));
	    };
	
	    service.formatTime = function (date, locale, timeFormat) {
	      return kendo.toString(date, service.getTimeFormat(locale, timeFormat));
	    };
	
	    service.formatDateTime = function (date, locale, timeFormat) {
	      if (!angular.isDate(date)) {
	        return '';
	      }
	      return kendo.toString(date, service.getDateTimeFormat(locale, timeFormat));
	    };
	
	    service.getDate = function (date, locale) {
	      if (angular.isDate(date)) {
	        return date;
	      } else {
	        // eslint-disable-line no-else-return
	        var supportedFormat = _getSupportedDateFormat(locale);
	        if (!angular.isUndefined(date) && date !== null && angular.isString(date) && service.isValidDate(date, 'yyyy-MM-dd', true)) {
	          supportedFormat = 'yyyy-MM-dd';
	        }
	        return kendo.parseDate(date ? date.toString() : date, supportedFormat);
	      }
	    };
	
	    service.getDateTime = function (dateTime, locale, timeFormat, currentDateTimeFormat) {
	      if (angular.isDate(dateTime)) {
	        return dateTime;
	      } else {
	        // eslint-disable-line no-else-return
	        var supportedFormat = _getSupportedDateTimeFormat(locale, timeFormat, currentDateTimeFormat);
	        if (angular.isString(dateTime) && dateTime.lastIndexOf('T') > 0 && service.isValid(dateTime)) {
	          return new Date(dateTime);
	        } else {
	          // eslint-disable-line no-else-return
	          return kendo.parseDate(dateTime ? dateTime.toString() : dateTime, supportedFormat);
	        }
	      }
	    };
	
	    service.formatPlaceHolder = function (placeholderText) {
	      var regExDays = /d/g;
	      var regExDaysReplace = 'dd';
	      var regExMonth = /M/g;
	      var regExMonthReplace = 'MM';
	      if (placeholderText) {
	        if (placeholderText.indexOf(regExDaysReplace) < 0) {
	          placeholderText = placeholderText.replace(regExDays, regExDaysReplace);
	        }
	        if (placeholderText.indexOf(regExMonthReplace) < 0) {
	          placeholderText = placeholderText.replace(regExMonth, regExMonthReplace);
	        }
	      }
	      return placeholderText;
	    };
	
	    service.getDateTimePickerOptions = function (locale, timeFormat) {
	      var options = {};
	      options.format = service.getDateTimeFormat(locale, timeFormat);
	      options.timeFormat = service.getTimeFormat(locale, timeFormat);
	      options.culture = service.getCulture(locale);
	      return options;
	    };
	
	    service.getDatePickerOptions = function (locale) {
	      var options = {};
	      options.format = service.getDateFormat(locale);
	      options.culture = service.getCulture(locale);
	      return options;
	    };
	
	    service.isValidDateRange = function (dateObj, minValue, maxValue, isDatepicker) {
	      var isValid = true;
	      var dateObjDiff = dateObj;
	      // getting difference between browser timezone and utc. SDHTML-11012 & SDHTML-12719
	      if (isDatepicker) {
	        // Date.prototype.getTimezoneOffset returns the UTCoffset(UTC-local time) in minutes. It is the reverse of what moment.js does(Local-UTC)
	        if (angular.isDate(dateObj)) {
	          var offsetTime = dateObj.getTimezoneOffset();
	          // convert offsetTime to milliseconds and and add to dateObj.[UTC time = local + getTimeZoneOffset]
	          dateObjDiff = new Date(dateObj.getTime() + offsetTime * (60 * 1000));
	        }
	      }
	
	      var minDateTime = minValue || new Date(1900, 0, 1);
	      var maxDateTime = maxValue || new Date(2099, 11, 31);
	      if (dateObj < minDateTime || dateObjDiff > maxDateTime) {
	        isValid = false;
	      }
	      return isValid;
	    };
	
	    service.getDateToBindModel = function (attributes, viewValue, isMidnightUTC) {
	      var retVal;
	      if (!angular.isUndefined(attributes.fisDateOnly) && attributes.fisDateOnly === 'true') {
	        if (!angular.isUndefined(viewValue) && viewValue !== null && this.isValidDate(new Date(viewValue))) {
	          var date = new Date(viewValue); // eslint-disable-line block-scoped-var
	          retVal = $filter('date')(date, 'yyyy-MM-dd'); // eslint-disable-line block-scoped-var
	        }
	      } else {
	        if (isMidnightUTC) {
	          // eslint-disable-line no-lonely-if
	          if (!angular.isUndefined(viewValue) && viewValue !== null) {
	            var date = new Date(viewValue); // eslint-disable-line no-redeclare, block-scoped-var
	            // Date.UTC returns in milliseconds, so create the date Obj
	            var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())); // eslint-disable-line block-scoped-var
	            retVal = utcDate;
	          }
	        } else {
	          retVal = viewValue.toISOString();
	        }
	      }
	      return retVal;
	    };
	
	    function determineFullYear(decadeStr, cutOff) {
	      var decadeInt = parseInt(decadeStr, 10);
	      var century = '';
	      if (decadeInt > cutOff) {
	        century = '19';
	      } else {
	        century = '20';
	      }
	      return century + decadeStr;
	    }
	
	    function interpret2DigitYear(value, dateFormat, cutOffYear) {
	      var delimiterInput = value.replace(/\w/g, '');
	      var delimiterFormat = dateFormat.replace(/\w/g, '');
	
	      if (delimiterFormat === delimiterInput && delimiterInput.length >= 1) {
	        // Determine what part of the input is the year
	        var delimiter = delimiterInput.substr(0, 1);
	        var partsInput = value.split(delimiter);
	        var partsFormat = dateFormat.split(delimiter);
	        var yearPosition = null;
	        for (var i = 0; i < partsFormat.length; i++) {
	          if (partsFormat[i].indexOf('y') !== -1) {
	            yearPosition = i;
	            break;
	          }
	        }
	        if (yearPosition && partsInput[yearPosition].length === 2) {
	          partsInput[yearPosition] = determineFullYear(partsInput[yearPosition], cutOffYear);
	          return partsInput.join(delimiter);
	        }
	      }
	      return value;
	    }
	
	    service.getDateTimeAsDateTimeObject = function (value, fisLocale, timeFormat) {
	      var retVal = value;
	      if (!angular.isUndefined(value) && !_.isNull(value)) {
	        if (!angular.isDate(value) && angular.isString(value) && value.lastIndexOf('T') > 0) {
	          retVal = new Date(value);
	        } else {
	          retVal = service.getDateTime(value, fisLocale, timeFormat);
	          if (_.isNull(retVal)) {
	            retVal = service.getDate(value, fisLocale);
	          }
	        }
	        return retVal;
	      }
	    };
	
	    service.getDateAsDateObject = function (value, fisLocale, isTimezoneConversionRequired, isMidnightUTC, fisDateOnly) {
	      if (!angular.isUndefined(value) && !_.isNull(value)) {
	        value = checkIfDateOnly(value, fisDateOnly);
	
	        if (!angular.isDate(value) && angular.isString(value) && (value.lastIndexOf('T') > 0 || this.isValidDate(value, 'yyyy-MM-dd', true))) {
	          value = new Date(value);
	        } else {
	          value = service.getDate(value, fisLocale);
	        }
	        if (isTimezoneConversionRequired && isMidnightUTC) {
	          value = new Date(value);
	          // date.utc returns in milliseconds,so crreate  a date obj
	          value = new Date(Date.UTC(value.getFullYear(), value.getMonth(), value.getDate()));
	        }
	        return value;
	      }
	    };
	
	    function checkIfDateOnly(value, fisDateOnly) {
	      if (!angular.isUndefined(fisDateOnly) && fisDateOnly === 'true') {
	        if (angular.isString(value) && value.lastIndexOf('T') > 0) {
	          value = value.substr(0, value.lastIndexOf('T'));
	        }
	        if (service.isValidDate(value, 'yyyy-MM-dd', true)) {
	          // value string should be wrapped in date obj as  angular date filter returns a string
	          value = new Date($filter('date')(value));
	        }
	      }
	      return value;
	    }
	
	    function extractDateTime(options, currentDateTimeFormat) {
	      var dateTime;
	      if (angular.isDate(options.viewValue)) {
	        dateTime = options.viewValue;
	      } else {
	        // eslint-disable-next-line no-lonely-if
	        if (angular.isString(options.viewValue) && (options.viewValue.indexOf(' ') > 0 || options.viewValue.lastIndexOf('T') > 0)) {
	          dateTime = service.getDateTime(options.viewValue, options.fisLocale, options.timeFormat, currentDateTimeFormat);
	        } else {
	          if (!angular.isUndefined(options.dateFormat)) {
	            // eslint-disable-line no-lonely-if
	            dateTime = kendo.parseDate(options.viewValue ? options.viewValue.toString() : options.viewValue, options.dateFormat, options.fisLocale);
	            if (_.isNull(dateTime)) {
	              dateTime = service.getDate(options.viewValue, options.fisLocale);
	            }
	          }
	        }
	      }
	      return dateTime;
	    }
	
	    service.extractDateTimeFromModelValue = function (options) {
	      return extractDateTime(options);
	    };
	
	    service.extractDateFromModelValue = function (options) {
	      var retVal;
	      options.viewValue = checkIfDateOnly(options.viewValue, options.attributes.fisDateOnly);
	
	      if (angular.isDate(options.viewValue)) {
	        retVal = options.viewValue;
	      } else if (angular.isString(options.viewValue) && options.viewValue.lastIndexOf('T') > 0) {
	        retVal = service.getDateTime(options.viewValue, options.locale, '24');
	      } else if (!angular.isUndefined(options.dateFormat)) {
	        // eslint-disable-line no-negated-condition
	        retVal = kendo.parseDate(options.viewValue ? options.viewValue.toString() : options.viewValue, options.dateFormat, options.fisLocale);
	      } else {
	        retVal = service.getDate(options.viewValue, options.fisLocale);
	      }
	      return retVal;
	    };
	
	    service.extractDateTimeFromViewValue = function (options, currentDateTimeFormat) {
	      var retVal;
	      if (!angular.isUndefined(options.viewValue)) {
	        retVal = extractDateTime(options, currentDateTimeFormat);
	        if (!this.isValidDate(retVal) && !angular.isUndefined(options.scope.fisCustomValidateFn)) {
	          retVal = options.viewValue;
	        }
	      }
	      return retVal;
	    };
	
	    service.extractDateFromViewValue = function (options) {
	      if (options.supportTwoDigitYear && angular.isString(options.viewValue)) {
	        options.viewValue = interpret2DigitYear(options.viewValue, options.dateFormat, options.cutOffYear);
	      }
	      var dateTime = service.extractDateFromModelValue(options);
	      var retVal;
	      if (!angular.isUndefined(options.viewValue)) {
	        retVal = service.getDateToBindModel(options.attributes, dateTime, options.isMidnightUTC);
	        if (!this.isValidDate(retVal) && !angular.isUndefined(options.scope.fisCustomValidateFn)) {
	          retVal = options.viewValue;
	        }
	      }
	      return retVal;
	    };
	
	    service.makeWidgetAsReadOnly = function (readonly, element) {
	      if (readonly === 'true') {
	        // html5 readonly attributes is not working when date picker widget used
	        // when element is not visible like in grid, modal dialog, when ng-show used to hide/show
	        // date picker. Adding keypress, keydown, keyup event to provide readonly functionality
	        var ctrlDown = false;
	        element.on('keypress', function () {
	          return false;
	        }).on('keydown', function (e) {
	          if (e.keyCode == 17) {
	            // eslint-disable-line eqeqeq
	            ctrlDown = true;
	          }
	          if (e.keyCode == 8 || e.keyCode == 46 || ctrlDown && e.keyCode == 86) {
	            // eslint-disable-line eqeqeq
	            return false;
	          }
	        }).on('keyup', function (e) {
	          if (e.keyCode == 17) {
	            // eslint-disable-line eqeqeq
	            ctrlDown = false;
	          }
	        });
	      } else {
	        element.off('keypress').off('keydown').off('keyup');
	      }
	    };
	
	    /**
	     * This method is used to make an adjustment to the viewValue - to synchronize the view and edit value
	     * Adding 12h to make sure that if user between noon and midnight (12.00 - 24.00), then UTC will be 'next' day - and adjustment needs to be made
	     * to make sure user and UTC is on same calendar day
	     * if user is in am (00.00 - 12.00) - then user and UTC is on same calendar day - and adding 12h will make no difference to date
	     */
	    service.adjustDateViewValueForTimeZone = function (date) {
	      var dateObj = new Date(date);
	      // getTimezoneOffset = UTCtime - localtime
	      // (moment computes the reverse localtime-UTC) hence using -1
	      var utcOffset = dateObj.getTimezoneOffset() * -1;
	      if (this.isValidDate(date)) {
	        if (utcOffset > 0) {
	          dateObj.setMinutes(dateObj.getMinutes() + 720);
	        }
	      }
	      return dateObj;
	    };
	
	    /**
	     * This method is used to check if the date is valid or not
	     */
	    service.isValid = function (value, fisDateOnly) {
	      // return values for null and undefined keeping instep with legacy moment
	      if (value === null) return false;
	      if (value === undefined) return true;
	
	      if (angular.isString(value) && fisDateOnly === 'true') {
	        return this.isValidDate(value, 'yyyy-MM-dd', true);
	      }
	      return this.isValidDate(value);
	    };
	
	    /**
	     * This method supports two modes of validation strict validation and forgiving(non-strict) validation
	     * for strict parsing use kendo and for forgiving parsing use angular date filter.
	     *
	     * Note: Strict parsing is only supported if value is a string or date object. For all other value
	     * types "false" will be returned, as kendo parsing method might throw errors (SDHTML-14553).
	     * Refer to http://docs.telerik.com/kendo-ui/api/javascript/kendo#methods-parseDate for official method signature
	     */
	    service.isValidDate = function (value, format, strictParse) {
	      // return values for null and undefined keeping instep with legacy moment
	      if (value === null) return false;
	      if (value === undefined) return true;
	
	      var options;
	      var locale = fisI18nService.defaultLocale();
	
	      if (angular.isString(value) && value.lastIndexOf('T') > 0) {
	        options = this.getDateTimePickerOptions(locale);
	      } else {
	        options = this.getDatePickerOptions(locale);
	      }
	
	      if (!format) {
	        format = options.format;
	      }
	
	      if (strictParse) {
	        if (!angular.isString(value) && !angular.isDate(value)) {
	          // An input type that can not be parsed by kendo.parseDate() method
	          return false;
	        }
	        var retVal = kendo.parseDate(value, format);
	        if (retVal != null) {
	          // eslint-disable-line no-negated-condition, eqeqeq, no-eq-null
	          return true;
	        } else {
	          // eslint-disable-line no-else-return
	          return false;
	        }
	      }
	
	      return $filter('date')(new Date(value), format).toString() === 'Invalid Date' ? false : true; // eslint-disable-line no-unneeded-ternary
	    };
	
	    return service;
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 31 */
/*!**************************************************!*\
  !*** ./date/date-time-picker-field.directive.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "$filter", "$timeout", "$parse", "fisDateTimeFormatService", "fisFieldDirectiveFactory", "fisMemoryUtilService", "fisUniqueIdService", function ($compile, $filter, $timeout, $parse, fisDateTimeFormatService, fisFieldDirectiveFactory, fisMemoryUtilService, fisUniqueIdService) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	    editTemplate: '<input fis-input="input" class="<% if(field.attrs.fisSize) {%>input-<%=field.attrs.fisSize%><% } else {%>input-large<% }%><%if(field.attrs.fisReadonlyInput === "true") {%> date-ready-only<% }%>"/>',
	
	    viewTemplate: '{{fieldValue()}}',
	
	    link: function link(scope, element, attrs) {
	      var dateTimePickerElem = element.find('input');
	      var ngModel = dateTimePickerElem.controller('ngModel');
	
	      var timeFormat = '12';
	      if (!angular.isUndefined(attrs.fisTimeFormat) && !_.isEmpty(attrs.fisTimeFormat)) {
	        timeFormat = attrs.fisTimeFormat;
	      }
	      var fisLocale = attrs.fisLocale;
	      var dateTimeFormat = attrs.fisDateTimeFormat;
	      var isIgnoreLocaleFormatting = true;
	      if (angular.isUndefined(dateTimeFormat) || _.isEmpty(dateTimeFormat)) {
	        dateTimeFormat = fisDateTimeFormatService.getDateTimeFormat(fisLocale, timeFormat);
	        isIgnoreLocaleFormatting = false;
	      }
	
	      var getFormattedDateTime = function getFormattedDateTime() {
	        var modelVal = ngModel.$modelValue;
	        if (!angular.isUndefined(modelVal)) {
	          var dateTime = fisDateTimeFormatService.getDateTime(modelVal, fisLocale, timeFormat, dateTimeFormat);
	          if (dateTime) {
	            return kendo.toString(dateTime, dateTimeFormat, fisLocale);
	          }
	        }
	      };
	
	      var setDateTimePickerValue = function setDateTimePickerValue() {
	        var widget = dateTimePickerElem.data('kendoDateTimePicker');
	        var widgetValue = widget.value();
	        if (angular.isUndefined(widgetValue) || _.isNull(widgetValue)) {
	          var modelVal = ngModel.$modelValue;
	          if (!angular.isUndefined(modelVal)) {
	            var dateTime = fisDateTimeFormatService.getDateTime(modelVal, fisLocale, timeFormat);
	            widget.value(dateTime);
	          }
	        }
	      };
	
	      var updateDateTimePicker = function updateDateTimePicker() {
	        setDateTimePickerValue();
	        var formattedDateTime = getFormattedDateTime();
	        if (!angular.isUndefined(formattedDateTime)) {
	          dateTimePickerElem.val(formattedDateTime);
	        }
	      };
	
	      dateTimePickerElem.blur(function () {
	        if (!scope.$$phase && !scope.$root.$$phase) {
	          scope.$apply(function () {
	            updateDateTimePicker();
	          });
	        } else {
	          updateDateTimePicker();
	        }
	      });
	
	      var updateDateTimeFormat = function updateDateTimeFormat(options) {
	        var widget = dateTimePickerElem.data('kendoDateTimePicker');
	        widget.setOptions(options);
	        dateTimePickerElem.attr('placeholder', fisDateTimeFormatService.formatPlaceHolder(options.format).toUpperCase());
	      };
	
	      var updateLocale = function updateLocale() {
	        var options = fisDateTimeFormatService.getDateTimePickerOptions(fisLocale, timeFormat);
	        dateTimeFormat = fisDateTimeFormatService.getDateTimeFormat(fisLocale, timeFormat);
	        if (!scope.$$phase && !scope.$root.$$phase) {
	          scope.$apply(function () {
	            updateDateTimeFormat(options);
	          });
	        } else {
	          updateDateTimeFormat(options);
	        }
	      };
	
	      var setMinDateTime = function setMinDateTime() {
	        var widget = dateTimePickerElem.data('kendoDateTimePicker');
	        if (!angular.isUndefined(widget) && !angular.isUndefined(scope.minDateTime)) {
	          widget.min(scope.minDateTime);
	        }
	      };
	
	      var setMaxDateTime = function setMaxDateTime() {
	        var widget = dateTimePickerElem.data('kendoDateTimePicker');
	        if (!angular.isUndefined(widget) && !angular.isUndefined(scope.maxDateTime)) {
	          widget.max(scope.maxDateTime);
	        }
	      };
	
	      var createKendoDateTimePicker = function createKendoDateTimePicker(change, open) {
	        var widget = dateTimePickerElem.data('kendoDateTimePicker');
	        if (widget) {
	          widget.destroy();
	        }
	
	        dateTimePickerElem.kendoDateTimePicker({
	          interval: attrs.fisTimeInterval,
	          change: change,
	          open: open,
	          month: {
	            // template for dates in month view add fisid
	            content: '<div fisid="day_#=data.dateString.split("/").join("_")#">' + // unique by day and month
	            '#= data.value #' + '</div>'
	          },
	          footer: '<div fisid="today_#=kendo.toString(data, "dd") #">' + '#=kendo.toString(data, "D") #' + '</div>'
	        });
	        setMinDateTime();
	        setMaxDateTime();
	      };
	
	      var createOptions = function createOptions(viewValue) {
	        var options = {};
	        options.scope = scope;
	        options.attributes = attrs;
	        options.dateFormat = dateTimeFormat;
	        options.viewValue = viewValue;
	        options.fisLocale = fisLocale;
	        options.timeFormat = attrs.fisTimeFormat || '12';
	        return options;
	      };
	
	      var initializeDateTimePicker = function initializeDateTimePicker() {
	        createKendoDateTimePicker(function () {
	          ngModel.$dirty = true;
	          scope.$evalAsync(function () {
	            if (dateTimePickerElem.data('kendoDateTimePicker').value()) {
	              if (!$.isEmptyObject(ngModel.$error)) {
	                // In case of invalid date, set the view value from kendo date picker.
	                ngModel.$setViewValue(dateTimePickerElem.data('kendoDateTimePicker').value());
	              }
	            }
	          });
	        }, function () {
	          var kendoDateTimePicker = dateTimePickerElem.data('kendoDateTimePicker');
	          if (!kendoDateTimePicker.value()) {
	            if (kendoDateTimePicker.dateView.calendar) {
	              kendoDateTimePicker.dateView.calendar.value(new Date());
	              kendoDateTimePicker.dateView.calendar._value = null;
	            }
	          }
	        });
	
	        // Validate datepicker based on condition provided
	        var validateDate = attrs.fisValidateDate !== 'false';
	        if (!angular.isUndefined(attrs.fisCustomValidate) && !angular.isUndefined(scope[attrs.fisCustomValidate])) {
	          scope.fisCustomValidateFn = scope[attrs.fisCustomValidate];
	        }
	
	        // Add date validator to validate date
	        if (validateDate) {
	          ngModel.$validators.date = function (value) {
	            if (!angular.isUndefined(scope.fisCustomValidateFn)) {
	              // eslint-disable-line no-negated-condition
	              return scope.fisCustomValidateFn(value);
	            } else {
	              // eslint-disable-line no-else-return
	              if (fisDateTimeFormatService.isValid(value) || angular.equals(value, '')) {
	                // eslint-disable-line no-lonely-if
	                return true;
	              }
	            }
	            return false;
	          };
	        }
	
	        // Add date-range validator to validate min/max
	        if (attrs.fisMinDateTime || attrs.fisMaxDateTime) {
	          // This means that date range should be validated
	          ngModel.$validators['date-range'] = function (value) {
	            if (fisDateTimeFormatService.isValid(value)) {
	              var widget = dateTimePickerElem.data('kendoDateTimePicker');
	              if (!angular.isUndefined(widget) && widget !== null) {
	                return fisDateTimeFormatService.isValidDateRange(new Date(value), widget.min(), widget.max());
	              }
	            }
	            return true;
	          };
	        }
	
	        // SDHTML-12931 - This is because of kendo upgrade. The change event of input element doesm't
	        // bind once 'keydown' event is fired. Hence it needs to be explicitly triggered.
	        // Kendo has fixed this defect in the latest version. This code can be removed then.
	        dateTimePickerElem.data('kendoDateTimePicker').bind('change', function () {
	          dateTimePickerElem.trigger('change');
	        });
	
	        // Add model formatters
	        ngModel.$formatters.push(function (modelValue) {
	          var retVal = modelValue;
	          if (modelValue) {
	            modelValue = fisDateTimeFormatService.extractDateTimeFromModelValue(createOptions(modelValue));
	            if (modelValue) {
	              var dateTimePicker = dateTimePickerElem.data('kendoDateTimePicker');
	              if (!angular.isUndefined(dateTimePicker) && dateTimePicker !== null) {
	                dateTimePicker.value(modelValue);
	              }
	              retVal = kendo.toString(modelValue, dateTimeFormat, fisLocale);
	            }
	          }
	          return retVal;
	        });
	
	        // Add model parsers
	        ngModel.$parsers.unshift(function (viewValue) {
	          var retVal = viewValue;
	          if (viewValue) {
	            retVal = fisDateTimeFormatService.extractDateTimeFromViewValue(createOptions(viewValue), dateTimeFormat);
	            if (retVal) {
	              retVal = retVal.toISOString();
	            } else {
	              if (!validateDate) {
	                // eslint-disable-line no-lonely-if
	                retVal = viewValue;
	              }
	            }
	          }
	          return retVal !== null ? retVal : undefined; // eslint-disable-line no-negated-condition
	        });
	
	        if (!isIgnoreLocaleFormatting) {
	          updateLocale();
	        }
	
	        function addSgIdsToTimeViewListItems() {
	          var idTimeout = $timeout(function () {
	            // Add fisIDs to list-items
	            var parentSgId = timeViewList.attr('fisid'); // eslint-disable-line no-use-before-define, block-scoped-var
	            var dropdownItems = timeViewList.find('li'); // eslint-disable-line no-use-before-define, block-scoped-var
	            for (var i = 0; i < dropdownItems.length; i++) {
	              dropdownItems.eq(i).attr('fisid', parentSgId + '_entry_' + i);
	            }
	          });
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, idTimeout, $timeout);
	        }
	
	        if (fis.initParams().appStage === 'T') {
	          element.find('.k-i-calendar').attr('fisid', dateTimePickerElem.attr('fisid') + '_openWidgetCalendarButton');
	          element.find('.k-i-clock').attr('fisid', dateTimePickerElem.attr('fisid') + '_openWidgetClockButton');
	          dateTimePickerElem.data('kendoDateTimePicker').dateView.div.attr('fisid', dateTimePickerElem.attr('fisid') + '_calendar');
	          var timeViewList = dateTimePickerElem.data('kendoDateTimePicker').timeView.list;
	          if (!angular.isUndefined(timeViewList)) {
	            fisUniqueIdService.generateUniqueId(scope, timeViewList, {}, attrs.ngModelInput + '_time_list-container');
	            // Add Ids for Inline Data usage
	            addSgIdsToTimeViewListItems(timeViewList);
	          }
	        }
	      };
	
	      // This overwrites the field value function used in the view template
	      scope.fieldValue = function () {
	        var formattedDateTime = getFormattedDateTime();
	        if (!angular.isUndefined(formattedDateTime)) {
	          // eslint-disable-line no-negated-condition
	          return formattedDateTime;
	        } else {
	          // eslint-disable-line no-else-return
	          return '';
	        }
	      };
	
	      var disabledWatch = scope.$watch('fisDisabled', function (disabled) {
	        dateTimePickerElem.data('kendoDateTimePicker').enable(!disabled);
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, disabledWatch);
	
	      scope.$on('$destroy', function () {
	        var widget = dateTimePickerElem.data('kendoDateTimePicker');
	        fisMemoryUtilService.destroyKendoWidgets(widget);
	      });
	
	      function resetDatePicker(newDate) {
	        if (newDate === undefined || newDate === null || newDate === '') {
	          var dateTimePicker = dateTimePickerElem.data('kendoDateTimePicker');
	          if (!angular.isUndefined(dateTimePicker) && dateTimePicker !== null) {
	            dateTimePicker.value(newDate);
	          }
	        }
	      }
	
	      if (attrs.ngModelInput) {
	        var modelInputWatch = scope.$watch(attrs.ngModelInput, function (newDate, oldDate) {
	          if (+newDate !== +oldDate) {
	            // eslint-disable-line no-implicit-coercion
	            resetDatePicker(newDate);
	          }
	        });
	        fisMemoryUtilService.cancelWatchOnDestroy(scope, modelInputWatch);
	      }
	
	      attrs.$observe('fisLocale', function (value) {
	        fisLocale = value;
	        var options = {
	          locale: value,
	          format: dateTimeFormat
	        };
	        updateDateBasedOnFormatAndLocale(options); // eslint-disable-line no-use-before-define
	      });
	
	      attrs.$observe('fisDateTimeFormat', function (value) {
	        var options = {
	          format: value,
	          locale: fisLocale
	        };
	        updateDateBasedOnFormatAndLocale(options); // eslint-disable-line no-use-before-define
	      });
	
	      var updateDateBasedOnFormatAndLocale = function updateDateBasedOnFormatAndLocale(options) {
	        if (!angular.isUndefined(attrs.fisDateTimeFormat) && !_.isEmpty(attrs.fisDateTimeFormat)) {
	          dateTimeFormat = options.format;
	          updateDateTimeFormat(options);
	          if (ngModel.$modelValue) {
	            ngModel.$modelValue = new Date(ngModel.$modelValue);
	          }
	        } else {
	          updateLocale();
	        }
	      };
	
	      var getMinDateTime = function getMinDateTime() {
	        // AngularJS v1.4 does not call $observe if the attribute is not specified. Hence default values need to be assigned.
	        var minDateTime = $parse(attrs.fisMinDateTime)(scope) || new Date(1900, 0, 1);
	        if (!angular.isDate(minDateTime)) {
	          minDateTime = fisDateTimeFormatService.getDateTimeAsDateTimeObject(minDateTime, fisLocale, timeFormat);
	        }
	        scope.minDateTime = minDateTime;
	        setMinDateTime();
	        return scope.minDateTime;
	      };
	
	      var getMaxDateTime = function getMaxDateTime() {
	        // AngularJS v1.4 does not call $observe if the attribute is not specified. Hence default values need to be assigned.
	        var maxDateTime = $parse(attrs.fisMaxDateTime)(scope) || new Date(2099, 11, 31);
	        if (!angular.isDate(maxDateTime)) {
	          maxDateTime = fisDateTimeFormatService.getDateTimeAsDateTimeObject(maxDateTime, fisLocale, timeFormat);
	        }
	        scope.maxDateTime = maxDateTime;
	        setMaxDateTime();
	        return scope.maxDateTime;
	      };
	
	      attrs.fisMinDateTime = getMinDateTime();
	      attrs.fisMaxDateTime = getMaxDateTime();
	
	      attrs.$observe('fisMinDateTime', function (value) {
	        // Sets min if user cleared minDate
	        if (angular.isUndefined(value) || value === '') {
	          value = new Date(1900, 0, 1);
	        }
	        if (!angular.isDate(value)) {
	          value = fisDateTimeFormatService.getDateTimeAsDateTimeObject(value, fisLocale, timeFormat);
	        }
	        // if(fisDateTimeFormatService.isValid(value)){
	        scope.minDateTime = value;
	        setMinDateTime();
	        // }
	      });
	
	      attrs.$observe('fisMaxDateTime', function (value) {
	        // Sets max if user cleared maxDate
	        if (angular.isUndefined(value) || value === '') {
	          value = new Date(2099, 11, 31);
	        }
	        if (!angular.isDate(value)) {
	          value = fisDateTimeFormatService.getDateTimeAsDateTimeObject(value, fisLocale, timeFormat);
	        }
	        // if(fisDateTimeFormatService.isValid(value)){
	        scope.maxDateTime = value;
	        setMaxDateTime();
	        // }
	      });
	
	      attrs.$observe('fisTimeInterval', function (value) {
	        if (!angular.isUndefined(value)) {
	          // default to 30 min
	          value = value || 30;
	          var dateTimePicker = dateTimePickerElem.data('kendoDateTimePicker');
	          dateTimePicker.setOptions({ interval: value });
	        }
	      });
	
	      attrs.$observe('fisTimeFormat', function (value) {
	        if (!angular.isUndefined(value)) {
	          timeFormat = value;
	          var options = fisDateTimeFormatService.getDateTimePickerOptions(fisLocale, timeFormat);
	          dateTimeFormat = options.format;
	          updateDateTimeFormat(options);
	          if (ngModel.$modelValue) {
	            ngModel.$modelValue = new Date(ngModel.$modelValue);
	          }
	        }
	      });
	
	      // Clear model for readonly mode
	      var clearModal = function clearModal() {
	        ngModel.$setViewValue('');
	      };
	
	      attrs.$observe('fisReadonlyInput', function (readonly) {
	        if (readonly === 'true') {
	          var clearIcon = $compile('<span unselectable="on" class="date-time-clear-button" role="button"><span unselectable="on" class="clear-icon"></span></span>')(scope);
	          if (clearIcon.bind('click') !== undefined) {
	            clearIcon.bind('click', clearModal);
	          }
	          dateTimePickerElem.after(clearIcon);
	        }
	        fisDateTimeFormatService.makeWidgetAsReadOnly(readonly, dateTimePickerElem);
	      });
	
	      scope.resize = function (width) {
	        var kendoDateTimePicker = dateTimePickerElem.data('kendoDateTimePicker');
	        var dateTimePicker = kendoDateTimePicker._inputWrapper;
	        dateTimePicker.removeClass('fis-input'); // this is being applied twice, only need it on the actual input
	        dateTimePicker.css('width', width);
	        dateTimePicker.find('input').css('width', width);
	      };
	
	      // Initialize and create datetime picker component
	      initializeDateTimePicker();
	    }
	  });
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 32 */
/*!*****************************!*\
  !*** ./date/date.filter.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisDateTimeFormatService", function (fisDateTimeFormatService) {
	  'ngInject';
	
	  return function (date, specifiedLocale) {
	    if (!angular.isDate(date)) {
	      if (angular.isString(date) && date.indexOf('T') > 0) {
	        date = fisDateTimeFormatService.getDateTime(date, specifiedLocale, '24');
	      } else {
	        date = fisDateTimeFormatService.getDate(date, specifiedLocale);
	      }
	    }
	    if (angular.isUndefined(date) || _.isNull(date)) {
	      return '';
	    } else {
	      // eslint-disable-line no-else-return
	      // return the newly formatted date
	      var adjustedDate = fisDateTimeFormatService.adjustDateViewValueForTimeZone(date);
	      return fisDateTimeFormatService.formatDate(adjustedDate, specifiedLocale);
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 33 */
/*!*****************************!*\
  !*** ./date/year.filter.js ***!
  \*****************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return function (format, value) {
	    if (format.indexOf('/') !== -1) {
	      var fullYearLength = 4;
	      var shouldAddYear = true;
	      var splitDateFormat = format.split('/');
	      var yearPosition = null;
	      for (var i = 0; i < splitDateFormat.length; i++) {
	        if (splitDateFormat[i].indexOf('y') !== -1) {
	          yearPosition = i;
	          break;
	        }
	      }
	      if (value && value.split) {
	        var dateComponents = value.split('/');
	        shouldAddYear = dateComponents[yearPosition] && dateComponents[yearPosition].length === fullYearLength;
	      }
	      if (shouldAddYear) {
	        var numberOfYsToAdd = fullYearLength - splitDateFormat[yearPosition].length;
	        if (numberOfYsToAdd > 0) {
	          for (var j = 0; j < numberOfYsToAdd; j++) {
	            splitDateFormat[yearPosition] += 'y';
	          }
	        }
	        format = splitDateFormat.join('/');
	      }
	    }
	    return format;
	  };
	};

/***/ }),
/* 34 */
/*!*************************!*\
  !*** ./dialog/index.js ***!
  \*************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _base = __webpack_require__(/*! ../base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _dialog = __webpack_require__(/*! ./dialog.controller */ 35);
	
	var _dialog2 = _interopRequireDefault(_dialog);
	
	var _dialog3 = __webpack_require__(/*! ./dialog.run */ 36);
	
	var _dialog4 = _interopRequireDefault(_dialog3);
	
	var _modalContainer = __webpack_require__(/*! ./modal-container.directive */ 37);
	
	var _modalContainer2 = _interopRequireDefault(_modalContainer);
	
	var _modalDialog = __webpack_require__(/*! ./modal-dialog.directive */ 38);
	
	var _modalDialog2 = _interopRequireDefault(_modalDialog);
	
	var _modalDialog3 = __webpack_require__(/*! ./modal-dialog.provider */ 39);
	
	var _modalDialog4 = _interopRequireDefault(_modalDialog3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.dialog', [_base2.default]);
	
	ngModule.controller('fis.kendo.DialogController', _dialog2.default);
	ngModule.directive('fisModalContainer', _modalContainer2.default);
	ngModule.directive('fisModalDialog', _modalDialog2.default);
	ngModule.provider('fisModalDialogService', _modalDialog4.default);
	
	ngModule.run(_dialog4.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 35 */
/*!*************************************!*\
  !*** ./dialog/dialog.controller.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$scope", "fisModalDialogService", function ($scope, fisModalDialogService) {
	  'ngInject';
	  /**
	   * @name openDialog
	   * @methodOf fis.shell.Controller
	   * @param {String} the name of the modal dialog that needs to be opened
	   * @description
	   * <p>Helper method to open dialog. Delegates to <em>fisModalDialogService</em>.
	   * </p>
	   */
	
	  $scope.openDialog = fisModalDialogService.openDialog;
	
	  /**
	   * @name closeDialog
	   * @methodOf fis.shell.Controller
	   * @param {String} the name of the modal dialog that needs to be closed
	   * @description
	   * <p>Helper method to close dialog. Delegates to <em>fisModalDialogService</em>.
	   * </p>
	   */
	  $scope.closeDialog = fisModalDialogService.closeDialog;
	
	  /**
	   * @name activeDialogs
	   * @fieldOf fis.shell.Controller
	   * @description Reference to active dialogs
	  */
	  // FIXME: why is this exposed in the scope?
	  $scope.activeDialogs = fisModalDialogService.activeDialogs;
	
	  /**
	   * Displays an alert dialog
	   * @param msg The message to be shown
	   * @param def object that contain arguments for alert window
	   * @return {promise} Returns a promise which will be resolved as soon as the dialog gets closed.
	  */
	  $scope.alert = function (msg, def) {
	    def = def || {};
	    def.scope = $scope;
	    return fisModalDialogService.alert(msg, def);
	  };
	
	  /*
	   * Displays a prompt dialog providing the same functionality has window.prompt
	   * @param msg The prompt that will be displayed above the input box
	   * @param def object that contain arguments for prompt window
	   * @returns {promise(string)} Returns a promise on the string that was entered by the user or null if the user
	   * cancelled the operation or closed the dialog.
	  */
	  $scope.prompt = function (msg, def) {
	    def = def || {};
	    def.scope = $scope;
	    return fisModalDialogService.prompt(msg, def);
	  };
	
	  /**
	   * Provides a standard confirm dialog with ok/cancel buttons.
	   * @param msg The message to be shown
	   * @param def object that contain arguments for confirm window
	   * @returns {promise(boolean)} The promise resolves to true if the user clicked ok and false otherwise.
	  */
	  $scope.confirm = function (msg, def) {
	    def = def || {};
	    // determine scope from provided event object or take the shell's scope
	    var scope = def && def.event && def.event.target && angular.element(def.event.target).scope() || $scope;
	    def.scope = scope;
	
	    var title; // eslint-disable-line no-unused-vars
	    var actions; // eslint-disable-line no-unused-vars
	    if (!_.isUndefined(def)) {
	      // eslint-disable-line no-undef
	      title = def.title ? def.title : def;
	      actions = def.actions ? def.actions : undefined;
	    }
	
	    var onConfirmFn = angular.noop;
	
	    if (def && def.onConfirm) {
	      if (angular.isFunction(def.onConfirm)) {
	        onConfirmFn = def.onConfirm;
	      } else if (angular.isString(def.onConfirm)) {
	        // this is an angular expression we want to execute
	        onConfirmFn = function onConfirmFn() {
	          scope.$eval(def.onConfirm);
	        };
	      }
	    }
	
	    var promise = fisModalDialogService.confirm(msg, def).then(function (confirmed) {
	      promise.value = confirmed;
	      if (confirmed) {
	        onConfirmFn();
	      }
	      return confirmed;
	    });
	
	    return promise;
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 36 */
/*!******************************!*\
  !*** ./dialog/dialog.run.js ***!
  \******************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$rootScope", function ($rootScope) {
	  'ngInject';
	
	  if ($rootScope.controllersArr) {
	    $rootScope.controllersArr.push('fis.kendo.DialogController');
	  }
	}];

/***/ }),
/* 37 */
/*!*********************************************!*\
  !*** ./dialog/modal-container.directive.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "$timeout", "fisModalDialogService", "$q", "fisMemoryUtilService", function ($compile, $timeout, fisModalDialogService, $q, fisMemoryUtilService) {
	  'ngInject';
	
	  return {
	    template: '<div class="fis-modal-list"><div id="tempDialog"></div></div>',
	    restrict: 'EA',
	    replace: true,
	    link: function link(scope, element) {
	      scope.dialogObject = {};
	      scope.result = {};
	      fisModalDialogService.registerModalContainer(scope);
	      function isEval(val) {
	        return val.toLowerCase().indexOf('i18n') >= 0; // check if it must be $eval
	      }
	      function addContent(dialogObject) {
	        var content = '';
	        if (dialogObject.contentURL) {
	          content += '<div ng-include src="\'' + scope.dialogObject.contentURL + '\'"></div>';
	        } else {
	          return content += scope.dialogObject.content; // eslint-disable-line no-return-assign
	        }
	        return content;
	      }
	      function addButtons(actions, modalID) {
	        var buttons = '';
	        _.each(actions, function (action) {
	          if (isEval(action.label)) {
	            buttons += ' <button class="' + action.cls + '" id="' + scope.$eval(action.label) + modalID + '" >' + scope.$eval(action.label) + '</button>';
	          } else {
	            buttons += ' <button class="' + action.cls + '"  id="' + action.label + modalID + '" >' + action.label + '</button>';
	          }
	        });
	        return buttons;
	      }
	      scope.addDialog = function (val) {
	        scope.dialogObject = val;
	        var dialogElement = element.find('#tempDialog');
	        var uniqueId = 'modalDialog-' + new Date().getTime();
	
	        if (!_.isUndefined(val) && scope.dialogObject.actions !== undefined && val !== {}) {
	          dialogElement.append('<div fis-name="' + uniqueId + '" class="fis-modal-dialog" fis-title="' + scope.dialogObject.title + '">' + ' <div >' + addContent(scope.dialogObject) + '</div>' + ' <fis-footer>' + ' <div class="fis-action-bar">' + addButtons(scope.dialogObject.actions, uniqueId) + '</fis-footer>' + '</div>' + '</div>');
	          $compile(dialogElement)(scope.dialogObject.scope);
	          var deferred = $q.defer();
	
	          $('.fis-action-bar').delegate('button', 'click', function (event) {
	            var actionLabel = '';
	            _.each(scope.dialogObject.actions, function (action) {
	              if (isEval(action.label)) {
	                actionLabel = scope.$eval(action.label);
	              } else {
	                actionLabel = action.label;
	              }
	              if (event.target.id === actionLabel + uniqueId) {
	                var result = {
	                  action: actionLabel,
	                  close: function close() {
	                    fisModalDialogService.closeDialog();
	                  }
	                };
	                deferred.resolve(result);
	              }
	              scope.$apply();
	            });
	          });
	          // Dom is read with modal and can call modal now
	          var deferredModal = $timeout(function () {
	            deferred.promise = fisModalDialogService.openDialog(uniqueId);
	          });
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, deferredModal, $timeout);
	        }
	        return deferred.promise; // eslint-disable-line block-scoped-var
	      };
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 38 */
/*!******************************************!*\
  !*** ./dialog/modal-dialog.directive.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$timeout", "$compile", "$location", "$rootScope", "$parse", "fisModalDialogService", "fisConfig", "$window", "fisMemoryUtilService", "fisUniqueIdService", "$document", "fisPubSubService", "$interval", "$sanitize", function ($timeout, $compile, $location, $rootScope, $parse, fisModalDialogService, fisConfig, $window, fisMemoryUtilService, fisUniqueIdService, $document, fisPubSubService, $interval, $sanitize) {
	  'ngInject';
	
	  function handleNonModal(scope, $window, attrs) {
	    scope._activePanel = $window.location.hash.substring(1);
	    if (scope._activePanel.indexOf('#') !== -1) {
	      scope._activePanel = scope._activePanel.substring(0, scope._activePanel.indexOf('#'));
	    }
	    scope._modalHidden = false;
	    scope._tabModalHidden = false;
	    // Handle locationChange event of angular. If there is a modal dialog open in a particular view,
	    // hide it when the view loses focus, and show it again when the view gets focus again.
	    scope._viewPanelWithModal = -1;
	    scope._deregisterLocationChangeSuccess = $rootScope.$on('$locationChangeSuccess', function () {
	      if ($location.path() !== scope._activePanel && scope.kendoWindow && scope.kendoWindow.is(':visible')) {
	        scope._viewPanelWithModal = scope._activePanel;
	        scope._modalHidden = true;
	        // closing the dialog here loses dialog state and its original position, we just need to hide it
	        fisModalDialogService.hideNonModalDialog(scope._prependedSgName);
	      } else if (scope._modalHidden && $location.path() === scope._viewPanelWithModal) {
	        fisModalDialogService.showNonModalDialog(scope._prependedSgName);
	        scope._modalHidden = false;
	      }
	    });
	
	    // Handle tabChanged event of fisTabbedComponentList. If there is a modal dialog in a particular tab,
	    // it should be hidden when tab switches, and open up again when the relevant tab opens up again.
	    scope._tabWithModal = -1;
	    scope._tabChangedListener = fisPubSubService.subscribe('fisTabbedComponentList.tabChanged', function (params) {
	      if (scope.kendoWindow && scope.kendoWindow.is(':visible') && attrs.fisSource === 'tabbedList') {
	        scope._tabWithModal = params.oldIndex;
	        scope._tabModalHidden = true;
	        // closing the dialog here loses dialog state and its original position, we just need to hide it
	        fisModalDialogService.hideNonModalDialog(scope._prependedSgName);
	      } else if (scope._tabModalHidden && scope._tabWithModal === params.newIndex) {
	        fisModalDialogService.showNonModalDialog(scope._prependedSgName);
	        scope._tabModalHidden = false;
	      }
	      // heapspace cleanup
	      params = undefined;
	    });
	  }
	
	  function isFalse(val) {
	    return val === 'false' ? false : val;
	  }
	
	  function fillKendoOptions(options, scope) {
	    options.title = $sanitize(scope.fisTitle);
	    options.visible = false;
	    options.modal = scope.fisModal && scope.fisModal.toLowerCase() === 'false' ? false : true; // eslint-disable-line no-unneeded-ternary
	    options.resizable = isFalse(scope.fisResizable) || false;
	    options.width = scope.fisWidth({ dialogName: scope.fisName }) || 500;
	    options.height = scope.fisHeight || 'auto';
	    options.maxWidth = scope.fisMaxWidth || 9999999;
	    options.maxHeight = scope.fisMaxHeight || 9999999;
	    options.minWidth = scope.fisMinWidth || 50;
	    options.minHeight = scope.fisMinHeight || 90;
	    options.draggable = scope.fisDraggable && scope.fisDraggable.toLowerCase() === 'false' ? false : true; // eslint-disable-line no-unneeded-ternary
	    options.maximize = isFalse(scope.fisMaximize) || false;
	    options.maximizable = isFalse(scope.fisMaximizable) || false;
	    options.height = options.height > options.maxHeight ? options.maxHeight : options.height;
	  }
	
	  return {
	    restrict: 'ACE',
	    replace: true,
	    transclude: true,
	    scope: {
	      onCloseFn: '&fisOnClose',
	      fisAutoCenter: '@',
	      fisTitle: '@',
	      fisName: '@',
	      fisHeight: '@',
	      fisContentHeight: '@',
	      fisWidth: '&',
	      fisResizable: '@',
	      fisMaxWidth: '@',
	      fisMaxHeight: '@',
	      fisMinWidth: '@',
	      fisMinHeight: '@',
	      fisDraggable: '@',
	      fisMaximizable: '@',
	      fisMaximize: '@',
	      fisWrapContent: '@',
	      fisInclude: '@',
	      fisClass: '@',
	      fisModal: '@'
	    },
	    template: '<div class="k-content">' + '<div kendo-window data-dialog-name="{{fisName}}"' + ' k-on-activate="initiateHeightUpdate()" k-on-resize="updateOnResize()" k-options="options">' + '<div class="fis-modal-content-wrapper">' + '<div fis-scrollable class="fis-modal-content" fis-height="fisContentHeight" fis-wrap-content="fisWrapContent" ng-transclude>' + '</div>' + '</div>' + '</div>' + '</div>',
	    link: function link(scope, element, attrs) {
	      var options = {};
	
	      options.actions = ['custom-close'];
	      // options.actions = scope.windowActions;
	
	      scope.appliedBindings = false; // used to ensure bindings are only applied once
	      // hide the element before the kendo cycle executes. This is done to avoid flashing the dialog.
	      element.hide();
	      if (!scope.fisName) {
	        throw new Error('fisModalDialog must have a fis-name defined');
	      }
	      scope.kendoWindow = element.children().first();
	      scope._prependedSgName = fisModalDialogService.prependPanelId(scope.fisName);
	      scope._deregisterLocationChangeSuccess = undefined;
	
	      // Non-modal dialog handling
	      if (scope.fisModal === false || scope.fisModal === 'false') {
	        handleNonModal(scope, $window, attrs);
	      }
	
	      /*
	       * This code block manages the config fisModalDialog.widget value!
	       * and its affects on whether to open a dialog maximized
	       * and/or show the max/min icons.
	       */
	      // the config.json widget value
	      var configMax = false;
	      if (fisConfig.widgets && fisConfig.widgets.fisModalDialog) {
	        configMax = fisConfig.widgets.fisModalDialog.maximizable;
	      }
	      var fisOpenMaxUndefined = _.isUndefined(scope.fisMaximize);
	      var fisOpenMax;
	      if (!fisOpenMaxUndefined && scope.fisMaximize === 'true') {
	        fisOpenMax = true;
	      } else {
	        fisOpenMax = false;
	      }
	      var fisMaxUndefined = _.isUndefined(scope.fisMaximizable);
	      var fisMax;
	      if (!fisMaxUndefined && scope.fisMaximizable === 'true') {
	        fisMax = true;
	      } else {
	        fisMax = false;
	      }
	      // eslint-disable-next-line no-negated-condition
	      if (!configMax) {
	        // config is false
	        if (!fisOpenMaxUndefined && !fisMaxUndefined && !fisMax && fisOpenMax) {
	          // no icon, open maximised
	          options.actions = ['custom-close'];
	          scope.fisMaximizable = true;
	        } else if (!fisOpenMaxUndefined && !fisMaxUndefined && fisMax && !fisOpenMax) {
	          // show icon, open normal
	          options.actions = ['Maximize', 'custom-close'];
	          scope.fisMaximizable = false;
	        } else if (!fisOpenMaxUndefined && !fisMaxUndefined && fisMax && fisOpenMax) {
	          // show icon, open maximized
	          options.actions = ['Maximize', 'custom-close'];
	          scope.fisMaximizable = true;
	        } else if (!fisOpenMaxUndefined && !fisMaxUndefined && !fisMax && !fisOpenMax) {
	          // no icon, open normal
	          options.actions = ['custom-close'];
	          scope.fisMaximizable = false;
	        } else if (fisOpenMaxUndefined && !fisMaxUndefined && fisMax && !fisOpenMax) {
	          // no icon, open maximized (1st dialog where you can manually set maximised)
	          options.actions = ['Maximize', 'custom-close'];
	          scope.fisMaximizable = false;
	        }
	      } else {
	        // config is true
	        // eslint-disable-next-line no-lonely-if
	        if (fisOpenMaxUndefined && fisMaxUndefined && !fisMax && !fisOpenMax) {
	          // no icon, open normal
	          options.actions = ['Maximize', 'custom-close'];
	          scope.fisMaximizable = true;
	        } else if (fisOpenMaxUndefined && !fisMaxUndefined && fisMax && !fisOpenMax) {
	          // no icon, open maximized (1st dialog where you can manually set maximised)
	          options.actions = ['Maximize', 'custom-close'];
	          scope.fisMaximizable = true;
	        } else if (!fisOpenMaxUndefined && !fisMaxUndefined && !fisMax && fisOpenMax) {
	          // show icon, open normal
	          options.actions = ['custom-close'];
	          scope.fisMaximizable = true;
	        } else if (!fisOpenMaxUndefined && !fisMaxUndefined && fisMax && !fisOpenMax) {
	          // no icon, open maximized (all other dialogs)
	          options.actions = ['Maximize', 'custom-close'];
	          scope.fisMaximizable = false;
	        } else if (!fisOpenMaxUndefined && !fisMaxUndefined && fisMax && fisOpenMax) {
	          // show icon, open maximized
	          options.actions = ['Maximize', 'custom-close'];
	          scope.fisMaximizable = true;
	        }
	      }
	      // heapspace cleanup
	      configMax = undefined;
	      fisMax = undefined;
	      fisMaxUndefined = undefined;
	      fisOpenMax = undefined;
	      fisOpenMaxUndefined = undefined;
	
	      var innerDiv = angular.element('<div fis-message-container class="fis-message-container-div" style="position:absolute; top:0px; left:0px; width:100%; height:0px;"><div class="fis-info-panel" style="width:100%;"></div></div>');
	      innerDiv.attr('fis-name', scope._prependedSgName);
	      // need to tell the message container, and the action bar the dialogs unique name so they can communicate with each other
	      if (!_.isUndefined(scope.kendoWindow.find('.fis-action-bar').scope())) {
	        // we want the emit events to fire specifically to the modal dialog's message container so we store the dialogs name on the action bars scope
	        scope.kendoWindow.find('.fis-action-bar').scope().fisMessageContainerId = scope._prependedSgName;
	      }
	      $compile(innerDiv)(scope);
	      scope.kendoWindow.append(innerDiv);
	      innerDiv = undefined;
	      // var infoPanel = scope.kendoWindow.find('div.fis-info-panel');
	      // div for the dialog's content
	      var footer;
	      var viewWindow = angular.element($window);
	
	      /**
	       * Capture escape key
	       */
	      var keyEvents = function keyEvents(event) {
	        switch (event.keyCode) {// eslint-disable-line default-case
	          case 27:
	            // Escape Key
	            // needs an unchanging reference as there is no guarantee about how many times this will be called
	            fisModalDialogService.closeDialog(scope._prependedSgName);
	            break;
	        }
	        // heapspace cleanup
	        event = undefined;
	      };
	
	      // add events listener to the document.
	      scope.kendoWindow.on('keydown', undefined, keyEvents);
	      // Tidy Up on destroy by removing listener
	      scope.$on('$destroy', function () {
	        scope.kendoWindow.off('keydown', keyEvents);
	      });
	
	      // when the browser window changes size, this fires
	      scope._browserResizeHandler = function () {
	        if (!_.isUndefined(scope.fisAutoCenter) && scope.fisAutoCenter === 'true') {
	          if (!_.isUndefined(scope.kendoWindow.data('kendoWindow'))) {
	            scope.kendoWindow.data('kendoWindow').center();
	          }
	        }
	        scope.updateHeight();
	      };
	      viewWindow.bind('resize', scope._browserResizeHandler);
	      scope._updateFooterPosition = function (footerElem) {
	        // only calculate and set footer sizes if the dialog is visible
	        if (scope.kendoWindow.parents('.k-widget.k-window').css('display') !== 'none') {
	          // get the padding at the bottom of the modal content wrapper to set as the default
	          var wrapperElem = scope.kendoWindow.find('.fis-modal-content-wrapper');
	          var defaultFooterHeight = Number(wrapperElem.css('paddingBottom').replace('px', ''));
	          if (defaultFooterHeight === 'NaN') {
	            // we set it to zero so later it tries to get the height of the action bar
	            defaultFooterHeight = 0;
	          }
	          // if footerElem is not specified, we try get the footer ourselves
	          var footerBar = footerElem ? footerElem : scope.kendoWindow.find('.fis-footer:visible');
	          if (footerBar.length > 0) {
	            // there might be more than one footer, but we don't calculate anything if there are none
	            var actualFooterHeight = defaultFooterHeight;
	            // outerheight includes padding, so we get the outer height of both the footer and the actionbar
	            var footerOuterHeight = footerBar.outerHeight(); // eslint-disable-line no-unused-vars
	            var actionBarHeight = footerBar.find('.fis-action-bar').outerHeight();
	            if (actionBarHeight > actualFooterHeight) {
	              // if, for whatever reason, the action bar is bigger than the default footer height
	              // we increase the height of the footer to compensate
	              actualFooterHeight = actionBarHeight;
	            }
	            // now we overwrite the default styling with the critically important styles
	            footer.css({
	              position: 'absolute',
	              left: '0px',
	              bottom: '0px',
	              height: actualFooterHeight + 'px',
	              boxSizing: 'border-box' // DO NOT REMOVE, COMPULSORY TO GET CONSISTENT HEIGHTS
	            });
	            actualFooterHeight = undefined;
	          }
	          // heapspace cleanup
	          footerBar = undefined;
	        }
	      };
	
	      /**
	       * Called when dialog is maximized or minimized.
	       *
	       * Do not set the max-height of fisWrapContent dialogs. These use kendo API
	       * to calculate correct height/max-height depending on browser size.
	       *
	       * @returns {boolean}
	       */
	      scope.updateOnResize = function () {
	        // console.log('> updateOnResize');
	        // we do some preliminary checks to verify if the dialog is moving from a maximized to minimized state
	        var windowData = scope.kendoWindow.data('kendoWindow');
	        var resizeDirection = 'x'; // means its minimized/maximized but not resizable
	        if (windowData.resizing !== undefined && windowData.resizing.resizeDirection !== undefined) {
	          // console.log('resize direction: '+windowData.resizing.resizeDirection);
	          // if we have a direction, its resizable
	          resizeDirection = windowData.resizing.resizeDirection;
	        }
	        if (resizeDirection.indexOf('n') === 0 || resizeDirection.indexOf('s') === 0 || resizeDirection === 'x') {
	          // either vertical resize, or min/max(notresizable)
	          if (windowData.options.isMaximized === true) {
	            scope.state = 'maximized';
	            scope._minimizing = false;
	          } else if (windowData.options.isMaximized === false && scope.state === 'maximized') {
	            scope.state = 'minimizing';
	            scope._minimizing = true;
	          } else {
	            scope.state = 'minimized';
	            scope._minimizing = false;
	          }
	          // now we update the height
	          scope.updateHeight();
	        }
	        // console.log('< updateOnResize');
	      };
	
	      scope.decorateSgIdButtons = function (closeIcon) {
	        // Check test and check the kendo component has been created, else wait for next scope apply;
	        if (fis.initParams().appStage === 'T' && !_.isUndefined(scope.kendoWindow.data('kendoWindow'))) {
	          var win = scope.kendoWindow.data('kendoWindow').wrapper;
	          // note that modal dialoges can only exist one per current window, thus no counters.
	          if (scope.fisName.indexOf('generated', 0) > -1) {
	            scope.fisName = 'anonymous_dialog';
	          }
	          var modalContent = win.find('.k-content');
	          fisUniqueIdService.generateIdWithStaticSeed(scope, modalContent, attrs, scope.fisName, null, 'content');
	          if (!closeIcon) {
	            closeIcon = win.find('.k-i-custom-close');
	          }
	          fisUniqueIdService.generateIdWithStaticSeed(scope, closeIcon, attrs, scope.fisName, 'tools', 'close');
	          var maximise = win.find('.k-i-maximize ');
	          fisUniqueIdService.generateIdWithStaticSeed(scope, maximise, attrs, scope.fisName, 'tools', 'maximize');
	          var restore = win.find('.k-i-restore ');
	          fisUniqueIdService.generateIdWithStaticSeed(scope, restore, attrs, scope.fisName, 'tools', 'restore');
	          // heapspace cleanup
	          win = undefined;
	          closeIcon = undefined;
	          modalContent = undefined;
	          maximise = undefined;
	          restore = undefined;
	        }
	      };
	
	      // This function is used to get the bottom css value applied to the footer as an Integer value.
	      scope._getFooterBottomCSSVal = function (footerBottomCss) {
	        var footerBottomCssVal = 0;
	        if (!_.isUndefined(footerBottomCss)) {
	          // eslint-disable-next-line radix
	          footerBottomCssVal = parseInt(footerBottomCss.substring(0, footerBottomCss.indexOf('px'))); // parsing css bottom value to integer
	        }
	        return footerBottomCssVal;
	      };
	
	      scope._resizeModalContentHeight = function (kendoWindowDiv, height, maxHeightOnly, footerHeight, titleBarHeight, maximized) {
	        // console.log('> _resizeModalContentHeight');
	        var contentWrapperDiv = kendoWindowDiv.find('.fis-modal-content-wrapper');
	        var contentDiv = contentWrapperDiv.find('.fis-modal-content');
	        kendoWindowDiv.css('max-height', '');
	        kendoWindowDiv.css('height', '');
	        // contentWrapperDiv.css('paddingBottom', footerHeight + 'px'); removing this as the default size is now specified in the theme
	        if (!_.isUndefined(height) && !_.isNaN(height)) {
	          // eslint-disable-line no-negated-condition
	          var wrapperTopPadding = parseInt(contentWrapperDiv.css('paddingTop')); // eslint-disable-line radix
	          var topPadding = parseInt(contentDiv.css('paddingTop')); // eslint-disable-line radix
	          var bottomPadding = parseInt(contentDiv.css('paddingBottom')); // eslint-disable-line radix
	          var unpaddedHeight = height - topPadding - bottomPadding - footerHeight + wrapperTopPadding;
	          // the content area has padding, we need to remove this from the height value
	          // console.log('  wrapperTopPadding:'+wrapperTopPadding);
	          // console.log('  topPadding:'+topPadding);
	          // console.log('  bottomPadding:'+bottomPadding);
	          // console.log('  unpaddedHeight:'+unpaddedHeight);
	          contentDiv.css('max-height', unpaddedHeight);
	          if (_.isUndefined(maxHeightOnly) || maxHeightOnly === false) {
	            contentDiv.css('height', unpaddedHeight);
	            kendoWindowDiv.css('height', height);
	            scope.fisContentHeight = height; // this updates fisHeight on the modal content area
	            // console.log('  setting window and content heights');
	          } else {
	            contentDiv.css('height', unpaddedHeight);
	            if (maximized) {
	              // the window is maximized, so we set the content height to remember its previous size
	              scope.fisContentHeight = height;
	              // console.log('  content height set to: '+height);
	            }
	          }
	          // we have to explicitly set the right titlebar height here
	          var properTitleHeight = height - footerHeight - contentDiv.outerHeight() + titleBarHeight;
	          // console.log('  properTitleHeight = (height-footerHeight-contentDiv.outerHeight())+titleBarHeight - ('+properTitleHeight+') ('+height+') ('+footerHeight+') ('+contentDiv.outerHeight()+') ('+titleBarHeight+')');
	          kendoWindowDiv.find('.k-window-content').css('padding-top', properTitleHeight + 'px');
	        } else {
	          // we have to unset kendo and our inner content heights to allow the dialog
	          // to fill as much space as it wants, we will always try to supply a height
	          // if there are sufficient attributes on the directive
	          // console.log('  unsetting max, height and content height');
	          contentDiv.css('max-height', '');
	          contentDiv.css('height', '');
	          scope.fisContentHeight = '';
	        }
	        // heapspace cleanup
	        contentWrapperDiv = undefined;
	        contentDiv = undefined;
	        // console.log('< _resizeModalContentHeight');
	      };
	
	      scope.initiateHeightUpdate = function () {
	        // console.log('> initiateHeightUpdate');
	        /* this is called by kendo, and should only happen once in the dialogs lifecycle
	         * the problem here is the calculation needs to be careful of including the height
	         * of the info panel
	         */
	        scope._updateFooterPosition();
	
	        var footers = scope.kendoWindow.find('.fis-footer');
	        angular.forEach(footers, function (footer) {
	          scope.$watch(function () {
	            return angular.element(footer).is(':visible');
	          }, function (newValue, oldValue) {
	            if (newValue !== oldValue) {
	              scope.$evalAsync(function () {
	                scope._updateFooterPosition(angular.element(footer));
	                scope.updateHeight();
	              });
	            }
	          });
	        });
	
	        // recursive height check, runs down the dom until it finds an element with a height set
	        // otherwise we return 0
	        var heightChangeCheck = function heightChangeCheck(tree, skip) {
	          var height = skip ? 0 : tree.outerHeight();
	          // we have to ignore footers in the height check
	          var footer = tree.hasClass('fis-footer') || tree.prop('tagName') === 'FOOTER';
	          if (!footer && height === 0 && tree.children().length > 0) {
	            var totalHeight = 0;
	            // if there are children, run the funciton on the children
	            // and total the values
	            angular.forEach(tree.children(), function (value) {
	              totalHeight += heightChangeCheck(angular.element(value), false);
	            });
	            return totalHeight;
	          } else if (!footer && height > 0) {
	            // console.log('['+tree.prop('tagName')+'] Height Found: '+height);
	            // here we just return the height of the element straight, no need to check for children
	            return height;
	          } else {
	            // eslint-disable-line no-else-return
	            return 0;
	          }
	        };
	        // only watch for content size change if its a resizeable dialog
	        if (scope.fisResizable === true || scope.fisResizable === 'true') {
	          // var timestamp = new Date().getTime();
	          scope.parentElem = scope.kendoWindow.parents('.k-widget.k-window');
	          var intervalReference = $interval(function () {
	            var height = 0;
	            // performance improvement: we keep searching until we find what we looking for, then we store it
	            // and just use the reference
	            var elemToCheck = scope.parentElem;
	            if (elemToCheck.length === 0) {
	              scope.parentElem = scope.kendoWindow.parents('.k-widget.k-window');
	            }
	            if (elemToCheck.length > 0 && elemToCheck.css('display') !== 'none') {
	              // console.log('ping');
	              height = heightChangeCheck(scope.kendoWindow.find('.fis-modal-content'), true);
	            }
	            if (height > 0) {
	              // now kill the watch, we have our initial size so move on
	              $interval.cancel(intervalReference);
	              var totalHeight = '0px';
	              if (scope.fisHeight !== undefined) {
	                // eslint-disable-line no-negated-condition
	                // if there is a default height specified we use that instead
	                totalHeight = scope.fisHeight;
	              } else {
	                // we calculate the total height by adding content height, to padding height and double footer height.
	                // the reason for the double footer add is we are countering a footer subtraction in the later height
	                // calculation, its also because we are applying the size update at a place which doesn't break things
	                // in the later calculation (i.e. on the modal content container)
	                // we add an additional 10 to avoid having a scrollbar show up
	                totalHeight = height + footer.outerHeight() * 2 + Number(scope.kendoWindow.find('.fis-modal-content').css('paddingTop').replace('px', '')) + 10 + 'px';
	              }
	              // console.log('setting content height to: '+totalHeight);
	              scope.kendoWindow.css('height', totalHeight);
	              // now we fire off the resize handler
	              scope._browserResizeHandler();
	            }
	            // console.log('ping - '+timestamp);
	          }, 500);
	        }
	
	        // we need to fire a dialog loaded event through the scope to allow any listening
	        // components to call their on display functions
	        scope.$broadcast('fisModalDialog.displayed', [scope.fisName]);
	        // console.log('< initiateHeightUpdate');
	      };
	
	      scope.setMinHeight = function () {
	        // console.log('> setMinHeight');
	        // only calculate and set footer sizes if the dialog is visible
	        if (scope.kendoWindow.parents('.k-widget.k-window').css('display') !== 'none') {
	          var topMargin = 0; // we ignoring percentages here (they will break our calculations so we force it to just be px)
	          topMargin = Number(scope.kendoWindow.css('marginTop').replace('px', ''));
	          if (topMargin + '' === 'NaN') {
	            // eslint-disable-line no-implicit-coercion
	            topMargin = 0;
	          }
	          // we quickly set the min height
	          var minHeight = scope.kendoWindow.outerHeight() + topMargin;
	          // console.log('setting min height to: '+minHeight);
	          // console.log('windowOuterHeight('+scope.kendoWindow.outerHeight()+'), topMargin('+topMargin+')');
	          scope.kendoWindow.parents('.k-widget.k-window').css('minHeight', minHeight + 'px');
	          scope.fisMinHeight = minHeight;
	        }
	        // console.log('< setMinHeight');
	      };
	
	      scope.updateHeight = function () {
	        // console.log('> updateHeight');
	        scope._updateFooterPosition();
	        if (scope.kendoWindow.parents('.k-widget.k-window').css('display') !== 'none') {
	          var kendoWindowDiv = scope.kendoWindow;
	          var kendoWindowContainer = kendoWindowDiv.parents('.k-widget.k-window');
	          var isMaximized = kendoWindowContainer.hasClass('k-window-maximized');
	          var isResizable = scope.fisResizable;
	          var maxWindowHeight = parseFloat(angular.element(window).height());
	          // if we have a maximized dialog we need to set its height to match the height of the browser
	          var totalWinHeight = kendoWindowContainer.outerHeight(); // height of outer kendowindow
	          var titleBarHeight = kendoWindowContainer.find('.k-window-titlebar').outerHeight(); // height of title bar
	          var titleBarMargin = Number(scope.kendoWindow.css('marginTop').replace('px', '')); // top margin
	          if (titleBarMargin + '' === 'NaN') {
	            // eslint-disable-line no-implicit-coercion
	            titleBarMargin = 0;
	          }
	          var footerHeightValue = footer.outerHeight(); // height of footer
	          if (footerHeightValue === null || footerHeightValue === undefined) {
	            // this happens if the footer is empty (it specifically returns null)
	            footerHeightValue = 0;
	          }
	
	          // the following code handles a min-height issue that occurs with kendoui's faulty resize
	          // when the height of the window gets to the right size, we drop the height % to stop it suddenly
	          // increasing the height of the outer window beyond the actual height of the dialog
	          // (kendo is attempting one last incorrect resize after our resize correctly calculates everything)
	          var contentHeight = parseFloat(kendoWindowContainer.find('.fis-modal-content-wrapper').height());
	          var smallerThanBuffer = 5;
	          if (isResizable !== undefined && kendoWindowContainer.outerHeight() < titleBarMargin + footerHeightValue + contentHeight + smallerThanBuffer) {
	            scope.kendoWindow.css('height', '50%');
	            // console.log('kendo window height 50%');
	          } else {
	            scope.kendoWindow.css('height', '100%');
	            // console.log('kendo window height 100%');
	          }
	          // only set the min height if dialog is resizeable
	          if (isResizable !== undefined) {
	            scope.setMinHeight();
	          }
	
	          var heightToUse = totalWinHeight; // default
	          // console.log('  heightToUse: '+heightToUse);
	          var maxOnly = false;
	          var topBottomBuffer = 40;
	          if (isMaximized) {
	            heightToUse = maxWindowHeight - titleBarHeight; // we use the height of the browser window here
	            // console.log('  heightToUse = maxWindowHeight - titleBarHeight;('+heightToUse+')('+maxWindowHeight+')('+titleBarHeight+')');
	            maxOnly = true;
	          } else if (!_.isUndefined(scope.fisWrapContent) && scope.fisWrapContent === 'true' && _.isUndefined(scope.fisHeight)) {
	            // dialog is in maximized state
	            heightToUse = maxWindowHeight - titleBarHeight - topBottomBuffer; // we use the height of the browser window here
	            // console.log('  heightToUse = maxWindowHeight - titleBarHeight - topBottomBuffer;('+heightToUse+')('+maxWindowHeight+')('+titleBarHeight+')('+topBottomBuffer+')');
	            maxOnly = true;
	          } else if (!scope._minimizing && (isResizable === 'true' || isResizable === true)) {
	            // if dialog can resize then
	            maxOnly = true;
	            heightToUse = totalWinHeight - titleBarHeight; // we use the height of the kendo window here (40px buffer, 20 at top and 20 at bottom)
	            // console.log('  heightToUse = totalWinHeight - titleBarHeight;('+heightToUse+')('+totalWinHeight+')('+titleBarHeight+')');
	          } else if (!_.isUndefined(scope.fisHeight) && scope._minimizing) {
	            // we use the fixed height here
	            maxOnly = true;
	            heightToUse = scope.fisHeight - titleBarHeight; // use the normal dialog height instead
	            // console.log('  heightToUse = scope.fisHeight - titleBarHeight;('+heightToUse+')('+scope.fisHeight+')('+titleBarHeight+')');
	          } else {
	            // if its a non fixed height dialog and not maximized, but its set to wrap, we only set the max size of the dialog
	            // eslint-disable-next-line no-lonely-if
	            if (!_.isUndefined(scope.fisWrapContent) && scope.fisWrapContent === 'true' && _.isUndefined(scope.fisHeight)) {
	              // wrap content means we need to fill the page with the dialog but without being maximized
	              heightToUse = maxWindowHeight - titleBarHeight - footerHeightValue - topBottomBuffer;
	              // console.log('  heightToUse = maxWindowHeight - titleBarHeight - footerHeightValue - topBottomBuffer;('+heightToUse+')('+maxWindowHeight+')('+titleBarHeight+')('+footerHeightValue+')('+topBottomBuffer+')');
	            } else {
	              if (scope.fisHeight !== undefined) {
	                // eslint-disable-line no-negated-condition, no-lonely-if
	                // clamp the height to the max-height, if set
	                if (!_.isUndefined(scope.fisMaxHeight) && scope.fisHeight > scope.fisMaxHeight) {
	                  scope.fisHeight = scope.fisMaxHeight;
	                }
	                heightToUse = parseFloat(scope.fisHeight) - titleBarHeight;
	                // console.log('  heightToUse = scope.fisHeight - titleBarHeight;('+heightToUse+')('+scope.fisHeight+')('+titleBarHeight+')');
	              } else {
	                // this implies that we don't want the dialog to wrap if its too big
	                // we also don't have a set height, so the dialog needs to just size to fit its contents
	                heightToUse = undefined;
	              }
	            }
	          }
	          kendoWindowContainer.css('minHeight', titleBarHeight + footerHeightValue);
	          // console.log('  titleBarHeight:'+titleBarHeight);
	          // console.log('  heightToUse:'+heightToUse);
	          // console.log('  footerHeightValue:'+footerHeightValue);
	          scope._resizeModalContentHeight(kendoWindowContainer, heightToUse, maxOnly, footerHeightValue, titleBarHeight, isMaximized);
	          // now we check if the dialog is meant to auto center
	          if (scope.fisAutoCenter === true || scope.fisAutoCenter === 'true') {
	            if (scope.kendoWindow && scope.kendoWindow.data('kendoWindow')) {
	              scope.kendoWindow.data('kendoWindow').center();
	            }
	          }
	          // redecotate buttons if maximize has been added
	          scope.decorateSgIdButtons();
	          // we set this to false always, it only gets set to true once when dialog is minimized
	          scope._minimizing = false;
	          // heapspace cleanup
	          isMaximized = undefined;
	        }
	        // console.log('< updateHeight');
	      };
	
	      // handle correct tab navigation
	      var keydownHandler = function keydownHandler(event) {
	        if (fisModalDialogService.activeDialogs.length > 0 && _.last(fisModalDialogService.activeDialogs).name === scope._prependedSgName) {
	          if (event.keyCode !== 9) {
	            return;
	          }
	          // fetch all focusable elements
	          var focusableElements = [];
	          _.each(scope.kendoWindow.find('.fis-message-container-div *:focusable,.fis-inputs *:focusable,*:focusable,*:tabbable,.fis-footer *:focusable'), function (elem) {
	            if (angular.element(elem).is('a, button, select, textarea, :input, [tabindex]')) {
	              focusableElements.push(elem);
	            }
	            // heapspace cleanup
	            elem = undefined;
	          });
	          var prevTabIndex = 0; // eslint-disable-line no-unused-vars
	          // sort elements according to tabindex
	          focusableElements = _.sortBy(focusableElements, function (element) {
	            return angular.element(element).attr('tabindex');
	          });
	          var indexOfCurrentElement = focusableElements.indexOf(event.target);
	          var nextElementToFocus = {};
	          if (event.shiftKey) {
	            if (indexOfCurrentElement === 0) {
	              nextElementToFocus = _.last(focusableElements);
	            } else {
	              nextElementToFocus = focusableElements[indexOfCurrentElement - 1];
	            }
	          } else {
	            if (indexOfCurrentElement === focusableElements.length - 1) {
	              // eslint-disable-line no-lonely-if
	              nextElementToFocus = focusableElements[0];
	            } else {
	              nextElementToFocus = focusableElements[indexOfCurrentElement + 1];
	            }
	          }
	          nextElementToFocus.focus();
	          // heapspace cleanup
	          event = undefined;
	          nextElementToFocus = undefined;
	          indexOfCurrentElement = undefined;
	          focusableElements = undefined;
	          return false;
	        }
	      };
	
	      scope.kendoWindow.bind('keydown', keydownHandler);
	      footer = element.find('footer');
	      scope.kendoWindow.css('position', 'relative');
	      var titleElem; // required here so the title can be cleaned up in the destroy
	
	      // register/unregister the modal dialog with the service
	      fisModalDialogService._registerDialog(scope._prependedSgName, {
	        name: scope._prependedSgName,
	        element: scope.kendoWindow,
	        resizeCallback: scope.updateHeight, // we pass a callback to updating this dialogs height, so the service can call update height for the specified dialog
	        wrapContent: scope.fisWrapContent,
	        fisInclude: scope.fisInclude,
	        onClose: function onClose() {
	          // this function is called every time closeDialog is invoked for this modal
	          if (attrs.fisOnClose) {
	            // evaluate the fis-on-close expression and pass the clearDialog function
	            // so that it can be used in expressions
	            return scope.onCloseFn({
	              clearDialog: function clearDialog(opts) {
	                var form;
	                opts = opts || {};
	                // clear the messages displayed in the modal's info panel
	                if (opts.clearMessages !== false) {
	                  var msgContainer = scope.kendoWindow.find('div[fis-message-container]');
	                  msgContainer.scope().clearMessages();
	                  // heapspace cleanup
	                  msgContainer = undefined;
	                }
	                // Make a form inside the modal pristine again
	                if (!opts.formName) {
	                  // eslint-disable-line no-negated-condition
	                  // search for the first form element and get its name
	                  form = scope.kendoWindow.find('form');
	                  if (form) {
	                    opts.formName = form.attr('name');
	                  }
	                } else {
	                  form = scope.kendoWindow.find('[name="' + opts.formName + '"]');
	                }
	                if (form && opts.formName) {
	                  // make the form pristine. This assumes other code in the app's controller is taking care of
	                  // is resetting the form value's to an acceptable initial state.
	                  form.scope()[opts.formName].$setPristine();
	                  document.getElementsByName(opts.formName)[0].reset();
	                  scope.$broadcast('fisClearMessages');
	                }
	                // heapspace cleanup
	                opts = undefined;
	                form = undefined;
	              }
	            });
	          }
	        }
	      });
	
	      // we need to check if the displayed message is too big for its container, if so, the container must get bigger
	      var dispMessage = scope.$on('fisDisplayMessage', function () {
	        $timeout(function () {
	          var infoMessageContainer = scope.kendoWindow.find('.fis-message-container-div .fis-info-panel');
	          var infoMessageList = infoMessageContainer.find('ul');
	          if (parseFloat(infoMessageList.height()) > parseFloat(infoMessageContainer.height())) {
	            infoMessageContainer.css('height', infoMessageList.height());
	            // OLD CODE vv REPLACED WITH LINE OF CODE ABOVE ^^
	            // var messageContainerPositionTop = messageContainerHeight * -1;
	            // var originalStyleContent = infoMessageList.attr('style');
	            // angular.element(scope.kendoWindow.find('.fis-message-container-div')[0]).attr('style',originalStyleContent+';top:'+messageContainerPositionTop+'px !important;');
	            // angular.element(scope.kendoWindow.find('.fis-message-container-div .fis-info-panel')[0]).css({'height': messageContainerHeight+'px'});
	            // angular.element(scope.kendoWindow.find('.fis-message-container-div')[0]).css({'display': 'block'});
	          }
	        }, 0);
	      });
	
	      scope.$on('$destroy', function () {
	        if (dispMessage !== undefined) {
	          dispMessage();
	        }
	        dispMessage = undefined;
	      });
	
	      var stylingWatch = scope.$watch(function (watchedScope) {
	        return watchedScope.kendoWindow.parents('.k-widget.k-window').length > 0 ? watchedScope.fisName : undefined;
	      }, function (watchedWindow) {
	        if (watchedWindow !== undefined) {
	          if (scope.kendoWindow.data('kendoWindow') !== undefined && !scope.appliedBindings) {
	            scope.updateHeight();
	            scope.appliedBindings = true;
	            var kendoWindowData = scope.kendoWindow.data('kendoWindow');
	            // only set minheight if dialog is resizable
	            if (scope.fisResizable !== undefined) {
	              scope.setMinHeight();
	            }
	            var win = kendoWindowData.wrapper;
	            // Add custom class to kendo window to customize window
	            if (scope.fisClass) {
	              win.addClass(scope.fisClass);
	            }
	            /*
	             Find the 'x' in top-right corner of each individual dialog and add a click function
	             to it that, when fired, calls the service to close the dialog.
	             */
	            var closeIcon = win.find('.k-i-custom-close').parent();
	            var closeFunction = function closeFunction(e) {
	              e.preventDefault(); // need to add this, otherwise hash fragment of browser URL is removed
	              if (_.isUndefined(scope.$parent.closeDialog)) {
	                fisModalDialogService.closeDialog(scope._prependedSgName);
	              } else {
	                scope.$parent.closeDialog(scope._prependedSgName);
	              }
	            };
	            if (closeIcon.on('click') !== undefined) {
	              closeIcon.on('click', closeFunction); // makes sure to remove the listener if it happens to already be there
	            }
	            // Tidy Up on destroy by removing listener
	            scope.$on('$destroy', function () {
	              closeIcon.off('click', closeFunction);
	              // heapspace cleanup
	              closeIcon = undefined;
	            });
	            // enable testing via fisid's
	            scope.decorateSgIdButtons();
	            // the title element generated by kendo now binds to the fisTitle present on scope.
	            titleElem = win.children().first().children().first();
	            titleElem.attr('ng-bind', 'fisTitle');
	            $compile(titleElem)(scope);
	            // Removing the element which is an empty fis-modal-dialog div element.
	            // kendo window div is attached at the bottom of the DOM.
	            element.remove();
	            // now need to apply some variables to kendos window data
	            if (!_.isUndefined(scope.fisMaximize) && scope.fisMaximize === 'true') {
	              kendoWindowData.options.position.top = 0;
	              kendoWindowData.options.position.left = 0;
	            }
	            if (!_.isUndefined(scope.fisMinHeight)) {
	              kendoWindowData.options.minHeight = scope.fisMinHeight;
	            }
	            if (!_.isUndefined(scope.fisMaxHeight)) {
	              kendoWindowData.options.maxHeight = scope.fisMaxHeight;
	            }
	            // heapspace cleanup
	            kendoWindowData = undefined;
	            win = undefined;
	            titleElem = undefined;
	          }
	          // Here your view content is fully loaded !!
	          var parentWin = angular.element('div[data-dialog-name="' + watchedWindow + '"]').parents('.k-widget.k-window');
	          if (!_.isUndefined(parentWin) && !parentWin.hasClass('fis-non-modal-dialog') && (scope.fisModal === false || scope.fisModal === 'false')) {
	            // Add custom class to kendo window to customize window
	            parentWin.addClass('fis-non-modal-dialog');
	          }
	          parentWin = undefined;
	        }
	        watchedWindow = undefined;
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, stylingWatch);
	
	      scope.$on('$destroy', function () {
	        // unregister the dialog as it is being destroyed
	        fisModalDialogService._unregisterDialog(scope._prependedSgName);
	        // in race conditions this sometimes removed the wrong dialog without the scope prefix
	        // unbind handlers attached to DOM elements
	        viewWindow.unbind('resize', scope._browserResizeHandler);
	        scope.kendoWindow.unbind('keydown', keydownHandler);
	
	        // unbinding all the events associated with kendoWindow
	        var dialogEvents = scope.kendoWindow.data('kendoWindow');
	        for (var count = 0; count < dialogEvents.events.length; count++) {
	          scope.kendoWindow.unbind(dialogEvents.events[count]);
	        }
	        if (!_.isUndefined(scope._deregisterLocationChangeSuccess)) {
	          scope._deregisterLocationChangeSuccess();
	          scope._deregisterLocationChangeSuccess = undefined;
	        }
	        if (!_.isUndefined(scope._tabChangedListener)) {
	          scope._tabChangedListener();
	          scope._tabChangedListener = undefined;
	        }
	        if (scope.kendoWindow !== undefined) {
	          if (scope.kendoWindow.data('kendoWindow') !== undefined && scope.kendoWindow.data('kendoWindow').destroy !== undefined) {
	            scope.kendoWindow.data('kendoWindow').destroy(); // kendo's destroy
	          }
	          fisMemoryUtilService.purgeAttributes(scope.kendoWindow);
	          scope.kendoWindow.parents('.k-widget.k-window').remove(); // remove the html from the page
	        }
	        if (titleElem !== undefined) {
	          titleElem.removeData().removeAttr();
	        }
	        if (footer !== undefined) {
	          footer.removeData().removeAttr();
	        }
	        element.removeData().removeAttr();
	        element.remove();
	        dialogEvents = undefined;
	        element = undefined;
	        viewWindow = undefined;
	        footer = undefined;
	      });
	
	      // kendo pass-through attributes
	      scope.options = options;
	      var keys = Object.keys(attrs);
	
	      var kAttrWatch = scope.$watch(function () {
	        var dElement = scope.kendoWindow.data('kendoWindow');
	        if (dElement) {
	          for (var i = 0; i < keys.length; i++) {
	            var attr = keys[i];
	            if (attr.indexOf('kOn') === 0) {
	              var kendoEvent = attr.substring(3);
	              kendoEvent = kendoEvent.charAt(0).toLowerCase() + kendoEvent.slice(1);
	              var eventFn = $parse(attrs[attr])(scope.$parent) ? $parse(attrs[attr])(scope.$parent) : attrs[attr];
	              dElement.bind(kendoEvent, eventFn);
	            }
	          }
	          // De-registering Watch
	          kAttrWatch();
	        }
	      });
	
	      for (var i = 0; i < keys.length; i++) {
	        var attr = keys[i];
	        if (attr.indexOf('k') === 0 && attr.indexOf('kOn') !== 0) {
	          var kendoAttribute = attr.substring(1);
	          kendoAttribute = kendoAttribute.charAt(0).toLowerCase() + kendoAttribute.slice(1);
	          var attrVal = $parse(attrs[attr])(scope.$parent.$parent) ? $parse(attrs[attr])(scope.$parent.$parent) : attrs[attr];
	          scope.options[kendoAttribute] = attrVal;
	        }
	      }
	
	      // set kendo options and their defaults
	      fillKendoOptions(options, scope);
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 39 */
/*!*****************************************!*\
  !*** ./dialog/modal-dialog.provider.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var self = this;
	
	  self.$get = ['$q', '$document', '$rootScope', '$compile', '$templateCache', '$injector', '$timeout', '$sanitize', 'fisI18nService', 'fisPubSubService', '$controller', '$http', '$window', 'fisKendoUtilService', function ($q, $document, $rootScope, $compile, $templateCache, $injector, $timeout, $sanitize, fisI18nService, fisPubSubService, $controller, $http, $window, fisKendoUtilService) {
	    var service = {}; // to be returned
	
	    var registeredDialogs = {};
	
	    /**
	     * @name activeDialogs
	     * @fieldOf fisModalDialogService
	     * @description collection of active dialogs
	     */
	    // FIXME: any reason this is public?
	    service.activeDialogs = [];
	
	    service._getParentDialog = function (name) {
	      // we assume the name is 100% correct here as this is an internal function
	      var dialog = registeredDialogs[name];
	      if (!dialog) {
	        throw new Error('No such dialog registered by that name: \'' + name + '\'');
	      }
	      return dialog.element.parents('.k-widget.k-window');
	    };
	
	    service.hideNonModalDialog = function (dialogName) {
	      var parentDialog = service._getParentDialog(dialogName);
	      parentDialog.css('display', 'none');
	    };
	
	    service.showNonModalDialog = function (dialogName) {
	      var parentDialog = service._getParentDialog(dialogName);
	      parentDialog.css('display', 'block');
	    };
	
	    /**
	     * @name openDialog
	     * @methodOf fisModalDialogService
	     * @param {String} the name of the modal dialog that needs to be opened/{Object}dialog object of the modal dialog that needs to be opened
	     * @description
	     * <p>This method opens the dialog with the given dialogName. All the registered dialogs
	     * will be scanned to find the correct dialog. If found, it will be opened, calling the modal
	     * method on the dialog element.
	     * </p>
	     */
	    service.openDialog = function (dialog, cb) {
	      var name = '';
	      if (!dialog) {
	        throw new Error('Cannot open a dialog without a name or dialog definition object');
	      }
	      if (angular.isObject(dialog)) {
	        name = openNewDialog(dialog, cb);
	      } else if (_.isString(dialog)) {
	        dialog = service.prependPanelId(dialog); // required as this call potentially comes from 'user' who won't know all the prepended identifiers
	        service.openNamedDialog(dialog, cb);
	      }
	      // heapspace cleanup
	      dialog = undefined;
	      cb = undefined;
	      return name;
	    };
	
	    /**
	     * @name closeDialog
	     * @methodOf fisModalDialogService
	     * @description
	     * <p>This method closes the dialog with the given dialogName. All the registered dialogs
	     * will be scanned to find the correct dialog. If found, it will be closed.
	     * </p>
	     */
	    service.closeDialog = function (dialogName, invokeOnCloseFn) {
	      var dialog;
	      var result;
	      var fnReturnValue;
	      var deferred = $q.defer();
	      result = deferred.promise;
	      // invokeOnCloseFn will be defined in case of non-modal modal dialogs, wherein we dont want the fis-on-close method to be invoked.
	      // It is possible that the user clears the scope in fis-on-close, and then when the modal dialog shows up again, the form values will be wiped off,
	      // which we do not want.
	      // For rest of the cases, it is defaulted to true.
	      var callOnClose = !_.isUndefined(invokeOnCloseFn) ? invokeOnCloseFn : true; // eslint-disable-line no-negated-condition
	      if (_.isString(dialogName)) {
	        // required as this call potentially comes from 'user' who won't know all the prepended identifiers
	        dialogName = service.prependPanelId(dialogName);
	      }
	      if (service.activeDialogs.length > 0) {
	        if (_.isUndefined(dialogName)) {
	          dialog = service.activeDialogs[service.activeDialogs.length - 1];
	          if (callOnClose) {
	            fnReturnValue = dialog.onClose();
	          }
	          if (!_.isUndefined(fnReturnValue) && fisKendoUtilService.isPromiseObject(fnReturnValue)) {
	            fnReturnValue.then(function (results) {
	              if (_.isUndefined(results) || results !== false) {
	                dialog.win.close();
	              } else {
	                service.activeDialogs.push(dialog);
	              }
	              // remove the last one on the stack (the active one)
	              service.activeDialogs.pop();
	              deferred.resolve(results);
	              // heapspace cleanup
	              dialog = undefined;
	            });
	          } else {
	            if (_.isUndefined(fnReturnValue) || fnReturnValue !== false) {
	              dialog.win.close();
	            } else {
	              service.activeDialogs.push(dialog);
	            }
	            // remove the last one on the stack (the active one)
	            service.activeDialogs.pop();
	            deferred.resolve(fnReturnValue);
	            // heapspace cleanup
	            dialog = undefined;
	          }
	        } else {
	          var foundIndex;
	          var foundWindow;
	          _.each(service.activeDialogs, function (obj, index) {
	            if (obj.name === dialogName) {
	              foundIndex = index;
	              foundWindow = obj;
	            }
	          });
	          if (!_.isUndefined(foundIndex) && !_.isUndefined(foundWindow)) {
	            if (callOnClose) {
	              fnReturnValue = foundWindow.onClose();
	            }
	            if (!_.isUndefined(fnReturnValue) && fisKendoUtilService.isPromiseObject(fnReturnValue)) {
	              fnReturnValue.then(function (results) {
	                if (_.isUndefined(results) || results !== false) {
	                  foundWindow.win.close();
	                  // service.activeDialogs = service.activeDialogs.splice(foundIndex, 1);
	                  service.activeDialogs.splice(foundIndex, 1);
	                  deferred.resolve(results);
	                }
	                // heapspace cleanup
	                foundIndex = undefined;
	                foundWindow = undefined;
	              });
	            } else {
	              if (_.isUndefined(fnReturnValue) || fnReturnValue !== false) {
	                foundWindow.win.close();
	                // service.activeDialogs = service.activeDialogs.splice(foundIndex, 1);
	                service.activeDialogs.splice(foundIndex, 1);
	                deferred.resolve(fnReturnValue);
	              }
	              // heapspace cleanup
	              foundIndex = undefined;
	              foundWindow = undefined;
	            }
	          }
	        }
	      }
	      // heapspace cleanup
	      callOnClose = undefined;
	      dialogName = undefined;
	      invokeOnCloseFn = undefined;
	      return result;
	    };
	
	    service._registerDialog = function (dialogName, def) {
	      if (registeredDialogs[dialogName]) {
	        // heapspace cleanup
	        def = undefined;
	        throw new Error('fisModalDialog already registered with that name: ' + dialogName);
	      }
	
	      registeredDialogs[dialogName] = def;
	      // heapspace cleanup
	      dialogName = undefined;
	      def = undefined;
	    };
	
	    service._unregisterDialog = function (dialogName) {
	      if (registeredDialogs[dialogName]) {
	        delete registeredDialogs[dialogName];
	      }
	      // heapspace cleanup
	      dialogName = undefined;
	    };
	
	    // Construct dialog from parameters
	    function constructDialogFromParameters(msg, opts, serviceType) {
	      var dialog = {};
	      dialog.title = opts.title || '';
	      dialog.scope = opts.scope;
	      dialog.target = opts.target;
	      dialog.width = opts.width;
	      dialog.height = opts.height;
	      dialog.wrapContent = opts.wrapContent;
	      dialog.cls = opts.cls;
	      dialog.uniqueId = serviceType;
	      if (serviceType === 'alert') {
	        dialog.template = '<div class="fis-alert-dialog fis-well">' + $sanitize(msg) + '</div>';
	        dialog.actions = { ok: { label: fisI18nService.translate('ok', 'Ok'), close: true, cls: 'fis-primary' } };
	      } else if (serviceType === 'prompt') {
	        dialog.template = '<div class="fis-prompt-dialog fis-well"><p>' + $sanitize(msg) + '</p><input type="text" fis-unique-id ng-model="model.value"/></div>';
	        dialog.actions = {
	          ok: { label: fisI18nService.translate('ok', 'Ok'), cls: 'fis-primary', close: true },
	          cancel: { label: fisI18nService.translate('cancel', 'Cancel'), cls: 'fis-secondary', close: true }
	        };
	        var optsModel = opts.model;
	        dialog.controller = ['$scope', function ($scope) {
	          $scope.model = optsModel;
	          $scope.$on('$destroy', function () {
	            // on this new controllers scope, when destroyed, clear this model
	            optsModel = undefined;
	          });
	        }];
	      } else if (serviceType === 'confirm') {
	        dialog.template = '<div class="fis-confirm-dialog fis-well">' + $sanitize(msg) + '</div>';
	        var actions = {};
	        if (opts.actions && opts.actions.yesno === true) {
	          actions = {
	            yes: { label: fisI18nService.translate('yes', 'Yes'), cls: 'fis-primary', close: true },
	            no: { label: fisI18nService.translate('no', 'No'), cls: 'fis-secondary', close: true }
	          };
	          // If there are additional yes & no options available, we use them
	          // We treat each of these individually, so that if one property is ommited
	          // it will not break the entire confirm dialog window
	          // Please see https://www.csa.sungard.com/jira/browse/SDHTML-13513
	          if (opts.actions.yes && opts.actions.no) {
	            // If there is a label option
	            if (opts.actions.yes.label && opts.actions.no.label) {
	              actions.yes.label = fisI18nService.translate('yes', opts.actions.yes.label);
	              actions.no.label = fisI18nService.translate('no', opts.actions.no.label);
	            }
	            // If there is a cls (class) option
	            if (opts.actions.yes.cls && opts.actions.no.cls) {
	              actions.yes.cls = opts.actions.yes.cls;
	              actions.no.cls = opts.actions.no.cls;
	            }
	            // If there is a close option
	            if (opts.actions.yes.close && opts.actions.no.close) {
	              actions.yes.close = opts.actions.yes.close;
	              actions.no.close = opts.actions.no.close;
	            }
	          }
	          // allows enabler to use differen label
	        } else if (opts.actions && opts.actions.cancel && opts.actions.ok) {
	          actions = {
	            ok: { label: fisI18nService.translate('ok', opts.actions.ok), cls: 'fis-primary', close: true },
	            cancel: { label: fisI18nService.translate('cancel', opts.actions.cancel), cls: 'fis-secondary', close: true }
	          };
	        } else {
	          actions = {
	            ok: { label: fisI18nService.translate('ok', 'Ok'), cls: 'fis-primary', close: true },
	            cancel: { label: fisI18nService.translate('cancel', 'Cancel'), cls: 'fis-secondary', close: true }
	          };
	        }
	        dialog.actions = actions;
	        // heapspace cleanup
	        actions = undefined;
	      }
	      // heapspace cleanup
	      msg = undefined;
	      opts = undefined;
	      serviceType = undefined;
	      return dialog;
	    }
	
	    service.alert = function (msg, opts) {
	      var deferred = $q.defer();
	      opts = opts || {};
	      var dialogType = {
	        error: 'fis-modal-error-icon',
	        success: 'fis-modal-success-icon',
	        warning: 'fis-modal-warning-icon'
	      };
	      if (!_.isUndefined(dialogType[opts.dialogType]) && !_.isUndefined(opts.headlineMessageText)) {
	        msg = '<span class="' + dialogType[opts.dialogType] + '"></span>' + '<span class="fis-modal-custom-header"> ' + opts.headlineMessageText + '</span>' + '<div class="fis-modal-msg">' + msg + '</div>';
	      }
	      var dialog = constructDialogFromParameters(msg, opts, 'alert');
	      service.openDialog(dialog, function () {
	        deferred.resolve();
	      });
	      // heapspace cleanup
	      msg = undefined;
	      opts = undefined;
	      dialogType = undefined;
	      dialog = undefined;
	      return deferred.promise;
	    };
	
	    service.prompt = function (msg, opts) {
	      var deferred = $q.defer();
	      opts = opts || {};
	      opts.model = { value: opts.value };
	      var dialog = constructDialogFromParameters(msg, opts, 'prompt');
	      service.openDialog(dialog, function (result) {
	        if (result.id === 'ok') {
	          deferred.promise.value = opts.model.value;
	          deferred.resolve(opts.model.value);
	        } else {
	          deferred.resolve(null);
	        }
	        // heapspace cleanup
	        result = undefined;
	      });
	      // heapspace cleanup
	      dialog = undefined;
	      return deferred.promise;
	    };
	
	    service.confirm = function (msg, opts) {
	      var deferred = $q.defer();
	      opts = opts || {};
	      var dialog = constructDialogFromParameters(msg, opts, 'confirm');
	      service.openDialog(dialog, function (result) {
	        if (result.id === 'ok' || result.id === 'yes') {
	          deferred.promise.value = true;
	          deferred.resolve(true);
	        } else {
	          // if result.id is 'close' and promise.value was already set by a result.id of yes/no, don't replace promise.value
	          deferred.promise.value = deferred.promise.value || false;
	          deferred.resolve(false);
	        }
	        // heapspace cleanup
	        result = undefined;
	      });
	      // heapspace cleanup
	      msg = undefined;
	      opts = undefined;
	      dialog = undefined;
	      return deferred.promise;
	    };
	
	    service.openNamedDialog = function (dialogName) {
	      // FIXME: nothing is preventing duplicate names. Should add a way to make name unique
	      var dialog = registeredDialogs[dialogName];
	      if (!dialog) {
	        throw new Error('No such dialog registered by that name: \'' + dialogName + '\'');
	      }
	      dialog.win = dialog.element.data('kendoWindow');
	      service.activeDialogs.push(dialog);
	
	      if (dialog.win) {
	        // Widget got created already
	        openNamedDialogAfterWidgetCreation(dialog);
	      } else {
	        // Widget has not been created yet, so listen for that on the scope and continue afterwards
	        angular.element(dialog.element).scope().$on('kendoWidgetCreated', function (event, widget) {
	          if (widget && widget.options.name === 'Window') {
	            dialog.win = widget;
	            openNamedDialogAfterWidgetCreation(dialog);
	          }
	        });
	      }
	
	      // heapspace cleanup
	      dialogName = undefined;
	      return dialog;
	    };
	
	    function openNamedDialogAfterWidgetCreation(dialog) {
	      if (dialog.win.options.maximize) {
	        dialog.win.center().open().maximize();
	      } else {
	        dialog.win.center().open();
	      }
	      /*
	       * If an fisWrapContent dialog is opened while browser restored down
	       * then make sure it has correct dimensions.
	       */
	      // if (dialog.wrapContent && dialog.wrapContent == 'true') {
	      // setDialogHeight(dialog);
	      // }
	      /*
	       * If dialog contains content taken from an fis-include then
	       * make sure it opens with the correct styling.
	       */
	      if (dialogHasIncludedContent(dialog)) {
	        setStylingForDialogWithInclude(dialog);
	      }
	      // we call the update height function of the dialog to ensure its sized correctly after opening
	      dialog.resizeCallback();
	      /*
	       * If a modal dialog is opened using a directive and it contains
	       * a tabbed component list then broadcast
	       * an event to say so.
	       * This event is subscribed to in fisTabbedCompList and it
	       * ensures that the tabbed comp list is loaded in the DOM and so things
	       * like tabstrip and tab width can be properly read.
	       */
	      if (dialogHasTabbedCompList(dialog)) {
	        var event = {}; // in case we want to send extra info later
	        fisPubSubService.publish('fisModalDialogHasTabbedCompList', event);
	        // heapspace cleanup
	        event = undefined;
	      }
	    }
	
	    var nameCounter = 0;
	
	    function openNewDialog(dialog) {
	      if (!dialog.template && !dialog.templateUrl) {
	        throw new Error('A template or templateUrl needs to be provided to create a dialog.');
	      }
	      var arg;
	      var cb;
	      var name;
	      // look if there's a callback passed as the last argument
	      if (arguments.length > 1) {
	        arg = arguments[arguments.length - 1];
	        if (angular.isFunction(arg)) {
	          cb = arg;
	        }
	      }
	      // heapspace cleanup
	      arg = undefined;
	      // create a unique name for the dialog
	      dialog.name = 'generated' + nameCounter++;
	      name = dialog.name;
	      loadLocals(dialog).then(function (locals) {
	        var dialogObject = locals.dialog;
	        var tpl = getDialogTemplate(dialogObject, locals.$template);
	        var prependedDialogName = service.prependPanelId(dialogObject.name);
	        if (dialogObject.controller) {
	          // get a hold of the controller and provide locals for injection
	          var ctrl = $controller(dialogObject.controller, locals);
	          // add the controller to the children's data as if added by ngController
	          tpl.children().data('ngControllerController', ctrl);
	          // heapspace cleanup
	          ctrl = undefined;
	        }
	        // subscribe to this modal dialog's actions (button clicks by user) and store the unsubscribe function
	        // in the dialog definition object only if a callback is provided
	        dialogObject.unsubscribe = cb ? fisPubSubService.subscribe('fisModalDialog.' + prependedDialogName, cb, true) : angular.noop;
	        // the function that the generated dialog buttons will invoke
	        locals.$scope.dialogAction = function (actionId, event, isCloseInvocation) {
	          if (!_.isUndefined(registeredDialogs[this.dialogName]) && ( // hotkey fires multiple times for old removed dialogs so need to skip them
	          service.activeDialogs.length > 1 && service.getActiveDialogIndex(this.dialogName) === service.activeDialogs.length - 1 || // makesure the hotkey only applies to active dialogs and specifically the last one in the array
	          service.activeDialogs.length === 1 && !_.isUndefined(service.getActiveDialog(this.dialogName)))) {
	            var dialogObj = this.dialogObject;
	            var dialogName = this.dialogName;
	            // get the action object that was provided for the actionId
	            var action = dialogObj.actions && dialogObj.actions[actionId];
	            // the close function that will allow closing this dialog
	            var closeAndDestroy = function closeAndDestroy() {
	              // this is getting called twice... needs to only get called once
	              if (_.isUndefined(isCloseInvocation) || !isCloseInvocation) {
	                service.closeDialog(dialogName);
	              }
	              dialogName = undefined;
	              // unsubscribe the callback
	              if (dialogObj !== undefined) {
	                dialogObj.unsubscribe();
	                // heapspace cleanup
	                dialogObj = undefined;
	              }
	              // destroy the scope we created for the dialog
	              if (locals !== undefined) {
	                locals.$scope.$destroy();
	                // heapspace cleanup
	                locals = undefined;
	              }
	            };
	            if (actionId === 'close' && _.isUndefined(action)) {
	              action = {
	                close: true
	              };
	            }
	            // "action" can be undefined if the close icon is clicked and no "close" action is provided.
	            // If the dialog is already closed (like when the user clicks on the X icon),
	            // the close function returned will be a noop.
	            fisPubSubService.publish('fisModalDialog.' + dialogName, { id: actionId, dialogName: dialogName, action: action, event: event, close: action.close ? angular.noop : closeAndDestroy });
	            // if the action has a "close" property, close the dialog immediately.
	            if (action && action.close) {
	              locals.$scope.$evalAsync(function () {
	                closeAndDestroy();
	              });
	            }
	            // heapspace cleanup
	            actionId = undefined;
	            event = undefined;
	            isCloseInvocation = undefined;
	            return action.close;
	          } else {
	            // eslint-disable-line no-else-return
	            return undefined;
	          }
	        };
	        // attach dialog object and name onto the scope (for use inside the dialogAction function)
	        locals.$scope.dialogObject = dialogObject;
	        locals.$scope.dialogName = prependedDialogName;
	        // compile the dialog with the new scope
	        $compile(tpl)(locals.$scope);
	        // insert it in the dom
	        $document.find('body').append(tpl);
	        // when the current digest cycle is done, make the new dialog visible
	        $timeout(function () {
	          // THIS BREAKS STUFF!!! its closing before its opened
	          var win = service.openNamedDialog(prependedDialogName); // eslint-disable-line no-unused-vars
	          /*
	           * If it is a dialog with extra large content
	           * (has attribute fisWrapContent) then open
	           * it with the contents fully visible
	           */
	          // if (dialogObject.wrapContent === 'true') {
	          //    resizeWrapContentDialog(win.element);
	          // }
	          // heapspace cleanup
	          win = undefined;
	          dialogObject = undefined;
	          prependedDialogName = undefined;
	          tpl = undefined;
	        });
	      });
	      // heapspace cleanup
	      dialog = undefined;
	      return name;
	    }
	
	    /**
	     * Returns a locals object containing the resolved template, items from dialog.resolve and the $scope to
	     * use for compiling a dialog.
	     * @private
	     * @param dialog
	     * @returns promise that gets resolved with the locals object
	     */
	    function loadLocals(dialog) {
	      var values = [];
	      var keys = [];
	      var templatePromise;
	      if (dialog.template) {
	        // if a template string is provided, simply wrap it in a promise
	        templatePromise = $q.when(dialog.template);
	      } else if (dialog.templateUrl) {
	        // if a templateUrl, then fetch the url and wrap the response data in a promise
	        templatePromise = $http.get(dialog.templateUrl, { params: { version: fis.version }, cache: $templateCache }).then(function (response) {
	          return response.data;
	        });
	      }
	      // for each key defined in dialog.resolve, add to the values
	      angular.forEach(dialog.resolve || [], function (value, key) {
	        keys.push(key);
	        values.push(angular.isString(value) ? $injector.get(value) : $injector.invoke(value));
	      });
	      // add the template to the locals keys
	      keys.push('$template');
	      values.push(templatePromise);
	      // heapspace cleanup
	      templatePromise = undefined;
	      // return a promise on the resolved promises value
	      return $q.all(values).then(function (values) {
	        var locals = {};
	        // fill in the locals object with the resolved values
	        angular.forEach(values, function (value, index) {
	          locals[keys[index]] = value;
	          // heapspace cleanup
	          value = undefined;
	          index = undefined;
	        });
	        // Find a base scope that will serve as the dialog's parent scope
	        var baseScope = dialog.scope || dialog.target && angular.element(dialog.target).scope() || $rootScope;
	        // make sure we create a new scope so we can destroy it without fearing destroying a scope we don't
	        // control
	        locals.$scope = baseScope.$new();
	        // save the dialog object used to create this dialog so it can be injected in the controller
	        locals.dialog = dialog;
	        // return the locals, which will be automatically wrapped in a promise by then()
	        // heapspace cleanup
	        values.length = 0; // still referring to the old variable, so 0 it and set to undefined
	        values = undefined;
	        baseScope = undefined;
	        keys = undefined; // bad reference, this needs to be dealt with
	        return locals;
	      });
	    }
	
	    /**
	     * Returns the markup dialog template.
	     *
	     * To add a custom attribute to markup, do this:
	     *
	     * 1. declare it as a property on the modal (dialog) object in the Controller (e.g. desktop-ui.testController.js: var modal = {wrapContent: 'true'}.
	     * 2. this property will then be present in the 'dialog' parameter of this method.
	     * 3. add the attribute to the 'attributes' array below and it will automatically be added as an fis-XXX attribute to the template (tpl) object (e.g. fisWrapContent).
	     * 4. to set its value, get the attribute from the tpl object using jQuery and set its value (e.g tpl.attr('fis-wrap-content', 'your value here');
	     * 5. if opening using markup, i.e. through the Directive first, then also add the attribute in the Directive
	     * where the call is made to fisModalDialogService._registerDialog() (e.g. scope.fisName, {wrapContent: scope.fisWrapContent)
	     *
	     * @param dialog
	     * @param content
	     * @returns {Object}
	     */
	    function getDialogTemplate(dialog, content) {
	      var tpl = angular.element('<div fis-modal-dialog>');
	      var actionBarElem;
	      var footer;
	      var btn;
	      // Look for fis-* attributes specified in the dialog object
	      var attributes = ['name', 'title', 'draggable', 'maximizable', 'maximize', 'resizable', 'width', 'height', 'maxWidth', 'maxHeight', 'minWidth', 'minHeight', 'wrapContent', 'include', 'modal'];
	      _.each(attributes, function (attribute) {
	        if (dialog[attribute] !== undefined && dialog[attribute] !== null) {
	          tpl.attr('fis-' + attribute, dialog[attribute]);
	        }
	        // heapspace cleanup
	        attribute = undefined;
	      });
	
	      var keys = Object.keys(dialog);
	      for (var i = 0; i < keys.length; i++) {
	        var attr = keys[i];
	        if (attr.indexOf('k') === 0) {
	          tpl.attr(attr, dialog[attr]);
	        }
	      }
	
	      if (!_.isUndefined(dialog.uniqueId)) {
	        tpl.attr('fis-unique-id', dialog.uniqueId);
	      }
	      // If wrapContent property is present then set its value
	      if (!_.isUndefined(dialog.wrapContent)) {
	        tpl.attr('fis-wrap-content', dialog.wrapContent);
	      }
	      // If maximize property is present then set its value
	      if (!_.isUndefined(dialog.maximize)) {
	        tpl.attr('fis-maximize', dialog.maximize);
	      }
	      // If maximizable property is present then set its value
	      if (!_.isUndefined(dialog.maximizable)) {
	        tpl.attr('fis-maximizable', dialog.maximizable);
	      }
	      // If fis-include property is present then set its value
	      if (!_.isUndefined(dialog.include)) {
	        tpl.attr('fis-include', dialog.include);
	      }
	      // If fis-class property is present then set its value
	      if (!_.isUndefined(dialog.cls)) {
	        tpl.attr('fis-class', dialog.cls);
	      }
	
	      if (!_.isUndefined(dialog.close)) {
	        // eslint-disable-line no-negated-condition
	        tpl.attr('fis-on-close', dialog.close);
	      } else {
	        tpl.attr('fis-on-close', 'dialogAction(\'close\', $event, true)');
	      }
	
	      tpl.html(content);
	      // if actions are provided, generate a fis-footer with a fis-action-bar
	      if (dialog.actions) {
	        footer = angular.element('<fis-footer>');
	        actionBarElem = angular.element('<div>');
	        actionBarElem.addClass('fis-action-bar');
	        angular.forEach(dialog.actions, function (action, key) {
	          // create a button for each possible action and assign dialogAction function to ng-click
	          // Should not add a action if class not provided
	          if (!_.isUndefined(action.cls)) {
	            var buttonId = 'dialog button ' + key;
	            btn = angular.element('<button fis-unique-id="' + buttonId + '" ng-click="dialogAction(\'' + key + '\', $event)">' + action.label + '</button>');
	            if (action.cls) {
	              btn.addClass(action.cls);
	            } else {
	              btn.addClass('fis-secondary');
	            }
	            // when there is a single button, it should be a primary button
	            if (_.keys(dialog.actions).length === 1) {
	              btn.removeClass('fis-secondary');
	              btn.addClass('fis-primary');
	            }
	            if (btn.attr('class') === 'fis-primary') {
	              btn.attr('fis-hotkey', 'enter');
	              btn.attr('fis-custom-hotkey', 'false');
	            }
	            actionBarElem.append(btn);
	          }
	        });
	        footer.append(actionBarElem);
	        tpl.append(footer);
	      }
	      // heapspace cleanup
	      dialog = undefined;
	      content = undefined;
	      attributes = undefined;
	      actionBarElem = undefined;
	      btn = undefined;
	      footer = undefined;
	      return tpl;
	    }
	
	    /**
	     * Used externally by directive to resize a dialog with
	     * wrapped content.
	     * @param dialog
	     * @returns {Results of method call}
	     */
	    service.resizeDialog = function (dialog) {
	      return resizeWrapContentDialog(dialog);
	    };
	
	    /**
	     * Used externally by directive to resize a dialog
	     * with wrapped content down when the browser is
	     * re-sized.
	     *
	     * @param dialog - the currently active dialog
	     *
	     * @returns {Results of method call}
	     */
	    service.resizeDialogDown = function (dialog) {
	      return resizeDialogDown(dialog);
	    };
	
	    /**
	     * Used externally by directive to resize a dialog
	     * with wrapped content up when the browser is
	     * re-sized.
	     *
	     * @param dialog - the currently active dialog
	     *
	     * @returns {Results of method call}
	     */
	    service.resizeDialogUp = function (dialog) {
	      return resizeDialogUp(dialog);
	    };
	
	    /**
	     * Used externally by directive to find the largest content height
	     *
	     * @param fields - fields of the currently active dialog
	     *
	     * @returns {Results of method call}
	     */
	    service.findLargestItemHeight = function (fields) {
	      return findLargestItemHeight(fields);
	    };
	
	    /**
	     * This function finds the largest content heightamong various content fields
	     * of a dialog box
	     *
	     * @param fields
	     *
	     * @returns (Returns the largest content height value)
	     */
	    function findLargestItemHeight(fields) {
	      var largestHeight = 0;
	      _.each(fields, function (item) {
	        item = angular.element(item);
	        if (parseFloat(item.height()) > largestHeight) {
	          largestHeight = parseFloat(item.height());
	        }
	        // heapspace cleanup
	        item = undefined;
	      });
	      return largestHeight;
	    }
	
	    /**
	     * Used externally by directive to get the form fieds of
	     * a dialog box
	     *
	     * @param wrapper - wrapper of the currently active dialog
	     *
	     * @returns {Results of method call}
	     */
	    service.findDialogFormFields = function (wrapper) {
	      return findDialogFormFields(wrapper);
	    };
	
	    /**
	     * This function sets the height and max-height of the newly opened dialog and
	     * is called when the dialog is first opened.
	     *
	     * If the dialog is higher than the browser then its height is set to 85% of the
	     * browser's height and a max-height is added
	     * to the dialog's contents so that the buttons are visible without having to scroll.
	     *
	     * If the dialog is lower than the browser's height, then the dialog's height
	     * and max-height properties are removed so that kendo can auto resize the dialog.
	     *
	     * @param dialog
	     */
	    function setDialogHeight(dialog) {} // eslint-disable-line no-unused-vars
	    /* var largestHeight = 0; // initialise to zero
	    var browserHeight = angular.element($window).height();
	    var wrapper = dialog.win.wrapper;
	     //Largest height is calculated by getting the height of each form field
	    //and setting it to the height of the highest field.
	    //Doing it this way guarantees that the correct height of the dialog
	    //is always calculated properly.
	     var fields = findDialogFormFields(wrapper);
	    largestHeight = findLargestItemHeight(fields);
	    var buffer = 60; // extra buffer space in case dialog only slightly smaller than browser, still need to resize it.
	    var fisHeightValue = dialog.win.$angular_scope.fisHeight; // get the fis-height attribute
	    var newHeight;
	    if ((largestHeight+buffer) > browserHeight) {
	        if(!_.isUndefined(fisHeightValue) && fisHeightValue !== ""){
	            newHeight = fisHeightValue; // setting the new size to user specified height
	        } else {
	            newHeight = (85 * browserHeight) / 100; // new size should be 85% of new browser size
	        }
	        wrapper.css('height', newHeight + 'px');
	         // To keep the footer (the buttons) always visible, need to set max-height of the div holding the content
	         var fisModalHeight = newHeight - 80;
	        wrapper.find('.fis-modal-content').css('max-height',  + fisModalHeight + 'px');
	        // heapspace cleanup
	        fisModalHeight = undefined;
	    } else if (largestHeight < browserHeight){
	        if(!_.isUndefined(fisHeightValue) && fisHeightValue !== ""){
	            newHeight = fisHeightValue; // setting the new size to user specified height
	        } else {
	            newHeight = largestHeight;
	        }
	        wrapper.css('height', newHeight + 'px'); // set the height according to fis-height or largestHeight of content
	         // Need to remove the max-height on the footer so that
	        // kendo can auto re-size the dialog back up.
	         var fisModalHeight  = newHeight - 80;
	        wrapper.find('.fis-modal-content').css('max-height',  + fisModalHeight + 'px');
	        // heapspace cleanup
	        fisModalHeight = undefined;
	    }
	    dialog.win.center();
	    // heapspace cleanup
	    dialog = undefined;
	    browserHeight = undefined;
	    wrapper = undefined;
	    fields = undefined;
	    buffer = undefined;
	    largestHeight = undefined;
	    newHeight = undefined;
	    fisHeightValue = undefined; */
	
	
	    /**
	     * If the current dialog's height is greater than the browser's
	     * height then resize the dialog to fit 90% of the
	     * browser's new height.
	     *
	     * @param dialog - the currently active dialog
	     */
	    function resizeDialogDown(dialog) {
	      // eslint-disable-line no-unused-vars
	      var browserHeight = parseFloat(angular.element($window).height());
	      var browserWidth = parseFloat(angular.element($window).width()); // eslint-disable-line no-unused-vars
	      var largestHeight = 0;
	      var kendoModal = angular.element('.k-widget.k-window.k-state-focused div.k-window-content');
	      if (kendoModal.data('kendoWindow') !== null && kendoModal.data('kendoWindow')) {
	        var wrapper = kendoModal.data('kendoWindow').wrapper;
	        if (wrapper === undefined) {
	          wrapper = kendoModal.parent();
	        }
	        /*
	         Largest height is calculated by getting the height of each form field
	         and setting it to the height of the highest field.
	        */
	        var fields = findDialogFormFields(wrapper);
	        _.each(fields, function (item) {
	          item = angular.element(item);
	          if (parseFloat(item.height()) > largestHeight) {
	            largestHeight = parseFloat(item.height());
	          }
	          // heapspace cleanup
	          item = undefined;
	        });
	        //                        var wrapContent = wrapper.find('[fis-scrollable]').attr('fis-wrap-content'); // get the wrap content attribute
	        var kenWindowElem = kendoModal.data('kendoWindow');
	        var fisHeightVal = kenWindowElem.$angular_scope.fisHeight; // get the fis-height attribute
	        //                        if (wrapContent.length > 0 && wrapContent == 'true') {  // it the attribute is present and true on the dialog
	        var buffer = 50;
	        if (largestHeight + buffer > browserHeight) {
	          if (!_.isUndefined(fisHeightVal) && fisHeightVal !== '') {
	            // eslint-disable-next-line block-scoped-var
	            var newHeight = fisHeightVal; // setting the new size to user specified height
	          } else {
	            // eslint-disable-next-line block-scoped-var, no-redeclare
	            var newHeight = 90 * browserHeight / 100; // new size should be 90% of new browser size
	          }
	          wrapper.css('height', newHeight + 'px'); // eslint-disable-line block-scoped-var
	          var fisModalHeight = newHeight - 80; // eslint-disable-line block-scoped-var
	          wrapper.find('.fis-modal-content').css('max-height', +fisModalHeight + 'px'); // eslint-disable-line block-scoped-var, no-implicit-coercion
	          wrapper.find('[fis-scrollable]').css('overflow', 'auto');
	          // heapspace cleanup
	          newHeight = undefined; // eslint-disable-line block-scoped-var
	          fisModalHeight = undefined; // eslint-disable-line block-scoped-var
	          fisHeightVal = undefined;
	        } else if (largestHeight + buffer < browserHeight) {
	          var newHeight = ''; // eslint-disable-line block-scoped-var, no-redeclare
	          if (!_.isUndefined(fisHeightVal) && fisHeightVal !== '') {
	            newHeight = fisHeightVal; // eslint-disable-line block-scoped-var
	          } else {
	            newHeight = largestHeight + buffer; // eslint-disable-line block-scoped-var
	          }
	          // eslint-disable-next-line block-scoped-var
	          wrapper.css('height', newHeight + 'px'); // set the height according to fis-height or largestHeight of content
	          var fisModalHeight = newHeight - 80; // eslint-disable-line block-scoped-var, no-redeclare
	          wrapper.find('.fis-modal-content').css('max-height', fisModalHeight + 'px'); // eslint-disable-line block-scoped-var
	          // heapspace cleanup
	          newHeight = undefined; // eslint-disable-line block-scoped-var
	          fisModalHeight = undefined; // eslint-disable-line block-scoped-var
	          fisHeightVal = undefined;
	        }
	        // heapspace cleanup
	        buffer = undefined;
	        //                        }
	        kendoModal.data('kendoWindow').center();
	        kendoModal.data('kendoWindow').$angular_scope.updateHeight(); // to set the proper height of kendowindow while user resize the browser window
	        // heapspace cleanup
	        wrapper = undefined;
	        fields = undefined;
	        //                        wrapContent = undefined;
	        kenWindowElem = undefined;
	      }
	      // heapspace cleanup
	      dialog = undefined;
	      browserHeight = undefined;
	      browserWidth = undefined;
	      largestHeight = undefined;
	      kendoModal = undefined;
	    }
	
	    /**
	     * If the current dialog's height is less than the browser's
	     * height then remove the dialog's CSS height property so
	     * that kendo automatically resizes it up.
	     *
	     * @param dialog - the currently active dialog
	     */
	    function resizeDialogUp(dialog) {
	      // eslint-disable-line no-unused-vars
	      var browserHeight = parseFloat(angular.element($window).height());
	      var kendoModal = angular.element('.k-widget.k-window.k-state-focused div.k-window-content');
	      if (kendoModal.data('kendoWindow') !== null && kendoModal.data('kendoWindow')) {
	        var wrapper = kendoModal.data('kendoWindow').wrapper;
	        var wrapContent = wrapper.find('[fis-scrollable]').attr('fis-wrap-content'); // get the wrap content attribute
	        var kenWindowElem = kendoModal.data('kendoWindow');
	        var fisHeightVal = kenWindowElem.$angular_scope.fisHeight; // get the fis-height attribute
	        if (wrapContent.length > 0 && wrapContent === 'true') {
	          // it the attribute is present and true on the dialog
	          if (parseFloat(wrapper.height()) < browserHeight) {
	            // and the wrapper is currently smaller than the browser
	            var newHeight = '';
	            if (!_.isUndefined(fisHeightVal) && fisHeightVal !== '') {
	              newHeight = fisHeightVal;
	            } else {
	              newHeight = parseFloat(wrapper.height());
	            }
	            wrapper.css('height', newHeight + 'px'); // set the height according to fis-height or wrapper.height()
	            /*
	             Need to remove the max-height on the footer so that
	             kendo can auto re-size the dialog back up.
	             */
	            var fisModalHeight = newHeight - 80;
	            wrapper.find('.fis-modal-content').css('max-height', fisModalHeight + 'px');
	          }
	        }
	        kendoModal.data('kendoWindow').center();
	        // heapspace cleanup
	        wrapper = undefined;
	        wrapContent = undefined;
	        newHeight = undefined; // eslint-disable-line block-scoped-var
	        fisModalHeight = undefined; // eslint-disable-line block-scoped-var
	        fisHeightVal = undefined;
	        kenWindowElem = undefined;
	      }
	      // heapspace cleanup
	      dialog = undefined;
	      browserHeight = undefined;
	      kendoModal = undefined;
	    }
	
	    /**
	     * Used externally by directive to resize a dialog
	     * with wrapped content when the dialog is
	     * maximized and restored down.
	     *
	     * @param dialog - the currently active dialog
	     *
	     * @returns {Results of method call}
	     */
	    service.resizeDialogMaximizable = function (dialog) {
	      return resizeDialogMaximizable(dialog);
	    };
	
	    /**
	     * Ensures the dialog's dimensions are correct
	     * when maximizing and restoring down.
	     *
	     * @param dialog - the currently active dialog
	     */
	    function resizeDialogMaximizable(dialog) {
	      // eslint-disable-line no-unused-vars
	      /*
	      cannot use dialog.win.center() because win is undefined so get the actual DOM
	      element and call center on it.
	       */
	      var kendoModal = angular.element('.k-widget.k-window.k-state-focused div.k-window-content');
	      if (kendoModal.data('kendoWindow') !== null && kendoModal.data('kendoWindow')) {
	        kendoModal.data('kendoWindow').center();
	      }
	      // heapspace cleanup
	      kendoModal = undefined;
	      dialog = undefined;
	    }
	
	    /**
	     * Called when fisWrapContent attribute is present on the dialog.
	     *
	     * Resizes the width of dialog to fit the the width of the content.
	     *
	     * @param dialog - the current active dialog
	     */
	    function resizeWrapContentDialog(dialog) {
	      var win = dialog.data('kendoWindow'); // div k-window
	      var wrapper;
	      var fieldSet;
	      if (!_.isUndefined(win) && win !== null) {
	        wrapper = win.wrapper;
	        fieldSet = wrapper.find('fieldset'); // container for all the form elements
	      }
	      var bufferWidth = 10; // prevents the horizontal scrollbar from showing
	      var largestWidth = parseFloat(fieldSet.width());
	      if (largestWidth === 0) {
	        // fieldset width = 0 when opening dialog programmatically (i.e. using directive)!
	        var fields = findDialogFormFields(wrapper); // get all the form's fields
	        _.each(fields, function (item) {
	          // for each field
	          item = angular.element(item); // convert to angular Object
	          var currentWidth = parseFloat(item.width()); // get its width
	          /*
	           If the width of the current Item exceeds the current largest width
	           then set the width to equal the width of that item
	           */
	          if (currentWidth > largestWidth) {
	            largestWidth = currentWidth;
	          }
	          bufferWidth = 100; // more buffer space needed when opening dialog using directive
	          // heapspace cleanup
	          item = undefined;
	          currentWidth = undefined;
	        });
	        // heapspace cleanup
	        fields = undefined;
	      }
	      var browserWidth = parseFloat(angular.element($window).width());
	      var eightyFivePercentOfWidth = 85 * browserWidth / 100;
	      /*
	       if the content of the dialog is longer than 85% of the browser then
	       set the dialog's width to be 85% of the browser size
	       */
	      if (largestWidth > eightyFivePercentOfWidth) {
	        largestWidth = eightyFivePercentOfWidth;
	      }
	      setDialogWidth(wrapper, largestWidth, bufferWidth);
	      var browserHeight = parseFloat(angular.element($window).height());
	      var dialogHeight = parseFloat(wrapper.height());
	      var eightyFivePercentOfHeight = 85 * browserHeight / 100;
	      /*
	       if the content of the dialog is bigger than 85% of the browser then
	       set the dialog's height to be 85% of the browser size
	       */
	      if (dialogHeight > browserHeight) {
	        wrapper.css('height', eightyFivePercentOfHeight + 'px');
	      }
	      // heapspace cleanup
	      win = undefined;
	      wrapper = undefined;
	      browserHeight = undefined;
	      browserWidth = undefined;
	      bufferWidth = undefined;
	      largestWidth = undefined;
	      fieldSet = undefined;
	      dialog = undefined;
	      dialogHeight = undefined;
	      eightyFivePercentOfWidth = undefined;
	      eightyFivePercentOfHeight = undefined;
	    }
	
	    /**
	     * Sets the width of the dialog to the width of the dialog's fieldset or,
	     * if the dialog is opened using the directive, then the width is the
	     * width of the longset field in the form.
	     *
	     * @param win - the dialog
	     * @param largestWidth
	     * @param bufferWidth
	     */
	    function setDialogWidth(win, largestWidth, bufferWidth) {
	      win.css({
	        width: largestWidth + bufferWidth + 'px'
	      });
	      // heapspace cleanup
	      win = undefined;
	      largestWidth = undefined;
	      bufferWidth = undefined;
	    }
	
	    /**
	     * Returns all the form fields in the dialog.
	     * @param win
	     * @returns {Array}
	     */
	    function findDialogFormFields(win) {
	      // find the content div and all the fields within it
	      return win.find('.fis-modal-content .fis-fields').find('*'); // get the form fields(inputs, textareas + labels)
	    }
	
	    /**
	     * Used externally by directive to insert a horizontal
	     * scrollbar onto a dialog with wrapped content if the
	     * dialog's width exceeds that of the browser.
	     *
	     * @param dialog - the currently active dialog
	     *
	     * @returns {Results of method call}
	     */
	    service.setDialogHorizontalScrollbar = function (dialog) {
	      return setDialogHorizontalScrollbar(dialog);
	    };
	
	    /**
	     * Inserts a horizontal scrollbar onto the div containing
	     * the form fields if the dialog's width exceeds that of the browser
	     * otherwise removes it.
	     *
	     * @param dialog
	     */
	    function setDialogHorizontalScrollbar(dialog) {
	      var fieldSet = dialog.find('fieldset'); // container for all the form elements
	      var largestWidth = parseFloat(fieldSet.width());
	      if (largestWidth === 0) {
	        // fieldset width = 0 when opening dialog programmatically (i.e. using directive)!
	        var fields = findDialogFormFields(dialog); // get all the form's fields
	        _.each(fields, function (item) {
	          // for each field
	          item = angular.element(item); // convert to angular Object
	          var currentWidth = parseFloat(item.width()); // get its width
	          /*
	           If the width of the current Item exceeds the current largest width
	           then set the width to equal the width of that item
	           */
	          if (currentWidth > largestWidth) {
	            largestWidth = currentWidth;
	          }
	          // heapspace cleanup
	          item = undefined;
	          currentWidth = undefined;
	        });
	        // heapspace cleanup
	        fields = undefined;
	        largestWidth = undefined;
	        fieldSet = undefined;
	      }
	      var browserWidth = parseFloat(angular.element($window).width());
	      /*
	       if the dialog width exceeds browser width then insert horizontal scrollbar
	       else remove it.
	       */
	      if (largestWidth > browserWidth) {
	        dialog.find('[fis-message-container]').css('overflow-y', 'scroll');
	      } else {
	        dialog.find('[fis-message-container]').css('overflow-y', '');
	      }
	      // heapspace cleanup
	      dialog = undefined;
	      browserWidth = undefined;
	    }
	
	    /**
	     * Returns true if the currently active dialog
	     * has been built up using an ng-include.
	     *
	     * @param dialog
	     *
	     * @returns {boolean}
	     */
	    function dialogHasIncludedContent(dialog) {
	      var hasInclude = false;
	      if (dialog.fisInclude !== undefined && dialog.fisInclude === 'true') {
	        hasInclude = dialog.fisInclude;
	      } else if (dialog.include) {
	        hasInclude = true;
	      }
	      // heapspace cleanup
	      dialog = undefined;
	      return hasInclude;
	    }
	
	    /**
	     * This function ensures that the scrollable div (containing the
	     * dialog's contents) in a dialog with an include does not have
	     * a scrollbar.
	     *
	     * @param dialog
	     */
	    function setStylingForDialogWithInclude(dialog) {
	      var scrollable;
	      if (dialog.win !== undefined) {
	        // eslint-disable-line no-negated-condition
	        scrollable = dialog.win.wrapper.find('[fis-scrollable]');
	      } else {
	        scrollable = dialog.find('[fis-scrollable]');
	      }
	      scrollable.css('padding-left', 0 + 'px');
	      scrollable.css('padding-right', 0 + 'px');
	      // heapspace cleanup
	      dialog = undefined;
	      scrollable = undefined;
	    }
	
	    /**
	     * Returns true if the currently active dialog
	     * has a tabbed component list embedded.
	     *
	     * @param dialog
	     *
	     * @returns {boolean}
	     */
	    function dialogHasTabbedCompList(dialog) {
	      var hasTabbedCompList = false;
	      var wrapper = dialog.win.wrapper;
	      if (wrapper !== undefined) {
	        hasTabbedCompList = wrapper.find('div[fis-tabbed-component-list]').length > 0;
	      }
	      // heapspace cleanup
	      dialog = undefined;
	      wrapper = undefined;
	      return hasTabbedCompList;
	    }
	
	    /**
	     * Used externally by directive to set styling for
	     * a dialog that has an ng-include.
	     *
	     * @param dialog
	     * @returns {Results of method call}
	     */
	    service.setStylingForDialogWithInclude = function (dialog) {
	      return setStylingForDialogWithInclude(dialog);
	    };
	
	    function _prependPanelId(name, panelPath) {
	      if (_.isString(panelPath) && name.indexOf(panelPath) !== 0) {
	        // The name does not already starts with the panel id
	        return panelPath + '_' + name;
	      }
	      // heapspace cleanup
	      panelPath = undefined;
	      return name;
	    }
	
	    service.prependPanelId = function (name) {
	      // replace '/' of the hash part of URL with '_'
	      var hash = $window.location.hash.substring(2);
	      // if hash part contains another #, then use the path only till there
	      if (hash.indexOf('#') !== -1) {
	        hash = hash.substring(0, hash.indexOf('#'));
	      }
	
	      // This ensure dailog can be closed if path
	      // changes while dailog is still open.
	      var path = hash.replace(/\//g, '_');
	      var isPerpendedName = _.contains(name, '_');
	      var isAnActiveDialog = service.getActiveDialog(name);
	      if (service.activeDialogs.length > 0 && isAnActiveDialog && isPerpendedName) {
	        // path has changed with active dailog
	        return name; // name is already prepended
	      }
	      return _prependPanelId(name, path);
	    };
	
	    service.getActiveDialog = function (name) {
	      var found;
	      _.each(service.activeDialogs, function (item) {
	        if (item.name === name) {
	          found = item;
	        }
	        // heapspace cleanup
	        item = undefined;
	      });
	      return found;
	    };
	
	    service.getActiveDialogIndex = function (name) {
	      var found = false;
	      var index = -1;
	      _.each(service.activeDialogs, function (item) {
	        if (!found) {
	          index++;
	          if (item.name === name) {
	            found = true;
	          }
	        }
	        // heapspace cleanup
	        item = undefined;
	      });
	      return index;
	    };
	
	    return service;
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 40 */
/*!***********************!*\
  !*** ./grid/index.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _base = __webpack_require__(/*! ../base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _data = __webpack_require__(/*! ../data */ 9);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _date = __webpack_require__(/*! ../date */ 21);
	
	var _date2 = _interopRequireDefault(_date);
	
	var _cellAction = __webpack_require__(/*! ./cell-action.directive */ 41);
	
	var _cellAction2 = _interopRequireDefault(_cellAction);
	
	var _editor = __webpack_require__(/*! ./editor.factory */ 42);
	
	var _editor2 = _interopRequireDefault(_editor);
	
	var _filterMenu = __webpack_require__(/*! ./filter-menu.directive */ 43);
	
	var _filterMenu2 = _interopRequireDefault(_filterMenu);
	
	var _gridRow = __webpack_require__(/*! ./grid-row.directive */ 44);
	
	var _gridRow2 = _interopRequireDefault(_gridRow);
	
	var _gridUtil = __webpack_require__(/*! ./grid-util.provider */ 45);
	
	var _gridUtil2 = _interopRequireDefault(_gridUtil);
	
	var _grid = __webpack_require__(/*! ./grid.directive */ 46);
	
	var _grid2 = _interopRequireDefault(_grid);
	
	var _kendoToCriteria = __webpack_require__(/*! ./kendo-to-criteria.filter */ 47);
	
	var _kendoToCriteria2 = _interopRequireDefault(_kendoToCriteria);
	
	var _liveFilter = __webpack_require__(/*! ./live-filter.directive */ 48);
	
	var _liveFilter2 = _interopRequireDefault(_liveFilter);
	
	var _pager = __webpack_require__(/*! ./pager.directive */ 49);
	
	var _pager2 = _interopRequireDefault(_pager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.grid', [_base2.default, _data2.default, _date2.default]);
	
	ngModule.directive('fisCellAction', _cellAction2.default);
	ngModule.factory('fisEditorFactory', _editor2.default);
	ngModule.directive('fisFilterMenu', _filterMenu2.default);
	ngModule.directive('fisGridRow', _gridRow2.default);
	ngModule.provider('fisGridUtilService', _gridUtil2.default);
	ngModule.directive('fisGrid', _grid2.default);
	ngModule.filter('convertKendoFiltersToCriteria', _kendoToCriteria2.default);
	ngModule.directive('fisLiveFilter', _liveFilter2.default);
	ngModule.directive('fisPager', _pager2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 41 */
/*!***************************************!*\
  !*** ./grid/cell-action.directive.js ***!
  \***************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$parse", "$timeout", "fisMemoryUtilService", function ($parse, $timeout, fisMemoryUtilService) {
	  'ngInject';
	
	  return {
	    restrict: 'AC',
	    scope: {
	      actionFn: '&fisCellAction',
	      fisCellAction: '@fisCellAction',
	      fisCellIcon: '@fisCellIcon',
	      fisCellLabel: '@fisCellLabel',
	      fisDisabled: '&fisDisabled'
	    },
	    // eslint-disable-next-line no-multi-str
	    template: '<div>\
	                    <a href="" ng-click="onClick()" ng-if="!isDisabled(fisDisabled)">\
	                        <i ng-if="fisCellIcon !== undefined" fis-unique-id="editButton" ng-class="{{fisCellIcon}}" title="{{fisCellLabel}}"></i>\
	                        <div ng-if="fisCellIcon === undefined">{{fisCellLabel}}</div>\
	                    </a>\
	                    <div ng-if="isDisabled(fisDisabled)" class="fis-cursor-not-allowed">\
	                        <i ng-if="fisCellIcon !== undefined" ng-class="{{fisCellIcon}}" fis-unique-id="editButton" title="{{fisCellLabel}}"></i>\
	                        <div ng-if="fisCellIcon === undefined">{{fisCellLabel}}</div>\
	                    </div>\
	                </div>',
	    transclude: true,
	    link: function link(scope, element, attrs) {
	      // $timeout added to wait for ng-if evaluation
	      var classChange = $timeout(function () {
	        if (scope.fisCellIcon && scope.fisCellIcon.indexOf('{') !== 0) {
	          // simple class name need not be added as ng-class
	          var iconElem = element.find('i[title=' + scope.fisCellLabel + ']');
	          iconElem.addClass(scope.fisCellIcon);
	          iconElem.removeAttr('ng-class');
	        }
	      }, 0);
	      fisMemoryUtilService.cancelTimeoutOnDestroy(scope, classChange, $timeout);
	
	      scope.isDisabled = function (fisDisabled) {
	        return $parse(fisDisabled)(scope);
	      };
	
	      scope.onClick = function () {
	        if (attrs.fisCellAction) {
	          scope.actionFn({ rowData: scope.$parent.rowData });
	        }
	      };
	
	      scope.open = scope.$parent.open;
	
	      scope.$on('$destroy', function () {
	        scope.open = null;
	      });
	    }
	  };
	}];

/***/ }),
/* 42 */
/*!********************************!*\
  !*** ./grid/editor.factory.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return {
	    getNumberEditor: function getNumberEditor(precison, disableSpinner) {
	      var myDecimals = precison;
	      var myFormat = 'n' + precison.toString();
	      var hasSpinner = true;
	
	      if (!_.isUndefined(disableSpinner) && disableSpinner) {
	        hasSpinner = false;
	      }
	
	      var myEditor = function myEditor(container, options) {
	        var ss = $('<input data-bind="value:' + options.field + '"' + ' name=' + options.field + '>') // eslint-disable-line no-useless-concat
	        .appendTo(container).kendoNumericTextBox({
	          format: myFormat,
	          decimals: myDecimals,
	          spinners: hasSpinner
	        });
	
	        var tooltipSpan = $('<span>');
	        tooltipSpan.attr('class', 'k-invalid-msg');
	        tooltipSpan.attr('data-for', options.field);
	        tooltipSpan.appendTo(container);
	
	        return ss;
	      };
	
	      return myEditor;
	    },
	
	    getDateTimeEditor: function getDateTimeEditor(fisDateTimeFormatService) {
	      var locale;
	      var myCulture = fisDateTimeFormatService.getCulture(locale);
	      var myDateTimeFormat = fisDateTimeFormatService.getDateTimeFormat(locale, '12');
	      var myTimeFormat = fisDateTimeFormatService.getTimeFormat(locale, '12');
	      var myEditor = function myEditor(container, options) {
	        var ss = $('<input data-bind="value:' + options.field + '"' + ' name=' + options.field + '>') // eslint-disable-line no-useless-concat
	        .appendTo(container).kendoDateTimePicker({
	          culture: myCulture,
	          format: myDateTimeFormat,
	          timeFormat: myTimeFormat
	        });
	
	        var tooltipSpan = $('<span>');
	        tooltipSpan.attr('class', 'k-invalid-msg');
	        tooltipSpan.attr('data-for', options.field);
	        tooltipSpan.appendTo(container);
	
	        return ss;
	      };
	      return myEditor;
	    },
	
	    getTimeEditor: function getTimeEditor(fisDateTimeFormatService) {
	      var locale;
	      var myCulture = fisDateTimeFormatService.getCulture(locale);
	      var myTimeFormat = fisDateTimeFormatService.getTimeFormat(locale, '12');
	
	      var myEditor = function myEditor(container, options) {
	        var ss = $('<input data-bind="value:' + options.field + '"' + ' name=' + options.field + '>') // eslint-disable-line no-useless-concat
	        .appendTo(container).kendoTimePicker({
	          culture: myCulture,
	          format: myTimeFormat
	        });
	
	        var tooltipSpan = $('<span>');
	        tooltipSpan.attr('class', 'k-invalid-msg');
	        tooltipSpan.attr('data-for', options.field);
	        tooltipSpan.appendTo(container);
	        return ss;
	      };
	      return myEditor;
	    }
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 43 */
/*!***************************************!*\
  !*** ./grid/filter-menu.directive.js ***!
  \***************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return {
	    restrict: 'AC',
	    scope: { fisIndex: '@fisIndex' },
	    replace: true,
	    template: '<div class="dropdown fis-grid-filter-menu-container">' + '<div>' + '<ul class="dropdown-menu pull-right fis-grid-filter-menu-item-container" role="menu">' + '<li fis-unique-id="applyConstraint_constraint_filterMenuContainerIds_{{fisIndex}}" ng-repeat="constraint in columnConstraints.constraints[fisIndex].values" class="fis-grid-filter-menu-item" ng-class="{\'fis-grid-filter-menu-item-selected\': constraint.method === liveFilterCriteria.operands[fisIndex].constraint}" ng-click="applyConstraint(constraint, filterMenuContainerIds[fisIndex])">' + '<div fis-unique-id="filterMenuContainerdiv_{{fisIndex}}" title={{constraint.label}} >' + '{{constraint.label}}' + '</div>' + '</li>' + '</ul>' + '</div>' + '<a class="dropdown-toggle k-icon k-filter fis-grid-filter-icon" fis-unique-id="filterIcon_{{fisIndex}}"></a>' + '</div>',
	    link: function link(scope, element) {
	      scope.columnConstraints = scope.$parent.columnConstraints;
	      scope.applyConstraint = scope.$parent.applyConstraint;
	      scope.liveFilterCriteria = scope.$parent.liveFilterCriteria;
	
	      scope.$on('$destroy', function () {
	        // check if elements have already been rendered
	        element.off();
	        element.remove();
	        scope.columnConstraints = null;
	      });
	    }
	  };
	};

/***/ }),
/* 44 */
/*!************************************!*\
  !*** ./grid/grid-row.directive.js ***!
  \************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return {
	    restrict: 'C',
	    scope: true,
	    link: function link() {}
	  };
	};

/***/ }),
/* 45 */
/*!************************************!*\
  !*** ./grid/grid-util.provider.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  /**
	   * @private
	   */
	
	  var self = this;
	
	  /**
	   * @name $get
	   * @methodOf fisGridUtilServiceProvider
	   * @description <p>Factory method to create instance of fisNumberFormatService.</p>
	   */
	  self.$get = ['fisI18nService', 'fisPubSubService', 'fisUniqueIdService', 'fisCriteriaService', function (fisI18nService, fisPubSubService, fisUniqueIdService, fisCriteriaService) {
	    var constraintsWithoutValue = [fisCriteriaService.constraints.IS_EMPTY, fisCriteriaService.constraints.NOT_EMPTY, fisCriteriaService.constraints.IS_NULL, fisCriteriaService.constraints.NOT_NULL];
	
	    /**
	     * @private
	     */
	    var service = {}; // to be returned
	
	    /**
	     * Get the grid's name. Preferred option is uniqueIdSeed, with fallback onto fisData or existing fisid.
	     * @param attrs
	     * @param scope
	     * @param kendoGrid
	     * @returns {*}
	     */
	    service.getGridName = function (attrs, scope, kendoGrid) {
	      var gridName;
	      var jGrid;
	      if (kendoGrid) {
	        jGrid = $(kendoGrid);
	      }
	      if (attrs.fisUniqueIdSeed) {
	        gridName = fisUniqueIdService.generateIdWithStaticSeed(scope, jGrid, attrs);
	      } else {
	        if (kendoGrid && _.isUndefined(kendoGrid.fisid)) {
	          gridName = fisUniqueIdService.generateUniqueId(scope, jGrid, {}, attrs.fisData);
	        }
	        if (!kendoGrid) {
	          gridName = fisUniqueIdService.generateUniqueId(scope, undefined, {}, attrs.fisData);
	        } else if (kendoGrid) {
	          gridName = kendoGrid.fisid;
	        }
	      }
	      // catch all warning to add a name to the grid!
	      if (_.isUndefined(gridName)) {
	        console.warn('Grid has no unique name - please add  a fis-unique-id-seed or defined a unique fis-data source');
	      }
	      jGrid = null;
	      return gridName;
	    };
	
	    /**
	     * @name getCorrectOperator
	     * @param operator {String}
	     *
	     * @description converts and returns the incoming String criteria
	     * into a format that can be understood by fisGrid filter.
	     */
	    service.getCorrectOperator = function (operator) {
	      if (operator === 'starts_with') {
	        return 'startswith';
	      } else if (operator === 'ends_with') {
	        return 'endswith';
	      } else if (operator === 'not_contains') {
	        return 'doesnotcontain';
	      } else if (operator === 'ne') {
	        return 'neq';
	      } else if (operator === 'ge') {
	        return 'gte';
	      } else if (operator === 'le') {
	        return 'lte';
	      }
	      return operator;
	    };
	
	    /**
	     * returns custom filter for date fields to ignore time when filtering
	     * @param constraint
	     * @param fieldName
	     * @param selectedDate
	     * @param scope
	     */
	    service.getCustomDateFilter = function (constraint, fieldName, selectedDate, scope) {
	      var result = scope.gridColumns().filter(function (obj) {
	        return obj.field == fieldName; // eslint-disable-line eqeqeq
	      });
	      selectedDate = kendo.format(result[0].format, selectedDate);
	      return {
	        field: fieldName,
	        operator: function operator(fieldDate) {
	          // create custom filter operator
	          var parsedSelectedDate = kendo.parseDate(selectedDate);
	          var result = false;
	          if (!_.isNull(fieldDate)) {
	            // parse the field date in order to ignore the time
	            var parsedFieldDate = new Date(fieldDate.getFullYear(), fieldDate.getMonth(), fieldDate.getDate());
	            if (constraint === 'gt') {
	              result = parsedFieldDate.getTime() > parsedSelectedDate.getTime();
	            } else if (constraint === 'lt') {
	              result = parsedFieldDate.getTime() < parsedSelectedDate.getTime();
	            } else if (constraint === 'ge') {
	              result = parsedFieldDate.getTime() == parsedSelectedDate.getTime() || parsedFieldDate.getTime() >= parsedSelectedDate.getTime(); // eslint-disable-line eqeqeq
	            } else if (constraint === 'le') {
	              result = parsedFieldDate.getTime() == parsedSelectedDate.getTime() || parsedFieldDate.getTime() <= parsedSelectedDate.getTime(); // eslint-disable-line eqeqeq
	            } else if (constraint === 'eq') {
	              // eq
	              result = parsedFieldDate.getTime() == parsedSelectedDate.getTime(); // eslint-disable-line eqeqeq
	            } else {
	              result = parsedFieldDate.getTime() !== parsedSelectedDate.getTime();
	            }
	          }
	          return result;
	        },
	        value: selectedDate
	      };
	    };
	
	    /**
	     * Builds a JSON object for the grid's filter
	     * using values taken from the incoming criteria (filterArgs) object.
	     *
	     * @param filterArgs
	     * @param resultObj
	     * @param attrs
	     * @param dataSource
	     * @param scope
	     */
	    service.getGridFilterObject = function (filterArgs, resultObj, attrs, dataSource, scope) {
	      resultObj.logic = filterArgs.operator;
	      if (filterArgs.operands) {
	        resultObj.filters = [];
	      }
	      for (var i = 0; i < filterArgs.operands.length; i++) {
	        var operand = filterArgs.operands[i];
	        if (operand.operands) {
	          resultObj.filters.push({});
	          service.getGridFilterObject(operand, resultObj.filters[i], attrs, dataSource, scope);
	        } else {
	          var filter;
	          if (dataSource && dataSource.reader && dataSource.reader.model && !_.isEmpty(dataSource.reader.model.fields)) {
	            if (dataSource.reader.model.fields[operand.property].type === 'date') {
	              if (attrs.fisMode && attrs.fisMode === 'local') {
	                filter = service.getCustomDateFilter(operand.constraint, operand.property, operand.value, scope);
	              } else {
	                var parsedSelectedDate = kendo.parseDate(operand.value);
	                var parsedFieldDate = new Date(Date.UTC(parsedSelectedDate.getFullYear(), parsedSelectedDate.getMonth(), parsedSelectedDate.getDate()));
	                filter = { field: operand.property, operator: service.getCorrectOperator(operand.constraint), value: parsedFieldDate };
	              }
	            } else {
	              // not a date
	              operand.value = dataSource.reader.model.fields[operand.property].parse(operand.value);
	              filter = { field: operand.property, operator: service.getCorrectOperator(operand.constraint), value: operand.value };
	            }
	          } else {
	            // grids with fisSchemaColumns have an empty dataSource.reader.model.fields
	            filter = { field: operand.property, operator: service.getCorrectOperator(operand.constraint), value: operand.value };
	          }
	          resultObj.filters.push(filter);
	        }
	      }
	    };
	
	    /**
	     * This function removes empty values from
	     * the Criteria sent to the server when
	     * filtering a grid with fis-live-filtering.
	     *
	     * This prevents the following error thrown by GridAccountService.java:
	     * GET ... 400 (Unable to extract parameter from http request: javax.ws.rs.QueryParam("crit")
	     *
	     * @param criteria
	     */
	    service.removeEmptySearchCriteria = function (criteria) {
	      /*
	       * Need to iterate in reverse because
	       * splice changes the index
	       */
	      var len = criteria.operands.length;
	      while (len--) {
	        var operand = criteria.operands[len];
	        if (!_.contains(constraintsWithoutValue, operand.constraint)) {
	          if (_.isNull(operand.value) || operand.value === '') {
	            criteria.operands.splice(len, 1);
	          }
	        }
	      }
	      return criteria;
	    };
	
	    /**
	     * This function builds a filter object to send to the grid's filter
	     * so that when the grid loads, only those rows matching the criteria
	     * are displayed.
	     *
	     * @error if the filterArgs argument is not a valid fisCriteria object.
	     *
	     * @param ds
	     * @param filterArgs
	     * @param scope
	     * @param attrs
	     */
	    service.buildGridFilterObject = function (ds, filterArgs, scope, attrs) {
	      if (!_.isObject(filterArgs)) {
	        handleError(scope, 'filterArgs must be a valid fisCriteria object', null, 'fisCriteria');
	        return;
	      }
	      var filterCritObj = fisCriteriaService.newCriteria(filterArgs);
	      try {
	        filterCritObj.validate(); // throws an error if not valid
	      } catch (err) {
	        handleError(scope, err, null, 'fisCriteria');
	        return;
	      }
	      var criteriaToKendoFilter = {};
	      service.getGridFilterObject(filterArgs, criteriaToKendoFilter, attrs, ds, scope);
	      return criteriaToKendoFilter;
	
	      //                if (!_.isEqual(criteriaToKendoFilter, ds._filter)) {
	      //                    // Only do filtering if the new filter is different than the current one
	      //                    // Especially usefull to not trigger the search when changing constraint of an empty field
	      //                    // if other fields are filled
	      //                    doFilter(criteriaToKendoFilter, ds);
	      //                }
	    };
	
	    /**
	     * Returns the maximum height the given element may grow to without getting larger than the parent
	     * Iterates over all other children
	     * @param element DOM object to investigate the max height for
	     * @returns {*}
	     */
	    service.getAvailableHeightInParent = function (element) {
	      var parent = element.parent();
	      var height = parseFloat(parent.height());
	      // If we're not the only children, need to check what the heights of our siblings are
	      if (parent.children().length > 1) {
	        // Work with offsets, so we don't have to deal with collapsing margins
	        var parentTopOffset = parent.offset().top;
	        var elementTopOffset = element.offset().top;
	        var elementBottomOffset = elementTopOffset + element.outerHeight();
	        var firstChildrenTopOffset = elementTopOffset;
	        var lastChildrenBottomOffset = elementBottomOffset;
	        var foundElem = false;
	        _.each(parent.children(), function (child) {
	          // Iterate over all children from top to bottom
	          child = angular.element(child); // Wrap it
	          if (child[0] !== element[0]) {
	            // eslint-disable-line no-negated-condition
	            if (foundElem) {
	              // children is after our element in DOM
	              var childrenBottomOffset = child.offset().top + child.outerHeight();
	              if (childrenBottomOffset >= elementBottomOffset && childrenBottomOffset > lastChildrenBottomOffset) {
	                lastChildrenBottomOffset = childrenBottomOffset;
	              }
	            } else {
	              // children is prior to our element in DOM
	              var childrenTopOffset = child.offset().top;
	              if (childrenTopOffset >= parentTopOffset && childrenTopOffset < firstChildrenTopOffset) {
	                firstChildrenTopOffset = childrenTopOffset;
	              }
	            }
	          } else {
	            // Set flag that all children() to come are located after/below our element
	            foundElem = true;
	          }
	        });
	        var spaceUsedAbove = elementTopOffset - firstChildrenTopOffset;
	        var spaceUsedBelow = lastChildrenBottomOffset - elementBottomOffset;
	        height = height - spaceUsedAbove - spaceUsedBelow;
	      }
	      return height;
	    };
	
	    /**
	     * Get the callType/HTTP request method associated for the given kind of action.
	     * Returns POST for all unknown actions.
	     * @param actionName name of the action, currently supported 'Create', 'Update' and 'Delete'
	     * @param attrs
	     * @returns {*} used calltype to perform server requests
	     */
	    service.getCallType = function (actionName, attrs) {
	      var overallDefault = 'POST';
	      var callTypes = {
	        Create: { attr: 'fisDataCreateType', default: 'POST' },
	        Update: { attr: 'fisDataUpdateType', default: 'PUT' },
	        Delete: { attr: 'fisDataDeleteType', default: 'DELETE' }
	      };
	      if (!_.isUndefined(callTypes[actionName])) {
	        if (!_.isUndefined(attrs[callTypes[actionName].attr])) {
	          return attrs[callTypes[actionName].attr];
	        } else if (!_.isUndefined(callTypes[actionName].default)) {
	          return callTypes[actionName].default;
	        }
	      }
	      return overallDefault;
	    };
	
	    /**
	     * Generates resource url from fis-data for standard REST endpoint
	     * @param actionName name of the action, currently supported 'Update' and 'Delete'
	     * @param attrs
	     * @param ds datasource
	     * @param scope
	     * @returns {*}
	     */
	    service.generateResourceURL = function (actionName, attrs, ds, scope) {
	      var url = attrs.fisData;
	      if (actionName === 'Update' || actionName === 'Delete') {
	        if (!_.isUndefined(ds.options.schema.model.id)) {
	          // eslint-disable-line no-negated-condition
	          url = attrs.fisData + '/:id';
	          attrs['fisData' + actionName + 'ParamId'] = '@' + ds.options.schema.model.id;
	        } else {
	          service.handleError(scope, 'No unique column identifier provided, please provide schema model using fis-schema', null, 'fisSchema');
	          return;
	        }
	      }
	      return url;
	    };
	
	    service.generateURLParams = function (actionName, attrs) {
	      var methodName = attrs['fisData' + actionName];
	      if (!_.isUndefined(methodName)) {
	        var extractRegEx = /\/:\w+/g;
	        var placeholders = methodName.match(extractRegEx);
	        if (placeholders) {
	          for (var i = 0; i < placeholders.length; i++) {
	            var paramsId = placeholders[i].replace('/:', '');
	            var attrsId = paramsId.charAt(0).toUpperCase() + paramsId.slice(1);
	            if (_.isUndefined(attrs['fisData' + actionName + 'Param' + attrsId])) {
	              attrs['fisData' + actionName + 'Param' + attrsId] = '@' + paramsId;
	            }
	          }
	        }
	      }
	    };
	
	    service.handleError = function (scope, data, status, errorType) {
	      if (!_.isUndefined(scope.onErrorFn) && _.isFunction(scope.onErrorFn)) {
	        scope.onErrorFn({ data: data, status: status, errorType: errorType });
	      } else {
	        // throw error on console
	        throw new Error(data);
	      }
	    };
	
	    return service;
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 46 */
/*!********************************!*\
  !*** ./grid/grid.directive.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$filter", "$parse", "$interpolate", "fisKendoDataSourceFactory", "fisI18nService", "$timeout", "$compile", "fisPubSubService", "fisDateTimeFormatService", "fisEditorFactory", "$resource", "fisUniqueIdService", "fisElementUtils", "fisCriteriaService", "fisConstraintsFactory", "fisMemoryUtilService", "$window", "fisGridUtilService", "fisConfig", "$interval", function ($filter, $parse, $interpolate, fisKendoDataSourceFactory, fisI18nService, $timeout, $compile, fisPubSubService, fisDateTimeFormatService, fisEditorFactory, $resource, fisUniqueIdService, fisElementUtils, fisCriteriaService, fisConstraintsFactory, fisMemoryUtilService, $window, fisGridUtilService, fisConfig, $interval) {
	  'ngInject';
	
	  var uncamelcase = $filter('uncamelcase');
	
	  var $useDataTypes = false;
	  // class for alignment datatypes
	  var right = {
	    class: 'datatype-align-right'
	  };
	
	  var left = {
	    class: 'datatype-align-left'
	  };
	
	  var center = {
	    class: 'datatype-align-center'
	  };
	  var typeMapping = {
	    integer: {
	      format: '{0:n}',
	      precision: 0,
	      schemaType: {
	        type: 'number'
	      },
	      attributes: right,
	      headerAttributes: right
	    },
	    number: {
	      format: '{0:n}',
	      precision: 0,
	      schemaType: {
	        type: 'number'
	      },
	      attributes: right,
	      headerAttributes: right
	    },
	    double: {
	      format: '{0:n}',
	      precision: 2,
	      schemaType: {
	        type: 'number'
	      },
	      attributes: right,
	      headerAttributes: right
	    },
	    string: {
	      format: '{0}',
	      schemaType: {
	        type: 'string'
	      },
	      attributes: left,
	      headerAttributes: left
	    },
	    currency: {
	      format: '{0:c}',
	      precision: 2,
	      schemaType: {
	        type: 'number'
	      },
	      attributes: right,
	      headerAttributes: right
	    },
	    percentage: {
	      format: '{0:p}',
	      precision: 2,
	      schemaType: {
	        type: 'number'
	      },
	      attributes: right,
	      headerAttributes: right
	    },
	    date: {
	      format: '{0:MM/dd/yyyy}',
	      schemaType: {
	        type: 'date'
	      },
	      attributes: right,
	      headerAttributes: right
	    },
	    datetime: {
	      format: '{0:MM/dd/yyyy h:mm:ss tt}',
	      schemaType: {
	        type: 'datetime'
	      },
	      attributes: right,
	      headerAttributes: right
	    },
	    time: {
	      format: '{0:h:mm:ss tt}',
	      schemaType: {
	        type: 'time'
	      },
	      attributes: right,
	      headerAttributes: right
	    },
	    boolean: {
	      schemaType: {
	        type: 'boolean'
	      }
	    }
	  };
	
	  var checkboxColumn = {};
	
	  function addFilterMenuIds(event, scope) {
	    var elements = event.container.find('select, button, input, .k-dropdown .k-input');
	    var idBase = 'grid_filter_' + event.field;
	
	    _.each(elements, function (element) {
	      var idSuffix = '';
	      if (element.className.indexOf('k-button') > -1) {
	        idSuffix = '_' + element.textContent;
	      } else if (element.className.indexOf('k-textbox') > -1) {
	        idSuffix = '_input';
	      } else if (element.className.indexOf('k-dropdown') > -1) {
	        idSuffix = '_dropdown';
	      } else if (element.className.indexOf('k-input') > -1) {
	        idSuffix = '_dropdown_value';
	      }
	      fisUniqueIdService.generateUniqueId(scope, $(element), {}, idBase + idSuffix);
	    });
	  }
	
	  // update date, datetime and time format as per locale/kendo culture
	  function updateTypeMapping() {
	    var locale;
	    // set the date format from the format Service.
	    typeMapping.date.format = '{0:' + fisDateTimeFormatService.getDateFormat(locale) + '}';
	    typeMapping.datetime.format = '{0:' + fisDateTimeFormatService.getDateTimeFormat(locale, '12') + '}';
	    typeMapping.time.format = '{0:' + fisDateTimeFormatService.getTimeFormat(locale, '12') + '}';
	  }
	
	  updateTypeMapping();
	
	  fisPubSubService.subscribe('fisLocaleChanged', function (locale) {
	    if (!_.isUndefined(locale)) {
	      updateTypeMapping();
	    }
	  });
	
	  function isGridDirty(kendoGrid) {
	    // eslint-disable-next-line no-unneeded-ternary
	    return kendoGrid.dataSource.hasChanges() || kendoGrid.element.find('.k-dirty-cell').length > 0 ? true : false;
	  }
	
	  function markRowsAsFaulty(rowElements) {
	    _.each(rowElements, function (rowElement) {
	      $(rowElement).addClass('error-row');
	    });
	  }
	
	  function setSaveCancelStatus(kendoGrid) {
	    var isDirty = isGridDirty(kendoGrid);
	
	    // Find for save and cancel should search toolbar only
	    var savebutton = kendoGrid.element.parent().find('.k-grid-toolbar .k-i-check').parent();
	    var cancelbutton = kendoGrid.element.parent().find('.k-grid-toolbar .k-i-cancel').parent();
	    bindDisablerForBatchEdit(savebutton, isDirty);
	    bindDisablerForBatchEdit(cancelbutton, isDirty);
	  }
	
	  function enableAddRecordStatus(kendoGrid) {
	    var isDirty = isGridDirty(kendoGrid); // eslint-disable-line no-unused-vars
	    // Find for add should search toolbar only
	    var addbutton = kendoGrid.element.parent().find('.k-grid-toolbar .k-i-plus').parent();
	    addbutton.addClass('k-grid-add');
	    addbutton.removeClass('k-state-disabled');
	    addbutton.removeAttr('onclick', 'return false'); // enabling the anchor tag click event
	    setSaveCancelStatus(kendoGrid);
	  }
	
	  function disableAddRecordStatus(kendoGrid) {
	    var isDirty = isGridDirty(kendoGrid);
	    // Find for add should search toolbar only
	    var addbutton = kendoGrid.element.parent().find('.k-grid-toolbar .k-grid-add');
	
	    addbutton.removeClass('k-grid-add');
	    addbutton.addClass('k-state-disabled');
	    addbutton.attr('onclick', 'return false'); // disabling the anchor tag click event
	
	    var addbuttonCheck = kendoGrid.element.parent().find('.k-grid-toolbar .k-i-plus').parent();
	    if (addbuttonCheck.hasClass('k-grid-cancel-changes')) {
	      // add record button in active mode. Don't enable
	      bindDisablerForBatchEdit(addbutton, isDirty);
	    }
	  }
	
	  function bindDisablerForBatchEdit(button, isDirty) {
	    if (button && button.length > 0) {
	      var buttonSpecificClass = 'k-grid-cancel-changes';
	      if (button.length >= 1 && button.eq(0).children().hasClass('k-i-check')) {
	        buttonSpecificClass = 'k-grid-save-changes';
	      }
	      if (isDirty) {
	        button.removeClass('k-state-disabled').addClass(buttonSpecificClass).removeAttr('disabled');
	      } else {
	        button.addClass('k-state-disabled').removeClass(buttonSpecificClass);
	        button.removeAttr('href').attr('disabled', 'disabled'); // IE workaround: disabled added for IE not handling pointer-events: none
	      }
	    }
	  }
	
	  // scrolls grid content in edit mode to last row: Solution provided be kendo support: SDHTML-3300
	  function scrollGridContent(event, grid) {
	    var tr = event.container.closest('tr');
	    if (tr.is(':last-child')) {
	      // when value is changed scroll the content to the bottom
	      event.model.bind('set', function () {
	        if (grid.content) {
	          grid.content[0].scrollTop = grid.content[0].clientHeight;
	        }
	      });
	    }
	  }
	
	  function buildGridOptions(scope, attrs, elm) {
	    var opts = {};
	    var kendoGrid;
	    // setup sorting
	    if (attrs.fisSort || scope.sortable && (scope.sortable.toUpperCase() === 'true'.toUpperCase() || scope.sortable.toUpperCase() === 'single'.toUpperCase() || scope.sortable.toUpperCase() === 'multiple'.toUpperCase())) {
	      var sortMode;
	      // if fis-sortable attribute is provided, set the sorting mode of the grid
	      if (scope.sortable) {
	        sortMode = scope.sortable === 'multiple' ? 'multiple' : 'single';
	      } else if (attrs.fisSort) {
	        // if fis-sortable is not provided, set the mode depending on the fis-sort attribute
	        var sort = $parse(attrs.fisSort)(scope.$parent);
	        if (sort === 'single' || sort === 'multiple' || sort === 'true' || sort === true) {
	          sortMode = sort === 'multiple' ? 'multiple' : 'single';
	        } else if (sort) {
	          if (angular.isArray(sort) && sort.length > 1) {
	            sortMode = 'multiple';
	          } else {
	            sortMode = 'single';
	          }
	        }
	      }
	      if (sortMode) {
	        opts.sortable = {
	          mode: sortMode,
	          allowUnsort: sortMode === 'multiple'
	        };
	      }
	    }
	
	    // setup selection
	    opts.selectable = scope.selectable && scope.selectable.toUpperCase() === 'row'.toUpperCase() ? scope.selectable : scope.selectable && scope.selectable.toUpperCase() === 'multiple'.toUpperCase() ? scope.selectable : scope.selectable && scope.selectable.toUpperCase() === 'cell'.toUpperCase() ? scope.selectable : '';
	
	    opts.change = getChangeCallback(scope);
	
	    opts.resizable = true;
	
	    if (attrs.kReorderable === 'true') {
	      /**
	       * Check whether the passend reorderingEvent should avoid the reordering
	       * revert the order change.
	       * @param reorderingEvent {boolean} true if reordering should be reverted, false otherwise
	       */
	      var avoidReordering = function avoidReordering(reorderingEvent) {
	        var gridWidget = reorderingEvent.sender;
	        // Avoid reordering if either the current column has the custom property "reorderable" set to false
	        // or the column at the destination index has reorderable false
	        return reorderingEvent.column.reorderable === false || gridWidget.columns[reorderingEvent.newIndex].reorderable === false;
	      };
	
	      // Column reordering activated => in callback check that nun-reorderable columns stay at their position
	      opts.columnReorder = function (event) {
	        var gridWidget = event.sender;
	        if (avoidReordering(event)) {
	          // Custom implementation to avoid specific columns to not be reorderable
	          $timeout(function () {
	            gridWidget.reorderColumn(event.oldIndex, gridWidget.columns[event.newIndex]);
	            gridWidget.refresh();
	          });
	        } else {
	          $timeout(function () {
	            // If liveFiltering is enabled, remove the last column (clear/apply button)
	            var howMany = attrs.fisLiveFiltering === 'true' ? -1 : 0;
	            // Update the columns array in the scope, so other functions relying on that can use the new column order
	            // (the clear/apply button column is not included in scope.columns array by default, so remove it)
	            scope.columns = gridWidget.columns.slice(0, howMany);
	            gridWidget.refresh();
	          });
	        }
	      };
	    }
	
	    // setup keyboard navigation
	    opts.navigatable = true;
	    // setup pagination
	    // TODO: add more pagination options (including live scrolling)
	    opts.pageable = scope.pageable;
	    // initialize the pageSizes only when pager position is "bottom" or "both" because a new kendo pager element is created for "top".
	    if (attrs.fisPageSize && (scope.pagerPosition === 'bottom' || scope.pagerPosition === 'both')) {
	      opts.pageable = {
	        pageSizes: scope.evaluatedPageSizes,
	        change: function change(e) {
	          if (!_.isUndefined(attrs.fisOnPagination) && _.isFunction(scope.onPaginationFn)) {
	            var paginationEvent = buildPaginationEvent(e.index, scope.pagerPrevPage, e.sender.dataSource.totalPages());
	            scope.pagerPrevPage = paginationEvent.nextPage;
	            scope.onPaginationFn({ event: paginationEvent });
	          }
	          //                        addPagerIDs(scope, attrs, kendoGrid); //causes id Inconsistence
	        },
	        messages: {
	          display: fisI18nService.translate(['fisPager', 'display'], '{0} - {1} of {2} items'),
	          empty: fisI18nService.translate(['fisPager', 'empty'], 'No items to display'),
	          allPages: fisI18nService.translate(['fisPager', 'allPages'], 'All'),
	          page: fisI18nService.translate(['fisPager', 'page'], 'Page'),
	          of: fisI18nService.translate(['fisPager', 'of'], 'of {0}'),
	          itemsPerPage: fisI18nService.translate(['fisPager', 'itemsPerPage'], 'items per page'),
	          first: fisI18nService.translate(['fisPager', 'first'], 'Go to the first page'),
	          previous: fisI18nService.translate(['fisPager', 'previous'], 'Go to the previous page'),
	          next: fisI18nService.translate(['fisPager', 'next'], 'Go to the next page'),
	          last: fisI18nService.translate(['fisPager', 'last'], 'Go to the last page'),
	          refresh: fisI18nService.translate(['fisPager', 'refresh'], 'Refresh')
	        }
	      };
	    }
	    if (scope.scrollable) {
	      opts.scrollable = {
	        virtual: scope.scrollable
	      };
	      // http://www.telerik.com/account/support-tickets/view-ticket.aspx?threadid=768352
	    } else {
	      opts.scrollable = true;
	    }
	
	    var metadata = getColumns(scope.columns, attrs, scope);
	
	    scope.isDetail = !_.isUndefined(attrs.fisDetailGrid);
	
	    if (scope.selectable === 'multiple' && _.isUndefined(attrs.fisSchemaColumns) && _.isUndefined(attrs.fisSchemaColumnsDefault)) {
	      if (scope.gridConfig.deselectQuitsSelectAll === false) {
	        // Create a storage object for saving explicitly deselected rows when in selectAll state
	        scope.deselectedRowIds = {};
	      }
	
	      var noCheckboxMultiselect = showNoCheckboxesForMultiSelection(scope, attrs);
	
	      if ((noCheckboxMultiselect === 'false' || noCheckboxMultiselect === false) && angular.isArray(metadata)) {
	        // width of the checkbox column is set to 40 to avoid occupying unnecessary column space
	        var checkboxColumnBase = {};
	        if (scope.pageable) {
	          checkboxColumnBase = {
	            width: 50,
	            reorderable: false, // custom property so we manually avoid changing position of that column
	            headerTemplate: '<div><input type="checkbox" ng-model="selection.all" class="select-all" fis-unique-id="select-all-checkbox" /> ' + '<a fis-quick-action-menu fis-unique-id="select-all-subMenu" fis-quick-action-data="selectMenu" fis-attach-to-body></a></div> ',
	            template: '<input type="checkbox" class="select-row" ng-disabled="!isRowSelectable(rowData)" ng-click="selectRow($event, rowData)"/>'
	          };
	        } else {
	          checkboxColumnBase = {
	            width: 40,
	            reorderable: false, // custom property so we manually avoid changing position of that column
	            headerTemplate: '<div><input type="checkbox" fis-unique-id ng-model="selection.all" class="select-all"/></div> ',
	            template: '<input type="checkbox" class="select-row" ng-disabled="!isRowSelectable(rowData)" ng-click="selectRow($event, rowData)"/>'
	          };
	        }
	        // SDHTML-11439 : fisGrid: In multiple row selection, provide way to style checkbox column based on row data
	        angular.merge(checkboxColumnBase, checkboxColumn);
	        metadata.splice(0, 0, checkboxColumnBase);
	      }
	    }
	    transformFilterTemplates(metadata, scope, elm);
	    if (!scope.filterable && _.find(metadata, function (col) {
	      return !!col.filterTemplate; // eslint-disable-line no-implicit-coercion
	    })) {
	      scope.filterable = 'true';
	    }
	    opts.columns = metadata;
	
	    /*
	     Create the criteria arguments to filter the grid on load.
	     Do not do this if the grid has live-filtering.
	     */
	    if (scope.filterable === 'true' && attrs.fisLiveFiltering !== 'true') {
	      setGridFilterOptions(scope, opts, attrs);
	    }
	    /**
	     * Create Export options filenames etc.
	     */
	    setGridPDFExportOptions(scope, opts, attrs, kendoGrid);
	    setGridExcelExportOptions(scope, opts, attrs, kendoGrid);
	
	    /**
	     * Update the array that contains the column information
	     * if a new column has been shown or hidden. The array is located in the parent scope of the grid
	     */
	    function updateColumnsExpression() {
	      var columnsObj = [];
	      var fisColumns = $parse(attrs.fisColumns);
	      angular.forEach(kendoGrid.columns, function (column) {
	        if (!column.hidden) {
	          columnsObj.push(angular.copy(column));
	        }
	      });
	      fisColumns.assign(scope.$parent, columnsObj);
	      if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	        scope.$apply();
	      }
	    }
	
	    function getColumnShowHideCallback(event) {
	      var needUpdateColumnExpression = scope.columnMenu !== 'false' && angular.isString(attrs.fisColumns) && attrs.fisColumns.indexOf(',') === -1 && $parse(attrs.fisColumns).assign;
	      var customCallback;
	      if (event === 'show') {
	        customCallback = scope.onColumnShowFn;
	      } else {
	        customCallback = scope.onColumnHideFn;
	      }
	      if (!(_.isUndefined(event) || _.isUndefined(event.sender) || _.isUndefined(event.sender.element))) {
	        var table = event.sender.element.parents('.fis-grid');
	        applyElementResizeToTable(table);
	      }
	      return function (event) {
	        if (needUpdateColumnExpression) {
	          updateColumnsExpression();
	        }
	        customCallback({ event: event });
	        var resizeTableTimeoutID = $timeout(function () {
	          var table = event.sender.element.parents('.fis-grid');
	          applyElementResizeToTable(table);
	        });
	        scope.$on('$destroy', function () {
	          $timeout.cancel(resizeTableTimeoutID);
	        });
	      };
	    }
	
	    // setup column menu
	    if (scope.columnMenu) {
	      if (scope.columnMenu !== 'false') {
	        // use an object instead of true so that we can add the i18n'd messages
	        opts.columnMenu = scope.columnMenu === 'true' ? {} : scope.columnMenu;
	        if (_.isObject(opts.columnMenu)) {
	          opts.columnMenu.messages = {
	            columns: fisI18nService.translate(['fisGrid', 'columnMenuColumns'], 'Columns'),
	            filter: fisI18nService.translate(['fisGrid', 'columnMenuFilter'], 'Filter'),
	            sortAscending: fisI18nService.translate(['fisGrid', 'columnMenuSortAsc'], 'Sort Ascending'),
	            sortDescending: fisI18nService.translate(['fisGrid', 'columnMenuSortDesc'], 'Sort Descending')
	          };
	        }
	        opts.columnMenuInit = function (event) {
	          if (fis.initParams().appStage === 'T') {
	            // test appStage
	            // add fisid to the grid filtering dropdowns,buttons and input boxes
	            addFilterMenuIds(event, scope);
	          }
	        };
	      }
	    }
	
	    opts.columnShow = getColumnShowHideCallback('show');
	    opts.columnHide = getColumnShowHideCallback('hide');
	
	    // TODO: map autoBind option to attribute for the search use case
	    //       (where you want the user to fill the criteria and press a button before data is displayed)
	    opts.autoBind = true; // eventually this could be controlled by attribute. fisRefresh event would need to be used for the data to be bound if false
	    if (!_.isUndefined(attrs.fisSchemaColumns) || !_.isUndefined(attrs.fisSchemaColumnsDefault)) {
	      // the autoBind needs to be set to false in cases where the fisSchemaColumns have been defined to prevent, infinite loading of data
	      opts.autoBind = false;
	    }
	
	    function addSelectionMethods(selectionScope, rowScope) {
	      // add column selection methods here:
	      selectionScope.selectAllPage = function () /* nodeId, elemText */{
	        rowScope.selectAll(null, false);
	      };
	
	      selectionScope.selectAllData = function () /* nodeId, elemText */{
	        rowScope.selectAll(null, true);
	      };
	    }
	
	    addSelectionMethods(scope, scope);
	
	    scope.selectMenu = [{
	      label: fisI18nService.translate(['fisGrid', 'all'], 'All'),
	      method: 'selectAllData'
	    }, {
	      label: fisI18nService.translate(['fisGrid', 'this_page'], 'This page only'),
	      method: 'selectAllPage'
	    }];
	
	    var prevSel;
	    opts.dataBound = function () {
	      if (attrs.fisSelectable === 'multiple') {
	        kendoGrid.table.keydown(function (e) {
	          if (e.keyCode == 32) {
	            // eslint-disable-line eqeqeq
	            var selected = $(e.target).find('td.k-state-focused');
	            if (attrs.fisNoCheckbox) {
	              var rowElem = selected.parent();
	              var row = gridDataSourceView[rowElem.index()]; // eslint-disable-line no-use-before-define, block-scoped-var
	              var idee = scope.getIdee(row);
	              var contained = false;
	              _.each(scope.selection.rows, function (xRow) {
	                if (row[idee] === xRow[idee]) {
	                  contained = true;
	                }
	              });
	              if (!contained) {
	                // eslint-disable-line no-negated-condition
	                rowElem.removeClass('k-state-selected');
	              } else {
	                rowElem.addClass('k-state-selected');
	              }
	            }
	            selected.mousedown();
	            if (scope.selection.rows.length > 0) {
	              // we need to ensure that paginated items are marked if previously selected
	              _.each(gridDataSourceView, function (row) {
	                // eslint-disable-line no-use-before-define, block-scoped-var
	                var idee = scope.getIdee(row);
	                var contained = false;
	                _.each(scope.selection.rows, function (xRow) {
	                  if (row[idee] === xRow[idee]) {
	                    contained = true;
	                  }
	                });
	                if (contained) {
	                  var elem = kendoGrid.table.find('tr[data-uid=' + row.uid + ']');
	                  elem.addClass('k-state-selected');
	                  elem.find('.select-row').prop('checked', true);
	                }
	              });
	            }
	          }
	        });
	      }
	      var trArr = elm.find('tbody').find('tr');
	      trArr.addClass('fis-grid-row');
	      if (scope.rowAttributes) {
	        var rowStyle = null;
	        try {
	          rowStyle = angular.fromJson(scope.rowAttributes);
	        } catch (error) {
	          rowStyle = $parse(scope.rowAttributes)(scope.$parent);
	        }
	        if (rowStyle && rowStyle.attributes && rowStyle.attributes.class) {
	          trArr.addClass(rowStyle.attributes.class);
	        }
	      }
	      var ds;
	      var i = 0;
	
	      if (scope.mode === 'local') {
	        ds = kendoGrid.dataSource.view();
	      } else {
	        ds = kendoGrid.dataSource.data();
	      }
	
	      // create context menu
	      if (attrs.fisContextMenu !== undefined) {
	        var contextMenuElem = elm.parents().find('div[fis-name="' + attrs.fisContextMenu + '"]');
	        var contextMenuOpts = buildContextMenuOpts(elm, contextMenuElem, kendoGrid, scope);
	
	        var contextMenu = angular.element(contextMenuElem.children()[0]).kendoContextMenu(contextMenuOpts);
	        var contextMenuData = contextMenu.data('kendoContextMenu');
	
	        // expose context menu api on scope
	        if (contextMenuElem[0].attributes['fis-context-menu']) {
	          var myContextMenu = $parse(contextMenuElem[0].attributes['fis-context-menu'].value).assign;
	          if (myContextMenu) {
	            myContextMenu(scope.$parent, contextMenuData);
	          }
	        }
	      }
	
	      // Bug SDHTML-9600
	      // Close the context menu manually when detail grid is clicked
	      // Only closes the last context menu as the widget element is the same on each scope
	      // kendo.widgetInstance(scope.$parent.myMenu.element).close();   or:
	      // scope.$parent.myMenu.close();
	      elm.on('click', function () {
	        if (!_.isUndefined(contextMenuData)) {
	          // eslint-disable-line block-scoped-var
	          contextMenuData.close(); // eslint-disable-line block-scoped-var
	        }
	      });
	
	      angular.forEach(trArr, function (item) {
	        var childScope = scope.$parent.$new();
	
	        if (kendoGrid && kendoGrid.dataSource.at(0)) {
	          childScope.rowData = ds[i];
	          childScope.selectRow = scope.selectRow;
	          childScope.isRowSelectable = scope.isRowSelectable;
	          addSelectionMethods(childScope.$parent, scope);
	        }
	
	        _.each(item.cells, function (cell, index) {
	          // Set the cell dirty flag if row is dirty and _dirtyFields object is present
	          if (childScope.rowData && childScope.rowData.dirty && childScope.rowData._dirtyFields && childScope.rowData._dirtyFields[kendoGrid.columns[index].field]) {
	            angular.element(cell).addClass('k-dirty-cell').prepend('<span class="k-dirty"></span>');
	          }
	          $(cell).unbind('mouseover');
	          $(cell).mouseover(function (e) {
	            if (!$(e.target).is('td')) {
	              // if td has child elements apply title to those instead of td
	              var titleText1 = e.target.textContent.trim(); // eslint-disable-line block-scoped-var
	              if (titleText1 !== '') {
	                e.target.title = titleText1; // eslint-disable-line block-scoped-var
	              }
	            }
	            if ($(e.target).is('td') && (cell.childElementCount === 0 || $(cell).children('span.k-dirty').length > 0)) {
	              var titleText2 = e.target.textContent.trim(); // eslint-disable-line no-redeclare, block-scoped-var
	              if (titleText2 !== '') {
	                cell.title = titleText2; // eslint-disable-line block-scoped-var
	              }
	            }
	          });
	        });
	
	        if (fis.initParams().appStage === 'T') {
	          var gridName = fisGridUtilService.getGridName(attrs, scope, kendoGrid);
	
	          // add fisids to each row if necessary
	          var rowId = gridName + '_' + i;
	          var row = $(item);
	          row.attr('fisid', rowId);
	          if (scope.selectable) {
	            var checkInput = row.find('input.select-row'); // find row select
	            checkInput.attr('fisid', 'selectRowCheckInput_' + rowId);
	          }
	
	          // add fisid to the arrow in this row that is used to expand/collapse the row
	          var exandRowArrow = row.find('.k-icon.k-i-plus, .k-icon.k-i-minus');
	          for (var a = 0; a < exandRowArrow.length; a++) {
	            // Iterate, just in case there are multiple arrows one day
	            exandRowArrow.eq(a).attr('fisid', gridName + '_' + i + '_expandRow');
	          }
	
	          // add fisids to each cell if necessary
	          var j = 0;
	          _.each(item.cells, function (cell) {
	            var colId = rowId + '_' + j;
	            $(cell).attr('fisid', colId);
	            j++;
	          });
	        }
	        i++;
	
	        $compile(item)(childScope);
	      });
	
	      scope.$on('$destroy', function () {
	        elm.find('.k-grid-content').find('td').unbind('mouseover');
	      });
	
	      if (fis.initParams().appStage === 'T') {
	        var gridName = fisGridUtilService.getGridName(attrs, scope, kendoGrid);
	        var columheaders = elm.find('th.k-header');
	        _.each(columheaders, function (header) {
	          if (header) {
	            header = $(header); // Wrap it
	            var headerDataField = header.attr('data-field');
	            var headerDataIndex = header.attr('data-index');
	            if (headerDataField === undefined) {
	              headerDataField = '';
	            }
	            header.attr('fisid', gridName + '_headerCell_' + headerDataField + '_' + headerDataIndex);
	            header.find('a').attr('fis-unique-id', headerDataField);
	            header.find('span.k-icon').attr('fis-unique-id', 'arrow_' + headerDataField);
	          }
	        });
	        addPagerIDs(scope, attrs, kendoGrid);
	      }
	
	      /*
	       Compile the column header elements against the same scope.
	        If there is more than one row in the head then compile
	       only the first one (the second one will be the live filter
	       row)
	        Ensure that the header row only gets compiled once
	       and not after every pagination
	       */
	      var headerRow = kendoGrid.thead.children('tr:first');
	      if (scope.headerCompiled !== true) {
	        $compile(headerRow)(scope);
	        scope.headerCompiled = true;
	      }
	
	      // need to add the click listener later because recompiling an element multiple times creates multiple copies of the
	      // click handler. When the element is clicked, the click handler gets called the number of times element was compiled.
	      if (scope.selectable === 'multiple') {
	        headerRow.find('input[ng-model="selection.all"]').off('click');
	        headerRow.find('input[ng-model="selection.all"]').on('click', function (event) {
	          scope.selectAll(event, true);
	          if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	            scope.$apply();
	          }
	        });
	      }
	
	      // Add tooltip for grid columns
	      var gridColumns = kendoGrid.thead.find('th');
	      _.each(gridColumns, function (item) {
	        var titleText = angular.element(item).attr('data-title') || '';
	        // TODO:  carl see if item has a div
	        if (titleText.trim() !== '') {
	          $(item).attr('title', titleText);
	        }
	      });
	
	      bindCustomDeleteConfirmation(); // eslint-disable-line no-use-before-define
	      if (attrs.fisBatch || attrs.fisEditable === 'inline' || attrs.fisEditable === 'incell') {
	        setSaveCancelStatus(kendoGrid);
	      }
	      if (scope.selectable === 'multiple') {
	        // remove any previous mousedown bindings
	        kendoGrid.tbody.unbind('mousedown');
	        // mousedown event handler required because multiple selection mode causes draggable selection
	
	        kendoGrid.tbody.on('mousedown', function (e) {
	          // SDHTML-11278
	          kendoGrid.selectable.userEvents._events.move = null;
	          e.stopPropagation(); // bug SDHTML-12016 stop propogation for detail grid
	
	          var cell;
	          if (!_.isUndefined(e.srcElement)) {
	            // eslint-disable-line no-negated-condition
	            cell = $(e.srcElement);
	          } else {
	            cell = $(e.target); // On FireFox, "e.srcElement" comes as "undefined" so we are using "e.target"
	          }
	          var row = $(cell.parent());
	          var gridElemObject = row.closest('.fis-grid');
	          if (!angular.isUndefined(gridElemObject.attr('fis-selectable')) && gridElemObject.attr('fis-selectable') === 'multiple') {
	            var selectionChanged = false;
	            // This "indexCorrection" value is used for handling the scenarios when user wants to show "checkboxes" or not.
	            // In case user wants to show checkboxes then "indexCorrection=2" otherwise it will be "indexCorrection=1" as shown below.
	            // Based on whether or not user wants to show checkboxes we need to adjust the columns selection index value.
	            var indexCorrection = 1;
	
	            // execute the below code only when row cell is selected or the select checkbox is clicked.
	            // It should not be execute when some cell action clicked (example, edit, delete actions as a part of cell action)
	            if (cell && (row.is('tr') || row.contents().hasClass('select-row'))) {
	              kendoGrid.tbody.find('td.k-state-selected').removeClass('k-state-selected'); // deselect other cells
	              var input = $(row.find('input'));
	              var isRowSelectedIndex = -1;
	              if (!_.isUndefined(row.attr('class'))) {
	                isRowSelectedIndex = row.attr('class').indexOf('k-state-selected');
	              }
	
	              var index = cell[0].cellIndex;
	              var selectableRows = kendoGrid.dataSource.view(); // eslint-disable-line no-unused-vars
	              if (scope.mode === 'local') {
	                selectableRows = kendoGrid.dataSource.data();
	              }
	              if (input.length > 0) {
	                if (!index && !scope.deselectCell || !index && !input.prop('checked')) {
	                  index = 1;
	                } else if (!index && scope.deselectCell && input.prop('checked')) {
	                  // set default cell from scope when deselecting
	                  index = parseInt(scope.deselectCell); // eslint-disable-line radix
	                }
	              } else {
	                if (!index && !scope.deselectCell || !index && isRowSelectedIndex < 0) {
	                  // eslint-disable-line no-lonely-if
	                  index = 1;
	                } else if (!index && scope.deselectCell && isRowSelectedIndex > -1) {
	                  // set default cell from scope when deselecting
	                  index = parseInt(scope.deselectCell); // eslint-disable-line radix
	                }
	              }
	
	              if (scope.hasDetail && !_.isUndefined(input.prop('checked')) && index > 1) {
	                indexCorrection = 2;
	              }
	
	              var columnNames;
	              var columnName;
	              columnNames = typeof scope.columns === 'function' ? scope.columns() : scope.columns;
	              if (!_.isUndefined(columnNames)) {
	                if (_.isString(columnNames)) {
	                  columnNames = columnNames.split(',');
	                  columnName = columnNames[index - indexCorrection]; // ignore checkbox column
	                } else {
	                  columnName = columnNames[index - indexCorrection].field; // ignore checkbox column
	                }
	              }
	              var textCell = $('td:not(:has(input),:has(select),:has(a),:has(button))', row.parent());
	
	              var angularRow = angular.element(row).scope().rowData; // eslint-disable-line no-unused-vars
	
	              var rowData = angular.element(row).scope().rowData;
	              var angularCell = { data: rowData[columnName] };
	
	              if (!angularCell.data && textCell.length > 0 && index === 1) {
	                angularCell = { data: $(textCell[0]).text() };
	              }
	              scope.selection.cell = angularCell;
	
	              // should not select disabled rows
	              // Also, for multiple selection case, user won't be able to select any row by clicking on any columns of that row (if 'incell' editing is enabled)
	              if (scope.isRowSelectable(rowData) && (_.isUndefined(scope.editable) || scope.editable !== 'incell')) {
	                scope.selection.currentRow = rowData; // set current row as setRowSelectionStatus does not update it
	                var selected = input.length > 0 ? input.prop('checked') : isRowSelectedIndex > -1;
	
	                var currSel;
	                if (!_.isUndefined(row) && row.length > 0) {
	                  currSel = row[0].rowIndex;
	                }
	
	                if (!e.shiftKey) {
	                  // eslint-disable-line no-negated-condition
	                  var rowSelectCheckbox = kendoGrid.element.find('th .select-all').first(); // bug SDHTML-12016
	                  if (selected && cell.is('td')) {
	                    scope.setRowSelectionStatus(rowData, false); // uncheck it
	                    setHeaderCheckboxStatus(scope, kendoGrid.dataSource, false, rowSelectCheckbox);
	                    selectionChanged = true;
	                  } else if (!selected && cell.is('td')) {
	                    scope.setRowSelectionStatus(rowData, true); // check it
	                    setHeaderCheckboxStatus(scope, kendoGrid.dataSource, true, rowSelectCheckbox);
	                    selectionChanged = true;
	                  }
	                } else {
	                  // This code will execute in case user made selection while pressing the shift key
	                  if (e.shiftKey && !_.isUndefined(prevSel) && prevSel !== currSel) {
	                    selectMultipleRowsWithShiftKey(prevSel, currSel, selected, cell, scope, kendoGrid);
	                    selectionChanged = true;
	                  }
	                  e.preventDefault();
	                }
	                prevSel = currSel;
	                var rowElem = row;
	                if (!row.is('tr')) {
	                  rowElem = row.parent('tr');
	                }
	                addSelectedIndexOnSelectionObj(scope, kendoGrid, rowElem);
	                if (selectionChanged) {
	                  fireChangeCallback(scope);
	                }
	                // Select cell or default cell
	                if (!row.is('td')) {
	                  // eslint-disable-line no-negated-condition
	                  row.find('td:eq(' + index + ')').addClass('k-state-selected');
	                } else {
	                  // eslint-disable-next-line no-lonely-if
	                  if (textCell.length > 0 && index === 1) {
	                    // default cell not defined
	                    $(textCell[0]).addClass('k-state-selected'); // nearest text cell
	                  } else {
	                    row.parent().find('td:eq(' + index + ')').addClass('k-state-selected');
	                  }
	                }
	              }
	            }
	          }
	        });
	
	        kendoGrid.tbody.on('mouseup', function (e) {
	          var selectRowChecked = kendoGrid.tbody.find('input.select-row:checked');
	          selectRowChecked.closest('tr').addClass('k-state-selected');
	          e.stopPropagation();
	        });
	
	        kendoGrid.tbody.on('mousemove', function (e) {
	          var selectRowChecked = kendoGrid.tbody.find('input.select-row:checked');
	          selectRowChecked.closest('tr').addClass('k-state-selected');
	          e.stopPropagation();
	        });
	      }
	
	      // if schema is provided by user (unique identifier), then check if the current gridview has elements
	      // that match the selected element's id.
	      // should work for scenarios with and without schema
	      if (scope.selectable) {
	        var gridDataSourceView = kendoGrid.dataSource.view();
	        var items; // eslint-disable-line no-unused-vars
	        var length;
	        var elem;
	        if (scope.selectable === 'multiple') {
	          items = scope.selection.rows;
	        } else {
	          items = scope.selectedDataItems;
	        }
	
	        if (scope.selectable === 'multiple') {
	          // Default/Historic behavior: All new rows get selected as long as at least one row get's deselected
	          var shouldSelectAllNewRows = scope.selection.all;
	          var alternativeSelectBehavior = false;
	
	          // Alternative behavior: Deselecting a row does not influence the "selectAll" mode. That way it is consistent
	          //                      with selectAll with local data
	          if (scope.gridConfig.deselectQuitsSelectAll === false) {
	            shouldSelectAllNewRows = scope.isSelectAll;
	            alternativeSelectBehavior = true;
	          }
	
	          if (shouldSelectAllNewRows) {
	            // preselect : if select all is checked, then all the new paginated data items should be selected
	            length = gridDataSourceView.length;
	            for (var j = 0; j < length; j++) {
	              var row = gridDataSourceView[j];
	              elem = kendoGrid.table.find('tr[data-uid=' + row.uid + ']');
	              // Item can only be checked if it is selectable
	              if (elem.scope().isRowSelectable(elem.scope().rowData)) {
	                var idProperty = scope.getIdee(row);
	                if (!alternativeSelectBehavior || alternativeSelectBehavior && scope.deselectedRowIds[row[idProperty]] !== true) {
	                  // In alternative select behavior we have to make sure that when paging back
	                  // deselected table rows do not get selected
	
	                  // In default behavior we select all new table rows, no matter whether they have been
	                  // deselected before
	                  scope.addToRowSelection(row);
	                }
	              }
	            }
	            if (scope.onSelect) {
	              scope.onSelect({ rows: scope.selection.rows, all: scope.selection.all, currentRow: null, selection: scope.selection });
	            }
	          }
	          // If we have selected rows (either the ones we just selected in the if-clause above or manually selected ones from)
	          if (scope.selection.rows.length > 0) {
	            // we need to ensure that paginated items are marked if previously selected
	            _.each(gridDataSourceView, function (item) {
	              scope.markSelectedFromSelection(item);
	            });
	          }
	        }
	      }
	      if (attrs.fisPageSize) {
	        var fisPageSize = $parse(attrs.fisPageSize);
	        // if fis-page-size expression is assignable, change the expression on user's scope
	        if (fisPageSize && fisPageSize.assign) {
	          fisPageSize.assign(scope.$parent, kendoGrid.dataSource.pageSize());
	        }
	      }
	
	      var sortArr = kendoGrid.dataSource.sort();
	
	      if (attrs.fisSort || attrs.fisSortable || sortArr && sortArr.length > 1) {
	        kendoGrid.element.find('th').find('.fis-sort-order-indicator').remove();
	        kendoGrid.element.find('th').find('a.k-link').append('<span class="fis-sort-order-indicator invisible">0</span>');
	      }
	
	      if (attrs.fisShowSortOrder !== 'false') {
	        if (sortArr && sortArr.length > 1) {
	          var sortOrder = 1;
	          angular.forEach(sortArr, function (sortObj) {
	            var field = sortObj.field;
	            var th = kendoGrid.element.find('th[data-field="' + field + '"]');
	            var linkElem = th.find('a.k-link');
	            linkElem.find('.fis-sort-order-indicator').replaceWith('<span class="fis-sort-order-indicator">' + sortOrder + '</span>');
	            sortOrder++;
	          });
	        }
	      }
	
	      // update the fis-sort assignable expression only if mode is local.
	      // For server mode, fisData updates the expression.
	      if (attrs.fisSort && scope.mode === 'local') {
	        var fisSort = $parse(attrs.fisSort);
	        // if fis-page-size expression is assignable, change the expression on user's scope
	        if (fisSort && fisSort.assign) {
	          fisSort.assign(scope.$parent, kendoGrid.dataSource.sort());
	        }
	      }
	      if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	        scope.$apply();
	      }
	
	      if (!(attrs.fisLiveFiltering === 'true')) {
	        $timeout(function () {
	          var gridHeaderElem = elm.find('.k-grid-header');
	          if (gridHeaderElem !== []) {
	            // wrap with k-grid-header-container only if it is not present
	            // if (gridHeaderElem.parent('.k-grid-header-container').length === 0) {
	            //    gridHeaderElem.wrap('<div class="k-grid-header-container"></div>');
	            // }
	            var headerContainer = elm.find('.k-grid-header'); // no longer k-grid-header-container
	            var headers = $(kendoGrid.thead).find('tr')[0]; // eslint-disable-line no-unused-vars
	            var headerHeight = parseFloat($(headerContainer).height());
	            var underlayDiv = headerContainer.find('.k-grid-column-header-underlay');
	            // append with k-grid-column-header-underlay only if it is not present
	            if (underlayDiv.length === 0) {
	              headerContainer.append('<div class="k-grid-column-header-underlay"></div>');
	              underlayDiv = headerContainer.find('.k-grid-column-header-underlay');
	            }
	            underlayDiv.height(headerHeight);
	          }
	        });
	      }
	
	      /*
	       * If the attribute fis-live-filtering is present then create an
	       * always visible filter row with inputs containing
	       * the values used to filter the grid.
	       */
	      var liveFilterRow = elm.find('.fis-grid-filter-row').length;
	      if (liveFilterRow === 0) {
	        if (attrs.fisLiveFiltering && attrs.fisLiveFiltering === 'true') {
	          scope.addLiveFilter();
	        }
	      }
	
	      // removing scrollbar for the empty grid SDHTML-11269 & SDHTML-10985
	      var expander = elm.find('div.k-grid-content > div.k-grid-content-expander');
	      var contentWidth = parseFloat(elm.find('div.k-grid-content').width());
	      if (parseFloat(expander.width()) <= contentWidth) {
	        expander.removeClass('k-grid-content-expander');
	      }
	      if (attrs.fisDetailData) {
	        var gridContent = elm.find('div.k-grid-content');
	        gridContent.removeClass('fis-overflow-y-hidden');
	      }
	    };
	    opts.dataBinding = function () {
	      kendoGrid = elm.data('kendoGrid');
	      // clear selection in case there is a filter set
	      if (kendoGrid.dataSource._filter) {
	        if (scope.selection && scope.selection.rows) {
	          scope.selection.rows.length = 0;
	        }
	      }
	
	      var rows = elm.find('tbody').find('tr');
	      $timeout(function () {
	        for (var i = 0; i < rows.length; i++) {
	          var row = angular.element(rows[i]);
	          angular.forEach(row.find('[fis-cell-action]'), function (cellActionNode) {
	            var cellActionNodeScope = angular.element(cellActionNode).scope();
	            if (cellActionNodeScope && cellActionNodeScope !== scope) {
	              // Remove cell action scope and data
	              // Check SDHTML-7080 for more details
	              fisMemoryUtilService.destroyScopeAndData(cellActionNodeScope, cellActionNode);
	            }
	          });
	          var rowScope = row.scope();
	          if (rowScope && rowScope !== scope) {
	            // Remove Kendo grid row scope and data
	            // Check SDHTML-7080 for more details
	            fisMemoryUtilService.destroyScopeAndData(rowScope, row);
	          }
	        }
	        // remove Kendo pager data
	        // Check SDHTML-7080 for more details
	        if (scope.kendoPager) {
	          fisMemoryUtilService.destroyScopeAndData(null, scope.kendoPager.element);
	          prevSel = undefined;
	        }
	        if (kendoGrid && kendoGrid.pager) {
	          fisMemoryUtilService.destroyScopeAndData(null, kendoGrid.pager.element);
	          prevSel = undefined;
	        }
	      });
	    };
	
	    scope.$on('$destroy', function () {
	      if (opts) {
	        delete opts.dataBound;
	        opts.dataBound = null;
	        delete opts.dataBinding;
	        opts.dataBinding = null;
	      }
	      fisMemoryUtilService.callCleanAll(opts);
	      opts = null;
	    });
	
	    var bindCustomDeleteConfirmation = function bindCustomDeleteConfirmation() {
	      if (attrs.fisEditable) {
	        var deleteButton = elm.find('.k-grid-deleteConfirmation');
	        deleteButton.click(function (e) {
	          e.preventDefault();
	          var row = $(this).parents('tr:first');
	
	          $timeout(function () {
	            scope.$parent.confirm('Are you sure that you want to delete this record?', { title: 'Delete Confirmation' }).then(function (ok) {
	              if (ok) {
	                kendoGrid.removeRow($(row));
	              }
	            });
	          }, 0);
	        });
	      }
	    };
	    var toolbarLoc = 'top';
	    if (attrs.fisToolbarLocation === 'bottom') {
	      toolbarLoc = attrs.fisToolbarLocation;
	    }
	    if (scope.editable) {
	      opts.editable = {
	        mode: scope.editable,
	        createAt: toolbarLoc,
	        confirmation: false
	      };
	      opts.cancel = function (e) {
	        // Custom method, called on kendo cancel event
	        if (!_.isUndefined(attrs.fisOnCancel) && _.isFunction(scope.onCancelFn)) {
	          scope.onCancelFn({ event: e });
	        }
	        if (kendoGrid.dataSource.hasChanges()) {
	          e.preventDefault();
	          $timeout(function () {
	            scope.$parent.confirm(fisI18nService.translate(['fisGrid', 'exitEdit'], 'There are pending changes. Do you want to exit edit mode?'), { title: 'Cancel Edit', actions: { yesno: true } }).then(function (ok) {
	              if (ok) {
	                kendoGrid.cancelChanges();
	                enableAddRecordStatus(kendoGrid);
	                kendoGrid.table.off('keydown', keydownEventHandler); // eslint-disable-line no-use-before-define
	              } else {
	                return true;
	              }
	            });
	          }, 0);
	        } else {
	          kendoGrid.cancelChanges();
	          enableAddRecordStatus(kendoGrid);
	          kendoGrid.table.off('keydown', keydownEventHandler); // eslint-disable-line no-use-before-define
	          if (scope.selectable) {
	            kendoGrid.select('tr:eq(' + e.container.index() + ')');
	          }
	        }
	      };
	
	      var isColumnHasEditorTemplate = function isColumnHasEditorTemplate(index) {
	        return scope.columns && scope.columns[index].editorTemplate;
	      };
	
	      var keydownEventHandler = function keydownEventHandler(e) {
	        // if current key is Esc
	        if (e.keyCode == 27) {
	          // eslint-disable-line eqeqeq
	          enableAddRecordStatus(kendoGrid);
	          kendoGrid.table.off('keydown', keydownEventHandler);
	        }
	      };
	
	      var focusout = function focusout(event) {
	        var element = event.data.element;
	        var target = kendo._activeElement();
	        var model = event.data.model;
	        if (element && !$.contains(element[0], target) && element[0] !== target && !$(target).closest('.k-animation-container').length) {
	          var editTimeout = $timeout(function renderTemplate() {
	            if (editTimeout) {
	              $timeout.cancel(editTimeout);
	            }
	            var widgets = null;
	            if (element.find('form').length === 0) {
	              var newScope = scope.$parent.$new(); // eslint-disable-line block-scoped-var
	              newScope.rowData = model; // eslint-disable-line block-scoped-var
	              widgets = $compile(element)(newScope); // eslint-disable-line block-scoped-var
	            }
	            if (element.children().length === 0) {
	              try {
	                var newScope = scope.$parent.$new(); // eslint-disable-line block-scoped-var, no-redeclare
	                newScope.rowData = model; // eslint-disable-line block-scoped-var
	                widgets = $compile(element)(newScope); // eslint-disable-line block-scoped-var
	              } catch (error) {
	                widgets = null;
	              }
	            }
	            scope.$on('$destroy', function () {
	              fisMemoryUtilService.callCleanAll(widgets);
	              widgets = null;
	            });
	          });
	        }
	      };
	
	      opts.edit = function (e) {
	        var noCheckboxMultiSelect = showNoCheckboxesForMultiSelection(scope, attrs);
	        var index = scope.selectable === 'multiple' && (noCheckboxMultiSelect === 'false' || noCheckboxMultiSelect === false) ? e.container.index() - 1 : e.container.index();
	
	        // SDHTML-17943: Tabbing stops working after clicking on grid header
	        this._current = kendoGrid.element.find('.k-edit-cell');
	
	        // Registering a focusout event-handler for the cells not having editor template
	        if (scope.editable === 'incell' && !isColumnHasEditorTemplate(index)) {
	          e.container.on('focusout', { element: e.container, model: e.model, index: index }, focusout);
	        }
	
	        // Custom method, called on kendo edit event
	        if (!_.isUndefined(attrs.fisOnEdit) && _.isFunction(scope.onEditFn)) {
	          scope.onEditFn({ event: e });
	        }
	        if (scope.editable === 'inline') {
	          disableAddRecordStatus(kendoGrid);
	          // handle escape key
	          kendoGrid.table.on('keydown', keydownEventHandler);
	        }
	        var inEditMode = kendoGrid.element.find('.k-grid-edit-row').length > 0 || kendoGrid.element.find('k-edit-cell').length > 0;
	        if (scope.editable === 'inline' && !inEditMode) {
	          enableAddRecordStatus(kendoGrid);
	        }
	
	        setSaveCancelStatus(kendoGrid);
	        scrollGridContent(e, kendoGrid);
	
	        // clear heap
	        noCheckboxMultiSelect = undefined;
	      };
	      opts.save = function (e) {
	        // Custom method, called on kendo save event
	        if (!_.isUndefined(attrs.fisOnSave) && _.isFunction(scope.onSaveFn)) {
	          scope.onSaveFn({ event: e });
	        }
	        enableAddRecordStatus(kendoGrid);
	      };
	      opts.saveChanges = function (e) {
	        // Custom method, called on kendo saveChanges event
	        if (!_.isUndefined(attrs.fisOnSaveChanges) && _.isFunction(scope.onSaveChangesFn)) {
	          scope.onSaveChangesFn({ event: e });
	        }
	        enableAddRecordStatus(kendoGrid);
	      };
	
	      // Add on-* event handlers to options.
	      addEventHandlers(elm, opts, scope, attrs, /^on(.+)/); // not sure how to unregister these events..?
	
	      if (fis.initParams().appStage === 'T') {
	        var gridPrefix = fisGridUtilService.getGridName(attrs, scope, kendoGrid);
	        applySgIdsOnEvent(elm, scope, gridPrefix + '_edit', opts, 'dataBound');
	        applySgIdsOnEvent(elm, scope, gridPrefix + '_edit', opts, 'edit');
	        applySgIdsOnEvent(elm, scope, gridPrefix + '_edit', opts, 'cancel');
	      }
	    }
	
	    if (attrs.fisToolbar) {
	      opts.toolbar = getToolbar(scope, attrs.fisToolbar);
	      if (opts.toolbar.length === 0) {
	        // opts.toolbar = undefined;
	        delete opts.toolbar;
	      }
	      scope.$on('$destroy', function () {
	        if (opts && opts.toolbar) {
	          delete opts.toolbar;
	        }
	      });
	    }
	
	    // eslint-disable-next-line no-unneeded-ternary
	    opts.groupable = attrs.fisGroupable === true || attrs.fisGroupable === 'true' ? true : false;
	
	    // kendo grid pass through attributes
	    for (var attr in attrs) {
	      if (attr.indexOf('k') === 0) {
	        var kendoAttribute = attr.substring(1);
	        kendoAttribute = kendoAttribute.substring(0, 1).toLowerCase() + kendoAttribute.substring(1);
	        if (attrs[attr] === 'true') {
	          opts[kendoAttribute] = true;
	        } else {
	          opts[kendoAttribute] = opts[kendoAttribute] = $parse(attrs[attr])(scope.$parent);
	        }
	      }
	    }
	
	    return opts;
	  }
	
	  // This function is used to update the status of the Headers checkbox in case of row selection in grid widget
	  function setHeaderCheckboxStatus(scope, dataSource, isChecked, selectCheckbox) {
	    if (isChecked) {
	      // eslint-disable-next-line eqeqeq
	      if (scope.selection.rows.length == dataSource._total || scope.gridConfig.deselectQuitsSelectAll === false && scope.isSelectAll && _.isEmpty(scope.deselectedRowIds)) {
	        // All available items selected
	        scope.selection.all = true;
	        selectCheckbox.prop('indeterminate', false);
	      } else {
	        scope.selection.all = false;
	        selectCheckbox.prop('indeterminate', true);
	      }
	    } else {
	      // checkbox is unchecked so remove the row highlight
	      scope.selection.all = false;
	      selectCheckbox.prop('indeterminate', scope.selection.rows.length > 0);
	    }
	  }
	
	  /*
	   * This method will create context menu options.
	   * It will also take care of the pass-through attributes that will not be processed, but will be directly passed to kendo context menu
	   * */
	  function buildContextMenuOpts(gridElem, contextMenuElem, kendoGrid, scope) {
	    var contextMenuOpts = {};
	    var targetRow;
	    var targetRowIdx;
	    var targetCol; // eslint-disable-line no-unused-vars
	    var targetColIdx;
	    var targetColName;
	    var contextMenuFilter;
	    var contextMenuAttrs = contextMenuElem[0].attributes;
	
	    var target = contextMenuElem[0].getAttribute('fis-target') || 'row';
	    if (target === 'row') {
	      contextMenuFilter = '.fis-grid-row';
	    } else if (target === 'column') {
	      contextMenuFilter = 'td[role="gridcell"]';
	    }
	
	    contextMenuOpts.target = gridElem;
	    contextMenuOpts.filter = contextMenuFilter;
	
	    // expose current row data and column data on scope depending on the target specified by user
	    contextMenuOpts.open = function (e) {
	      if (target === 'row') {
	        targetRowIdx = $('tr', kendoGrid.tbody).index(e.target);
	      } else if (target === 'column') {
	        targetRow = $(e.target).closest('tr');
	        targetRowIdx = $('tr', kendoGrid.tbody).index(targetRow);
	
	        targetColIdx = $('td', targetRow).index(e.target);
	        targetColName = gridElem.find('th').eq(targetColIdx).attr('data-field');
	
	        var colsForContextMenu = contextMenuAttrs['fis-column-name'].value;
	        colsForContextMenu = $parse(colsForContextMenu)(scope) ? $parse(colsForContextMenu)(scope) : colsForContextMenu;
	        if (angular.isArray(colsForContextMenu)) {
	          if (colsForContextMenu.indexOf(targetColName) < 0) {
	            e.preventDefault();
	          }
	        } else {
	          if (targetColName !== colsForContextMenu) {
	            // eslint-disable-line no-lonely-if
	            e.preventDefault();
	          }
	        }
	      }
	      scope.$parent.rowData = kendoGrid.dataSource.data()[targetRowIdx];
	      scope.$parent.colName = targetColName;
	      if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	        scope.$apply();
	      }
	    };
	
	    // kendo pass through attributes for context  menu
	    for (var i = 0; i < contextMenuAttrs.length; i++) {
	      var attr = contextMenuAttrs[i];
	      if (attr.specified && attr.name.indexOf('k') === 0) {
	        var kendoAttribute = attr.name.substring(2);
	        // replace hypen character with camelCase
	        kendoAttribute = kendoAttribute.replace(/-([a-z])/g, function (g) {
	          return g[1].toUpperCase();
	        });
	        var attrVal = $parse(attr.value)(scope.$parent.$parent) ? $parse(attr.value)(scope.$parent.$parent) : attr.value;
	        contextMenuOpts[kendoAttribute] = attrVal;
	      }
	    }
	    return contextMenuOpts;
	  }
	
	  // This function is used to select the multiple rows when user presses the shift key and selects a column in the rows to be selected.
	  function selectMultipleRowsWithShiftKey(prevSelection, currSelection, selected, cell, scope, kendoGrid) {
	    // Select multiple rows at once
	    var startIndex = prevSelection;
	    var endIndex = currSelection;
	    var rowSelectCheckbox = kendoGrid.element.find('th .select-all');
	    if (startIndex > endIndex) {
	      // Some magic for swapping the values if they are in the "wrong" order
	      endIndex = [startIndex, startIndex = endIndex][0];
	    }
	    for (var i = startIndex, j = endIndex; i <= j; i++) {
	      if (selected && cell.is('td')) {
	        scope.setRowSelectionStatus(kendoGrid.dataSource.view()[i], false);
	        setHeaderCheckboxStatus(scope, kendoGrid.dataSource, false, rowSelectCheckbox);
	      } else if (!selected && cell.is('td')) {
	        scope.setRowSelectionStatus(kendoGrid.dataSource.view()[i], true);
	        setHeaderCheckboxStatus(scope, kendoGrid.dataSource, true, rowSelectCheckbox);
	      }
	    }
	  }
	
	  function getFilterGridOptions(fisFilterableOperators, type, attrs) {
	    var gridSupportedOperators = ['eq', 'lt', 'gt', 'contains', 'startswith', 'endswith', 'doesnotcontain', 'notstartswith', 'notendswith', 'ne', 'ge', 'le', 'neq', 'gte', 'lte'];
	    var conversionForKendo = { ne: 'neq', ge: 'gte', le: 'lte' };
	
	    if (fisFilterableOperators) {
	      var operatorsString = {};
	      var filterOption = fisFilterableOperators.split(',');
	      angular.forEach(filterOption, function (action) {
	        // metadata.push(action);
	        action = action.toLowerCase();
	        if (!_.isUndefined(conversionForKendo[action])) {
	          action = conversionForKendo[action];
	        }
	        if (gridSupportedOperators.indexOf(action) > -1) {
	          operatorsString[action] = fisI18nService.translate(['compareOperators', type, action], action);
	        }
	      });
	      return operatorsString;
	    } else {
	      // eslint-disable-line no-else-return
	      var result = {};
	      var constraints = angular.copy(fisConstraintsFactory.getConstraintsByType(type));
	      if (type === 'string') {
	        constraints.push({ value: 'doesnotcontain', label: fisI18nService.translate(['compareOperators', type, 'doesnotcontain'], 'does not contain') });
	        if (attrs.fisMode !== 'local') {
	          // add these operators only when the mode is not local because kendo does not support the below mentioned operators
	          // However, for server mode, users can provide their own immplementation for these operators
	          constraints.push({ value: 'notstartswith', label: fisI18nService.translate(['compareOperators', type, 'notstartswith'], 'not starts with') });
	          constraints.push({ value: 'notendswith', label: fisI18nService.translate(['compareOperators', type, 'notendswith'], 'not ends with') });
	        }
	      }
	      angular.forEach(constraints, function (constraint) {
	        if (_.contains(gridSupportedOperators, constraint.value)) {
	          if (!_.isUndefined(conversionForKendo[constraint.value])) {
	            // eslint-disable-line no-negated-condition
	            result[conversionForKendo[constraint.value]] = fisI18nService.translate(['compareOperators', type, conversionForKendo[constraint.value]], constraint.label);
	          } else {
	            result[constraint.value] = fisI18nService.translate(['compareOperators', type, constraint.value], constraint.label);
	          }
	        }
	      });
	      return result;
	    }
	  }
	
	  function getFilterOptionType(attrs) {
	    var operators = {};
	    operators.string = getFilterGridOptions(attrs.fisFilterableOperatorsString, 'string', attrs);
	    operators.number = getFilterGridOptions(attrs.fisFilterableOperatorsNumber, 'number', attrs);
	    operators.date = getFilterGridOptions(attrs.fisFilterableOperatorsDate, 'date', attrs);
	    operators.datetime = getFilterGridOptions(attrs.fisFilterableOperatorsDateTime, 'date', attrs);
	    operators.time = getFilterGridOptions(attrs.fisFilterableOperatorsTime, 'date', attrs);
	    operators.boolean = getFilterGridOptions(attrs.fisFilterableOperatorsBoolean, 'boolean', attrs);
	
	    return operators;
	  }
	
	  function getSecondCriteriaOption(attrs) {
	    return attrs.fisSecondFilterCriteria === '' || _.isUndefined(attrs.fisSecondFilterCriteria) || attrs.fisSecondFilterCriteria !== 'false';
	  }
	
	  function buildDataSourceOptions(scope, attrs, gridOptions, kendoGridElm) {
	    var opts = {};
	    // NOTE: as soon as serverFiltering is on, having paging and sorting local is inefficient:
	    //       the kendo grid will ask the 'server' (fetchData function) for all data every time sorting or pagination is used by the user
	    opts.serverAggregates = opts.serverPaging = opts.serverSorting = opts.serverFiltering = opts.serverGrouping = scope.mode !== 'local';
	    opts.pageSize = scope.pageSize;
	
	    var watchForFilterEvent = !_.isUndefined(attrs.fisOnFiltering) && attrs.fisOnFiltering && _.isFunction(scope.onFilteringFn);
	    var watchForSortEvent = !_.isUndefined(attrs.fisOnSorting) && attrs.fisOnSorting && _.isFunction(scope.onSortingFn);
	    var watchForGroupEvent = !_.isUndefined(attrs.fisGroup);
	    var previousFilter;
	    var previousSort;
	
	    var determineChangeReason = function determineChangeReason(e) {
	      if (watchForSortEvent && !_.isEqual(previousSort, e.sender._sort)) {
	        scope.onSortingFn({ event: e.sender._sort });
	        previousSort = e.sender._sort;
	      }
	      if (watchForFilterEvent && !_.isEqual(previousFilter, e.sender._filter)) {
	        scope.onFilteringFn({ event: e.sender._filter || {} }); // we want only the filter details or send an empty object, if _filter is undefined
	        previousFilter = angular.copy(e.sender._filter);
	        // empty previousFilter to see current filter in popup showing the filter event.
	        // previousFilter = {};
	      }
	    };
	
	    if (gridOptions.editable) {
	      opts.batch = attrs.fisBatch;
	      opts.schema = buildSchemaModel(scope, attrs);
	      opts.change = function (e) {
	        determineChangeReason(e);
	
	        // Save that we edited a specific field and thus this is dirty
	        if (e.action === 'itemchange' && e.field) {
	          if (!e.items[0]._dirtyFields) {
	            e.items[0]._dirtyFields = {};
	          }
	          e.items[0]._dirtyFields[e.field] = true;
	        }
	
	        var kendoGridObject = kendoGridElm.data('kendoGrid');
	
	        if (attrs.fisBatch || attrs.fisEditable === 'inline' || attrs.fisEditable === 'incell') {
	          setSaveCancelStatus(kendoGridObject);
	        }
	
	        bindUnsavedDataHandler(scope, kendoGridObject);
	        bindCancelHandler(scope, kendoGridObject);
	        if (attrs.ngModel) {
	          var ngModel = $parse(attrs.ngModel);
	          // if ng-model expression is assignable, change the expression on user's scope
	          if (ngModel && ngModel.assign) {
	            ngModel.assign(scope.$parent, kendoGridObject.dataSource.data());
	          }
	          if (kendoGridObject.dataSource.hasChanges() && scope.formCtrl) {
	            scope.formCtrl.$setDirty();
	          }
	          if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	            scope.$apply();
	          }
	        }
	        if (attrs.fisOnSelect) {
	          scope.updateSelectionOnEdit();
	        }
	      };
	    } else {
	      if (watchForFilterEvent || watchForSortEvent || watchForGroupEvent) {
	        opts.change = determineChangeReason;
	      }
	      if ($useDataTypes) {
	        opts.schema = buildSchemaModel(scope, attrs);
	      } else if (attrs.fisSchema) {
	        // if user has provided fisSchema, add it as an 'id'
	        opts.schema = buildSchemaModel(scope, attrs);
	      }
	    }
	
	    if (scope.sort) {
	      // parse the user provided fis-sort attribute and assign it to datasource's sort option
	      opts.sort = $parse(attrs.fisSort)(scope.$parent);
	    }
	
	    if (attrs.kAggregate) {
	      opts.aggregate = $parse(attrs.kAggregate)(scope.$parent);
	    }
	
	    /*
	     * If the filters attribute is present then build the criterion object to send to the
	     * grid's filter.
	     */
	    if (!_.isUndefined(scope.filters)) {
	      var criteriaToKendoFilter = {};
	      fisGridUtilService.getGridFilterObject(scope.filters, criteriaToKendoFilter, attrs);
	      opts.filter = criteriaToKendoFilter;
	    }
	
	    opts.group = processGroup(attrs.fisGroup, scope);
	    return opts;
	  }
	
	  function processGroup(group, scope) {
	    var ret;
	    if (group) {
	      if (group.indexOf(',') === -1) {
	        ret = $parse(group)(scope.$parent);
	      }
	
	      // if group is not defined as an object in partial, or in scope, it could be specified just as a field.
	      // in that case, create a group object and pass to datasource
	      if (!ret) {
	        var groups = group.split(',');
	        ret = [];
	        for (var i = 0; i < groups.length; i++) {
	          ret.push({ field: groups[i] });
	        }
	      }
	    }
	    return ret;
	  }
	
	  function getTarget(target, totalpages, currentPage) {
	    if (target.toLowerCase().indexOf('next') >= 0) {
	      return ++currentPage;
	    } else if (target.toLowerCase().indexOf('previous') >= 0) {
	      return --currentPage;
	    } else if (target.toLowerCase().indexOf('last') >= 0) {
	      return totalpages;
	    } else {
	      // eslint-disable-line no-else-return
	      var page = parseInt(target, 10);
	      if (!_.isNaN(page)) {
	        return page;
	      }
	      return 1;
	    }
	  }
	
	  /**
	   * Name:buildPaginationEvent
	   * Description:This method builds an event object that will be passed into the fis-on-pagination event handler,
	   *             that is called every time a page is changed the fisGrid
	   */
	  function buildPaginationEvent(nextPage, prevPage, totalPages) {
	    var event = {};
	
	    var numNextPage = parseInt(nextPage, 10);
	    var numPrevPage = parseInt(prevPage, 10);
	
	    event.totalPages = totalPages;
	
	    event.nextPage = numNextPage;
	    event.previousPage = prevPage === undefined ? 1 : numPrevPage;
	
	    return event;
	  }
	
	  function getPagerButtons(scope, kendoGrid) {
	    var gridPagerButtons;
	    var selectedPagerButton;
	
	    if (kendoGrid.pager) {
	      gridPagerButtons = kendoGrid.pager.element.find('a');
	      selectedPagerButton = kendoGrid.pager.element.find('.k-state-selected'); // find selected pager button
	      $.merge(gridPagerButtons, selectedPagerButton || {});
	    }
	
	    if (scope.pagerPosition !== 'bottom' && scope.kendoPager) {
	      var pagerElement = scope.kendoPager;
	
	      // Find the pager buttons from the top bar - but not the toolbar buttons
	      var topBarLinks = pagerElement.element.find('a');
	      selectedPagerButton = pagerElement.element.find('.k-state-selected'); // find selected pager button
	      $.merge(topBarLinks, selectedPagerButton || {});
	      var topBarPaginationItems = _.filter(topBarLinks, function (topBarLink) {
	        return !$(topBarLink).parent().hasClass('k-grid-toolbar');
	      });
	
	      gridPagerButtons = $.merge(topBarPaginationItems, gridPagerButtons || {});
	    }
	    return gridPagerButtons;
	  }
	
	  function bindCancelHandler(scope, kendoGrid) {
	    var cancelButton = kendoGrid.element.parent().find('.k-grid-toolbar .k-i-cancel').parent();
	    cancelButton.unbind('click');
	    cancelButton.click(function () {
	      if (!$(cancelButton).hasClass('k-state-disabled')) {
	        enableAddRecordStatus(kendoGrid);
	        kendoGrid.cancelChanges();
	      }
	    });
	  }
	
	  function isInDirtyEditMode(scope, kendoGrid) {
	    var inEditMode = kendoGrid.element.find('.k-grid-edit-row').length > 0 || kendoGrid.element.find('k-edit-cell').length > 0;
	    // for local mode, for incell editing it is not necessary to update changes before navigating to next page
	    // However, even in local mode, it should only check in case of inline edit if cell is dirty and grid is in edit mode.
	    if (scope.mode !== 'local' || scope.mode === 'local' && inEditMode && scope.editable === 'inline') {
	      return kendoGrid.element.find('.k-dirty-cell').length > 0 || inEditMode && kendoGrid.dataSource.hasChanges();
	    }
	    return false;
	  }
	
	  function bindUnsavedDataHandler(scope, kendoGrid) {
	    var gridPagerButtons = $(getPagerButtons(scope, kendoGrid));
	    var gridSortOrderButtons = kendoGrid.element.find('.k-header a.k-link');
	    var gridActionSaveButtons = $.merge(gridPagerButtons, gridSortOrderButtons || {});
	    gridActionSaveButtons.unbind('click');
	
	    gridActionSaveButtons.click(function (e) {
	      if (isInDirtyEditMode(scope, kendoGrid)) {
	        promptUserDueUnsavedChanges(e, kendoGrid, scope);
	      }
	      if (!isGridDirty(kendoGrid)) {
	        enableAddRecordStatus(kendoGrid);
	        var unsavedDataBinder = $timeout(function () {
	          bindUnsavedDataHandler(scope, kendoGrid); // rebind buttons after changing page
	        }, 1000);
	        scope.$on('$destroy', function () {
	          if (unsavedDataBinder) {
	            $timeout.cancel(unsavedDataBinder);
	          }
	        });
	      }
	    });
	
	    /*
	     * SDHTML-9977
	     * If you edit a row and then, without saving, click the edit button on another row
	     * then this code alerts you to unsaved changes
	     */
	    if (kendoGrid.element !== null) {
	      var gridEditButton = kendoGrid.element.find('.k-grid-edit');
	      gridEditButton.unbind('click');
	      gridEditButton.click(function (e) {
	        if (isInDirtyEditMode(scope, kendoGrid)) {
	          promptUserDueUnsavedChanges(e, kendoGrid, scope);
	        }
	      });
	    }
	    scope.$on('$destroy', function () {
	      if (gridPagerButtons) {
	        gridPagerButtons.unbind('click');
	      }
	    });
	  }
	
	  /**
	   * Creates a warning dialog to alert the user that there are unsaved changes
	   * when clicking either a grid's pager/sorter or the edit button belonging to another row.
	   * @param e
	   * @param kendoGrid
	   * @param scope
	   */
	  function promptUserDueUnsavedChanges(e, kendoGrid, scope) {
	    var targetButton = $(e.target);
	    if (targetButton.hasClass('k-grid-save-changes') === false) {
	      var nextActionIsEditing = targetButton.closest('.k-grid-edit').length > 0;
	
	      var activeCell = kendoGrid._current; // activeCell
	      var lastEditCells = kendoGrid.element.find('.k-dirty-cell');
	      // Based on Kendo support's answer, both preventDefault and stopImmediatePropagation need to be called
	      // preventDefault is required to avoid scrolling to the top of the page.
	      // See http://jsbin.com/uGaxogE/6/edit for an example.
	      e.preventDefault();
	      e.stopImmediatePropagation();
	
	      var messageTimeout = $timeout(function () {
	        var msg;
	        if (lastEditCells.length === 0) {
	          msg = fisI18nService.translate(['fisGrid', 'exitEdit'], 'There are pending changes. Do you want to exit edit mode?');
	        } else {
	          msg = fisI18nService.translate(['fisGrid', 'cancelChanges'], 'There are pending changes. Do you want to cancel your edited changes?');
	        }
	
	        scope.$parent.confirm(msg, { title: 'Cancel Edit', actions: { yesno: true } }).then(function (ok) {
	          if (ok) {
	            if (nextActionIsEditing) {
	              // We stopped an edit button press on another grid row
	              // => now trigger edit of this row
	              kendoGrid.editRow(targetButton.closest('[role="row"]'));
	            } else {
	              kendoGrid.dataSource.cancelChanges();
	              // We stopped a pagination press
	              // => now paginate to destination page
	              var target = getTarget(e.currentTarget.innerHTML || $(e.currentTarget).attr('data-page'), kendoGrid.dataSource.totalPages(), kendoGrid.dataSource.page());
	              if (scope.pagerPosition === 'top' || scope.pagerPosition === 'both') {
	                scope.kendoPager.dataSource.page(target);
	              }
	              if (activeCell && activeCell.hasClass('k-header')) {
	                var sort = activeCell.attr('data-dir');
	                if (_.isUndefined(sort)) {
	                  sort = 'asc';
	                }
	                kendoGrid.dataSource.sort({ field: activeCell.attr('data-field'), dir: sort });
	              }
	              kendoGrid.dataSource.page(target);
	            }
	            enableAddRecordStatus(kendoGrid);
	            return true;
	          } else {
	            // eslint-disable-line no-else-return
	            // User chose to not stop editing and will not lose changes
	            if (lastEditCells.length > 0) {
	              $timeout(function () {
	                if (!scope.$root.$$phase) {
	                  $(lastEditCells[0]).trigger('click'); // focus on first dirty edit
	                }
	              }, 0);
	            } else {
	              // focus on last edit
	              $timeout(function () {
	                if (!scope.$root.$$phase && !activeCell.hasClass('k-header')) {
	                  $(activeCell[0]).trigger('click'); // focus on first dirty edit
	                }
	              }, 0);
	            }
	            return false;
	          }
	        });
	      }, 0);
	
	      scope.$on('$destroy', function () {
	        if (messageTimeout) {
	          $timeout.cancel(messageTimeout);
	        }
	      });
	    }
	  }
	
	  function getColumns(cols, attrs, scope) {
	    if (_.isUndefined(attrs.fisColumns) && _.isUndefined(attrs.fisSchemaColumns) && _.isUndefined(attrs.fisSchemaColumnsDefault)) {
	      attrs.fisSchemaColumnsDefault = 'columns';
	      return;
	    }
	
	    if (!_.isUndefined(attrs.fisColumns) && !_.isUndefined(attrs.fisSchemaColumns)) {
	      fisGridUtilService.handleError(scope, 'Both fis-columns and fis-schema-columns have been defined, please select only one', null, 'fisColumns');
	      return;
	    }
	
	    // if ( _.isUndefined(attrs.fisSchemaColumnsDefault) && !_.isUndefined(cols) && !(cols.then)) {
	    if (!_.isUndefined(cols)) {
	      var metadata = [];
	      var parts;
	      var i;
	
	      // String
	      if (angular.isString(cols)) {
	        parts = cols.split(',');
	
	        for (i = 0; i < parts.length; i++) {
	          metadata.push({
	            field: parts[i],
	            title: fisI18nService.translate(parts[i], uncamelcase(parts[i]))
	          });
	        }
	
	        // Array
	      } else if (angular.isArray(cols)) {
	        metadata = cols;
	        // Function
	      } else if (angular.isFunction(cols)) {
	        metadata = cols();
	        // Error
	      } else {
	        fisGridUtilService.handleError(scope, 'No fis-columns/fis-schema-columns provided.', null, 'fisColumns');
	        return;
	      }
	      metadata = removeSelectionColumnType(metadata, scope);
	      metadata = transformDataTypeToColumn(metadata, scope);
	      metadata = translateColumnTitles(metadata, scope);
	      metadata = translateFilterOperators(metadata); // if fis-columns contains 'operators' property then build the menu's filterable property with the specified operators
	      metadata = applyColumnMinWidth(metadata);
	
	      return angular.copy(metadata);
	    }
	    return undefined;
	  }
	
	  function translateColumnTitles(metadata, scope) {
	    for (var i = 0; i < metadata.length; i++) {
	      var column = metadata[i];
	      if (!_.isUndefined(column.title) && !_.isUndefined(scope) && !_.isUndefined(scope.$parent)) {
	        var title = $interpolate(column.title)(scope.$parent);
	        column.title = title;
	      }
	    }
	    return metadata;
	  }
	
	  /**
	   * Assign the checkbox style from columns definition (columnType = Selection) and then remove it from column metadata
	   * SDHTML-11439 : fisGrid: In multiple row selection, provide way to style checkbox column based on row data
	   * @param metadata
	   * @param scope
	   * @returns {*}
	   */
	  function removeSelectionColumnType(metadata) {
	    checkboxColumn = {};
	    if (angular.isArray(metadata)) {
	      for (var i = 0; i < metadata.length; i++) {
	        var column = metadata[i];
	        if (!_.isUndefined(column.columnType) && column.columnType == 'selection') {
	          // eslint-disable-line eqeqeq
	          angular.copy(column, checkboxColumn); // Assign the property to checkboxColumn
	          metadata.splice(i, 1); // Remove the checkbox column from the metadata
	        }
	      }
	    }
	    return metadata;
	  }
	
	  /**
	   * Builds the column's filterable property with the specified operators
	   * @param metadata
	   * @returns {Object} - metadata with filterable property set
	   */
	  function translateFilterOperators(metadata) {
	    for (var i = 0; i < metadata.length; i++) {
	      var column = metadata[i];
	      if (!_.isUndefined(column.operators)) {
	        var filterable = {};
	        filterable.operators = {};
	        var dataType = translateOperatorDataType(metadata[i].dataType); // kendo filter for numbers must be number, not integer or double
	        filterable.operators[dataType] = {};
	        var parts = metadata[i].operators.split(','); // if this doesn't work then check there are no spaces between the operators, i.e. must be operators:'eq,gt'
	        for (var k = 0; k < parts.length; k++) {
	          var key = parts[k];
	          var operatorValue = getOperatorValue(dataType, key);
	          filterable.operators[dataType][key] = operatorValue;
	        }
	        column.filterable = filterable;
	      }
	    }
	    return metadata;
	  }
	
	  /**
	   * Adjusts the columns width property to have a certain minimum width.
	   * @param metadata
	   * @returns {Object} - metadata with every column having at least the minimum width set (or none set, if no column width was specified)
	   */
	  function applyColumnMinWidth(metadata) {
	    for (var i = 0; i < metadata.length; i++) {
	      var column = metadata[i];
	      if (!_.isUndefined(column.width) && column.width < 70) {
	        column.width = 70;
	      }
	    }
	    return metadata;
	  }
	
	  /**
	   * Used by grids with fis-columns that define the 'operator' property to
	   * translate the operator data type because Kendo filter recognises only 'number' and not 'integer' or 'double'
	   * @param type
	   * @returns {String}
	   */
	  function translateOperatorDataType(type) {
	    if (type === 'integer' || type === 'double') {
	      return 'number';
	    }
	    return type;
	  }
	
	  /**
	   * Used by grids with fis-columns that define the 'operator' property
	   * to return the operator value, e.g. eq: 'Is equal' for columns
	   * with datatype string.
	   * @param datatype
	   * @param operator
	   * @returns {string}
	   */
	  function getOperatorValue(datatype, operator) {
	    if (datatype === 'string') {
	      return getOperatorStringValue(operator);
	    }
	    if (datatype === 'number') {
	      return getOperatorNumberValue(operator);
	    }
	    if (datatype === 'date') {
	      return getOperatorDateValue(operator);
	    }
	  }
	
	  /**
	   * Used by grids with fis-columns that define the 'operator' property
	   * to return values for String operators, e.g. eq:'Is equal'
	   * @param operator
	   * @returns {string}
	   */
	  function getOperatorStringValue(operator) {
	    if (operator === 'contains') {
	      return 'Contains';
	    }
	    if (operator === 'not_contains' || operator === 'doesnotcontain') {
	      return 'Does not contain';
	    }
	    if (operator === 'endswith') {
	      return 'Ends with';
	    }
	    if (operator === 'eq') {
	      return 'Is equal';
	    }
	    if (operator === 'neq') {
	      return 'Is not equal';
	    }
	    if (operator === 'startswith') {
	      return 'Starts with';
	    }
	  }
	
	  /**
	   * Used by grids with fis-columns that define the 'operator' property
	   * to return values for Number operators, e.g. gt:'Greater than'
	   * @param operator
	   * @returns {string}
	   */
	  function getOperatorNumberValue(operator) {
	    if (operator === 'eq') {
	      return 'Is equal';
	    }
	    if (operator === 'gt') {
	      return 'Greater than';
	    }
	    if (operator === 'ge' || operator === 'gte') {
	      // kendo expects gte but fisCriteriaService expects ge
	      return 'Greater than or equal to';
	    }
	    if (operator === 'lt') {
	      return 'Less than';
	    }
	    if (operator === 'lte' || operator === 'lt') {
	      // kendo expects lte but fisCriteriaService expects le
	      return 'Is not equal to';
	    }
	    if (operator === 'ne' || operator === 'neq') {
	      // kendo expects neq but fisCriteriaService expects ne
	      return 'Not equal';
	    }
	  }
	
	  /**
	   * Used by grids with fis-columns that define the 'operator' property
	   * to return values for Date operators, e.g. lt:'Is before or equal'
	   * @param operator
	   * @returns {string}
	   */
	  function getOperatorDateValue(operator) {
	    if (operator === 'eq') {
	      return 'Is equal';
	    }
	    if (operator === 'ne' || operator === 'neq') {
	      // kendo expects neq but fisCriteriaService expects ne
	      return 'Not equal';
	    }
	    if (operator === 'ge' || operator === 'gte') {
	      // kendo expects gte but fisCriteriaService expects ge
	      return 'Is after or equal';
	    }
	    if (operator === 'gt') {
	      return 'Is after';
	    }
	    if (operator === 'lte' || operator === 'lt') {
	      // kendo expects lte but fisCriteriaService expects le
	      return 'Is before or equal';
	    }
	    if (operator === 'lt') {
	      return 'Is before';
	    }
	  }
	
	  function mergeAttributes(oldAttrObj, newAttrObj) {
	    var mergedObj;
	
	    if (_.isUndefined(oldAttrObj) && !_.isUndefined(newAttrObj)) {
	      return newAttrObj;
	    }
	
	    if (_.isObject(oldAttrObj) && _.isObject(newAttrObj)) {
	      mergedObj = newAttrObj;
	
	      var oldAttrKeys = _.keys(oldAttrObj);
	      var newAttrKeys = _.keys(newAttrObj);
	
	      // check if object 1 contains a ng-class and if object 2 contains a class
	      if (_.contains(oldAttrKeys, 'ng-class') && _.contains(newAttrKeys, 'class')) {
	        _.each(oldAttrKeys, function (key) {
	          var matchKey = _.find(newAttrKeys, function (nKey) {
	            return nKey === key;
	          });
	          if (!_.isUndefined(matchKey)) {
	            mergedObj[matchKey] = oldAttrObj[matchKey] + ' ' + newAttrObj[matchKey];
	          }
	        });
	      }
	
	      // extract keys that do not exist in both object and then add them to merged object
	      var oldExtraKeys = _.difference(oldAttrKeys, newAttrKeys);
	      var newExtaKeys = _.difference(newAttrKeys, oldAttrKeys);
	
	      _.each(oldExtraKeys, function (extraKey) {
	        mergedObj[extraKey] = oldAttrObj[extraKey];
	      });
	
	      _.each(newExtaKeys, function (extraKey) {
	        mergedObj[extraKey] = newAttrObj[extraKey];
	      });
	    }
	    return mergedObj;
	  }
	
	  function isDate(value) {
	    // Check for valid date as well as for fis-date-only formatted date
	    if (_.isDate(value) || fisDateTimeFormatService.isValidDate(value, 'yyyy-MM-dd', true)) {
	      return true;
	    }
	    return false;
	  }
	
	  function isValueEqual(newVal, oldVal) {
	    var isEqual = true;
	    if (isDate(newVal) || isDate(oldVal)) {
	      var oldDate = new Date(oldVal);
	      var newDate = new Date(newVal);
	      var oldUtcDate = new Date(Date.UTC(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate()));
	      var newUtcDate = new Date(Date.UTC(newDate.getFullYear(), newDate.getMonth(), newDate.getDate()));
	      if (+newUtcDate !== +oldUtcDate) {
	        // eslint-disable-line no-implicit-coercion
	        isEqual = false;
	      }
	    } else {
	      if (!_.isEqual(newVal, oldVal)) {
	        // eslint-disable-line no-lonely-if
	        isEqual = false;
	      }
	    }
	    return isEqual;
	  }
	
	  var findFocusable = function findFocusable(container) {
	    var inputElements = container.find('.fis-input:visible');
	    if (inputElements.length === 0) {
	      inputElements = container.find('input:visible');
	    }
	    if (inputElements.length > 0) {
	      return $(inputElements[inputElements.length - 1]);
	    }
	    return null;
	  };
	
	  var focusField = function focusField(container) {
	    return $timeout(function () {
	      var inputElement = findFocusable(container);
	      // To Do: Need to find a better way to identify kendo-angular widgets.
	      // Right now, we are explicitly using selectors for fis-select-field and fis-number-field
	      // to fix SDHTML-17344 and SDHTML-17335 issues.
	      var currElement = container.find('[fis-select-field], [fis-number-field]');
	      if (currElement.length > 0) {
	        var elmObj;
	        // SDHTML-17344, SDHTML-17335 For Kendo-angular components we need to keep checking till the component is
	        // rendered successfully before triggering the 'focus' event. That's why, we are using $interval here.
	        var stop = $interval(function () {
	          // eleObj is the kendo component rendered in DOM
	          elmObj = container.find('.k-widget');
	          if (elmObj.length > 0) {
	            // Since component has successfully rendered, canceling the $interval.
	            $interval.cancel(stop);
	            // triggering 'focus' event programmatically
	            if (currElement.attr('fis-select-field') === undefined) {
	              // For fis-number-field we need to focus the input element of the widget
	              inputElement = findFocusable($(elmObj[0]));
	              if (inputElement) {
	                inputElement.trigger('focus');
	              }
	            } else {
	              $(elmObj[0]).trigger('focus');
	            }
	          }
	        });
	      } else if (inputElement) {
	        inputElement.trigger('focus');
	      }
	    });
	  };
	
	  var compileCell = function compileCell(cell, model, scope) {
	    try {
	      if (angular.isFunction(cell)) {
	        cell = cell(model);
	      }
	      var newScope = scope.$parent.$new();
	      newScope.rowData = model;
	      var widgets = $compile(cell)(newScope);
	      return widgets;
	    } catch (error) {
	      console.error('Cell compilation error: ', error, model, cell);
	      return null;
	    }
	  };
	
	  // add widgets to grid provided through editorTemplate
	  function addWidgetsToEditor(metadata, scope) {
	    if (metadata.editorTemplate) {
	      var template = metadata.editorTemplate;
	      var viewTemplate = metadata.template;
	      var metadataScope = scope;
	      var isValueChanged = false;
	      metadata.editor = function (container, options) {
	        // timeout to compile editorTemplate appended to cell container
	        var widgetsTimeout = $timeout(function () {
	          try {
	            // wrap the element with <form> tag so the the template of the control is compiled correctly
	            template = angular.element(template).wrap('<form class="fis-grid-custom-widget-position" name="cell-' + options.field + '"></form>').parent().prop('outerHTML');
	            var widgets = $compile(template)(metadataScope.$parent.$new());
	            widgets.scope().rowData = options.model;
	            widgets.scope().$watch('rowData.' + options.field, function (newVal, oldVal) {
	              if (!angular.isUndefined(newVal) && !isValueEqual(newVal, oldVal)) {
	                options.model.dirty = true;
	                isValueChanged = true;
	                // Trigger the change event and pass on which field has been manipulated
	                options.model.trigger('change', { field: options.field });
	                if (metadataScope.editable === 'incell') {
	                  if (!container.hasClass('k-dirty-cell')) {
	                    container.addClass('k-dirty-cell');
	                  }
	                }
	              }
	            }, true);
	            container.empty();
	            widgets.appendTo(container);
	          } catch (error) {
	            console.error('Error: ', error);
	          }
	          // focus element only case of incell editing
	          if (metadataScope.editable === 'incell') {
	            if (!container.hasClass('k-edit-cell')) {
	              container.addClass('k-edit-cell');
	            }
	            // timeout to find input element once editorTemplate widgets compiled and added to DOM
	            if (container.find('.fis-input').is(':checkbox')) {
	              /* If element is a checkbox then set its label so that it appears next to the checkbox in the same td */
	              var fisField = container.find('.fis-field');
	              var trueLabel = fisField.attr('fis-true-value-label');
	              var falseLabel = fisField.attr('fis-false-value-label');
	              if (trueLabel && falseLabel) {
	                // If labels are defined at the checkbox, take care that we show in in edit mode
	                // by manipulating checkbox label field
	                var trueValue = fisField.attr('ng-true-value-input') || true;
	                var checkboxLabel = container.find('.checkbox-label');
	                checkboxLabel.text('{{ ' + fisField.attr('ng-model-input') + ' === ' + trueValue + ' ? "' + trueLabel + '" : "' + falseLabel + '" }}');
	                checkboxLabel.html($compile(checkboxLabel.prop('outerHTML'))(widgets.scope())); // eslint-disable-line block-scoped-var
	              }
	            } else {
	              var focusable = findFocusable(container);
	              if (focusable) {
	                var focusOutHandler = focusable.on('focusout', { element: container, model: options.model }, function (event) {
	                  if (focusable[0].validity && !focusable[0].validity.valid) {
	                    event.stopImmediatePropagation();
	                    event.preventDefault();
	                    return false;
	                  }
	                  var cell = event.data.element;
	                  var cellViewValue = cell.find('.fis-view-value').text();
	                  var model = event.data.model;
	                  var valueChangedField;
	                  var templateValue = '';
	
	                  var renderTemplate = function renderTemplate() {
	                    $timeout(function () {
	                      valueChangedField = cell.find('.k-dirty');
	                      if (!angular.isUndefined(valueChangedField) && valueChangedField.length > 0) {
	                        isValueChanged = true;
	                      }
	                      cell.empty();
	                      if (angular.isUndefined(viewTemplate)) {
	                        templateValue = cellViewValue.indexOf('<span>') > -1 ? cellViewValue : '<span>' + cellViewValue + '</span>';
	                      } else {
	                        templateValue = viewTemplate.indexOf('<span>') > -1 ? viewTemplate : '<span>' + viewTemplate + '</span>';
	                      }
	                      var widgets = compileCell(templateValue, model, scope);
	                      scope.$on('$destroy', function () {
	                        fisMemoryUtilService.callCleanAll(widgets);
	                        widgets = null;
	                      });
	                      if (widgets && widgets !== null) {
	                        if (isValueChanged) {
	                          cell.prepend('<span class="k-dirty"></span>');
	                          isValueChanged = false;
	                        }
	                        widgets.appendTo(cell);
	                      }
	                      if (cell.hasClass('k-edit-cell')) {
	                        cell.removeClass('k-edit-cell');
	                      }
	                    });
	                  };
	                  scope.$on('$destroy', function () {
	                    focusable.off('focusout', null, focusOutHandler);
	                    $timeout(renderTemplate);
	                  });
	                  $timeout(renderTemplate);
	                });
	              }
	            }
	            focusField(container);
	          }
	        });
	
	        scope.$on('$destroy', function () {
	          if (widgetsTimeout) {
	            $timeout.cancel(widgetsTimeout);
	          }
	        });
	      };
	    }
	  }
	
	  function transformDataTypeToColumn(metadata, scope) {
	    if (!angular.isArray(metadata)) {
	      console.warn('Unable to transformDataTypeToColumn, columns are not an array.');
	      return metadata;
	    }
	    var dataTypeFlag = false;
	    for (var i = 0; i < metadata.length; i++) {
	      var column = metadata[i];
	      var dataType = getColumnDataType(column);
	      if (!_.isUndefined(dataType) && (dataType.format || dataType.schemaType)) {
	        // first time we get a dataType, we start using $useDataTypes
	        dataTypeFlag = true;
	        metadata[i].format = dataType.format;
	        metadata[i].schemaType = dataType.schemaType;
	        // SDHTML-10327: If the editor template is provided to column that will be applied if
	        // editorTemplate is not provided and editor template based on the dataType is applied
	        if (!_.isUndefined(metadata[i].editorTemplate)) {
	          addWidgetsToEditor(metadata[i], scope);
	        }
	        if (_.isUndefined(metadata[i].editor) && !_.isUndefined(dataType.editor)) {
	          metadata[i].editor = dataType.editor;
	        }
	        var cellAttributes = angular.copy(dataType.attributes);
	        var headerAttributes = angular.copy(dataType.headerAttributes);
	        // set the column text alignment
	        metadata[i].attributes = mergeAttributes(metadata[i].attributes, cellAttributes);
	        metadata[i].headerAttributes = mergeAttributes(metadata[i].headerAttributes, headerAttributes);
	      } else {
	        addWidgetsToEditor(metadata[i], scope);
	      }
	    }
	
	    if (dataTypeFlag === true) {
	      $useDataTypes = true;
	    } else {
	      $useDataTypes = false;
	    }
	
	    return metadata;
	  }
	
	  function transformFilterTemplates(columns, scope, gridElem) {
	    angular.forEach(columns, function (column) {
	      if (column.filterTemplate) {
	        var template = column.filterTemplate;
	        var columnFilterScope = scope.$parent.$new();
	        column.filterable = {
	          ui: function ui(element) {
	            columnFilterScope.filterTimeout = $timeout(function () {
	              // var kendoGrid = gridElem.data('kendoGrid'); seems unused
	              var dataBindValue = element.attr('data-bind');
	              var ngModelInput = 'kendoFilterMenu.filterModel.' + dataBindValue.substring(dataBindValue.indexOf(':') + 1).trim();
	              var newTemplate = angular.copy(template);
	              newTemplate = angular.element(angular.element(newTemplate).attr('ng-model-input', ngModelInput).attr('ng-model', ngModelInput));
	              // wrap the element with <form> tag so the the template of the control is compiled correctly
	              newTemplate = newTemplate.wrap('<form name="filterForm-' + ngModelInput + '"></form>').parent().prop('outerHTML');
	              var widgets = $compile(newTemplate)(columnFilterScope);
	              if (!widgets.scope().kendoFilterMenu) {
	                widgets.scope().kendoFilterMenu = $(gridElem.find('.k-grid-header').find('th[data-field="' + column.field + '"]')).data('kendoFilterMenu');
	              }
	              var relacedWidgets = element.replaceWith(widgets); // eslint-disable-line no-unused-vars
	              scope.$on('$destroy', function () {
	                fisMemoryUtilService.callCleanAll(newTemplate);
	                fisMemoryUtilService.callCleanAll(widgets);
	                newTemplate = null;
	                widgets = null;
	              });
	            }, 0);
	            columnFilterScope.$on('$destroy', function () {
	              // in most scenarios it appears tha thte above call to destroy alreay cancels the timeout.
	              if (columnFilterScope.filterTimeout && columnFilterScope.filterTimeout.cancel) {
	                columnFilterScope.filterTimeout.cancel();
	              }
	            });
	          }
	        };
	      }
	    });
	    return columns;
	  }
	
	  function getColumnDataType(part) {
	    var myKendoType;
	
	    if (!_.isEmpty(part) && !_.isUndefined(part.dataType)) {
	      var myDt = part.dataType.split(':');
	      var kendoType = typeMapping[myDt[0].toLowerCase()] || typeMapping.string; // Fallback to string for unknown dataType values
	      myKendoType = angular.copy(kendoType);
	      if (!_.isUndefined(myKendoType.precision)) {
	        var precision = myKendoType.precision.valueOf();
	        var disableSpinner = part.spinner === 'false';
	        if (myDt[1]) {
	          // if it is specified
	          precision = myDt[1].valueOf();
	        }
	        myKendoType.format = kendoType.format.substring(0, [kendoType.format.length - 1]) + precision + '}';
	        // other editor types could be added in a 'better' way ???
	        if (myKendoType.schemaType.type === 'number') {
	          myKendoType.editor = fisEditorFactory.getNumberEditor(precision, disableSpinner);
	        }
	      }
	      // Get default kendo dateTimePicker/timePicker based on data types
	      if (myKendoType.schemaType.type === 'datetime') {
	        myKendoType.editor = fisEditorFactory.getDateTimeEditor(fisDateTimeFormatService);
	      } else if (myKendoType.schemaType.type === 'time') {
	        myKendoType.editor = fisEditorFactory.getTimeEditor(fisDateTimeFormatService);
	      }
	
	      // override the datatype alignment if it is set
	      if (!_.isUndefined(part.align)) {
	        var align = part.align.valueOf().toLowerCase();
	        if (align === 'right') {
	          myKendoType.attributes = right;
	          myKendoType.headerAttributes = right;
	        } else if (align === 'left') {
	          myKendoType.attributes = left;
	          myKendoType.headerAttributes = left;
	        } else {
	          myKendoType.attributes = center;
	          myKendoType.headerAttributes = center;
	        }
	      }
	
	      // Check to see if kendo specific formatting needs to be done
	      if (!_.isEmpty(part) && !_.isUndefined(part.format)) {
	        myKendoType.format = part.format;
	      }
	    }
	    return myKendoType;
	  }
	
	  function makeDate(value) {
	    var date = null;
	    if (angular.isUndefined(value) || value === null) {
	      return date;
	    }
	    if (!isNaN(value)) {
	      // eslint-disable-line no-negated-condition
	      date = new Date(parseInt(value, 10));
	    } else {
	      if (fisDateTimeFormatService.isValid(value)) {
	        // eslint-disable-line no-lonely-if
	        // if format is yyyy-mm-dd then replace - with / to handle timezone issues bug SDHTML-15448
	        var pattern = /\d{4}-\d{2}-\d{2}$/;
	        if (value.trim().match(pattern)) {
	          value = value.replace(/-/g, '/');
	        }
	        date = new Date(value);
	      }
	    }
	    return date;
	  }
	
	  function initializeSchema(schema) {
	    if (_.isUndefined(schema)) {
	      schema = {};
	    }
	    if (_.isUndefined(schema.model)) {
	      schema.model = {};
	    }
	    if (_.isUndefined(schema.model.fields)) {
	      schema.model.fields = {};
	    }
	  }
	
	  function mergeDataTypesToSchema(schemaArg, columnMetadata, scope, gridElem) {
	    var schema = schemaArg || {};
	    if (columnMetadata === undefined) {
	      console.warn('No columnMetadata provided, cannot merge in column dataTypes..');
	    }
	    initializeSchema(schema);
	
	    if (!_.isEmpty(columnMetadata)) {
	      for (var i = 0; i < columnMetadata.length; i++) {
	        var column = columnMetadata[i];
	        if (!_.isUndefined(column.field)) {
	          var columnName = column.field.toString();
	          var sType = column.schemaType;
	          if (_.isUndefined(sType)) {
	            sType = {};
	            sType.type = 'string';
	          }
	          if (_.isUndefined(schema.model.fields[columnName])) {
	            schema.model.fields[columnName] = sType;
	          }
	
	          if (!_.isUndefined(sType) && (schema.model.fields[columnName].type === 'date' || schema.model.fields[columnName].type === 'datetime' || schema.model.fields[columnName].type === 'time') && (column.dataType === 'date' || column.dataType === 'datetime' || column.dataType === 'time')) {
	            schema.model.fields[columnName].parse = function (viewValue) {
	              // format if its valid date
	              if (!_.isUndefined(viewValue) && fisDateTimeFormatService.isValid(viewValue)) {
	                return formatDateDataTypeColumn(viewValue, 'date');
	              }
	              return viewValue;
	            };
	          }
	          if (!_.isUndefined(column.validator)) {
	            if (scope.scrollable) {
	              console.warn('Warning - Validators are not supported in scrollable grids!' + 'Validator messages may not be in field of view');
	            }
	            var validateMethod = $parse(column.validator.method);
	            schema.model.fields[columnName].validation = getValidator(validateMethod, column.validator.message, gridElem);
	          }
	        }
	      }
	    }
	  }
	
	  function mergeSgSchemaWithColumnSchema(schema, columnMetadata) {
	    initializeSchema(schema);
	    if (!_.isEmpty(columnMetadata)) {
	      for (var i = 0; i < columnMetadata.length; i++) {
	        var column = columnMetadata[i];
	        if (!_.isUndefined(column.field)) {
	          var columnName = column.field.toString();
	          if (!_.isUndefined(column.schema)) {
	            // merge/override column schema with fis-schema
	            $.extend(true, column.schema, schema.model.fields[columnName]);
	            schema.model.fields[columnName] = column.schema;
	          }
	        }
	      }
	    }
	  }
	
	  function mergeValidatorsToSchema(schema, columnMetadata, scope, gridElem) {
	    initializeSchema(schema);
	    if (!_.isEmpty(columnMetadata)) {
	      for (var i = 0; i < columnMetadata.length; i++) {
	        var column = columnMetadata[i];
	        if (!_.isUndefined(column.field)) {
	          var columnName = column.field.toString();
	
	          if (!_.isUndefined(column.validator)) {
	            if (scope.scrollable) {
	              console.warn('Warning - Validators are not supported in scrollable grids!' + 'Validator messages may not be in field of view');
	            }
	            var validateMethod = $parse(column.validator.method);
	            if (_.isUndefined(schema.model.fields[columnName])) {
	              schema.model.fields[columnName] = {};
	            }
	            schema.model.fields[columnName].validation = getValidator(validateMethod, column.validator.message, gridElem);
	          }
	        }
	      }
	    }
	  }
	
	  function getValidator(validator, message, gridElem) {
	    var validatore = {
	      custom: function custom(input) {
	        var isValid = true;
	        // ensure that a message is set - else we live with the default '?'.
	        if (!_.isUndefined(message)) {
	          input.attr('data-custom-msg', message);
	        }
	        // kendo workaound for the double validation on spinner appears to be fixed in latest version.
	        isValid = validator(input.val());
	        if (!isValid) {
	          var tr = input.closest('tr');
	          if (tr.is(':last-child')) {
	            gridElem.scrollTop(100);
	          }
	        }
	        input.kendoValidator({ validateOnFocus: false });
	        return isValid;
	      }
	    };
	    return validatore;
	  }
	
	  // This will be called only for single row selection
	  function getChangeCallback(scope) {
	    if (scope.selectable === 'row' && scope.onSelect) {
	      return function () {
	        var selectedRows = this.select();
	        var selectedDataItems = [];
	        for (var i = 0; i < selectedRows.length; i++) {
	          var dataItem = angular.element(selectedRows[i]).scope().rowData;
	          selectedDataItems.push(dataItem);
	        }
	        scope.selectedDataItems = selectedDataItems;
	        var arg = selectedDataItems.length > 0 ? selectedDataItems[0] : null;
	        var indexOnPage = this.items().index(selectedRows);
	        var indexInGrid = indexOnPage;
	        if (this.dataSource.page() && this.dataSource.page() != 1) {
	          // eslint-disable-line eqeqeq
	          indexInGrid = (this.dataSource.page() - 1) * this.dataSource.pageSize() + indexOnPage;
	        }
	
	        scope.onSelect({ selection: arg, row: arg, indexOnPage: indexOnPage, indexInGrid: indexInGrid });
	        if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	          scope.$apply();
	        }
	      };
	    }
	    if (scope.selectable === 'cell' && scope.onSelect) {
	      return function () {
	        var selectedCells = this.select();
	        var selectedDataItems = [];
	        for (var i = 0; i < selectedCells.length; i++) {
	          if (this.options.columns[selectedCells.index()].selectableField == false) {
	            // eslint-disable-line eqeqeq
	            this.clearSelection();
	          } else {
	            var dataItem = {};
	            dataItem.cellValue = selectedCells.text();
	            dataItem.cellIndex = selectedCells.index();
	            dataItem.columnName = this.options.columns[selectedCells.index()].field;
	            dataItem.rowData = this.dataItem(selectedCells.parent('tr'));
	            selectedDataItems.push(dataItem);
	          }
	        }
	        scope.selectedDataItems = selectedDataItems;
	        var arg = selectedDataItems.length > 0 ? selectedDataItems[0] : null;
	        var indexOnPage = selectedCells.index();
	        var indexInGrid = indexOnPage;
	
	        scope.onSelect({ selection: arg, cellData: arg, indexOnPage: indexOnPage, indexInGrid: indexInGrid });
	        if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	          scope.$apply();
	        }
	      };
	    }
	  }
	
	  // This will be fire for multiple row selection when SHIFT key is not pressed
	  function fireChangeCallback(scope) {
	    if (scope.selectable === 'multiple' && scope.onSelect && scope.gridLoaded === true) {
	      scope.onSelect({ rows: scope.selection.rows, all: scope.selection.all, currentRow: scope.selection.currentRow, selection: scope.selection, action: scope.action, indexOnPage: scope.selection.indexOnPage, indexInGrid: scope.selection.indexInGrid });
	      if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	        scope.$apply();
	      }
	    }
	    return undefined;
	  }
	
	  function processColumnsAttr(scope, attrs) {
	    scope.columns = attrs.fisColumns;
	    var promiseObj;
	    try {
	      scope.columns = $parse(attrs.fisColumns)(scope.$parent);
	      if (scope.columns.then) {
	        // since angular 1.4 even if columns is a promise object, parsing does not return it as null/undefined.
	        // It is a promise object.
	        // check if it's a promise
	        promiseObj = scope.$parent[attrs.fisColumns];
	        if (promiseObj && promiseObj.then) {
	          // its a promise
	          promiseObj.then(function (data) {
	            scope.columns = data;
	          }, function (data) {
	            fisGridUtilService.handleError(scope, data, null, 'fisColumns');
	            return;
	          });
	        }
	      }
	    } catch (err) {
	      if (attrs.fisColumns && attrs.fisColumns.indexOf(',') === -1) {
	        fisGridUtilService.handleError(scope, err, null, 'fisColumns');
	        return;
	      }
	      // fisColumns contains a comma delimited string
	    }
	    return promiseObj;
	  }
	
	  function processDetailColumnsAttr(scope, attrs) {
	    scope.detailColumns = attrs.fisDetailColumns;
	    var promiseObj;
	    try {
	      scope.detailColumns = $parse(attrs.fisDetailColumns)(scope.$parent);
	      if (!scope.detailColumns) {
	        // check if it's a promise
	        promiseObj = scope.$parent[attrs.fisDetailColumns];
	        if (promiseObj && promiseObj.then) {
	          // its a promise
	          promiseObj.then(function (data) {
	            scope.detailColumns = data;
	          }, function (data) {
	            fisGridUtilService.handleError(scope, data, null, 'fisDetailColumns');
	            return;
	          });
	        }
	      }
	    } catch (err) {
	      if (attrs.fisDetailColumns && attrs.fisDetailColumns.indexOf(',') === -1) {
	        fisGridUtilService.handleError(scope, err, null, 'fisDetailColumns');
	        return;
	      }
	      // fisDetailColumns contains a comma delimited string
	    }
	    return promiseObj;
	  }
	
	  function checkOffsetParams(opts) {
	    var ret = null;
	    if (!isNaN(opts.skip)) {
	      ret = opts.skip;
	    }
	    return ret;
	  }
	
	  function checkLimitParams(opts) {
	    var ret = null;
	    if (!isNaN(opts.take)) {
	      ret = opts.take;
	    }
	    return ret;
	  }
	
	  function kendoSortingToSortParams(opts) {
	    var ret;
	    var i;
	
	    if (opts.sort && opts.sort.length) {
	      ret = [];
	      for (i = 0; i < opts.sort.length; i++) {
	        ret[i] = opts.sort[i].field + ',' + opts.sort[i].dir;
	      }
	    }
	    return ret;
	  }
	
	  function kendoSortingToSortParamsOdata(opts) {
	    var i;
	
	    var odataSortRet;
	    if (opts.sort && opts.sort.length) {
	      odataSortRet = '';
	      for (i = 0; i < opts.sort.length; i++) {
	        if (odataSortRet !== '') {
	          odataSortRet += ',';
	        }
	        odataSortRet = odataSortRet + opts.sort[i].field + ' ' + opts.sort[i].dir;
	      }
	    }
	
	    return odataSortRet;
	  }
	
	  function buildSchemaModel(scope, attrs) {
	    var attr = attrs.fisSchema;
	    var schema = {};
	    var evalAttr = parseAttribute(scope, attr);
	    if (angular.isString(evalAttr)) {
	      var parts = evalAttr.split(',');
	      var id = attrs.fisId;
	      // if single element is given in fis-schema, add it as 'id'
	      if (!id && parts.length === 1) {
	        id = parts[0];
	      } else {
	        id = 'id';
	      }
	      schema = { model: { id: id }, data: 'data', total: 'total' };
	    } else if (angular.isObject(evalAttr)) {
	      schema = evalAttr;
	    } else if (angular.isFunction(evalAttr)) {
	      schema = evalAttr();
	    }
	    return schema;
	  }
	
	  function parseAttribute(scope, attr) {
	    try {
	      var evalAttr = $parse(attr)(scope.$parent);
	      if (!evalAttr) {
	        evalAttr = attr;
	      }
	      return evalAttr;
	    } catch (err) {
	      // contains a comma delimited string
	      return attr;
	    }
	  }
	
	  function getToolbar(scope, attr) {
	    var onlyEditableToolbars = ['create', 'cancel', 'save'];
	    var metadata = [];
	    var parts;
	    var i;
	    var evalAttr;
	    evalAttr = parseAttribute(scope, attr);
	
	    if (angular.isString(evalAttr)) {
	      parts = evalAttr.split(',');
	
	      for (i = 0; i < parts.length; i++) {
	        metadata.push(parts[i]);
	      }
	    } else if (angular.isArray(evalAttr)) {
	      angular.forEach(evalAttr, function (action) {
	        metadata.push(action);
	      });
	    } else if (angular.isFunction(evalAttr)) {
	      metadata = evalAttr();
	    }
	    if (!scope.editable) {
	      metadata = _.reject(metadata, function (action) {
	        var actionName = angular.isString(action) ? action : action.name;
	        return onlyEditableToolbars.indexOf(actionName) !== -1;
	      });
	    }
	
	    return metadata;
	  }
	
	  // Create an event handler function for each attribute that matches the specified regex (eg. on-*/ds-*) and add to dest.
	  function addEventHandlers(elm, dest, scope, attrs, regex) {
	    var eventHandlers = reduce(attrs, function (memo, attValue, att) {
	      var match = att.match(regex);
	      var eventName;
	      var fn;
	      if (match) {
	        // Lowercase the first letter to match the event name kendo expects.
	        eventName = match[1].charAt(0).toLowerCase() + match[1].slice(1);
	        // Parse the expression.
	        fn = $parse(attValue);
	        // Add a kendo event listener to the memo.
	        memo[eventName] = function (e) {
	          // Invoke the parsed expression with a kendoEvent local that the expression can use.
	          fn(scope.$parent, { kendoEvent: e, kendo: elm });
	        };
	      }
	      return memo;
	    }, {});
	
	    // mix the eventHandlers in the options object
	    angular.extend(dest, eventHandlers);
	  }
	
	  // Simplistic reduce function
	  function reduce(obj, cb, memo) {
	    _.each(obj, function (value, key) {
	      memo = cb.call(value, memo, value, key);
	    });
	    return memo;
	  }
	
	  function applySgIdsOnEvent(gridElem, scope, fisId, opts, optFnAttr) {
	    var fn = opts[optFnAttr];
	    opts[optFnAttr] = function (e) {
	      if (fn) {
	        fn(e);
	      }
	      applySgIdsToRows(gridElem, scope, fisId);
	    };
	  }
	
	  function applySgIdsToRows(gridElem, scope, fisId) {
	    var count = 1; // original option preserved for cases where no rowId.
	    // we would also benefit from using a row id and a column name
	    var columnNames;
	    if (scope && scope.columns && typeof scope.columns === 'function') {
	      columnNames = scope.columns();
	    } else if (scope && scope.columns) {
	      columnNames = scope.columns;
	    }
	    gridElem.find('table').each(function (index, currentElement) {
	      var inputs = $(currentElement).find('.k-input');
	      var editSgId = fisId;
	
	      var row = $(inputs).closest('tr');
	      var rowIdx = $('tr', currentElement.tbody).index(row);
	      if (rowIdx) {
	        editSgId = editSgId + 'row_' + rowIdx; // else we don't add row id
	      }
	
	      inputs.each(function (index, inpElement) {
	        if (!_.isUndefined(columnNames[index].field)) {
	          $(inpElement).attr('fisid', editSgId + '_' + columnNames[index].field);
	        } else if (fisId) {
	          $(inpElement).attr('fisid', editSgId + '_' + count);
	          count++;
	        } else {
	          fisUniqueIdService.generateUniqueId(scope, angular.element(inpElement), {}, 'grid_td');
	        }
	      });
	
	      var buttons = $(currentElement).find('.k-button');
	      buttons.each(function (index, inpElement) {
	        if (fisId) {
	          angular.element(inpElement).scope().rowData; // eslint-disable-line no-unused-expressions
	          $(inpElement).attr('fisid', fisId + '_' + 'button' + count); // eslint-disable-line no-useless-concat
	          count++;
	        } else {
	          fisUniqueIdService.generateUniqueId(scope, angular.element(inpElement), {}, 'grid_td');
	        }
	      });
	    });
	  }
	
	  function clearGridSelection(kendoGrid, scope) {
	    if (!kendoGrid) {
	      return;
	    }
	    var visibleRows;
	    if (scope.isDetail || !scope.hasDetail) {
	      visibleRows = kendoGrid.element.find('tr.fis-grid-row');
	    } else {
	      visibleRows = kendoGrid.element.find('tr.k-master-row');
	    }
	    visibleRows.removeClass('k-state-selected');
	    visibleRows.find('.select-row').prop('checked', false);
	    // visibleRows.children().removeClass('k-multiselect-wrap');
	    scope.selection.rows.length = 0;
	    scope.selection.all = false;
	    scope.selection.currentRow = null;
	    var selectCheckbox = kendoGrid.element.find('th .select-all');
	    selectCheckbox.prop('indeterminate', false);
	    if (scope.gridConfig.deselectQuitsSelectAll === false) {
	      // Clear the temporary safe of explicitly deselected rows
	      scope.deselectedRowIds = {};
	    }
	  }
	
	  function exposeWidgetAPI(scope, attrs, kendoGrid) {
	    var myGrid = $parse(attrs.fisGrid).assign;
	    if (myGrid) {
	      // Grid has its own scope, exposing grid API to its parent scope
	      // Grid exposed exporting functinality
	      // saveAsPDF & saveAsExcel are available on parent scope
	      kendoGrid.ready = true;
	      myGrid(scope.$parent, kendoGrid);
	    }
	    // Grid exposed API to know grid status
	    kendoGrid.isEmpty = function () {
	      return !!(kendoGrid.dataSource.data().length === 0); // eslint-disable-line no-implicit-coercion
	    };
	
	    kendoGrid.setSelectable = scope.setSelectable;
	    kendoGrid.setSelected = scope.setSelected;
	    kendoGrid.setSelectableUID = scope.setSelectableUID;
	    kendoGrid.expandAll = scope.expandAll;
	    kendoGrid.collapseAll = scope.collapseAll;
	  }
	
	  function formatDateDataTypeColumn(viewValue, dataType) {
	    // eslint-disable-line no-unused-vars
	    var isDate;
	    var date;
	    if (!_.isDate(viewValue)) {
	      date = makeDate(viewValue);
	      isDate = angular.isDate(date);
	    }
	    if (dataType === 'date') {
	      // if string is a timestamp/date return as date
	      return isDate ? date : viewValue;
	    } else {
	      // eslint-disable-line no-else-return
	      // if string is a timestamp/date return as string
	      return isDate ? kendo.toString(date, 'u') : viewValue;
	    }
	  }
	
	  function addPagerIDs(scope, attrs, kendoGrid) {
	    if (fis.initParams().appStage === 'T') {
	      // test appStage
	      var pagerButtTimeout = $timeout(function () {
	        var gridPagerButtons = $(getPagerButtons(scope, kendoGrid));
	        var gridName = fisGridUtilService.getGridName(attrs, scope, kendoGrid);
	        var pagerBtn = 0;
	
	        function addSgIdToKendoPager(pagerElem) {
	          // Add fisid to pager-info label
	          var pageInfoElem = pagerElem.find('.k-pager-info');
	          fisUniqueIdService.generateUniqueIdForce(scope, pageInfoElem, attrs, gridName + '_pagerInfoLabel');
	
	          // Add Unique ID for "items per page" dropdown
	          var itemsPerPageSpan = pagerElem.find('.k-dropdown span.k-input');
	          fisUniqueIdService.generateUniqueIdForce(scope, itemsPerPageSpan, attrs, gridName + '_current_per_page');
	
	          // Add ids to possible select values for item per page option element
	          var itemsPerPageSelect = pagerElem.find('.k-dropdown select');
	          fisUniqueIdService.generateUniqueIdForce(scope, itemsPerPageSelect, attrs, gridName + '_select_per_page');
	          var itemsPerPageOptions = itemsPerPageSelect.find('option');
	          _.each(itemsPerPageOptions, function (itemsPerPageOption) {
	            itemsPerPageOption = angular.element(itemsPerPageOption);
	            var optionLabel = itemsPerPageOption.text().trim();
	            fisUniqueIdService.generateUniqueIdForce(scope, itemsPerPageOption, attrs, gridName + '_per_page_option_' + optionLabel);
	          });
	
	          // Add ids to possible select values in kendoDropDownList popup
	          var kendoDropDownWidget = itemsPerPageSelect.data('kendoDropDownList');
	          if (kendoDropDownWidget) {
	            var popupElem = kendoDropDownWidget.popup.element;
	            fisUniqueIdService.generateUniqueIdForce(scope, popupElem, attrs, gridName + '_select_per_page_popup');
	            var popupElemLis = popupElem.find('li');
	
	            _.each(popupElemLis, function (popupElemLi) {
	              popupElemLi = angular.element(popupElemLi);
	              var optionLabel = popupElemLi.text().trim();
	              fisUniqueIdService.generateUniqueIdForce(scope, popupElemLi, attrs, gridName + '_per_page_popup_option_' + optionLabel);
	            });
	          }
	        }
	
	        if (kendoGrid.pager) {
	          // Do we have a kendo pager widget?
	          if (scope.pagerPosition === 'both' || scope.pagerPosition === 'bottom') {
	            // The pager referenced in kendoGrid.pager is available in DOM and visible
	            addSgIdToKendoPager(kendoGrid.pager.element);
	          }
	          if (scope.pagerPosition !== 'bottom' && scope.kendoPager) {
	            // There's an additional pager above the grid
	            addSgIdToKendoPager(scope.kendoPager.element);
	          }
	        }
	        _.each(gridPagerButtons, function (gridPagerButton) {
	          var gridPageButtonElem = angular.element(gridPagerButton);
	          if (jQuery.isNumeric(gridPageButtonElem.text())) {
	            //  need to figure out how to see if child..
	            var rowElement = gridPageButtonElem.closest('tr');
	            // gridPageButtonElem.closest('tr').prev();
	            var isDetailString = rowElement.attr('class');
	            if (isDetailString && isDetailString.indexOf('k-detail-row') != -1) {
	              // eslint-disable-line eqeqeq
	              var detailRow = rowElement.prev();
	              var rowData = angular.element(detailRow).scope().rowData;
	              var idee = scope.getIdee(rowData);
	              var rowId = rowData[idee];
	
	              fisUniqueIdService.generateIdWithStaticSeed(scope, gridPageButtonElem, attrs, gridName + '_grid_pager', '_detail-' + rowId, 'elem-' + gridPageButtonElem.text());
	            } else {
	              var idBase = 'elem-' + gridPageButtonElem.text(); // eslint-disable-line block-scoped-var
	              if (gridPageButtonElem.closest('.k-grid-pager').length == 1) {
	                // eslint-disable-line eqeqeq
	                idBase = 'bottom-' + idBase; // eslint-disable-line block-scoped-var
	              }
	              fisUniqueIdService.generateIdWithStaticSeed(scope, gridPageButtonElem, attrs, gridName + '_grid_pager', null, idBase); // eslint-disable-line block-scoped-var
	            }
	          } else {
	            var idBase = 'grid_pager_buttons_' + pagerBtn++; // eslint-disable-line block-scoped-var, no-redeclare
	            fisUniqueIdService.generateIdWithStaticSeed(scope, gridPageButtonElem, attrs, gridName + 'grid_pager_buttons', null, idBase); // eslint-disable-line block-scoped-var
	          }
	        });
	
	        // Add fisids to multiple selection dropdown list items
	        // At least during the first data bound this dropdown still sits in the table header
	        // after we opened it for the first time it gets appended to body
	        _.each(kendoGrid.element.find('.k-header ul.dropdown-menu li'), function (quickActionLi) {
	          var aLink = angular.element(quickActionLi).find('a');
	          if (aLink.attr('method') === 'selectAllData') {
	            fisUniqueIdService.generateUniqueIdForce(scope, aLink, attrs, gridName + '_select_all');
	          } else if (aLink.attr('method') === 'selectAllPage') {
	            fisUniqueIdService.generateUniqueIdForce(scope, aLink, attrs, gridName + '_select_page');
	          }
	        });
	      }, 0);
	      scope.$on('$destroy', function () {
	        if (pagerButtTimeout) {
	          $timeout.cancel(pagerButtTimeout);
	        }
	      });
	    }
	  }
	
	  /**
	   * @name setGridFilterOptions
	   * @param {scope, JSON, Array}
	   *
	   * @description Builds a JSON criteria object for the grid's filter.
	   */
	  function setGridFilterOptions(scope, gridOptions, attrs) {
	    gridOptions.filterable = {};
	    gridOptions.filterable.operators = {};
	    gridOptions.filterable.operators = getFilterOptionType(attrs);
	    gridOptions.filterable.extra = getSecondCriteriaOption(attrs);
	    gridOptions.filterable.messages = {
	      and: fisI18nService.translate(['fisGrid', 'and'], 'And'),
	      or: fisI18nService.translate(['fisGrid', 'or'], 'Or'),
	      filter: fisI18nService.translate(['fisGrid', 'filter'], 'Filter'),
	      clear: fisI18nService.translate(['fisGrid', 'clear'], 'Clear'),
	      info: fisI18nService.translate(['fisGrid', 'info'], 'Show items with value that:'),
	      isTrue: fisI18nService.translate(['fisGrid', 'isTrue'], 'is true'),
	      isFalse: fisI18nService.translate(['fisGrid', 'isFalse'], 'is false')
	    };
	    // code to add fisid to certain elements on the grid filtering
	    // var fisIdAddedToLinks = false; => Never used variable?!
	    gridOptions.filterMenuInit = function (event) {
	      if (event.field && event.sender.columns) {
	        var fieldName = event.field;
	        var index = 0; // eslint-disable-line no-unused-vars
	        angular.forEach(event.sender.columns, function (column) {
	          if (column.dataType == 'boolean' && column.field == fieldName) {
	            // eslint-disable-line eqeqeq
	            event.container.find('label').addClass('fis-filter-menu-item-boolean');
	          }
	        });
	      }
	      if (fis.initParams().appStage === 'T') {
	        // test appStage
	        // add fisid to the grid filtering dropdowns,buttons and input boxes
	        addFilterMenuIds(event, scope);
	      }
	    };
	  }
	
	  /**
	   * @name setExportFileNameOption
	   * @param scope
	   * @param gridOptions
	   * @param gridName
	   * @param type (excel or pdf)
	   * @param extension
	   * @description sets the export file name option for excel/pdf.
	   */
	  function setExportFileNameOption(scope, gridOptions, gridName, type, extension) {
	    gridOptions[type].fileName = gridName + ' Export' + extension;
	    // eslint-disable-next-line eqeqeq, no-eq-null
	    if (scope.exportFileName != undefined && scope.exportFileName != '' && scope.exportFileName != null && scope.exportFileName.length > 0) {
	      scope.exportFileName = scope.exportFileName.replace(/\.(.*)$/, '');
	      if (/[A-Za-z0-9]/.test(scope.exportFileName)) {
	        gridOptions[type].fileName = scope.exportFileName + extension;
	      } else {
	        console.error('Invalid export file name: ', scope.exportFileName);
	      }
	    }
	  }
	  /**
	   * @name setGridExcelExportOptions
	   * @param scope
	   * @param gridOptions
	   * @param attrs
	   * @param kendoGrid
	   *
	   * @description Builds a JSON criteria object for the grid's filter.
	   */
	  function setGridExcelExportOptions(scope, gridOptions, attrs, kendoGrid) {
	    var gridName = fisGridUtilService.getGridName(attrs, scope, kendoGrid);
	    var exportFlag = false;
	    gridOptions.excel = {};
	    setExportFileNameOption(scope, gridOptions, gridName, 'excel', '.xlsx');
	
	    gridOptions.excelExport = function (e) {
	      if (scope.exportHiddenColumns === true || scope.exportHiddenColumns === 'true') {
	        var indexes = getHiddenColumns(scope.columns);
	        if (!exportFlag) {
	          // eslint-disable-line no-negated-condition
	          toggleHiddenColums(indexes, false, e);
	          e.preventDefault();
	          exportFlag = true;
	          setTimeout(function () {
	            e.sender.saveAsExcel();
	          });
	        } else {
	          toggleHiddenColums(indexes, true, e);
	          exportFlag = false;
	        }
	      }
	    };
	    // If set to true the grid will export all pages of data. By default the grid exports only the current page.
	    if (!scope.excelAllPages) {
	      // eslint-disable-line no-negated-condition
	      gridOptions.excel.allPages = false;
	    } else {
	      gridOptions.excel.allPages = scope.excelAllPages;
	    }
	    // Enables or disables column filtering in the Excel file. Not to be mistaken with the grid filtering feature.
	    gridOptions.excel.filterable = !!scope.filterable; // eslint-disable-line no-implicit-coercion
	    // proxyURL: 'http://demos.telerik.com/kendo-ui/service/export';
	
	    // added watch on attrs
	    scope.$parent.$watch(attrs.fisExcelAllPages, function (newVal, oldVal) {
	      // reinitialize grid
	      if (newVal !== oldVal) {
	        // prevent continuous reinitializing grid
	        scope.$broadcast('fisReinit'); // trigger watch to reinitialize grid
	      }
	    });
	  }
	
	  /**
	   * @name toggleHiddenColums
	   * @param indexes- indexes of hidden columns
	   * @param hide - hide or show coluum
	   * @param e -event
	   */
	  function toggleHiddenColums(indexes, hide, e) {
	    if (hide) {
	      for (var i = 0; i < indexes.length; i++) {
	        // eslint-disable-line block-scoped-var
	        e.sender.hideColumn(indexes[i]); // eslint-disable-line block-scoped-var
	      }
	    } else {
	      for (var i = 0; i < indexes.length; i++) {
	        // eslint-disable-line block-scoped-var, no-redeclare
	        e.sender.showColumn(indexes[i]); // eslint-disable-line block-scoped-var
	      }
	    }
	  }
	
	  /**
	   * @name getHiddenColumns
	   * @param columns
	   */
	  function getHiddenColumns(columns) {
	    var indexes = [];
	    for (var i = 0; i < columns.length; i++) {
	      if (columns[i].hidden === 'true' || columns[i].hidden === true) {
	        indexes.push(i);
	      }
	    }
	    return indexes;
	  }
	
	  /**
	   * @name setGridPDFExportOptions
	   * @param scope
	   * @param gridOptions
	   * @param attrs
	   * @param kendoGrid
	   *
	   * @description Builds a JSON criteria object for the grid's filter.
	   */
	  function setGridPDFExportOptions(scope, gridOptions, attrs, kendoGrid) {
	    var gridName = fisGridUtilService.getGridName(attrs, scope, kendoGrid);
	    gridOptions.pdf = {};
	    setExportFileNameOption(scope, gridOptions, gridName, 'pdf', '.pdf');
	
	    if (!scope.pdfAllPages) {
	      // eslint-disable-line no-negated-condition
	      gridOptions.pdf.allPages = false;
	    } else {
	      gridOptions.pdf.allPages = scope.pdfAllPages;
	    }
	
	    var exportFlag = false;
	    gridOptions.pdfExport = function (e) {
	      if (scope.exportHiddenColumns === true || scope.exportHiddenColumns === 'true') {
	        var indexes = getHiddenColumns(scope.columns);
	        if (!exportFlag) {
	          // eslint-disable-line no-negated-condition
	          toggleHiddenColums(indexes, false, e);
	          e.preventDefault();
	          exportFlag = true;
	          setTimeout(function () {
	            e.sender.saveAsPDF();
	          });
	        } else {
	          e.promise.done(function () {
	            toggleHiddenColums(indexes, true, e);
	            exportFlag = false;
	          });
	        }
	      }
	    };
	
	    // added watch on attrs
	    scope.$parent.$watch(attrs.fisPdfAllPages, function (newVal, oldVal) {
	      // reinitialize grid
	      if (newVal !== oldVal) {
	        // prevent continuous reinitializing grid
	        scope.$broadcast('fisReinit'); // trigger watch to reinitialize grid
	      }
	    });
	  }
	
	  /*
	   * This function runs through all of a tables filter objects, and resizes each
	   * @param {type} table
	   */
	  function applyElementResizeToTable(table) {
	    if (!_.isUndefined(table)) {
	      var elementsToResize = table.find('.fis-grid-filter-cell');
	      for (var i = 0; i < elementsToResize.length; i++) {
	        var elem = elementsToResize.eq(i);
	        if (elem.css('display') !== 'none') {
	          applyElementSize(elem, elem.outerWidth());
	        }
	      }
	    }
	  }
	
	  /*
	   * This function is meant to generically apply the parent size to widgets and inputs.
	   * Ideally they should all have an api exposed, so all this would do is call their api function.
	   * @param json element
	   * @param integer currentSize
	   */
	  function applyElementSize(element, currentSize) {
	    // now calculate the input width: remove 20px for the filter icon
	    var inputWidth = currentSize - 20;
	    // now, check if the cell width is too small and enforce a minimum width of 80px
	    if (inputWidth < 50) {
	      inputWidth = 50;
	    }
	
	    var autoCompleteWidget = element.find('.k-autocomplete');
	    // now check for widgets, and size appropriately
	    if (autoCompleteWidget.length > 0) {
	      // we need to remove the k-header, we use it on the th tag instead
	      autoCompleteWidget.removeClass('k-header');
	      var autoCompleteScope = autoCompleteWidget.scope();
	      var modifier = -15; // eslint-disable-line block-scoped-var
	      if (!_.isUndefined(autoCompleteScope)) {
	        autoCompleteScope.resize(inputWidth + modifier); // eslint-disable-line block-scoped-var
	      }
	    } else {
	      var widgetElement = element.find('span.k-widget');
	      // we need to remove the k-header, we use it on the th tag instead
	      widgetElement.removeClass('k-header');
	      if (widgetElement.length > 0) {
	        // is this a widget?
	        var modifier = 0; // eslint-disable-line block-scoped-var, no-redeclare
	        var isNumericTextBox = widgetElement.hasClass('k-numerictextbox');
	        if (isNumericTextBox) {
	          modifier = 3; // eslint-disable-line block-scoped-var
	          // eslint-disable-next-line block-scoped-var
	          widgetElement.find('.k-numeric-wrap').css('width', inputWidth + modifier); // number spinner
	          widgetElement.find('input').css('width', inputWidth + modifier); // eslint-disable-line block-scoped-var
	        } else {
	          var isComboBoxWidget = widgetElement.hasClass('k-combobox'); // combobox
	          if (isComboBoxWidget) {
	            // order is critical here, both combo box and k-dropdown uses k-dropdown class
	            modifier = -16; // eslint-disable-line block-scoped-var
	            // widgetElement.find('.k-dropdown-wrap').css('width', inputWidth+modifier);
	            // widgetElement.find('input').css('width', inputWidth+modifier);
	            var comboScope = widgetElement.scope();
	            if (!_.isUndefined(comboScope)) {
	              comboScope.resize(inputWidth + modifier); // eslint-disable-line block-scoped-var
	            }
	          } else {
	            var isDropDownWidget = widgetElement.hasClass('k-dropdown'); // dropdown
	            if (isDropDownWidget) {
	              modifier = 0; // eslint-disable-line block-scoped-var
	              // widgetElement.find('.k-dropdown-wrap').css('width', inputWidth+modifier);
	              var dropScope = widgetElement.scope();
	              if (!_.isUndefined(dropScope)) {
	                dropScope.resize(inputWidth + modifier); // eslint-disable-line block-scoped-var
	              }
	            } else {
	              var isDatePickerWidget = widgetElement.hasClass('k-datepicker'); // datepicker
	              if (isDatePickerWidget) {
	                modifier = 3; // eslint-disable-line block-scoped-var
	                var datePickerScope = widgetElement.scope();
	                if (!_.isUndefined(datePickerScope)) {
	                  datePickerScope.resize(inputWidth + modifier); // eslint-disable-line block-scoped-var
	                }
	              }
	            }
	          }
	        }
	        widgetElement.css('width', inputWidth + modifier); // eslint-disable-line block-scoped-var
	      } else {
	        // it's not a widget, it's a normal input
	        var nestedInput = element.find('input');
	        var modifier = -16; // eslint-disable-line block-scoped-var, no-redeclare
	        if (nestedInput.length > 0) {
	          nestedInput.css('width', inputWidth + modifier); // eslint-disable-line block-scoped-var
	        } else {
	          // it is the input
	          element.css('width', inputWidth + modifier); // eslint-disable-line block-scoped-var
	        }
	      }
	    }
	  }
	
	  // This function is used to take the user configuration( both app level and individual grid level) for showing checkboxes for multi-row selectable grids
	  // If user has specified the individual grid level configuration( using fis-no-checkbox attribute) then that value will override the app level configuration for that particular grid
	  function showNoCheckboxesForMultiSelection(scope, attrs) {
	    var showCheckbox = false;
	    if (!_.isUndefined(attrs.fisNoCheckbox)) {
	      showCheckbox = attrs.fisNoCheckbox;
	    } else if (!_.isUndefined(scope.gridConfig.showNoCheckbox)) {
	      showCheckbox = scope.gridConfig.showNoCheckbox;
	    }
	    return showCheckbox;
	  }
	
	  function addSelectedIndexOnSelectionObj(scope, kendoGrid, rowElem) {
	    if (rowElem) {
	      scope.selection.indexOnPage = angular.element(kendoGrid.items()).index(rowElem);
	    }
	    if (!kendoGrid.dataSource.page() || kendoGrid.dataSource.page() == 1) {
	      // eslint-disable-line eqeqeq
	      scope.selection.indexInGrid = scope.selection.indexOnPage;
	    } else {
	      scope.selection.indexInGrid = (kendoGrid.dataSource.page() - 1) * kendoGrid.dataSource.pageSize() + scope.selection.indexOnPage;
	    }
	  }
	
	  return {
	    restrict: 'AE',
	    scope: {
	      sortable: '@fisSortable',
	      sort: '@fisSort',
	      filterable: '@fisFilterable',
	      columnMenu: '<fisColumnMenu',
	      pageSize: '<fisPageSize',
	      pageSizes: '@fisPageSizes',
	      scrollable: '@fisScrollable',
	      mode: '@fisMode',
	      selectable: '@fisSelectable',
	      selectableCriteria: '@fisSelectableCriteria',
	      rowId: '@fisRowId',
	      editable: '@fisEditable',
	      onSelect: '&fisOnSelect',
	      pagerPosition: '@fisPagerPosition',
	      detailGridRefresh: '<?fisDetailGridRefresh',
	      onEditFn: '&fisOnEdit',
	      onSaveFn: '&fisOnSave',
	      onCancelFn: '&fisOnCancel',
	      onSaveChangesFn: '&fisOnSaveChanges',
	      onPaginationFn: '&fisOnPagination',
	      onSortingFn: '&fisOnSorting',
	      onFilteringFn: '&fisOnFiltering',
	      onColumnShowFn: '&fisOnColumnShow',
	      onColumnHideFn: '&fisOnColumnHide',
	      keepPageOnRefresh: '@fisKeepPageOnRefresh',
	      createSuccessFn: '&fisDataCreateSuccess',
	      createFailFn: '&fisDataCreateFail',
	      updateSuccessFn: '&fisDataUpdateSuccess',
	      updateFailFn: '&fisDataUpdateFail',
	      deleteSuccessFn: '&fisDataDeleteSuccess',
	      deleteFailFn: '&fisDataDeleteFail',
	      filters: '<fisFilters',
	      liveFiltering: '<fisLiveFiltering',
	      uniqueIdSeed: '@fisUniqueIdSeed',
	      onErrorFn: '&fisOnError',
	      liveFilteringApplyButton: '<fisLiveFilteringApplyButton',
	      deselectCell: '<fisDeselectCell',
	      excelAllPages: '<fisExcelAllPages',
	      pdfAllPages: '<fisPdfAllPages',
	      exportFileName: '@fisExportFileName',
	      group: '<fisGroup',
	      exportHiddenColumns: '<fisExportHiddenColumns',
	      rowAttributes: '<?fisRowAttributes'
	    },
	    require: ['fisData', '?fisRefresh', '?fisReinit', '?^form'],
	    replace: true,
	    // eslint-disable-next-line no-multi-str
	    template: '<div class="fis-grid">\
	                  <div class="fis-grid-pager-bar">\
	                      <div></div>\
	                  </div>\
	                  <div></div>\
	              </div>',
	    link: function link(scope, elm, attrs, ctrls) {
	      var gridElem;
	      var gridOptions;
	      var dataSourceOptions;
	      var dataSource;
	      var kendoGrid;
	      var kendoPager;
	      var cssDirectiveStyles;
	      var promiseObj = processColumnsAttr(scope, attrs);
	      var previousGridData;
	
	      scope.liveFilterExists = false; // Used to see if liveFilter already created #3486
	
	      var fisData = ctrls[0];
	      var fisRefresh = ctrls[1];
	      var fisReinit = ctrls[2];
	      scope.formCtrl = ctrls[3];
	      var odataV3Adaptor = attrs.fisAdaptor === 'odatav3' || fisConfig.dataSourceAdaptor === 'odatav3';
	      var viewWindow = angular.element($window); // eslint-disable-line no-unused-vars
	
	      // read context menu info, set the context menu filter (grid, column, or row), and hide the context menu
	      var contextMenuElem;
	      if (attrs.fisContextMenu !== undefined) {
	        contextMenuElem = elm.parents().find('div[fis-name="' + attrs.fisContextMenu + '"]');
	        contextMenuElem.hide();
	      }
	
	      // Read configuration
	
	      scope.gridConfig = { showLoadingIndicator: true };
	      if (angular.isDefined(fisConfig.widgets)) {
	        scope.gridConfig = _.extend(scope.gridConfig, fisConfig.widgets.fisGrid);
	      }
	      setupLoadingIndicator(scope.gridConfig.showLoadingIndicator);
	
	      if (scope.selectable === 'multiple') {
	        scope.selection = { rows: [], all: false, id: scope.$id, action: 'deselect' };
	      } else {
	        scope.selectedDataItems = [];
	      }
	      scope.scrollable = scope.scrollable && scope.scrollable === 'true';
	      if (!scope.scrollable) {
	        scope.$parent.pagerPosition = typeof attrs.fisPagerPosition === 'undefined' || attrs.fisPagerPosition === 'undefined' ? 'top' : attrs.fisPagerPosition.toLowerCase();
	      }
	      scope.pageSize = scope.pageSize < 0 ? 0 : scope.pageSize;
	      // Need to keep pageable true even for top pager, therefore retaining original line below. Refer to TODO pager
	      // scope.pageable = !!scope.pageSize && (scope.pagerPosition === 'bottom' || scope.pagerPosition === 'both');
	      scope.pageable = !!scope.pageSize; // eslint-disable-line no-implicit-coercion
	      scope.evaluatedPageSizes = $parse(scope.pageSizes)(scope.$parent);
	
	      scope.liveFilterCriteria = {};
	
	      // get the grid div
	      gridElem = elm.find(':nth-child(2)');
	
	      var gridDataChangeListener = function gridDataChangeListener() {
	        dataSource.read();
	        if (scope.selectable === 'multiple') {
	          clearGridSelection(kendoGrid, scope);
	        }
	      };
	
	      var getCurrentGridMetaData = function getCurrentGridMetaData(value) {
	        var currentGridData = angular.copy(value);
	        delete currentGridData.$promise;
	        delete currentGridData.$resolved;
	        delete currentGridData.data;
	        return currentGridData;
	      };
	
	      var gridBuildSchemaMetadata = function gridBuildSchemaMetadata(value) {
	        var definedSchemaColumns = attrs.fisSchemaColumns;
	        var needsRebuild = false;
	        // Take a decision based on previous and current grid resource data
	        // whether we have to rebuild or refresh the grid for live scrolling
	        var currentGridData = getCurrentGridMetaData(value);
	
	        if (_.isEqual(previousGridData, currentGridData)) {
	          return;
	        }
	        previousGridData = currentGridData;
	
	        if (!_.isUndefined(attrs.fisSchemaColumns) || !_.isUndefined(attrs.fisSchemaColumnsDefault)) {
	          needsRebuild = true;
	          // rebuild the columns
	          if (!_.isUndefined(attrs.fisSchemaColumnsDefault) && _.isUndefined(attrs.fisSchemaColumns)) {
	            definedSchemaColumns = attrs.fisSchemaColumnsDefault;
	          }
	          var schemaColumns = value[definedSchemaColumns];
	          if (scope.liveFiltering && !_.isUndefined(schemaColumns)) {
	            var clearColumn = {
	              headerTemplate: '',
	              template: '',
	              reorderable: false, // this column is not re-orderable
	              width: 30 + (scope.liveFilteringApplyButton === 'true' ? 30 : 0)
	            };
	            schemaColumns.push(clearColumn);
	          }
	          var metadata = getColumns(schemaColumns, attrs, scope);
	          gridOptions.columns = metadata;
	
	          if (_.isUndefined(schemaColumns)) {
	            fisGridUtilService.handleError(scope, 'No default "columns" provided', null, 'fisColumns');
	            return;
	          }
	          transformFilterTemplates(metadata, scope, elm);
	          if (!scope.filterable && _.find(metadata, function (col) {
	            return !!col.filterTemplate; // eslint-disable-line no-implicit-coercion
	          })) {
	            if (scope.liveFiltering !== true) {
	              // do not set filter options if the grid has live filtering
	              setGridFilterOptions(scope, gridOptions, attrs);
	              scope.filterable = 'true';
	            }
	          }
	          if (scope.selectable === 'multiple') {
	            var noCheckboxMultiselect = showNoCheckboxesForMultiSelection(scope, attrs);
	            if ((noCheckboxMultiselect === 'false' || noCheckboxMultiselect === false) && angular.isArray(metadata)) {
	              // width of the checkbox column is set to 40 to avoid occupying unnecessary column space
	              var checkboxColumnBase = {
	                width: 40,
	                reorderable: false, // custom property so we manually avoid changing position of that column
	                headerTemplate: '<input type="checkbox" ng-model="selection.all" class="select-all" fis-unique-id="select-all-checkbox"/>',
	                template: '<input type="checkbox" class="select-row" ng-disabled="isRowSelectDisabled(rowData)" ng-click="selectRow($event, rowData)"/>'
	              };
	              angular.merge(checkboxColumnBase, checkboxColumn);
	              metadata.splice(0, 0, checkboxColumnBase);
	            }
	          }
	
	          if ($useDataTypes === true) {
	            if (!dataSourceOptions.schema) {
	              dataSourceOptions.schema = {};
	            }
	            mergeDataTypesToSchema(dataSourceOptions.schema, gridOptions.columns, scope, gridElem);
	            // add model to reader
	            dataSource.reader.model = kendo.data.Model.define({
	              fields: dataSourceOptions.schema.model.fields
	            });
	            // reinit datasource reader to attach schema due to dataSource already created
	            dataSource.reader.init(dataSourceOptions.schema);
	            // update columns data which is passed in additionalOpts while creating dataSource
	            var additionalOpts = dataSource.options.getAdditionalOptions();
	            if (_.isUndefined(additionalOpts)) {
	              additionalOpts = {};
	            }
	            additionalOpts.columns = gridOptions.columns;
	            dataSource.options.setAdditionalOptions(additionalOpts);
	          }
	          mergeSgSchemaWithColumnSchema(dataSourceOptions.schema, gridOptions.columns);
	          mergeValidatorsToSchema(dataSourceOptions.schema, gridOptions.columns, scope);
	        }
	        // get pageSize from metadata
	        var definedPageSizeSchema = attrs.fisSchemaPageSize ? attrs.fisSchemaPageSize : 'pageSize';
	        var pageSize = value[definedPageSizeSchema];
	        if (pageSize) {
	          needsRebuild = true;
	          dataSource._pageSize = pageSize;
	          dataSource._take = pageSize;
	          scope.pageable = !!pageSize; // eslint-disable-line no-implicit-coercion
	          dataSource._page = 1;
	        }
	
	        // get sort from metadata
	        var definedSortSchema = attrs.fisSchemaSort ? attrs.fisSchemaSort : 'sort';
	        var sort = value[definedSortSchema];
	        if (sort) {
	          needsRebuild = true;
	          dataSource._sort = sort;
	          if (!scope.sortable) {
	            var sortMode = 'single';
	            if (angular.isArray(sort) && sort.length > 1) {
	              sortMode = 'multiple';
	            }
	            gridOptions.sortable = {
	              mode: sortMode,
	              allowUnsort: sortMode === 'multiple'
	            };
	          }
	          var fisSort = $parse(attrs.fisSort);
	          if (fisSort.assign) {
	            // Update the fis-sort assignable expression to the changed value
	            fisSort.assign(scope.$parent, sort);
	          }
	        }
	        // get filter from metadata
	        var definedFilterSchema = attrs.fisSchemaFilters ? attrs.fisSchemaFilters : 'filters';
	        var filter = value[definedFilterSchema];
	        if (filter) {
	          needsRebuild = true;
	          var kendoCrit = {};
	          fisGridUtilService.getGridFilterObject(filter, kendoCrit, attrs);
	          dataSource._filter = kendoCrit;
	          if (!scope.filterable && !scope.liveFiltering) {
	            setGridFilterOptions(scope, gridOptions, attrs);
	          }
	          var fisFilter = $parse(attrs.fisFilters);
	          if (fisFilter.assign) {
	            // Update the fis-filter assignable expression to the changed value
	            fisFilter.assign(scope.$parent, filter);
	          }
	        }
	        // get pageSizes from metadata
	        var definedPageSizesSchema = attrs.fisSchemaPageSizes ? attrs.fisSchemaPageSizes : 'pageSizes';
	        var pageSizes = value[definedPageSizesSchema];
	        if (pageSizes) {
	          needsRebuild = true;
	          scope.evaluatedPageSizes = pageSizes;
	        }
	
	        // get grouping information from metadata
	        var definedGroup = attrs.fisSchemaGroup ? attrs.fisSchemaGroup : 'group';
	        var groups = value[definedGroup];
	        if (groups) {
	          dataSource.group(groups);
	        }
	
	        // get rows attribute from metadata
	        var definedRowAttributesSchema = attrs.fisSchemaRowAttributes ? attrs.fisSchemaRowAttributes : 'rowsAttributes';
	        var rowAttributes = value[definedRowAttributesSchema];
	        if (rowAttributes) {
	          scope.rowAttributes = rowAttributes;
	        }
	
	        if (needsRebuild) {
	          buildGridPhase2(); // eslint-disable-line no-use-before-define
	          kendoGrid.refresh();
	          exposeWidgetAPI(scope, attrs, kendoGrid);
	        }
	      };
	
	      var unregisterDataChangeListener = fisData.addDataChangedListener(gridDataChangeListener);
	      var unregisterSchemaColumnsListener = fisData.addAfterFetchListener(gridBuildSchemaMetadata);
	      // Unregister the listeners on scope destruction
	      scope.$on('$destroy', unregisterSchemaColumnsListener);
	      scope.$on('$destroy', unregisterDataChangeListener);
	
	      scope.isRowSelectable = function (rowData) {
	        if (_.isUndefined(rowData)) {
	          return;
	        }
	        if (_.isUndefined(attrs.fisSelectableCriteria)) {
	          return true;
	        }
	        var selectable = rowData[attrs.fisSelectableCriteria];
	        if (!_.isBoolean(selectable)) {
	          console.warn('Error: ' + attrs.fisSelectableCriteria + ' data field has to be a boolean type');
	        }
	        return selectable;
	      };
	
	      /**
	       * Set the select state of a data row
	       * @param rowData data entry
	       * @param selected whether the data entry should be selected (true) or deselected (false)
	       */
	      scope.setRowSelectionStatus = function (rowData, selected) {
	        var selectCriteria = attrs.fisSelectableCriteria;
	        if (_.isUndefined(rowData[selectCriteria]) || rowData[selectCriteria] == true) {
	          // eslint-disable-line eqeqeq
	          if (selected) {
	            scope.addToRowSelection(rowData);
	            scope.markSelectedFromSelection(rowData);
	            scope.selection.action = 'select';
	          } else {
	            // scope.selection.currentRow=null;        //if nothing is selected, Clearing the object value
	            scope.removeFromRowSelection(rowData);
	            scope.selection.action = 'deselect';
	          }
	        }
	      };
	
	      var previousSelection;
	      scope.selectRow = function (event) {
	        var isChecked = angular.element(event.target).is(':checked');
	        var rowElem = angular.element(event.target).closest('tr');
	        // Only select first header checkbox, so we do not manipulate detail grid header checkboxes
	        var selectCheckbox = kendoGrid.element.find('th .select-all').first();
	        var currentSelectedData = rowElem.scope().rowData;
	        scope.selection.currentRow = currentSelectedData;
	        var currentSelection = dataSource.view().indexOf(scope.selection.currentRow);
	
	        if (event.shiftKey && !_.isUndefined(previousSelection) && previousSelection !== currentSelection) {
	          // Select multiple rows at once
	          var startIndex = previousSelection;
	          var endIndex = currentSelection;
	          if (startIndex > endIndex) {
	            // Some magic for swapping the values if they are in the "wrong" order
	            endIndex = [startIndex, startIndex = endIndex][0];
	          }
	          for (var i = startIndex, j = endIndex; i <= j; i++) {
	            scope.setRowSelectionStatus(dataSource.view()[i], isChecked);
	            setHeaderCheckboxStatus(scope, dataSource, isChecked, selectCheckbox);
	          }
	        } else {
	          // Select one row
	          scope.setRowSelectionStatus(currentSelectedData, isChecked);
	          setHeaderCheckboxStatus(scope, dataSource, isChecked, selectCheckbox);
	        }
	        addSelectedIndexOnSelectionObj(scope, kendoGrid, rowElem);
	        previousSelection = currentSelection;
	        fireChangeCallback(scope);
	      };
	
	      scope.getIdee = function (row) {
	        var idee = 'id';
	        if (!(_.isUndefined(attrs.fisRowId) || attrs.fisRowId === 'undefined')) {
	          idee = attrs.fisRowId;
	        }
	
	        if (_.isUndefined(row[idee]) || row[idee] === null) {
	          fisGridUtilService.handleError(scope, 'Missing row.uid for row selection - have you forgotten to define a row-id?', null, 'fisRowId');
	          return;
	        }
	        return idee;
	      };
	
	      /*
	       If more performance is required for selection and deselection of row
	       */
	      scope.addToRowSelection = function (row) {
	        var idee = scope.getIdee(row);
	        var contained = false;
	        _.each(scope.selection.rows, function (xRow) {
	          if (row[idee] === xRow[idee]) {
	            contained = true;
	          }
	        });
	        if (scope.gridConfig.deselectQuitsSelectAll === false && _.isObject(scope.deselectedRowIds)) {
	          // Remove remembrance that we might explicitly deselected this row before
	          delete scope.deselectedRowIds[row[idee]];
	        }
	        if (!contained) {
	          scope.selection.rows.push(row);
	        }
	      };
	
	      scope.markSelectedFromSelection = function (row) {
	        var idee = scope.getIdee(row);
	        var contained = false;
	        _.each(scope.selection.rows, function (xRow) {
	          if (row[idee] === xRow[idee]) {
	            contained = true;
	          }
	        });
	        if (contained) {
	          var elem = kendoGrid.table.find('tr[data-uid=' + row.uid + ']');
	          // Set styling via kendoGrid
	          kendoGrid.select(elem);
	          // Set checkbox status
	          elem.find('.select-row').prop('checked', true);
	        }
	      };
	
	      /*
	       If more performance is required for selection and deselection of row
	       */
	      scope.removeFromRowSelection = function (row) {
	        var idee = scope.getIdee(row);
	        var found = false;
	        _.each(scope.selection.rows, function (xRow, index) {
	          if (_.isObject(xRow) && row[idee] === xRow[idee]) {
	            scope.selection.rows.splice(index, 1);
	            // Remove Styling and checkbox checkmark
	            var elem = kendoGrid.table.find('tr[data-uid=' + row.uid + ']');
	            elem.removeClass('k-state-selected');
	            elem.find('.select-row').prop('checked', false);
	            found = true;
	          }
	        });
	        if (scope.gridConfig.deselectQuitsSelectAll === false && _.isObject(scope.deselectedRowIds)) {
	          // To keep track of explicitly deselected rows, save their id
	          scope.deselectedRowIds[row[idee]] = true;
	        }
	        if (!found) {
	          // This sometimes happens if we deselect a range of rows with some rows
	          // in between being not selected already
	          console.warn('removeFromRowSelection has not found row: ' + row[idee]);
	        }
	      };
	
	      scope.expandAll = function () {
	        if (!scope.isDetail) {
	          var allRows = kendoGrid.element.find('tr.k-master-row');
	          var angularRows = angular.element(allRows);
	
	          _.each(angularRows, function (row) {
	            kendoGrid.expandRow(row);
	          });
	        }
	      };
	
	      // select or deselect checkbox through API
	      scope.setSelected = function (rowsToSelect, colToSelect, checkBoxState) {
	        var selectionChanged = false;
	        var gridView = kendoGrid.dataSource.view();
	        var index = 0;
	        var selectedIndex = -1;
	        _.each(gridView, function (currentRow) {
	          var fieldValue = currentRow[colToSelect];
	
	          if (!_.isUndefined(fieldValue)) {
	            if (_.contains(rowsToSelect, fieldValue)) {
	              scope.setRowSelectionStatus(currentRow, checkBoxState);
	
	              selectionChanged = true;
	              selectedIndex = index;
	            }
	          }
	          index++;
	        });
	        scope.selection.indexOnPage = selectedIndex;
	        addSelectedIndexOnSelectionObj(scope, kendoGrid, null);
	        if (selectionChanged) {
	          fireChangeCallback(scope);
	        }
	      };
	
	      scope.collapseAll = function () {
	        if (!scope.isDetail) {
	          var allRows = kendoGrid.element.find('tr.k-master-row');
	          var angularRows = angular.element(allRows);
	
	          _.each(angularRows, function (row) {
	            kendoGrid.collapseRow(row);
	          });
	        }
	      };
	
	      // SDHTML-9836  In fis-grid, multiple row selection with incell editing, the edited data is not reflected in selected rows
	      scope.updateSelectionOnEdit = function () {
	        if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	          scope.$apply();
	        }
	      };
	      // temporary marker for select all / select page only
	      scope.isSelectAll = false;
	
	      scope.selectAll = function (event, select) {
	        var isChecked;
	        var selectThisPageOnly = scope.gridConfig.selectThisPage;
	        if (selectThisPageOnly && selectThisPageOnly === true) {
	          // eslint-disable-next-line block-scoped-var
	          var selectAllPages = false; // if select this page provided use that instead
	        } else {
	          // eslint-disable-next-line block-scoped-var, no-redeclare
	          var selectAllPages = true; // default
	        }
	
	        // Only select first header checkbox, so we do not manipulate detail grid header checkboxes
	        var headerSelectCheckbox = kendoGrid.element.find('th .select-all').first();
	        scope.selection.currentRow = null; // No currentRow available when using selectALl
	        scope.selection.indexOnPage = -1;
	        scope.selection.indexInGrid = -1;
	        if (!(event === null)) {
	          // eslint-disable-line no-negated-condition
	          // Header Checkbox used
	          isChecked = headerSelectCheckbox.prop('checked');
	        } else {
	          // we came here from the DropDown Menu
	          if (select === true) {
	            // eslint-disable-line no-lonely-if
	            // "Select all" chosen from DropDown Menu
	            var currentState = headerSelectCheckbox.prop('indeterminate');
	            selectAllPages = true; // eslint-disable-line block-scoped-var
	            isChecked = currentState || !headerSelectCheckbox.prop('checked');
	          } else if (select === false) {
	            // "This page only" chosen from DropDown Menu
	            selectAllPages = false; // eslint-disable-line block-scoped-var
	            isChecked = true;
	          }
	        }
	
	        if (isChecked) {
	          scope.selection.all = selectAllPages; // eslint-disable-line block-scoped-var
	          var selectCriteria = attrs.fisSelectableCriteria;
	
	          // eslint-disable-next-line block-scoped-var, no-negated-condition
	          if (!selectAllPages) {
	            // select only visible rows
	            var visibleRows;
	            if (scope.isDetail || !scope.hasDetail) {
	              visibleRows = kendoGrid.element.find('tr.fis-grid-row');
	            } else {
	              visibleRows = kendoGrid.element.find('tr.k-master-row');
	            }
	            if (scope.gridConfig.thisPageOnlyDeselectsOthers === true) {
	              // Selecting "This page only" should deselect other rows
	              // Do so here by clearing the selection
	              clearGridSelection(kendoGrid, scope);
	            }
	            var angularRows = angular.element(visibleRows); // eslint-disable-line block-scoped-var
	            var selectedAngularRows = []; // eslint-disable-line block-scoped-var
	            _.each(angularRows, function (row) {
	              // eslint-disable-line block-scoped-var
	              var angularElement = angular.element(row);
	              var rData = angularElement.scope().rowData;
	              if (_.isUndefined(rData[selectCriteria]) || rData[selectCriteria] === true) {
	                // scope.selection.rows.push(rData);
	                scope.addToRowSelection(rData);
	                selectedAngularRows.push(angularElement); // eslint-disable-line block-scoped-var
	                $(angularElement.find('.select-row')).prop('checked', true);
	              }
	            });
	            if (selectedAngularRows.length > 0) {
	              // eslint-disable-line block-scoped-var
	              kendoGrid.select(selectedAngularRows); // eslint-disable-line block-scoped-var
	            }
	            headerSelectCheckbox.prop('indeterminate', true); // for partial selection
	          } else {
	            // we want to select all data, so we select it from the datasource
	            var selectableRows = kendoGrid.dataSource.view();
	            if (scope.mode === 'local') {
	              selectableRows = kendoGrid.dataSource.data();
	            }
	            var angularRows = angular.element(selectableRows); // eslint-disable-line block-scoped-var, no-redeclare
	
	            var selectedAngularRows = []; // eslint-disable-line block-scoped-var, no-redeclare
	            var selectedRows = [];
	            _.each(angularRows, function (row) {
	              // eslint-disable-line block-scoped-var
	              if (_.isUndefined(row[selectCriteria]) || row[selectCriteria] == true) {
	                // eslint-disable-line eqeqeq
	                scope.addToRowSelection(row);
	                selectedRows.push(row);
	                var uid = row.uid;
	                var gridrow = kendoGrid.element.find('[data-uid=' + uid + ']');
	                var angularElement = angular.element(gridrow);
	                selectedAngularRows.push(angularElement); // eslint-disable-line block-scoped-var
	                var input = gridrow.find('.select-row');
	                $(input).prop('checked', true);
	                kendoGrid.tbody.children('tr').addClass('k-state-selected');
	              }
	            });
	            kendoGrid.select(selectedAngularRows); // eslint-disable-line block-scoped-var
	
	            if (scope.gridConfig.deselectQuitsSelectAll === false) {
	              // as we enter selectAll state, we do not want to have any deselected rows
	              scope.deselectedRowIds = {};
	            }
	
	            if (!_.isUndefined(attrs.fisRowId)) {
	              // eslint-disable-line no-negated-condition
	              // if fisRowId is provided, retain the previous selection
	              angular.forEach(selectedRows, function (row) {
	                // push only those data items which are not already added in 'rows'
	                var idee = scope.getIdee(row);
	                if (!_.find(scope.selection.rows, function (item) {
	                  return item[idee] === row[idee];
	                })) {
	                  scope.addToRowSelection(row);
	                }
	              });
	            } else {
	              // if fisSchema is not provided, remove the previous selection
	              scope.selection.rows.length = 0;
	              angular.forEach(selectedRows, function (row) {
	                scope.addToRowSelection(row);
	              });
	            }
	            headerSelectCheckbox.prop('indeterminate', false);
	          }
	          if (scope.onSelect) {
	            scope.selection.action = 'select';
	            scope.onSelect({ rows: scope.selection.rows, all: scope.selection.all, currentRow: null, selection: scope.selection, action: scope.action });
	          }
	        } else {
	          scope.selection.all = false;
	          scope.selection.action = 'deselect';
	          // clear selection if the select all checkbox is unchecked
	          clearGridSelection(kendoGrid, scope);
	          scope.onSelect({ rows: null, all: scope.selection.all, currentRow: null, selection: scope.selection, action: scope.action });
	        }
	        scope.isSelectAll = scope.selection.all;
	      };
	
	      scope.scrollGridIfLastTr = function (input) {
	        var tr = input.closest('tr');
	        if (tr.is(':last-child')) {
	          // tr.scrollTop(80);
	          kendoGrid.content.scrollTop(100);
	        }
	      };
	
	      // Hide existing pager
	      function removePager() {
	        var removedPager = gridElem.find('.k-grid-pager');
	        removedPager.remove();
	        removedPager = null;
	      }
	
	      // Returns the resource used for create/update/edit/delete operations
	      function getEditingResource(actionName, batch, functionName) {
	        // ensure actionName's first letter is capital
	        actionName = actionName.charAt(0).toUpperCase() + actionName.slice(1);
	        // Generate attribute property name to get url from directive attribute
	        var url = attrs['fisData' + actionName];
	        if (_.isUndefined(url)) {
	          // If undefined then generate resource url from fis-data for standard REST endpoint
	          url = fisGridUtilService.generateResourceURL(actionName, attrs, dataSource, scope);
	        }
	        // Create the parameters object for the save call
	        fisGridUtilService.generateURLParams(actionName, attrs);
	        var params = fisElementUtils.copyProperties(attrs, 'fisData' + actionName + 'Param');
	
	        var customActions = {};
	        customActions[functionName] = {
	          isArray: batch,
	          method: fisGridUtilService.getCallType(actionName, attrs)
	        };
	        return $resource(url, params, customActions);
	      }
	
	      // Called after the data is fetched to ensure that the current page is still valid
	      var adjustPagerIfNecessary = function adjustPagerIfNecessary(data) {
	        var dataLength = data && data.data ? data.data.length : 0;
	        var currentPage = dataSource.page();
	
	        if (attrs.fisMode === 'local') {
	          // For local mode, all data is returned at once. Here it needs to be checked that the total
	          // amount of data received still allows for the currently visible page to be displayed.
	          // If no data was returned, and we already are on page 1 (first half of the condition),
	          // then we don't request page 1 again. If we didn't do this, we would run into an endless loop.
	          var pageSize = dataSource.pageSize();
	          if (!(dataLength === 0 && currentPage === 1) && (currentPage - 1) * pageSize >= dataLength) {
	            dataSource.page(1);
	          }
	        } else if (dataLength === 0 && currentPage > 1 && data.total > 0) {
	          // For delegate mode we need to check the amount of data received for the current page.
	          // We only re-request the data if the paginator is on any page > 1, otherwise we run into
	          // an endless loop.
	          dataSource.page(1);
	        }
	      };
	
	      function setupLoadingIndicator(enableLoadingIndicator) {
	        if (enableLoadingIndicator) {
	          // Setup loading indicator
	          var unregisterBeforeFetchListen = fisData.addBeforeFetchListener(function () {
	            // console.log('DATA LOADING');
	            if (elm.attr('fis-detail-grid') === '') {
	              kendo.ui.progress(elm.parents('tbody').find('.k-master-row').first(), true);
	            } else {
	              var gridContent = elm.find('.k-grid-content');
	              if (gridContent.length > 0 && !isNaN(parseInt(gridContent[0].style.height, 10))) {
	                // There is a grid content div AND the grid content has a height set (like "156px") as inline style.
	                // It would be "auto" in case of no height specified and "auto" or "" will become NaN when parsing into an integer
	                // 1: Remove possibly existing loading overlays, as kendoUI prevents adding multiple ones to the same element
	                // KendoUI can do the removal for us
	                kendo.ui.progress(elm, false);
	                // 2: Add the loading overlay to the whole grid (which we do for non scrolling grids right away)
	              }
	              kendo.ui.progress(elm, true);
	            }
	          });
	          // Unregister the listener on scope destruction
	          scope.$on('$destroy', unregisterBeforeFetchListen);
	
	          var unregisterAfterFetchListener = fisData.addAfterFetchListener(function () {
	            // console.log('DATA LOAD COMPLETE');
	            if (elm.attr('fis-detail-grid') === '') {
	              kendo.ui.progress(elm.parents('tbody').find('.k-master-row').first(), false);
	            } else {
	              kendo.ui.progress(elm, false);
	            }
	          });
	          // Unregister the listener on scope destruction
	          scope.$on('$destroy', unregisterAfterFetchListener);
	        }
	      }
	
	      /**
	      * Set the grid height to a given value
	      * @param height Height the grid should be set to
	      * @param overall {boolean} true if the overall height should be set. Then top pagination is taken into
	      *                          account as well. Otherwise header, content and optional bottom navigation
	      *                          will have the given height value
	      */
	      function adjustGridHeight(height, overall) {
	        // console.log('>> adjustGridHeight: height-'+height+' overall-'+overall);
	        var content = elm.find('div.k-grid-content');
	        if (!(_.isNaN(height) || _.isUndefined(height))) {
	          // eslint-disable-line no-negated-condition
	          var header = elm.find('div.k-grid-header');
	          var calculatedHeight = Number(height) - header.outerHeight();
	          // console.log('>> adjustGridHeight: calculate the height-'+calculatedHeight);
	          if (!scope.scrollable && (scope.$parent.pagerPosition === 'bottom' || scope.$parent.pagerPosition === 'both')) {
	            var pager = elm.find('div.k-grid-pager');
	            calculatedHeight -= pager.outerHeight();
	            // console.log('>> adjustGridHeight: taking pagination into account-bottom');
	          }
	          if (overall === true) {
	            // Set the overall height, so consider top pagination as well
	            if (!scope.scrollable && (scope.$parent.pagerPosition === 'top' || scope.$parent.pagerPosition === 'both')) {
	              var topPagerHeight = elm.find('.fis-grid-pager-bar').outerHeight();
	              calculatedHeight -= topPagerHeight;
	              // console.log('>> adjustGridHeight: taking pagination into account-top');
	            }
	          }
	          // remove the toolbar height if its present ... SDHTML-12068
	          if (elm.find('.k-grid-toolbar').length > 0) {
	            calculatedHeight -= elm.find('.k-grid-toolbar').outerHeight();
	          }
	          if (calculatedHeight !== 0 && topPagerHeight !== 0) {
	            // eslint-disable-line block-scoped-var
	            content.css('height', calculatedHeight + 'px');
	            fisPubSubService.publish('heightAdjusted', true);
	          }
	          if (scope.fisResizeToParent) {
	            content.css('overflow-y', 'auto');
	          }
	          // console.log('>> adjustGridHeight: set height-'+calculatedHeight);
	          return calculatedHeight;
	        } else {
	          // eslint-disable-line no-else-return
	          content.css('height', 'auto');
	          // console.log('>> adjustGridHeight: setting height to auto');
	          return 'auto';
	        }
	      }
	
	      /*
	      SDHTML-11212
	      This solves the following issue:
	      1. open live filter grid with fis-height
	      2. grid has correct height
	      3. move to any other tab
	      4. return to live filter grid with fis-height tab
	      5. grid now has incorrect height.
	       */
	      fisPubSubService.subscribe('fisTabsBar.tabOpened', function () {
	        if (!_.isNull(elm) && !_.isUndefined(elm) && !_.isUndefined(elm.attr('fis-height'))) {
	          elm.css('height', 'auto');
	        }
	      });
	
	      if (attrs.fisHeight) {
	        // change height of grid if the fisHeight attribute changes
	        var fisHeightWatch = scope.$parent.$watch(attrs.fisHeight, function (newHeight, oldHeight) {
	          if (!_.isEqual(newHeight, oldHeight)) {
	            // console.log('>> Height Watch...');
	            adjustGridHeight(newHeight);
	          }
	        });
	        scope.$on('$destroy', function () {
	          if (fisHeightWatch) {
	            fisHeightWatch(); // unbinds watch
	          }
	        });
	      }
	
	      scope.fisResizeToParent = attrs.fisResizeToParent === 'true';
	      if (scope.fisResizeToParent && _.isUndefined(attrs.fisHeight)) {
	        // Only do resizing to parent if no fisHeight is specified
	        var timeout;
	
	        var setStyleTimeout = function setStyleTimeout(delay) {
	          if (!_.isUndefined(timeout)) {
	            $timeout.cancel(timeout);
	          }
	          timeout = $timeout(function () {
	            if (elm.is(':visible')) {
	              // console.log('>> Resize To Parent...');
	              // Only adjust height on visible grids. We can't do calculations on
	              // invisible ones and would set their height to zero (content rows not visible then)
	              adjustGridHeight(fisGridUtilService.getAvailableHeightInParent(elm), true);
	            }
	          }, delay);
	        };
	
	        var unsub = fisPubSubService.subscribe('shell.sizeChange', function () {
	          setStyleTimeout(0);
	        });
	
	        // Set initial timeout, so on grid construction the height is correct
	        $timeout(function () {
	          setStyleTimeout(0);
	        });
	
	        // Cancel the timeout on destruction
	        scope.$on('$destroy', function () {
	          if (timeout) {
	            $timeout.cancel(timeout);
	          }
	          if (unsub) {
	            unsub();
	          }
	        });
	      }
	
	      scope.addLiveFilter = function () {
	        var liveFilterRows = elm.find('.fis-grid-filter-row').length;
	        if (liveFilterRows === 0) {
	          var livebuildTimeout = $timeout(function () {
	            var liveFilterRows = elm.find('.fis-grid-filter-row').length;
	            if (liveFilterRows === 0) {
	              scope.$parent.getGridAttrs = function () {
	                return attrs;
	              };
	
	              scope.$parent.getGrid = function () {
	                return kendoGrid;
	              };
	
	              scope.$parent.getColumns = function () {
	                if (_.isUndefined(scope.columns)) {
	                  // Please see: SDHTML-12598
	                  // scope.columns = kendoGrid.columns;
	                  var noCheckboxMultiSelect = showNoCheckboxesForMultiSelection(scope, attrs);
	                  if (scope.selectable === 'multiple' && (noCheckboxMultiSelect === 'false' || noCheckboxMultiSelect === false)) {
	                    scope.columns = kendoGrid.columns.slice(1);
	                  } else {
	                    scope.columns = kendoGrid.columns;
	                  }
	                }
	                return scope.columns;
	              };
	
	              scope.$parent.getFilters = function () {
	                return scope.filters;
	              };
	
	              var template = '<fis-live-filter grid-columns="getColumns()" get-kendo-grid="getGrid()" grid-attrs="getGridAttrs()" get-filters="getFilters()" />';
	
	              if (!scope.liveFilterExists) {
	                if (_.isUndefined(kendoGrid)) {
	                  // kendoGrid is sometimes undefined for grids built using fis-schema-columns
	                  scope.$watch(function () {
	                    if (!_.isUndefined(kendoGrid)) {
	                      return true;
	                    }
	                    return false;
	                  }, function (result) {
	                    if (result && !scope.liveFilterExists) {
	                      scope.liveFilterExists = true;
	                      addFilterRowToKendoGrid(template, scope, elm, kendoGrid);
	                      styleFilterRowInKendoGrid(elm, kendoGrid);
	                    }
	                  });
	                } else {
	                  addFilterRowToKendoGrid(template, scope, elm, kendoGrid);
	                  styleFilterRowInKendoGrid(elm, kendoGrid);
	                }
	                var unsub = fisPubSubService.subscribe('shell.condensedToggle', function () {
	                  styleFilterRowInKendoGrid(elm, kendoGrid);
	                });
	                scope.$on('$destroy', unsub);
	                if (elm.is(':visible')) {
	                  // console.log('>> Live Filter build...')
	                  var heightToSet = adjustGridHeight(fisGridUtilService.getAvailableHeightInParent(elm), true); // eslint-disable-line no-unused-vars
	                  // we now have the legitimate height of the content, so we need to tell kendo as well
	                  // kendoGrid.setOptions({
	                  //    'height': heightToSet
	                  // });
	                }
	              }
	            }
	          });
	
	          if (fisMemoryUtilService.enabled) {
	            scope.$on('$destroy', function () {
	              $timeout.cancel(livebuildTimeout); // cancel the timeout when finished
	            });
	          }
	        }
	      };
	
	      function buildGrid() {
	        gridOptions = buildGridOptions(scope, attrs, gridElem);
	        dataSourceOptions = buildDataSourceOptions(scope, attrs, gridOptions, gridElem);
	        if (dataSourceOptions.serverPaging && gridOptions.pageable) {
	          // If the grid is pageable and delegates paging to fisData (that's what serverPaging means),
	          // It needs to receive from fisData only the data for the current page and the total number of rows available.
	          // If the user didn't provide the fis-schema-data and fis-schema-total attributes, force the default.
	          // fisData.fetchData cannot return a simple array in this case; it needs to return an object containing properties
	          // that match the schema.
	          var schema = fisData.getSchema();
	          if (!schema.data) {
	            schema.data = odataV3Adaptor && !$useDataTypes ? 'results' : 'data'; // odataV3Adaptor should only be used with dataSource schema when dataTypes are used.
	          } // This prevents the miss match when normalizing that data.
	          if (!schema.total) {
	            schema.total = odataV3Adaptor && !$useDataTypes ? '__count' : 'total'; // odataV3Adaptor should only be used with dataSource schema when dataTypes are used.
	          } // This prevents the miss match when normalizing that data.
	        }
	        if (gridOptions.editable || $useDataTypes) {
	          // Since the data is normalized in fisData and the fisResourceService
	          // schema metadata for the Datasourcefactory expects the hard-coded 'data' and 'total' values.
	          // see the normalizeData() method in fisData.
	          if (!dataSourceOptions.schema.data) {
	            dataSourceOptions.schema.data = odataV3Adaptor ? 'results' : 'data';
	          }
	          if (!dataSourceOptions.schema.total) {
	            dataSourceOptions.schema.total = odataV3Adaptor ? '__count' : 'total';
	          }
	        }
	
	        if ($useDataTypes === true && !_.isUndefined(attrs.fisColumns)) {
	          mergeDataTypesToSchema(dataSourceOptions.schema, gridOptions.columns, scope, gridElem);
	        }
	        mergeSgSchemaWithColumnSchema(dataSourceOptions.schema, gridOptions.columns);
	        mergeValidatorsToSchema(dataSourceOptions.schema, gridOptions.columns, scope, gridElem);
	
	        if (!_.isUndefined(attrs.fisInitialPage)) {
	          dataSourceOptions.page = parseInt(attrs.fisInitialPage); // eslint-disable-line radix
	          var unregisterAfterDataFetchListener = fisData.addAfterFetchListener(adjustPagerIfNecessary);
	          scope.$on('$destroy', unregisterAfterDataFetchListener);
	        }
	
	        var additionalOpts = {};
	        additionalOpts.columns = scope.columns;
	        if (!_.isUndefined(attrs.fisOnError) && _.isFunction(scope.onErrorFn)) {
	          additionalOpts.errorCb = scope.onErrorFn;
	        }
	        var expectObj = {
	          crit: $filter('convertKendoFiltersToCriteria'),
	          offset: checkOffsetParams,
	          limit: checkLimitParams,
	          sort: odataV3Adaptor ? kendoSortingToSortParamsOdata : kendoSortingToSortParams
	        };
	
	        if (odataV3Adaptor && schema.total) {
	          // eslint-disable-line block-scoped-var
	          expectObj.$inlinecount = function () {
	            return 'allpages';
	          };
	        }
	        dataSource = fisKendoDataSourceFactory.createListDataSource(fisData.fetchData, expectObj, dataSourceOptions, additionalOpts);
	
	        scope.removeActiveCell = function () {
	          var row = elm.find('[id=aria-active-cell]'); // eslint-disable-line no-unused-vars
	        };
	
	        scope.hasDetail = !_.isUndefined(attrs.fisDetailColumns);
	        if (attrs.fisDetailColumns) {
	          processDetailColumnsAttr(scope, attrs);
	
	          scope.detailGridFirstExpandEventFlag = {};
	
	          gridOptions.detailInit = function (e) {
	            var event = { row: e.data, gridId: attrs.fisGrid };
	            fisPubSubService.publish('fisDetailGridInit', event);
	
	            var fisDetailRefresh = ''; // eslint-disable-line no-unused-vars
	            var fisDataTemplate; // undefined if no detailData
	            var queryParam;
	
	            if (!_.isUndefined(scope.detailGridRefresh)) {
	              scope.detailGridRefresh[e.masterRow.scope().$id] = {};
	              scope.detailGridFirstExpandEventFlag[e.masterRow.scope().$id] = true;
	              var gridAttr = attrs.fisDetailGridRefresh + '.' + e.masterRow.scope().$id;
	              fisDetailRefresh = 'fis-refresh="' + gridAttr + '" \n';
	            }
	
	            if (attrs.fisDetailData && attrs.fisDetailIdColumns) {
	              var detailIdCols = $parse(attrs.fisDetailIdColumns)(scope.$parent);
	              for (var i = 0; i < detailIdCols.length; i++) {
	                var name = detailIdCols[i].name;
	                var value = e.data[detailIdCols[i].value];
	
	                // Make sure the parameter is encoded, to avoid issues with
	                // characters that might cause issues, e.g. ':' or '&'
	                value = encodeURIComponent(value);
	
	                if (queryParam) {
	                  queryParam = queryParam + name + '=' + value + '&';
	                } else {
	                  queryParam = name + '=' + value + '&';
	                }
	              }
	            } else {
	              if (e.data[attrs.fisDetailData]) {
	                // eslint-disable-line no-lonely-if
	                if (e.data[attrs.fisDetailData] instanceof kendo.data.ObservableArray) {
	                  /* if it is Observable array, get the original javascript array contents
	                   This is needed because angular.isArray() on object of ObservableArray returns false
	                   and further checks in fisData fails */
	                  fisDataTemplate = e.data[attrs.fisDetailData].toJSON();
	                } else {
	                  fisDataTemplate = e.data[attrs.fisDetailData];
	                }
	                fisDataTemplate = JSON.stringify(fisDataTemplate);
	                if (angular.isDefined(fisDataTemplate)) {
	                  fisDataTemplate = fisDataTemplate.replace(/"/g, '\'');
	                }
	              } else {
	                fisDataTemplate = attrs.fisDetailData;
	              }
	            }
	
	            /* eslint-disable no-useless-concat */
	            var template = ['<div fis-grid fis-detail-grid', queryParam ? ' fis-data=' + '"' + attrs.fisDetailData + '?' + queryParam + '"' : '', fisDataTemplate ? ' fis-data=' + '"' + fisDataTemplate + '"' : '', attrs.fisPagerPosition ? ' fis-pager-position=' + '"' + attrs.fisPagerPosition + '"' : '', attrs.fisDetailPageSize ? ' fis-page-size=' + '"' + attrs.fisDetailPageSize + '"' : '', attrs.fisDetailSelectable ? ' fis-selectable=' + '"' + attrs.fisDetailSelectable + '"' : '', attrs.fisDetailSelectableCriteria ? ' fis-selectable-criteria=' + '"' + attrs.fisDetailSelectableCriteria + '"' : '', attrs.fisDetailRowId ? ' fis-row-id=' + '"' + attrs.fisDetailRowId + '"' : '', attrs.fisDetailOnSelect ? ' fis-on-select=' + '"' + attrs.fisDetailOnSelect + '"' : '', attrs.fisDetailOnPagination ? ' fis-on-pagination=' + '"' + attrs.fisDetailOnPagination + '"' : '', attrs.fisDetailToolbar ? ' fis-toolbar=' + '"' + attrs.fisDetailToolbar + '"' : '', attrs.fisDetailSchema ? ' fis-schema=' + '"' + attrs.fisDetailSchema + '"' : '', attrs.fisDetailEditable ? ' fis-editable=' + '"' + attrs.fisDetailEditable + '"' : '', attrs.fisDetailSort ? ' fis-sort=' + '"' + attrs.fisDetailSort + '"' : '', attrs.fisDetailSortable ? ' fis-sortable=' + '"' + attrs.fisDetailSortable + '"' : '', attrs.fisDetailColumns ? ' fis-columns=' + '"' + attrs.fisDetailColumns + '"' : '', attrs.fisDetailRefresh ? ' fis-refresh=' + '"' + attrs.fisDetailRefresh + '"' : '', attrs.fisDetailRowAttributes ? ' fis-row-attributes=' + '"' + attrs.fisDetailRowAttributes + '"' : '', attrs.fisDetailMode === 'local' ? ' fis-mode="local"' : ' fis-mode="delegate"', '></div>'].join('');
	            /* eslint-enable no-useless-concat */
	
	            // Needs to be compiled with the parent scope - the grid scope is isolated
	            var elemToComp = e.detailCell.append(template);
	            $compile(elemToComp)(scope.$parent);
	          };
	
	          gridOptions.detailExpand = function (e) {
	            var detailGridId = e.masterRow.scope().$id;
	            var event;
	            if (_.isUndefined(attrs.fisDetailGridRefresh)) {
	              event = {
	                detailGridId: detailGridId,
	                refreshAttrName: attrs.fisDetailGridRefresh,
	                firstExpand: scope.detailGridFirstExpandEventFlag[detailGridId]
	              };
	              fisPubSubService.publish('fisDetailGridExpanded', event);
	            } else {
	              if (scope.detailGridFirstExpandEventFlag[detailGridId] === false) {
	                event = {
	                  detailGridId: detailGridId,
	                  refreshAttrName: attrs.fisDetailGridRefresh,
	                  firstExpand: scope.detailGridFirstExpandEventFlag[detailGridId]
	                };
	                fisPubSubService.publish('fisDetailGridExpanded', event);
	              } else {
	                event = {
	                  detailGridId: detailGridId,
	                  refreshAttrName: attrs.fisDetailGridRefresh,
	                  firstExpand: scope.detailGridFirstExpandEventFlag[detailGridId]
	                };
	                fisPubSubService.publish('fisDetailGridExpanded', event);
	
	                scope.detailGridFirstExpandEventFlag[detailGridId] = false;
	              }
	              scope.$apply();
	            }
	          };
	
	          gridOptions.detailCollapse = function (e) {
	            var detailGridId = e.masterRow.scope().$id;
	            var event = {
	              detailGridId: detailGridId,
	              refreshAttrName: attrs.fisDetailGridRefresh
	            };
	            fisPubSubService.publish('fisDetailGridCollapsed', event);
	          };
	        }
	
	        //                    if (!(attrs.fisLiveFiltering === 'true')) {
	        //                        $timeout(function () {
	        //                            if (elm.find('.k-grid-header') !== []) {
	        //                                elm.find('.k-grid-header').wrap('<div class="k-grid-header-container"></div>');
	        //                                var headerContainer = elm.find('.k-grid-header-container');
	        //                                var headers = $(kendoGrid.thead).find('tr')[0];
	        //                                var headerHeight = $(headers).height();
	        //                                headerContainer.append('<div class="k-grid-column-header-underlay"></div>');
	        //                                headerContainer.find('.k-grid-column-header-underlay').height(headerHeight);
	        //                            }
	        //                        });
	        //                    }
	
	        //                    /*
	        //                     * If the attribute fis-live-filtering is present then create an
	        //                     * always visible filter row with inputs containing
	        //                     * the values used to filter the grid.
	        //                     */
	        //                    if (attrs.fisLiveFiltering && attrs.fisLiveFiltering === 'true') {
	        //                        scope.addLiveFilter();
	        //                    }
	
	        if (attrs.fisLiveFiltering && attrs.fisLiveFiltering === 'true') {
	          //                         add another column to the gridOptions.columns to let kendo do the adding of the empty cells for live filtering clear/apply buttons.
	          //
	          //                         Note that there is no gridOptions object for grid with fis-schema-columns, hence the if check. These grids add the clear column
	          //                         directly to the schemaColumns var in x() instead.
	          //                         */
	          if (!_.isUndefined(gridOptions.columns)) {
	            gridOptions.columns.push({
	              headerTemplate: '',
	              template: '',
	              reorderable: false, // custom property so we manually avoid changing position of that column
	              width: 30 + (attrs.fisLiveFilteringApplyButton === 'true' ? 30 : 0)
	            });
	          }
	        }
	
	        // Attach datasource options for create, delete & update
	        var createOpts = {};
	        var updateOpts = {};
	        var deleteOpts = {};
	
	        var batch = false;
	
	        if (!_.isUndefined(attrs.fisBatch) && attrs.fisBatch === 'true') {
	          batch = true;
	        }
	
	        var gridSuccessCallback = function gridSuccessCallback(response, batch, successCallback) {
	          successCallback({ data: response, status: response.status });
	        };
	
	        var gridFailCallback = function gridFailCallback(response, failCallback, cancelGridChanges) {
	          var editRows = gridElem.find('tr.k-grid-edit-row');
	
	          if (editRows.length === 0) {
	            // Must be batch editing on incell editing mode, so search for dirty rows
	            editRows = gridElem.find('td.k-dirty-cell').closest('tr');
	          }
	
	          markRowsAsFaulty(editRows);
	
	          if (cancelGridChanges) {
	            var grid = gridElem.data('kendoGrid');
	
	            grid.cancelChanges();
	          }
	
	          if (failCallback) {
	            var data = { responseText: response.data };
	
	            failCallback({ data: data, status: 'error' });
	          }
	        };
	
	        var prepareForCreation = function prepareForCreation(data) {
	          _.each(dataSource.options.schema.model.fields, function (value, key) {
	            if (!_.isUndefined(value.editable) && value.editable === false) {
	              delete data[key];
	            }
	          });
	        };
	
	        // The purpose of this function is to ensure that the operation is always done in an apply phase
	        // If there is already an apply or digest going on, the next operation will be called directly.
	        var completeOperation = function completeOperation(resource, actionName, operation, batch, options, successFn, failFn, cancelOnFail) {
	          if (scope.$$phase || scope.$root.$$phase) {
	            // eslint-disable-next-line no-use-before-define
	            completeSingelOrMultipleOperation(resource, actionName, operation, batch, options, successFn, failFn, cancelOnFail);
	          } else {
	            // Need to wrap this in a scope.$apply since otherwise the call to $resource would only be made in the next
	            // digest cycle
	            scope.$apply(function () {
	              // eslint-disable-next-line no-use-before-define
	              completeSingelOrMultipleOperation(resource, actionName, operation, batch, options, successFn, failFn, cancelOnFail);
	            });
	          }
	        };
	
	        // Ensures that the correct data coming from kendo is used when doing editing operations in batch or single mode
	        var completeSingelOrMultipleOperation = function completeSingelOrMultipleOperation(resource, actionName, operation, batch, options, successFn, failFn, cancelOnFail) {
	          if (batch) {
	            // eslint-disable-next-line no-use-before-define
	            doOperation(resource, actionName, operation, options.data.models, options, successFn, failFn, cancelOnFail);
	          } else {
	            // eslint-disable-next-line no-use-before-define
	            doOperation(resource, actionName, operation, options.data, options, successFn, failFn, cancelOnFail);
	          }
	        };
	
	        var cleanupResource = function cleanupResource(resource) {
	          // angular 1.3 promises make a circular reference and when kendo translates a resource object to its
	          // Observable object, it goes into an infinite loop eventually busting the call stack.
	          // We therefore return the "pure" data object instead of the tainted Resource instance.
	          delete resource.$promise;
	          delete resource.$resolved;
	        };
	
	        var cleanupResponseForKendo = function cleanupResponseForKendo(response) {
	          if (angular.isArray(response)) {
	            response.forEach(function (resource) {
	              cleanupResource(resource);
	            });
	          } else {
	            cleanupResource(response);
	          }
	        };
	
	        var removeExtraFieldsFromPayload = function removeExtraFieldsFromPayload(data) {
	          if (data) {
	            if (angular.isArray(data)) {
	              // batch editing
	              angular.forEach(data, function (rowObj) {
	                if (rowObj) {
	                  delete rowObj._dirtyFields;
	                }
	              });
	            } else {
	              delete data._dirtyFields;
	            }
	          }
	        };
	        // Invokes the corresponding operation on the resource provided.
	        var doOperation = function doOperation(resource, actionName, operation, data, options, successFn, failFn, cancelOnFail) {
	          if (attrs.ngModel) {
	            gridSuccessCallback(data, batch, successFn);
	            options.success({ data: data });
	          } else {
	            var _resource = resource[operation];
	            var request;
	            if (fisGridUtilService.getCallType(actionName, attrs) === 'DELETE') {
	              // If we use DELETE calltype, we need to pass the data as second argument to the _resozrce object
	              // Otherwise the argument treatment in angular-resource will consider it as parameters for DELETE requests
	              // as DELETE requests do not have a request body
	              // By doing this potential "@something" placeholders in custom parameters will be replaced
	              request = _resource({}, data);
	            } else {
	              // In grid editing, while updating the record, grid sends extra param '_dirtyFields'  in payload which throws
	              // internal errors (500) on server side, so removing the extra param before server call.
	              removeExtraFieldsFromPayload(data);
	              request = _resource(data);
	            }
	            request.$promise.then(function (response) {
	              cleanupResponseForKendo(response);
	              gridSuccessCallback(response, batch, successFn);
	              if (response) {
	                var responseData = {};
	                if (response.data) {
	                  responseData = response;
	                } else {
	                  responseData.data = response;
	                }
	                options.success(responseData);
	              } else {
	                options.success();
	              }
	            }, function (response) {
	              gridFailCallback(response, failFn, cancelOnFail);
	              options.error(response);
	            });
	          }
	        };
	
	        createOpts = function createOpts(options) {
	          if (!_.isUndefined(options.data)) {
	            if (batch) {
	              _.each(options.data.models, function (data) {
	                prepareForCreation(data);
	              });
	            } else {
	              prepareForCreation(options.data);
	            }
	          }
	
	          var createResource = getEditingResource('Create', batch, 'save');
	          completeOperation(createResource, 'Create', 'save', batch, options, scope.createSuccessFn, scope.createFailFn, false);
	        };
	
	        updateOpts = function updateOpts(options) {
	          var updateResource = getEditingResource('Update', batch, 'save');
	          completeOperation(updateResource, 'Update', 'save', batch, options, scope.updateSuccessFn, scope.updateFailFn, false);
	        };
	
	        deleteOpts = function deleteOpts(options) {
	          var deleteResource = getEditingResource('Delete', batch, 'delete');
	          completeOperation(deleteResource, 'Delete', 'delete', batch, options, scope.deleteSuccessFn, scope.deleteFailFn, true);
	        };
	
	        dataSource.transport.create = createOpts;
	        dataSource.transport.update = updateOpts;
	        dataSource.transport.destroy = deleteOpts;
	
	        readDataSourceAndBuildGrid();
	        scope.gridLoaded = true;
	      }
	
	      /**
	       * Add the DOM filter row to the DOM kendoGrid.
	       * @param template - the filter row
	       * @param scope
	       * @param elm
	       * @param kendoGrid
	       */
	      function addFilterRowToKendoGrid(template, scope, elm, kendoGrid) {
	        kendoGrid.thead.append($compile(template)(scope.$parent));
	        // elm.find('.k-grid-header').wrap('<div class="k-grid-header-container"></div>');
	      }
	
	      function styleFilterRowInKendoGrid(elm, kendoGrid) {
	        var headerContainer = elm.find('.k-grid-header'); // no longer k-grid-header-container
	        var headers = $(kendoGrid.thead).find('tr')[0];
	        var headerHeight = parseFloat($(headers).height());
	        var filters = $(kendoGrid.thead).find('tr')[1];
	        var filtersHeight = parseFloat($(filters).height());
	
	        $(filters).addClass('k-filter-row');
	        var currentUnderLays = headerContainer.find('[class$="-underlay"]');
	
	        if (currentUnderLays.length !== 2) {
	          currentUnderLays.remove();
	          headerContainer.append('<div class="k-grid-column-header-underlay"></div>');
	          headerContainer.append('<div class="k-grid-column-filter-underlay"></div>');
	        }
	
	        headerContainer.find('.k-grid-column-header-underlay').height(headerHeight);
	        headerContainer.find('.k-grid-column-filter-underlay').height(filtersHeight).css('top', headerHeight);
	        $(filters).find('td').css('text-overflow', 'inherit'); // SDHTML-6679
	      }
	
	      function readDataSourceAndBuildGrid() {
	        if (!_.isUndefined(attrs.fisSchemaColumns) || !_.isUndefined(attrs.fisSchemaColumnsDefault)) {
	          dataSource.read();
	        } else {
	          buildGridPhase2(); // eslint-disable-line no-use-before-define
	          exposeWidgetAPI(scope, attrs, kendoGrid);
	        }
	        // Move cssDirective added styles to the gridElem.
	        var stylesTimeout = $timeout(function () {
	          cssDirectiveStyles = elm.attr('style');
	          if (cssDirectiveStyles) {
	            gridElem.attr('style', cssDirectiveStyles);
	            elm.attr('style', '');
	          }
	          var content = elm.find('div.k-grid-content');
	          // If grid is not scrollable and (fisHeight is not provided and fisResizeToParent is not provided),
	          // no need to show the vertical scrollbar (which kendogrid renders by default)
	          if (!scope.scrollable && !attrs.fisHeight && attrs.fisResizeToParent !== 'true') {
	            content.addClass('fis-overflow-y-hidden');
	          }
	          if (_.isUndefined(attrs.fisHeight) && attrs.fisResizeToParent !== 'true') {
	            var headerContainer = elm.find('.k-grid-header');
	            headerContainer.css('padding-right', '0px');
	          }
	          elm.find('.k-grid-header table').css('maxWidth', '8000px');
	          elm.find('.k-grid-content table').css('maxWidth', '8000px');
	          // bugfix/SDHTML-15150-white-space-live-filtering
	          // remove white space
	          var headerGridContainer = elm.find('.k-grid-header');
	          headerGridContainer.css('padding-right', '0px');
	          if (attrs.fisResizeToParent !== 'true') {
	            // console.log('>> Resize To Parent - read datasource...');
	            adjustGridHeight(attrs.fisHeight);
	          }
	          if (attrs.fisScrollable == 'true' && kendoGrid.dataSource.data() && kendoGrid.dataSource.data().length == 0) {
	            // eslint-disable-line eqeqeq
	            content.css('padding-right', '0px');
	            var expander = gridElem.find('.k-grid-content-expander');
	            if (parseFloat(expander.width()) <= content.width()) {
	              expander.removeClass('k-grid-content-expander');
	            }
	          }
	        }, 0);
	
	        scope.$on('$destroy', function () {
	          if (stylesTimeout) {
	            $timeout.cancel(stylesTimeout);
	          }
	        });
	      }
	
	      var buildGridPhase2 = function buildGridPhase2() {
	        // gridOptions = gOptions;
	        gridOptions.dataSource = dataSource;
	
	        if (kendoGrid) {
	          kendoGrid.destroy();
	        }
	        scope.liveFilterExists = false;
	        if (kendoPager) {
	          kendoPager.destroy();
	        }
	
	        var toolbarScope;
	
	        var unregisterAfterDataFetchListener = fisData.addAfterFetchListener(adjustPagerIfNecessary);
	        scope.$on('$destroy', unregisterAfterDataFetchListener);
	
	        // Need to call "empty()" when recreating a grid - see here:
	        // http://www.kendoui.com/forums/mvc/grid/recreate-the-grid-on-demand.aspx
	        gridElem.empty().kendoGrid(gridOptions);
	
	        scope.$on('$destroy', function () {
	          if (toolbarScope) {
	            toolbarScope.$destroy();
	            toolbarScope = null;
	          }
	        });
	
	        // Add pager if pagerPosition === top || pagerPosition === 'both'
	        if (!scope.scrollable && scope.pageable && (scope.$parent.pagerPosition === 'top' || scope.$parent.pagerPosition === 'both')) {
	          // get the pager div and create kendoPager widget
	          // var pagerElement = elm.children().first().children().first();
	          var pagerElement = elm.find('.fis-grid-pager-bar').children().first();
	          /*
	           SDHTML-13141 - sgGrid - Multiple rest calls on pagination after sg-reinit
	           The kendo pager element is getting created for every reinit.
	           Need to remove the kendo pager element before recreating.
	          */
	          pagerElement.remove();
	
	          scope.getDataSource = function () {
	            return dataSource;
	          };
	          scope.setKendoPager = function (kendoPager) {
	            scope.kendoPager = kendoPager;
	          };
	
	          for (var attr in attrs) {
	            if (attr.substring(0, 6) === 'kPager') {
	              pagerElement.attr(attr, attrs[attr]);
	            }
	          }
	
	          // recreating the pager element and replacing the existing element creates a problem
	          // when the grid with fis-page-sizes is refreshed or reloaded
	          pagerElement.attr('fis-pager', '');
	          pagerElement.attr('fis-pager-prev-page', 'pagerPrevPage');
	          pagerElement.attr('kendoPager', 'kendoPager');
	          pagerElement.attr('fis-on-pagination-fn', 'onPaginationFn');
	          pagerElement.attr('fis-data-source', 'getDataSource');
	          pagerElement.attr('fis-pager-evaluated-page-sizes', 'evaluatedPageSizes');
	          $compile(pagerElement)(scope);
	          /*
	          append the kendo pager element to .fis-grid-pager-bar
	          <div class="fis-grid-pager-bar">
	           <div fis-pager="" fis-pager-prev-page="pagerPrevPage" ..../>
	          </div>
	          */
	          var pagerInfoSpanElement = pagerElement.find('.k-pager-info');
	
	          if (!angular.isUndefined(pagerElement) && angular.isFunction(pagerElement[0].removeChild) && !angular.isUndefined(pagerInfoSpanElement) && pagerInfoSpanElement.length > 0) {
	            pagerElement[0].removeChild(pagerInfoSpanElement[0]);
	            pagerElement[0].appendChild(pagerInfoSpanElement[0]);
	          }
	          elm.find('.fis-grid-pager-bar')[0].appendChild(pagerElement[0]);
	
	          // TODO pager: Investigate why grid doesn't display data if pageable is set to false for top pager
	          // Hide the existing pager if pagerPosition === top
	          if (scope.$parent.pagerPosition === 'top') {
	            removePager();
	          }
	        }
	        // Hide the existing pager if live scrolling feature enabled
	        if (scope.scrollable) {
	          removePager();
	        }
	        kendoGrid = gridElem.data('kendoGrid');
	
	        // TODO remove this when angular-kendo is used
	        if (attrs.fisToolbar) {
	          // toolbar is compiled against parent scope so that callback methods are executed on user's scope
	          // this is similar to rows getting compiled to parent scope
	          var pagerElem = elm.find('div[data-role="pager"]');
	          var toolbarLoc = attrs.fisToolbarLocation;
	          // remove the toolbar if already present (this is required in case the grid is reinitialized using fisReinit)
	          var toolbarToRemove;
	          if (toolbarLoc === 'bottom') {
	            toolbarToRemove = elm.children('.k-grid-toolbar');
	          } else {
	            toolbarToRemove = elm.find('.fis-grid-pager-bar').find('.k-grid-toolbar');
	          }
	          toolbarToRemove.remove();
	
	          // Use the parent scope, but create a new scope inherited from the parent.
	          // This is required to give each toolbar on the same page its own scope, otherwise
	          // all toolbars on the same page would share the same scope and the same selection object.
	          var newParentScope = scope.$parent.$new();
	          var toolbar = $compile(elm.find('.k-grid-toolbar'))(newParentScope);
	          // Store the new scope so we can later destroy it
	          toolbarScope = toolbar.scope();
	          if (scope.selectable === 'multiple') {
	            // add selection object so that it can be passed to the callback functions
	            toolbarScope.selection = scope.selection;
	          }
	
	          toolbar.find('.k-button').each(function (index, currentElement) {
	            fisUniqueIdService.generateIdWithStaticSeed(scope, angular.element(currentElement), attrs, null, null, 'grid_toolbar_btn_' + index);
	          });
	          // Position the toolbar as specified by the user
	          toolbar.children().css('margin-right', '1em');
	          if (toolbarLoc === 'bottom') {
	            if (pagerElem.length > 0 && !angular.isUndefined(scope.pagerPosition) && scope.pagerPosition !== 'top') {
	              if (pagerElem.length === 1) {
	                angular.element(pagerElem[0]).append(toolbar);
	              } else {
	                angular.element(pagerElem[1]).append(toolbar);
	              }
	            } else {
	              elm.append(toolbar);
	            }
	          } else {
	            if (pagerElem.length > 0 && scope.pagerPosition !== 'bottom') {
	              // eslint-disable-line no-lonely-if
	              $(pagerElem[0]).parent().append(toolbar);
	            } else if (scope.pagerPosition === 'bottom' || angular.isUndefined(kendoGrid.dataSource.pageSize())) {
	              elm.find('.fis-grid-pager-bar').append(toolbar);
	            }
	          }
	          var tbClass = attrs.fisToolbarClass;
	          if (tbClass) {
	            toolbar.addClass(tbClass);
	          }
	
	          if (fisMemoryUtilService.enabled) {
	            scope.$on('$destroy', function () {
	              if (toolbarScope) {
	                if (toolbarScope.selection) {
	                  delete toolbarScope.selection;
	                }
	                fisMemoryUtilService.callCleanAll(toolbar);
	                toolbar = null;
	              }
	            });
	          }
	        }
	        // this code makes sure that when the toolbar has been added , but the data is still loading
	        // the toolbar's save and cancel changes button are disabled
	        if (attrs.fisBatch || attrs.fisEditable === 'inline' || attrs.fisEditable === 'incell') {
	          setSaveCancelStatus(kendoGrid);
	        }
	
	        if (attrs.fisCriteria) {
	          var criteriaWatch = scope.$parent.$watch(attrs.fisCriteria, function (newCriteria, oldCriteria) {
	            if (!_.isEqual(newCriteria, oldCriteria)) {
	              refresh(); // eslint-disable-line no-use-before-define
	            }
	          });
	        }
	
	        scope.$on('$destroy', function () {
	          if (criteriaWatch) {
	            // eslint-disable-line block-scoped-var
	            // eslint-disable-next-line block-scoped-var
	            criteriaWatch(); // unbinds watch
	          }
	        });
	
	        /*
	         If there is a change to the values of fisFilters (the attrs that allows you to pre-set
	         values for the filter) then pass those changes to a function that puts them
	         in a format that the grid's filter can process.
	         */
	        if (attrs.fisFilters) {
	          var filterChangeWatch = scope.$parent.$watch(attrs.fisFilters, function (newCriteria, oldCriteria) {
	            if (!_.isEqual(newCriteria, oldCriteria)) {
	              var updateTimeout = $timeout(function () {
	                if (attrs.fisLiveFiltering) {
	                  if (_.isFunction(scope.$parent.changeFilter)) {
	                    scope.$parent.changeFilter(newCriteria);
	                  }
	                } else {
	                  var criteriaCopy = angular.copy(newCriteria);
	                  criteriaCopy = fisGridUtilService.removeEmptySearchCriteria(criteriaCopy); // cannot send empty values
	                  var criteriaToKendoFilter = fisGridUtilService.buildGridFilterObject(kendoGrid.dataSource, criteriaCopy, scope, attrs); // do the filtering
	                  if (!_.isEqual(criteriaToKendoFilter, dataSource._filter)) {
	                    // Only do filtering if the new filter is different than the current one
	                    // Especially usefull to not trigger the search when changing constraint of an empty field
	                    // if other fields are filled
	                    dataSource.filter(criteriaToKendoFilter);
	                    // doFilter(criteriaToKendoFilter, ds);
	                  }
	                }
	              }, 0);
	              scope.$on('$destroy', function () {
	                if (updateTimeout) {
	                  $timeout.cancel(updateTimeout);
	                }
	              });
	            }
	          });
	        }
	        scope.$on('$destroy', function () {
	          if (filterChangeWatch) {
	            // eslint-disable-line block-scoped-var
	            // eslint-disable-next-line block-scoped-var
	            filterChangeWatch(); // unbinds watch
	          }
	        });
	
	        /*
	         Add a unique id to each grid.
	         See SDHTML-6109 for reason why a general jquery selector is used to get all
	         grids instead of this old code (in essence, gridElem always refreshes to last grid in IE):
	          gridElem.find('table').each(function (index, currentElement) {
	         fisUniqueIdService.generateUniqueId(scope, angular.element(currentElement), attrs, 'grid_table');
	         });
	         */
	        $('[role="grid"]').each(function (index, currentElement) {
	          fisUniqueIdService.generateUniqueId(scope, angular.element(currentElement), attrs, 'grid_table');
	        });
	
	        // we need to bind the unsaved data funtion
	        var unsavedDataBinder = $timeout(function () {
	          bindUnsavedDataHandler(scope, kendoGrid);
	          bindCancelHandler(scope, kendoGrid);
	          if (fis.initParams().appStage === 'T') {
	            // test appStage
	            // add fisid to the grid filtering links
	            var gridFilterLinks = $('a.k-grid-filter');
	            _.each(gridFilterLinks, function (gridFilterLink) {
	              var gridFilterLinkElem = angular.element(gridFilterLink);
	              fisUniqueIdService.generateUniqueIdForce(scope, gridFilterLinkElem, attrs, 'grid_filter_link');
	            });
	            //                            addPagerIDs(scope, attrs, kendoGrid); //causes id Inconsistence
	          }
	        }, 1000);
	
	        scope.$on('$destroy', function () {
	          if (unsavedDataBinder) {
	            $timeout.cancel(unsavedDataBinder);
	          }
	        });
	
	        if (attrs.fisResizeToParent !== 'true') {
	          // console.log('>> Resize To Parent - reinit...');
	          adjustGridHeight(attrs.fisHeight);
	        }
	        /*
	         Reset the reinit flag to false but only if
	         it is already true and fisRefresh attribute is present.
	         This prevents multiple calls of reinit()
	         when changing columns.
	         */
	        if (scope.reinitTriggered) {
	          scope.reinitTriggered = false;
	        }
	      };
	
	      if (promiseObj) {
	        promiseObj.then(function () {
	          buildGrid();
	        },
	        // We can safely swallow errors here as inside the processColumnsAttr() method, where the promiseObj comes from, an error handler has been added already
	        angular.noop);
	      } else {
	        buildGrid();
	      }
	      var refresh = function refresh(event) {
	        // do not execute the event if event.preventDefault() has been called before
	        if (event && event.defaultPrevented) {
	          return;
	        }
	        // Avoid race condition if both reinit and refresh are triggered by the same
	        // user change. In this case, the Reinit event should always win, and we'll not
	        // process the refresh. In some cases, this has lead to an inconsistent state in the
	        // grid, where the grid would show the data of the first page, but the pagination
	        // control would still be on the previously selected page.
	        if (!scope.reinitTriggered) {
	          // Need to add a timeout here to ensure any digest operations on the scope happened before
	          var refreshTimeout = $timeout(function () {
	            // Need to check here again to avoid situation where the order in which
	            // refresh and reinit are called is reversed.
	            if (!scope.reinitTriggered) {
	              if (scope.keepPageOnRefresh === 'true' || scope.keepPageOnRefresh === true) {
	                dataSource.read();
	              } else {
	                if (dataSource.page() === 1) {
	                  // eslint-disable-line no-lonely-if
	                  dataSource.read();
	                } else {
	                  dataSource.page(1);
	
	                  if (attrs.fisMode === 'local') {
	                    dataSource.read();
	                  }
	                }
	              }
	
	              if (scope.selectable === 'multiple') {
	                clearGridSelection(kendoGrid, scope);
	              }
	            }
	          });
	
	          scope.$on('$destroy', function () {
	            if (refreshTimeout) {
	              $timeout.cancel(refreshTimeout);
	            }
	          });
	        }
	      };
	      // listen for the fisRefresh event coming from a parent scope
	      scope.$on('fisRefresh', refresh);
	
	      // redefine the fisRefresh function if it is put on the same element
	      if (fisRefresh) {
	        fisRefresh.trigger = refresh;
	      }
	
	      var reBuildGrid = function reBuildGrid() {
	        // fix for issue where selectmenu disppears after reinit SDHTML-7761
	        scope.headerCompiled = false;
	        scope.isSelectAll = false;
	        if (scope.gridConfig.deselectQuitsSelectAll === false) {
	          scope.deselectedRowIds = {};
	        }
	
	        scope.liveFilterExists = false;
	
	        var liveFilterPresent = $('tr.fis-grid-filter-row');
	        if (kendoGrid && liveFilterPresent) {
	          scope.liveFilterExists = true;
	        }
	
	        buildGrid();
	
	        // exposeWidgetAPI(scope, attrs, kendoGrid);
	      };
	
	      var reinit = function reinit() {
	        promiseObj = processColumnsAttr(scope, attrs);
	
	        if (promiseObj) {
	          promiseObj.then(function () {
	            // scope.reinitTriggered = true;
	            reBuildGrid();
	          },
	          // We can safely swallow errors here as inside the processColumnsAttr() method an error handler has been added already
	          angular.noop);
	        } else if (!scope.reinitTriggered) {
	          // eslint-disable-line no-negated-condition
	          // Set a flag to indicate that a reinit has been triggered - to avoid race conditions.
	          // See the comment in the refresh() function for more details.
	          // Set flag within time to prevent it being reset multiple times.
	          scope.reinitTriggered = true;
	          reBuildGrid();
	        } else {
	          // Reset the reinit flag
	          if (scope.reinitTriggered) {
	            // eslint-disable-line no-lonely-if
	            scope.reinitTriggered = false;
	          }
	        }
	        if (scope.selectable === 'multiple') {
	          clearGridSelection(kendoGrid, scope);
	        }
	      };
	      // listen for the fisReinit event coming from a parent scope
	      var reinitListener = scope.$on('fisReinit', reinit);
	      scope.$on('$destroy', function () {
	        if (reinitListener) {
	          reinitListener(); // unbinds watch
	        }
	      });
	
	      // redefine the fisReinit function if it is put on the same element
	      if (fisReinit) {
	        fisReinit.trigger = reinit;
	      }
	
	      // in the case when a grid is inside a dialog, and the dialog is initially hidden,
	      // none of the resizes fire because the inputs are all hidden and don't have sizes
	      // so we have to wait for the dialog to show, and then fire all the appropriate resizes
	      scope.$on('fisModalDialog.displayed', function () {
	        styleFilterRowInKendoGrid(elm, kendoGrid);
	        kendoGrid._resize();
	        // $on's get cleaned up automatically by the $destroy
	      });
	
	      scope.$on('$destroy', function () {
	        // $destroy event, broadcasted when a parent scope is being destroyed
	        fisMemoryUtilService.destroyKendoWidgets(kendoGrid);
	        // Remove all filterMenuContainers bound to this grid from DOM
	        _.each(scope.filterMenuContainerIds, function (filterMenuContainerId) {
	          $('ul[fisid=' + filterMenuContainerId + ']').remove();
	        });
	        fisMemoryUtilService.destroyKendoWidgets(kendoPager);
	        gridElem = null;
	        elm.on('$destroy', function () {
	          if (elm && elm.data) {
	            delete elm.data;
	          }
	          elm = null;
	        });
	      });
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 47 */
/*!******************************************!*\
  !*** ./grid/kendo-to-criteria.filter.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisCriteriaService", function (fisCriteriaService) {
	  'ngInject';
	
	  var constraintsMap = {
	    eq: fisCriteriaService.constraints.EQ,
	    contains: fisCriteriaService.constraints.CONTAINS,
	    gte: fisCriteriaService.constraints.GE,
	    lte: fisCriteriaService.constraints.LE,
	    ne: fisCriteriaService.constraints.NE,
	    gt: fisCriteriaService.constraints.GT,
	    ge: fisCriteriaService.constraints.GE,
	    lt: fisCriteriaService.constraints.LT,
	    le: fisCriteriaService.constraints.LE,
	    neq: fisCriteriaService.constraints.NE,
	    startswith: fisCriteriaService.constraints.STARTS_WITH,
	    endswith: fisCriteriaService.constraints.ENDS_WITH,
	    doesnotcontain: fisCriteriaService.constraints.NOT_CONTAINS,
	    is_empty: fisCriteriaService.constraints.IS_EMPTY, // eslint-disable-line camelcase
	    not_empty: fisCriteriaService.constraints.NOT_EMPTY, // eslint-disable-line camelcase
	    is_null: fisCriteriaService.constraints.IS_NULL, // eslint-disable-line camelcase
	    not_null: fisCriteriaService.constraints.NOT_NULL, // eslint-disable-line camelcase
	    notstartswith: fisCriteriaService.constraints.NOT_STARTS_WITH,
	    notendswith: fisCriteriaService.constraints.NOT_ENDS_WITH
	  };
	  var logicMap = {
	    and: fisCriteriaService.operators.AND,
	    or: fisCriteriaService.operators.OR
	  };
	
	  function getType(field, columns) {
	    var col = _.find(columns, function (column) {
	      return column.field === field;
	    });
	    return col ? col.dataType : null;
	  }
	
	  return function (opts) {
	    if (opts.filter) {
	      var operator = logicMap[opts.filter.logic]; // eslint-disable-line block-scoped-var
	      var crit = fisCriteriaService.newCriteria(operator); // eslint-disable-line block-scoped-var
	      for (var counter1 = 0; counter1 < opts.filter.filters.length; counter1++) {
	        var current = opts.filter.filters[counter1];
	        if (current.field) {
	          var criterion = new fisCriteriaService.Criterion(current.field, current.value, constraintsMap[current.operator]); // eslint-disable-line block-scoped-var
	          if (opts.additionalOpts) {
	            var type = getType(current.field, opts.additionalOpts.columns); // eslint-disable-line block-scoped-var
	            if (type) {
	              // eslint-disable-line block-scoped-var
	              criterion.type = type; // eslint-disable-line block-scoped-var
	            }
	          } else {
	            criterion.type = 'string'; // eslint-disable-line block-scoped-var
	          }
	          crit.add(criterion); // eslint-disable-line block-scoped-var
	        } else {
	          var operator = logicMap[current.logic]; // eslint-disable-line no-redeclare
	          var subCrit = fisCriteriaService.newCriteria(operator);
	          for (var counter2 = 0; counter2 < current.filters.length; counter2++) {
	            // eslint-disable-next-line block-scoped-var,no-redeclare
	            var criterion = new fisCriteriaService.Criterion(current.filters[counter2].field, current.filters[counter2].value, constraintsMap[current.filters[counter2].operator]);
	            if (opts.additionalOpts) {
	              var type = getType(current.filters[counter2].field, opts.additionalOpts.columns); // eslint-disable-line block-scoped-var, no-redeclare
	              if (type) {
	                // eslint-disable-line block-scoped-var
	                criterion.type = type; // eslint-disable-line block-scoped-var
	              }
	            } else {
	              criterion.type = 'string'; // eslint-disable-line block-scoped-var
	            }
	            subCrit.add(criterion); // eslint-disable-line block-scoped-var
	          }
	          crit.add(subCrit);
	        }
	      }
	      return crit;
	    } else {
	      // eslint-disable-line no-else-return
	      return null;
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 48 */
/*!***************************************!*\
  !*** ./grid/live-filter.directive.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisI18nService", "fisUniqueIdService", "fisMemoryUtilService", "$compile", "$window", "$timeout", "fisCriteriaService", "fisGridUtilService", "fisConfig", "fisPubSubService", "fisUtilService", function (fisI18nService, fisUniqueIdService, fisMemoryUtilService, $compile, $window, $timeout, fisCriteriaService, fisGridUtilService, fisConfig, fisPubSubService, fisUtilService) {
	  'ngInject';
	
	  /**
	   * Creates an array of columns taken from the scope.
	   *
	   * The array is used locally by grids with live filtering,
	   * thus avoiding any interference with the scope variable.
	   *
	   * @param gridColumns - the columns currently on the scope
	   * @returns {Array}
	   */
	
	  function buildOriginalColumns(gridColumns) {
	    var originalColumns = [];
	    var columns;
	    if (_.isString(gridColumns)) {
	      columns = gridColumns.split(',');
	    }
	    if (_.isArray(gridColumns)) {
	      columns = gridColumns;
	    }
	    for (var k = 0; k < columns.length; k++) {
	      var column = columns[k];
	      if (_.isString(column)) {
	        originalColumns.push({ field: column });
	      } else {
	        originalColumns.push(column);
	      }
	    }
	    return originalColumns;
	  }
	
	  /**
	   * Builds the constraints for the dropdown menu that is opened
	   * when user clicks the filter icon on a grid with live filtering.
	   *
	   * @param dataSource
	   * @param scope
	   * @param originalColumns
	   * @param gridAttrs
	   */
	  function buildColumnConstraints(dataSource, scope, originalColumns, gridAttrs) {
	    var extraColumns = hasExtraColumns(gridAttrs);
	    doExtraColumns(extraColumns, originalColumns);
	    scope.columnConstraints.constraints = [];
	    for (var i = 0; i < originalColumns.length; i++) {
	      createColumnConstraints(originalColumns[i], i, gridAttrs, scope, dataSource);
	    }
	  }
	
	  /**
	   * Returns a JS object indicating that this grid has extra non data
	   * columns (at the beginning).
	   *
	   * These columns are not filterable and therefore must not have
	   * filtering functionality.
	   *
	   * @param scope
	   * @returns {object}
	   */
	  function hasExtraColumns(gridAttrs) {
	    var extraColumns = {
	      multi: false,
	      detail: false,
	      number: 0
	    };
	
	    if (gridAttrs.fisSelectable === 'multiple') {
	      extraColumns.multi = true;
	      extraColumns.number++;
	    }
	    if (gridAttrs.fisDetailColumns) {
	      extraColumns.detail = true;
	      extraColumns.number++;
	    }
	    return extraColumns;
	  }
	
	  /**
	   * Creates empty columm JS objects for each non-data, non-filterable column
	   * on the grid (e.g. checkbox).
	   *
	   * Creating empty object ensures that indexes/counts are always
	   * in sync when selecting menus/inputs and corresponding json.
	   *
	   * @param extraColumns
	   * @param originalColumns
	   */
	  function doExtraColumns(extraColumns, originalColumns) {
	    if (extraColumns.detail === true || extraColumns.multi === true || extraColumns.detail === true & extraColumns.multi === true) {
	      // if there are extra columns (e.g. checkbox)
	      var extraObject = {};
	      extraObject.field = '';
	      extraObject.dataType = '';
	      var total = extraColumns.number;
	      for (var k = 0; k < total; k++) {
	        if (_.isArray(originalColumns)) {
	          originalColumns.unshift(extraObject); // add them to the collection of grid columns
	        }
	      }
	    }
	  }
	
	  /**
	   * Sets the scope.columnConstraints array of constraints for each column by
	   * dataType.
	   *
	   * @param column - the current column
	   * @param index
	   * @param gridAttrs
	   * @param scope
	   * @param dataSource - holds the schema object to get datatype
	   */
	  function createColumnConstraints(column, index, gridAttrs, scope, dataSource) {
	    var operators = {};
	    operators.dataType = column.dataType;
	    if (_.isUndefined(operators.dataType)) {
	      // dataType may not be specified on column so get from the schema instead. Warning - this may not be present even on schema in which case datatype will always be undefined!
	      if (!_.isUndefined(dataSource.options.schema.model) && column.field) {
	        if (!_.isUndefined(dataSource.options.schema.model.fields[column.field])) {
	          // eslint-disable-line no-negated-condition
	          operators.dataType = dataSource.options.schema.model.fields[column.field].type;
	        } else {
	          // fis-schema-columns does not have a datatype
	          operators.dataType = 'string';
	        }
	      }
	    }
	    var filterableOperators = getFilterableOperators(gridAttrs, operators.dataType); // get any fis-filterable-operators-*
	    if (_.isUndefined(filterableOperators) && column.operators) {
	      filterableOperators = column.operators.split(',');
	    }
	    operators.values = setColumnConstraints(column, operators.dataType, index, index, filterableOperators); // an array of constraints by dataType
	    scope.columnConstraints.constraints.push(operators);
	  }
	
	  /**
	   * Returns an array of operators that have been specified using the fis-filterable-operators-* attribute.
	   *
	   * @param gridAttrs
	   * @param columnDataType
	   */
	  function getFilterableOperators(gridAttrs, columnDataType) {
	    if (columnDataType === 'string') {
	      if (!_.isUndefined(gridAttrs.fisFilterableOperatorsString)) {
	        return gridAttrs.fisFilterableOperatorsString.split(',');
	      }
	    }
	    if (columnDataType === 'number' || columnDataType === 'integer' || columnDataType === 'double') {
	      if (!_.isUndefined(gridAttrs.fisFilterableOperatorsNumber)) {
	        return gridAttrs.fisFilterableOperatorsNumber.split(',');
	      }
	    }
	    if (columnDataType === 'date') {
	      if (!_.isUndefined(gridAttrs.fisFilterableOperatorsDate)) {
	        return gridAttrs.fisFilterableOperatorsDate.split(',');
	      }
	    }
	    if (columnDataType === 'datetime') {
	      if (!_.isUndefined(gridAttrs.fisFilterableOperatorsDateTime)) {
	        return gridAttrs.fisFilterableOperatorsDateTime.split(',');
	      }
	    }
	  }
	
	  /**
	   * Sets a collection of constraints needed by the dropdown
	   * menu for each column in a grid with live-filtering.
	   *
	   * The constraints change according to the column's
	   * dataType.
	   *
	   * @param datatype
	   * @param index
	   * @param count
	   * @param filterableOperators
	   *
	   * @returns {Array} - of constraints
	   */
	  function setColumnConstraints(column, dataType, index, count, filterableOperators) {
	    if (dataType === 'string' || _.isUndefined(dataType)) {
	      return setStringConstraints(column, index, count, filterableOperators);
	    }
	    if (dataType === 'number' || dataType === 'integer' || dataType === 'double') {
	      return setNumberConstraints(column, index, count, filterableOperators);
	    }
	    if (dataType === 'date' || dataType === 'datetime') {
	      return setDateConstraints(column, index, count, filterableOperators);
	    }
	    if (dataType === 'boolean') {
	      return setBooleanConstraints(column, index, count, filterableOperators);
	    }
	  }
	
	  /**
	   * Returns a collection of constraints for columns containing strings.
	   *
	   * @param column
	   * @param index
	   * @param count
	   * @param filterableOperators
	   *
	   * @returns {Array}
	   */
	  function setStringConstraints(column, index, count, filterableOperators) {
	    /*
	     http://docs.telerik.com/kendo-ui/api/wrappers/jsp/grid/filterable-operators-string
	     contains,
	     doesnotcontain,  --> MUST BE not_contains FOR fisCriteriaService
	     endswith,
	     eq,
	     neq,
	     startswith
	     */
	    var hasTemplate = !_.isUndefined(column.filterTemplate); // this is a column that contains a widget, e.g. a datePicker, and not just a simple input
	    var stringConstraints = [{
	      label: fisI18nService.translate(['compareOperators', 'string', 'contains'], 'Contains'),
	      method: 'contains',
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'string', 'doesnotcontain'], 'Does not contain'),
	      method: 'not_contains', // kendo expects doesnotcontain but fisCriteriaService expects not_contains
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'string', 'endswith'], 'Ends with'),
	      method: 'endswith',
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'string', 'eq'], 'Is equal'),
	      method: 'eq',
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'string', 'neq'], 'Is not equal'),
	      method: 'ne',
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'string', 'startswith'], 'Starts with'),
	      method: 'startswith',
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }];
	    /*
	     * If specific operators have been specified using attr fis-filter-operators-*
	     * then return them instead as an array
	     */
	    var liveFilterOperators = [];
	    liveFilterOperators = setFilterableOperators(filterableOperators, stringConstraints, liveFilterOperators);
	    if (liveFilterOperators.length === 0) {
	      // if none specified then return the full list of constraints
	      return stringConstraints;
	    }
	    return liveFilterOperators;
	  }
	
	  /**
	   * Returns a collection of constraints for columns containing numbers.
	   *
	   * @param column
	   * @param index
	   * @param count
	   * @param filterableOperators
	   *
	   * @returns {Array}
	   */
	  function setNumberConstraints(column, index, count, filterableOperators) {
	    /*
	     http://docs.telerik.com/kendo-ui/api/wrappers/jsp/grid/filterable-operators-number
	     eq,
	     gt,
	     gte, --> MUST BE ge FOR fisCriteriaService
	     lt,
	     lte, --> MUST BE le FOR fisCriteriaService
	     neq  --> MUST BE ne FOR fisCriteriaService
	     */
	    var hasTemplate = !_.isUndefined(column.filterTemplate); // this is a column that contains a widget, e.g. a datePicker, and not just a simple input
	    var numberConstraints = [{
	      label: fisI18nService.translate(['compareOperators', 'number', 'eq'], 'Is equal'),
	      method: 'eq',
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'number', 'gt'], 'Greater than'),
	      method: 'gt',
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'number', 'gte'], 'Greater than or equal'),
	      method: 'ge', // kendo expects gte but fisCriteriaService expects ge
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'number', 'lt'], 'Less than'),
	      method: 'lt',
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'number', 'lte'], 'Less than or equal'),
	      method: 'le', // kendo expects lte but fisCriteriaService expects le
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'number', 'neq'], 'Not equal'),
	      method: 'ne', // kendo expects neq but fisCriteriaService expects ne
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }];
	    /*
	     * If specific operators have been specified using attr fis-filter-operators-*
	     * then return them instead as an array
	     */
	    var liveFilterOperators = [];
	    liveFilterOperators = setFilterableOperators(filterableOperators, numberConstraints, liveFilterOperators);
	    if (liveFilterOperators.length === 0) {
	      // if none specified then return the full list of constraints
	      return numberConstraints;
	    }
	    return liveFilterOperators;
	  }
	
	  /**
	   * Returns a collection of constraints for columns containing dates.
	   *
	   * @param column
	   * @param index
	   * @param count
	   * @param filterableOperators
	   *
	   * @returns {Array}
	   */
	  function setDateConstraints(column, index, count, filterableOperators) {
	    /*
	     http://www.telerik.com/forums/customizing-date-filter-options
	     date: {
	     eq: "Is equal to",
	     neq: "Is not equal to", --> MUST BE ne FOR fisCriteriaService
	     gte: "Is after or equal to",
	     gt: "Is after",
	     lte: "Is before or equal to",
	     lt: "Is before"
	     }
	     */
	    var hasTemplate = !_.isUndefined(column.filterTemplate); // this is a column that contains a widget, e.g. a datePicker, and not just a simple input
	    var dateConstraints = [{
	      label: fisI18nService.translate(['compareOperators', 'date', 'eq'], 'Is equal to'),
	      method: 'eq',
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'date', 'neq'], 'Is not equal to'),
	      method: 'ne', // kendo expects neq but fisCriteriaService expects ne
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'date', 'gte'], 'Is after or equal'),
	      method: 'ge', // kendo expects gte but fisCriteriaService expects ge
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'date', 'gt'], 'Is after'),
	      method: 'gt',
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'date', 'lte'], 'Is before or equal'),
	      method: 'le', // kendo expects lte but fisCriteriaService expects le
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'date', 'lt'], 'Is before'),
	      method: 'lt',
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate,
	      placeholder: getPlaceholderInput(column)
	    }];
	    /*
	     * If specific operators have been specified using attr fis-filter-operators-*
	     * then return them instead as an array
	     */
	    var liveFilterOperators = [];
	    liveFilterOperators = setFilterableOperators(filterableOperators, dateConstraints, liveFilterOperators);
	    if (liveFilterOperators.length === 0) {
	      // if none specified then return the full list of constraints
	      return dateConstraints;
	    }
	    return liveFilterOperators;
	  }
	
	  /**
	   * Returns a collection of constraints for columns containing boolean values.
	   *
	   * @param column
	   * @param index
	   * @param count
	   * @param filterableOperators
	   *
	   * @returns {Array}
	   */
	  function setBooleanConstraints(column, index, count, filterableOperators) {
	    var hasTemplate = !_.isUndefined(column.filterTemplate); // this is a column that contains a widget, e.g. a datePicker, and not just a simple input
	    var booleanConstraints = [{
	      label: fisI18nService.translate(['compareOperators', 'boolean', 'eq'], 'Is equal'),
	      method: 'eq',
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate
	    }, {
	      label: fisI18nService.translate(['compareOperators', 'boolean', 'neq'], 'Not equal'),
	      method: 'ne', // kendo expects neq but fisCriteriaService expects ne
	      position: count,
	      index: index,
	      hasTemplate: hasTemplate
	    }];
	    /*
	     * If specific operators have been specified using attr fis-filter-operators-*
	     * then return them instead as an array
	     */
	    var liveFilterOperators = [];
	    liveFilterOperators = setFilterableOperators(filterableOperators, booleanConstraints, liveFilterOperators);
	    if (liveFilterOperators.length === 0) {
	      // if none specified then return the full list of constraints
	      return booleanConstraints;
	    }
	    return liveFilterOperators;
	  }
	
	  /**
	   * Returns the column's placeholder. This may be on the column itself or
	   * it may be declared as part of the column's widget
	   *
	   * @param column - the column
	   * @returns String
	   */
	  function getPlaceholderInput(column) {
	    if (!_.isUndefined(column.filterTemplate) && column.filterTemplate != null && column.filterTemplate.indexOf('placeholder-input') > -1) {
	      // eslint-disable-line eqeqeq, no-eq-null
	      var valuesArr = column.filterTemplate.split('"');
	      var found = false;
	      var placeHolderValue = '';
	      for (var i = 0; i < valuesArr.length && !found; i++) {
	        if (valuesArr[i].indexOf('placeholder-input') >= 0) {
	          // the very next string in the values array is the placeholder value
	          if (valuesArr.length > i + 1) {
	            placeHolderValue = valuesArr[i + 1];
	          }
	          // even if there are no more values, we essentially just pass empty string back
	          found = true;
	        }
	      }
	      return placeHolderValue;
	    }
	  }
	
	  /**
	   * Returns the constraints/operators specified using the fis-filter-operators-* attribute.
	   *
	   * @param filterableOperators - contains the attr values (e.g. 'eq')
	   * @param typeOperators - string, date or number
	   * @param liveFilterOperators - return attr in an array
	   * @returns {Array}
	   */
	  function setFilterableOperators(filterableOperators, typeOperators, liveFilterOperators) {
	    if (!_.isUndefined(filterableOperators) && filterableOperators.length > 0) {
	      angular.forEach(typeOperators, function (constraint) {
	        angular.forEach(filterableOperators, function (action) {
	          if (constraint.method === action.toLowerCase() || getCorrectLiveFilterOperator(action.toLowerCase()) === constraint.method) {
	            // if this is not working check that fis-filterable-operators-* has no spaces between args.
	            liveFilterOperators.push(constraint);
	          }
	        });
	      });
	    }
	    return liveFilterOperators;
	  }
	
	  /**
	   * @name getCorrectLiveFilterOperator
	   * @param {String}
	   *
	   * @description converts and returns the incoming String criteria
	   * into a format that can be understood by fisGrid live filter.
	   */
	  function getCorrectLiveFilterOperator(operator) {
	    if (operator === 'startswith') {
	      return 'starts_with';
	    } else if (operator === 'endswith') {
	      return 'ends_with';
	    } else if (operator === 'doesnotcontain') {
	      return 'not_contains';
	    } else if (operator === 'neq') {
	      return 'ne';
	    } else if (operator === 'gte') {
	      return 'ge';
	    } else if (operator === 'lte') {
	      return 'le';
	    }
	    return operator;
	  }
	
	  /**
	   * Builds the Criteria object that is used for the ng-model
	   * in each filter input for a grid with live filtering.
	   *
	   * There is one separate ng-model for each data column in the grid (i.e
	   * the criterion are not constructed for columns with checkboxes and
	   * detail arrows).
	   *
	   * @param dataSource
	   * @param element
	   * @param scope
	   * @param originalColumns
	   */
	  function buildLiveFilterCriteria(dataSource, scope, originalColumns, rebuilding) {
	    var initialFilterProperties = [];
	    var initialFilters = {};
	    if (rebuilding === true) {
	      initialFilters = scope.liveFilterCriteria.operands;
	    } else {
	      scope.liveFilterCriteria.operator = 'and'; // default, could be 'or'
	    }
	    scope.liveFilterCriteria.operands = [];
	
	    if (!_.isUndefined(scope.filters) && _.isArray(scope.filters.operands) && scope.filters.operands.length > 0) {
	      // Initial filter setting supplied
	      initialFilters = flattenOperands(scope.filters.operands);
	      initialFilterProperties = _.pluck(initialFilters, 'property');
	    }
	    initialFilterProperties = _.pluck(initialFilters, 'property');
	    for (var i = 0; i < originalColumns.length; i++) {
	      var criterion = {};
	      var column = originalColumns[i];
	      criterion.property = column.field; // e.g. 'accountId'
	      var index = _.indexOf(initialFilterProperties, criterion.property);
	      if (index > -1) {
	        // We found a initial filtering value and constrain for this column
	        criterion.value = initialFilters[index].value;
	        criterion.constraint = initialFilters[index].constraint;
	      } else {
	        var dataType = column.dataType;
	        if (_.isUndefined(dataType)) {
	          // dataType may not be specified on column so get from the schema instead
	          if (!_.isUndefined(dataSource.options.schema.model) && column.field) {
	            if (!_.isUndefined(dataSource.options.schema.model.fields[column.field])) {
	              // eslint-disable-line no-negated-condition
	              dataType = dataSource.options.schema.model.fields[column.field].type;
	            } else {
	              // fis-schema-columns do not have a datatype
	              dataType = 'string';
	            }
	          }
	        }
	        criterion.value = '';
	        criterion.constraint = setDefaultColumnConstraint(dataType, column, scope.columnConstraints);
	      }
	      scope.liveFilterCriteria.operands.push(criterion);
	    }
	  }
	
	  function flattenOperands(operands) {
	    var processedProperties = [];
	    var ret = [];
	    var processFunction = function processFunction(operand) {
	      if (_.isUndefined(operand.operator)) {
	        // It's a criterion
	        if (!_.contains(processedProperties, operand.property)) {
	          processedProperties.push(operand.property);
	          ret.push(operand);
	        }
	      } else {
	        // this else block is never reached in any of the tests
	        _.each(operand.operands, processFunction);
	      }
	    };
	    _.each(operands, processFunction);
	    return ret;
	  }
	
	  /**
	   * Sets the default constraint for a column based on its datatype.
	   *
	   * @param dataType
	   * @param column - to determine whether column has an fis-select-field template
	   *
	   * @returns {String}
	   */
	  function setDefaultColumnConstraint(dataType, column, columnConstraints) {
	    if (column.operators) {
	      return getCorrectLiveFilterOperator(column.operators.split(',')[0]); // return first operator as default
	    }
	    if (dataType === 'string' || _.isUndefined(dataType)) {
	      if (!_.isUndefined(column.filterTemplate) && column.filterTemplate !== null && column.filterTemplate.indexOf('fis-select-field') > -1) {
	        // if column is a dropdown widget then default operator is 'Is equal'
	        return 'eq';
	      } else {
	        // eslint-disable-line no-else-return
	        return 'contains';
	      }
	    }
	    if (dataType === 'number' || dataType === 'integer' || dataType === 'double' || dataType === 'date' || dataType === 'datetime' || dataType === 'boolean') {
	      return checkForEqConstraint(dataType, columnConstraints);
	    }
	  }
	
	  /**
	   * Function sets a default filter value if eq is not present. -
	   * The first property is used as a default.
	   * @param dataType
	   * @param columnConstraints
	   * @returns {string}
	   */
	  function checkForEqConstraint(dataType, columnConstraints) {
	    var rf = 'eq'; // the default filter
	    var hasEquals = false;
	    _.each(columnConstraints, function (constraint) {
	      _.each(constraint, function (filter) {
	        if (dataType === filter.dataType) {
	          var v = filter.values; // eslint-disable-line no-unused-vars
	          _.each(filter.values, function (cm) {
	            if (cm.method === 'eq') {
	              hasEquals = true;
	            }
	          });
	          if (!hasEquals && filter.values.length > 0) {
	            rf = filter.values[0].method; // we return the first value in the list since there is no eq.
	          }
	        }
	      });
	    });
	    return rf;
	  }
	
	  /**
	   * A 'facade' type function that creates the functionality
	   * needed to enable a grid for fis-live-filtering.
	   *
	   * @param kendoGrid
	   * @param element - the grid
	   * @param scope
	   * @param originalColumns - the grid's columns
	   * @param attrs
	   * @param gridName
	   * @param rebuilding whether this call happens due to initially building the livefilter row or rebuilding due to column order changes
	    */
	  function buildGridLiveFilterRow(kendoGrid, element, scope, originalColumns, gridAttrs, gridName) {
	    var filterRow = createGridLiveFilterRow(element, kendoGrid, scope);
	    buildGridLiveFilterMenu(scope, element, originalColumns, gridAttrs, gridName);
	    buildGridLiveFilterInputs(kendoGrid, element, scope, originalColumns, gridAttrs);
	    buildGridLiveClearButton(scope, filterRow, gridName);
	    // if (scope.liveFilteringApplyButton) { // if the attr fis-live-filtering-apply-button is present and true...
	    if (fisUtilService.booleanCheck(gridAttrs.fisLiveFilteringApplyButton, false)) {
	      // if the attr fis-live-filtering-apply-button is present and true...
	      doApplyButton(scope, filterRow, element, gridName); // then create the button
	    }
	    fisMemoryUtilService.cancelTimeoutOnDestroy(scope, $timeout(function () {
	      // Apply the styling after a timeout to achieve proper widths of filter inputs
	      // even after initial loading and not only after some resizing
	      applyElementResizeToTable(element);
	    }), $timeout);
	  }
	
	  /**
	   * Creates a new live filter row
	   * in the grid's header.
	   *
	   * @param element - the current grid DOM element
	   * @param kendoGrid
	   * @param scope
	   *
	   * @returns {JQuery} - the new row
	   */
	  function createGridLiveFilterRow(element, kendoGrid, scope) {
	    var liveFilterRow = kendoGrid.thead.find('.fis-grid-filter-row');
	
	    /*
	     This code may not be commented out - Faan 17/11/2014
	     It prevents the following error :
	     Error: [$compile:multidir] Multiple directives
	     Multiple directives may not apply to the same Dom element
	     */
	    if (liveFilterRow.children().length > 0) {
	      // live filter row already filled, clean it up
	      liveFilterRow.empty();
	    }
	    liveFilterRow = element;
	    addCellsToFilterRow(liveFilterRow, kendoGrid);
	    $compile(liveFilterRow)(scope.$parent);
	    return liveFilterRow;
	  }
	
	  /**
	   * This function adds cells to the new filter row.
	   *
	   * Note that <td>s and not <th>s are added
	   * to the row to avoid kendo adding a 'k-state-focused' class
	   * that prevents typing inside the filter inputs.
	   *
	   * @param columns
	   * @param kendoGrid
	   * @param liveFilterRow
	   */
	  function addCellsToFilterRow(liveFilterRow, kendoGrid) {
	    // this probably needs to be improved, we should be able to tie column objects to their
	    // correct column index using a map, not just rely on index being correct
	    var totalHeaderColumns = kendoGrid.thead.find('th').length;
	    for (var k = 0; k < totalHeaderColumns; k++) {
	      var columnObject = kendoGrid.columns[k];
	      var liveFilterRowCell = $('<td class="fis-grid-filter-cell" style="border:0;">');
	      if (!_.isUndefined(columnObject)) {
	        if (!_.isUndefined(columnObject.hidden) & columnObject.hidden) {
	          // if the fis-column has property hidden...
	          liveFilterRowCell.addClass('fis-grid-filter-cell-hidden');
	        }
	        if (!_.isUndefined(columnObject.headerAttributes)) {
	          // Add Style classes to the new filter row cells
	          liveFilterRowCell.addClass(columnObject.headerAttributes.class);
	        }
	      }
	      liveFilterRow.append(liveFilterRowCell);
	    }
	    liveFilterRow.find('td:last').addClass('fis-clear-button-column');
	  }
	
	  /**
	   * Adds a filter dropdown menu to each input that is opened
	   * when the filter icon is clicked.
	   *
	   * @param scope
	   * @param element
	   * @param originalColumns
	   */
	  function buildGridLiveFilterMenu(scope, element, originalColumns, gridAttrs, gridName) {
	    // Clean up menu-remains of possible earlier grids with same name (or the previous instance of this grid in case of a reinit)
	    // (we can't listen to the reinit event directly as not broadcast happens when reinit is called by the grid itself)
	    $('body').children('ul[data-parent="' + gridName + '"]').remove();
	
	    // if this grid has non data columns, then hide the filter menu
	    var extraColumns = hasExtraColumns(gridAttrs);
	    var cells = element.find('.fis-grid-filter-cell');
	    // Start iteration with the nth column from left to skip potential extra columns (like checkbox, or the cart for opening detailgrids)
	    for (var i = extraColumns.number; i < originalColumns.length; i++) {
	      var column = originalColumns[i];
	      var cell = cells.eq(i);
	      if (_.isUndefined(column.filterable) || column.filterable) {
	        var menu = $compile('<div fis-filter-menu fis-index="' + i + '"></div>')(scope); // create the menu
	        menu.find('ul').attr('data-parent', gridName);
	        addMenuToFilterCell(cells.length, i, $(menu), cell, scope); // add it to the DOM
	        addShowMenuFunction(i, cell, scope, gridName); // create function to view the menu. Done separately because we need fisids that are created after the menu is compiled
	        if (fisMemoryUtilService.enabled) {
	          scope.$on('$destroy', function () {
	            // eslint-disable-line no-loop-func
	            /*
	             timeout avoids trying to destroy a $scope that is still in use during digest cycle in contenteditable#updateModel()
	             see http://stackoverflow.com/questions/18660839/cannot-read-property-nextsibling-of-null
	             */
	            var menuTimeout = $timeout(function () {
	              fisMemoryUtilService.callCleanAll(menu);
	              $timeout.cancel(menuTimeout); // cancel the timeout when finished
	            }, 0);
	            menu = null;
	          });
	        }
	      }
	    }
	    if (fisMemoryUtilService.enabled) {
	      scope.$on('$destroy', function () {
	        _.each(cells, function (cell) {
	          /*
	           timeout avoids trying to destroy a scope that is still in use during digest cycle in contenteditable#updateModel()
	           see http://stackoverflow.com/questions/18660839/cannot-read-property-nextsibling-of-null
	           */
	          var cellTimeout = $timeout(function () {
	            fisMemoryUtilService.callCleanAll(cell);
	            $timeout.cancel(cellTimeout); // cancel the timeout when finished
	          });
	          cell = null;
	        });
	      });
	    }
	  }
	
	  /**
	   * Adds a compiled filter dropdown menu to each filter cell.
	   *
	   * @param numberOfInputs
	   * @param index - current cell
	   * @param menu
	   * @param cell - the <td> to append the menu
	   * @param scope
	   */
	  function addMenuToFilterCell(numberOfInputs, index, menu, cell, scope) {
	    if (index < numberOfInputs - 1) {
	      // don't append menu to last cell which is the clear button column
	      cell.append(menu);
	    }
	    addUniqueIds(menu, scope, 'filterMenuContainer'); // add unique id to each dropdown menu
	  }
	
	  /**
	   * Adds a unique id to each constraint dropdown menu for grids
	   * with live filtering.
	   *
	   * @param element
	   * @param scope
	   * @param idBase
	   */
	  function addUniqueIds(element, scope, idBase) {
	    if (element.is('div')) {
	      var dropdownMenu = element.find('ul');
	      element = angular.element(dropdownMenu);
	      dropdownMenu = null;
	    }
	    fisUniqueIdService.generateUniqueIdForce(scope, element, {}, idBase);
	  }
	
	  /**
	   * Adds a compiled ng-click function to each dropdown menu that
	   * enables the menu to show.
	   *
	   * @param index
	   * @param input
	   * @param scope
	   */
	  function addShowMenuFunction(index, input, scope, gridName) {
	    var menu = input.find('ul[fisid^=filterMenuContainer_]');
	    // clean up the menu after destroy
	    scope.$on('$destroy', function () {
	      menu.remove();
	      menu = undefined;
	    });
	    /*
	     * Keep a dynamic collection of all filter menu ids belonging to this
	     * grid. There will be one for each column starting at 0
	     */
	    scope.filterMenuContainerIds[index] = menu.attr('fisid');
	    /*
	     * The second param of the function call is the item in the array
	     * of ids that corresponds to the current index.
	     */
	    var prevLink = input.find('.dropdown-toggle');
	    prevLink.attr('ng-click', 'showFilterMenu($event,filterMenuContainerIds[' + index + '],\'' + gridName + '\')');
	    var compiledLink = $compile(prevLink)(scope); // compile
	    angular.element(prevLink).replaceWith(compiledLink); // and replace the current DOM element with the compiled element
	    if (fisMemoryUtilService.enabled) {
	      scope.$on('$destroy', function () {
	        /*
	         timeout avoids trying to destroy a scope that is still in use during digest cycle in contenteditable#updateModel()
	         see http://stackoverflow.com/questions/18660839/cannot-read-property-nextsibling-of-null
	         */
	        var linkTimeout = $timeout(function () {
	          $timeout.cancel(linkTimeout); // cancel the timeout when finished
	          fisMemoryUtilService.callCleanAll(compiledLink);
	          fisMemoryUtilService.callCleanAll(prevLink);
	        });
	        compiledLink = null;
	        prevLink = null;
	        menu = null;
	      });
	    }
	  }
	
	  /**
	   * Creates the inputs for the filter row for a grid
	   * with fis-live-filtering enabled.
	   *
	   * @param dataSource
	   * @param element
	   * @param scope
	   * @param originalColumns - the grid's columns
	   * @param attrs
	   */
	  function buildGridLiveFilterInputs(kendoGrid, element, scope, originalColumns, attrs) {
	    // Put all column widths into an array. Do this prior to adding any elements
	    // to the cells to avoid table resizing if the first columns contain an element
	    // but the upcoming ones do not
	    var columnWidths = [];
	
	    var tableHeaderRow = kendoGrid.thead.find('tr').eq(0);
	    var tableHeaders = tableHeaderRow.find('th');
	    var headerTimeout;
	    _.each(tableHeaders, function (theader) {
	      var th = $(theader);
	      if (th.css('display') !== 'none') {
	        // eslint-disable-line no-negated-condition
	        if (th.outerWidth() < 22) {
	          // if grid is in a modal dialog then need to wait for grid to load so we can get the th's width (IE adds padding of 16 to outerWidth!)
	          headerTimeout = $timeout(function () {
	            columnWidths.push(th.outerWidth());
	          }, 0);
	        } else {
	          columnWidths.push(th.outerWidth());
	        }
	      } else {
	        columnWidths.push(0);
	      }
	    });
	
	    var filterCells = element.find('.fis-grid-filter-cell');
	
	    // cannot reference the element since its not available yet - we are in build options
	    var gridName = fisGridUtilService.getGridName(attrs, scope, null);
	    _.each(originalColumns, function (column, index) {
	      var elem = filterCells.eq(index);
	      if (!_.isUndefined(column.field) && column.field.length > 0 && (_.isUndefined(column.filterable) || column.filterable)) {
	        if (_.isUndefined(column.dataType) || column.dataType.length === 0) {
	          column.dataType = 'string'; // Set datatype to string if none is supplied
	        }
	
	        var applyBtn = attrs.fisLiveFilteringApplyButton;
	        var input;
	        var inputBuildArgs = {
	          dataSource: kendoGrid.dataSource,
	          column: column,
	          columnWidth: columnWidths[index],
	          scope: scope,
	          index: index,
	          numColumns: originalColumns.length,
	          element: elem, // filterCells.eq(index),
	          applyButton: applyBtn,
	          gridHeight: attrs.fisHeight,
	          userDefWidth: column.width
	        };
	
	        if (column.filterTemplate) {
	          input = createComponentForFilterColumn(inputBuildArgs, gridName); // add widget
	        } else {
	          input = createInputForFilterColumn(inputBuildArgs, attrs, gridName, element, index);
	          var cell = element.find('.fis-grid-filter-cell:eq(' + index + ')');
	          cell.append(input);
	        }
	        cell = null; // eslint-disable-line block-scoped-var
	        input = null;
	        elem = null;
	      }
	    });
	
	    // in the case when a livefilter is inside a dialog, and the dialog is initially hidden,
	    // none of the resizes fire because the inputs are all hidden and don't have sizes
	    // so we have to wait for the dialog to show, and then fire all the appropriate resizes
	    scope.$on('fisModalDialog.displayed', function () {
	      applyElementResizeToTable(element);
	      // $on's get cleaned up automatically by the $destroy
	    });
	
	    scope.$on('$destroy', function () {
	      tableHeaderRow = null;
	      tableHeaders = null;
	      $timeout.cancel(headerTimeout); // cancel the timeout when finished
	      headerTimeout = null;
	    });
	  }
	
	  /**
	   * Returns a compiled search Component to hold the filter values for each column
	   * in the grid.
	   *
	   * Filtering is triggered when the user leaves
	   * the filter field (blur()) or when pressing the enter key unless
	   * the grid has an apply button in which case the blur functionality
	   * is disabled.
	   *
	   * @param gridName
	   * @param buildArgs - JSON object containing values required to build the input correctly
	   * @returns {Angular Object} - the compiled input
	   */
	  function createComponentForFilterColumn(buildArgs, gridName) {
	    var columnFilterScope = buildArgs.scope.$parent.$new();
	    var newTemplate = angular.element(buildArgs.column.filterTemplate);
	
	    newTemplate = addTemplateComponentAttrs(newTemplate, buildArgs.index, buildArgs.applyButton, buildArgs.scope); // template specific attrs
	    var wrap = angular.element('<div class="fis-gridFilter-widget-position"><form fis-stacked="false" name="filterForm-liveFilterCriteria.operands[' + buildArgs.index + '].value"></form></div>');
	    wrap.find('form').append(newTemplate);
	    buildArgs.element.append(wrap); // place on DOM to Ensure  Kendo widget are styled and position correctly
	    var columnWidth = buildArgs.columnWidth;
	    if (!_.isUndefined(buildArgs.userDefWidth)) {
	      // if user specifies column width, use that
	      columnWidth = buildArgs.userDefWidth;
	    }
	    columnFilterScope.callback = function (opts) {
	      // var w = opts.element.outerWidth();
	      applyElementSize(opts.dropdownlist.parents('td'), columnWidth);
	    };
	    var widget = $compile(wrap)(columnFilterScope);
	    buildArgs.element.css('width', columnWidth);
	    // place required variables on widget scope
	    addRequiredScopeVariables(widget, buildArgs.scope);
	
	    applyElementSize(widget, columnWidth);
	    if (columnFilterScope.$$phase !== '$apply' && columnFilterScope.$$phase !== '$digest') {
	      columnFilterScope.$apply();
	    }
	    if (!fisUtilService.booleanCheck(buildArgs.applyButton, false)) {
	      // blur implemented only if there is no apply button
	      // We do not have a selectField or autocompleteField
	      if (_.isUndefined(newTemplate.attr('fis-number-field')) && _.isUndefined(newTemplate.attr('fis-select-field')) && _.isUndefined(newTemplate.attr('fis-autocomplete-field')) && _.isUndefined(newTemplate.attr('fis-date-picker-field')) && _.isUndefined(newTemplate.attr('fis-combo-box-field'))) {
	        bindBlurEvent(widget);
	      } else {
	        // In case of number field only bind blur event to the second (index 1) input
	        // need to wait for the kendo event that is fired when widget is created
	        buildArgs.scope.$parent.$on('kendoWidgetCreated', function (event, createdWidget) {
	          if (createdWidget.options.name === 'NumericTextBox') {
	            bindBlurEvent(widget, 1);
	          }
	        });
	      }
	    }
	    buildArgs.scope.$on('$destroy', function () {
	      columnFilterScope.$destroy();
	      columnFilterScope = null;
	      widget.remove();
	      widget = null;
	      buildArgs = null;
	    });
	    addLiveFilterMenuIds(buildArgs.scope, widget, gridName);
	    return widget;
	  }
	
	  /**
	   *  Adds Template Component Attributes.
	   *
	   * @param newTemplate
	   * @param index
	   * @param applyButton
	   *
	   * @returns {Object}
	   */
	  function addTemplateComponentAttrs(newTemplate, index, applyButton) {
	    newTemplate.attr('ng-model-input', 'liveFilterCriteria.operands[' + index + '].value');
	
	    // TODO Remove Check, this placeholder check is in place tell Kendo resolves space issues for number field
	    // This fix is for SDHTML-9398
	    if (_.isUndefined(newTemplate.attr('fis-number-field'))) {
	      newTemplate.attr('placeholder-input', '{{ getPlaceholder(' + index + ') }}');
	    } else {
	      newTemplate.attr('placeholder-input', '\'{{ getPlaceholder(' + index + ') }}\''); // replace spaces
	    }
	    newTemplate.attr('ng-keydown', 'filterInputKeyDown($event)');
	    if (!fisUtilService.booleanCheck(applyButton, false)) {
	      // blur implemented only if there is no apply button
	      if (!_.isUndefined(newTemplate.attr('fis-select-field')) || !_.isUndefined(newTemplate.attr('fis-combo-box-field'))) {
	        // overide ng-change and remove ng-blur for select-field  and fis-combo-box-field
	        newTemplate.attr('ng-change-input', 'applyFiltering()');
	      } else if (!_.isUndefined(newTemplate.attr('fis-autocomplete-field'))) {
	        newTemplate.attr('ng-change-input', 'applyFiltering()');
	      }
	    }
	    return newTemplate;
	  }
	
	  /*
	   * This function is meant to generically apply the parent size to widgets and inputs.
	   * Ideally they should all have an api exposed, so all this would do is call their api function.
	   * @param json element
	   * @param integer currentSize
	   */
	  function applyElementSize(element, currentSize) {
	    // now calculate the input width: remove 30px for the filter icon
	    var inputWidth = currentSize - 30;
	    /*
	     If the grid is loaded in a modal dialog then the currentSize
	     (i.e. the width of the <td>) argument will be undefined. This
	     is because the grid is only loaded when pressing a button to open
	     the modal dialog. SDHTML-8808
	     */
	    if (isNaN(inputWidth) || inputWidth < 30) {
	      inputWidth = 120;
	    }
	    var autoCompleteWidget = element.find('.k-autocomplete');
	    // now check for widgets, and size appropriately
	    if (autoCompleteWidget.length > 0) {
	      // we need to remove the k-header, we use it on the th tag instead
	      autoCompleteWidget.removeClass('k-header');
	      var autoCompleteScope = autoCompleteWidget.scope();
	      var modifier = -10; // eslint-disable-line block-scoped-var
	      if (!_.isUndefined(autoCompleteScope)) {
	        autoCompleteScope.resize(inputWidth + modifier); // eslint-disable-line block-scoped-var
	      }
	    } else {
	      var widgetElement = element.find('span.k-widget');
	
	      // we need to remove the k-header, we use it on the th tag instead
	      widgetElement.removeClass('k-header');
	      if (widgetElement.length > 0) {
	        // is this a widget?
	        var modifier = 0; // eslint-disable-line block-scoped-var, no-redeclare
	        var isNumericTextBox = widgetElement.hasClass('k-numerictextbox');
	        if (isNumericTextBox) {
	          modifier = 1; // eslint-disable-line block-scoped-var
	          // eslint-disable-next-line block-scoped-var
	          widgetElement.find('.k-numeric-wrap').css('width', inputWidth + modifier); // number spinner
	          widgetElement.find('input').css('width', inputWidth + 5);
	          widgetElement.find('input').css('display', 'inline');
	        } else {
	          var isComboBoxWidget = widgetElement.hasClass('k-combobox'); // combobox
	          if (isComboBoxWidget) {
	            // order is critical here, both combo box and k-dropdown uses k-dropdown class
	            modifier = -21; // eslint-disable-line block-scoped-var
	            // widgetElement.find('.k-dropdown-wrap').css('width', inputWidth+200);
	            // widgetElement.find('input').css('width', inputWidth+modifier);
	            var comboScope = widgetElement.scope();
	            if (!_.isUndefined(comboScope)) {
	              // comboScope.resize(inputWidth + modifier+300);
	              widgetElement.find('input').css('width', inputWidth + modifier); // eslint-disable-line block-scoped-var
	              widgetElement.find('.k-dropdown-wrap').css('width', inputWidth + 10);
	            }
	          } else {
	            var isDropDownWidget = widgetElement.hasClass('k-dropdown'); // dropdown
	            if (isDropDownWidget) {
	              modifier = 0; // eslint-disable-line block-scoped-var
	              // widgetElement.find('.k-dropdown-wrap').css('width', inputWidth+modifier);
	              var dropScope = widgetElement.scope();
	              if (!_.isUndefined(dropScope)) {
	                // dropScope.resize(inputWidth + modifier); // commented out see SDHTML-13757
	              }
	            } else {
	              var isDatePickerWidget = widgetElement.hasClass('k-datepicker'); // datepicker
	              if (isDatePickerWidget) {
	                modifier = 3; // eslint-disable-line block-scoped-var
	                var datePickerScope = widgetElement.scope();
	                if (!_.isUndefined(datePickerScope)) {
	                  datePickerScope.resize(inputWidth + modifier); // eslint-disable-line block-scoped-var
	                }
	                // need to resize the span containing the datePicker widget
	                widgetElement.find('.k-picker-wrap').css('width', inputWidth + modifier); // eslint-disable-line block-scoped-var
	              }
	            }
	          }
	        }
	        widgetElement.css('width', inputWidth + modifier); // eslint-disable-line block-scoped-var
	      } else {
	        // it's not a widget, it's a normal input (or it's a boolean radio input)
	        var radios = element.find('div[fis-radio-field]');
	        if (radios.length > 0) {
	          _.each(radios, function (radio) {
	            $(radio).find('input').css('width', '20px');
	          });
	        } else {
	          var nestedInput = element.find('input');
	          // eslint-disable-next-line block-scoped-var, no-redeclare
	          var modifier = -21; // do not remove this. Without it, when you tab from one field into a simple input, the width of the input is too big and the filter icon is masked.
	          if (nestedInput.length > 0) {
	            nestedInput.css('width', inputWidth + modifier); // eslint-disable-line block-scoped-var
	          } else {
	            // it is the input
	            element.css('width', inputWidth + modifier); // eslint-disable-line block-scoped-var
	          }
	        }
	      }
	    }
	  }
	
	  /**
	   * Places required variables on widget scope
	   * @param widget
	   * @param scope
	   */
	  function addRequiredScopeVariables(widget, scope) {
	    // place required variables on widget scope
	    if (!_.isUndefined(widget.scope()) && _.isUndefined(widget.scope().liveFilterCriteria)) {
	      widget.scope().liveFilterCriteria = scope.liveFilterCriteria;
	      widget.scope().getPlaceholder = scope.getPlaceholder;
	      // widget.scope().checkFilterInputValue = scope.checkFilterInputValue;
	      widget.scope().filterInputKeyDown = scope.filterInputKeyDown;
	      widget.scope().applyFiltering = scope.applyFiltering;
	    }
	  }
	
	  function bindBlurEvent(widget, nth) {
	    var blurTargets = widget.find('input.k-input, input.fis-input');
	    if (!_.isUndefined(nth)) {
	      blurTargets = blurTargets.eq(nth);
	    }
	    blurTargets.on('blur', function () {
	      widget.scope().applyFiltering();
	    });
	  }
	
	  function addLiveFilterMenuIds(scope, element, gridName) {
	    var idBase = gridName + '_live_filter_';
	    var idSuffix = '';
	    if (element.is('input')) {
	      idSuffix = 'input';
	    } else if (element.is('button')) {
	      idSuffix = 'button';
	    }
	    var inputElement = $(element).find('input[fis-input]');
	    if (inputElement.length > 0) {
	      fisUniqueIdService.generateUniqueId(scope, inputElement, {}, idBase + idSuffix, true);
	    } else {
	      fisUniqueIdService.generateUniqueId(scope, element, {}, idBase + idSuffix);
	    }
	    inputElement = null;
	  }
	
	  /**
	   * Returns a compiled search input to hold the filter values for each column
	   * in the grid.
	   *
	   * Filtering is triggered when the user leaves
	   * the filter field (blur()) or when pressing the enter key unless
	   * the grid has an apply button in which case the blur functionality
	   * is disabled.
	   *
	   * @param buildArgs - JSON object containing values required to build the input correctly
	   * @param attrs
	   * @param gridName - used when creating ids
	   * @param element - the current grid
	   *
	   * @returns {Angular Object} - the compiled input
	   */
	  function createInputForFilterColumn(buildArgs, attrs, gridName, element) {
	    var input;
	    input = '<input ng-change="checkFilterInputValue()" ng-keyup="filterInputKeyDown($event)" ng-model="liveFilterCriteria.operands[' + buildArgs.index + '].value" ng-model-options="{ updateOn:\'change submit blur default\', debounce:{ change:0, submit:0, blur:0, default:0 } }" type="search" class="fis-grid-filter-cell-input" placeholder="{{ getPlaceholder(' + buildArgs.index + ') }}">';
	    var compiled = $compile(input)(buildArgs.scope);
	    var columnWidth = buildArgs.columnWidth;
	    compiled.css('width', columnWidth);
	    element.find('.k-grid td').css('text-overflow', 'inherit'); // without this, td has inherited text-overflow: ellipsis causing IE and FF to display inputs with ellipses.
	    applyElementSize(compiled, columnWidth);
	    addLiveFilterMenuIds(buildArgs.scope, compiled, gridName);
	    if (!fisUtilService.booleanCheck(buildArgs.applyButton, false)) {
	      // blur implemented only if there is no apply button
	      $(compiled).on('blur', function () {
	        // used this blur because ng-blur and ng-keydown cause digest error together
	        buildArgs.scope.applyFiltering();
	      });
	      buildArgs.scope.$on('$destroy', function () {
	        compiled.off('blur');
	        compiled = null;
	      });
	    }
	    addUniqueIds(compiled, buildArgs.scope, 'filterCellInput'); // add unique id to each cell input
	    return compiled;
	  }
	
	  /**
	   * Creates a button to clear the values in the filter row
	   * for a grid with fis-live-filtering enabled.
	   *
	   * @param scope
	   * @param filterRow
	   * @param gridName
	   */
	  function buildGridLiveClearButton(scope, filterRow, gridName) {
	    var lastCell = filterRow.find('td.fis-clear-button-column');
	    var clearButton = '<button class="k-button fis-grid-filter-clear-button" ng-click="clearFilterValues()"><i class="fis-legacy-icon fis-legacy-i-pass"></i></button>';
	    var compiled = $compile(clearButton)(scope);
	    addLiveFilterMenuIds(scope, compiled, gridName);
	    lastCell.append(compiled);
	  }
	
	  /**
	   * Creates an button to apply filtering using
	   * the user entered values.
	   *
	   * @param scope
	   * @param filterRow
	   * @param element
	   */
	  function doApplyButton(scope, filterRow, element, gridName) {
	    var lastCell = filterRow.find('td.fis-clear-button-column');
	    var applyButton = '<button class="k-button fis-grid-filter-apply-button ng-scope" ng-click="applyFilterValues()"><i class="fis-legacy-icon fis-legacy-i-ok fis-grid-filter-apply-icon"></i></button>';
	    var compiled = $compile(applyButton)(scope);
	    addLiveFilterMenuIds(scope, compiled, gridName);
	    lastCell.append(compiled);
	    scope.liveFilteringApplyButton = true;
	  }
	
	  /**
	   * Binds various events to live filter grids.
	   *
	   * @param kendoGrid
	   * @param scope
	   * @param elm
	   * @param originalColumns
	   */
	  function bindLiveFilterEvents(kendoGrid, scope, elm, attrs, rebuilding) {
	    if (rebuilding !== true) {
	      // Only bind these two if we are building the grid for the first time
	      bindColumnShowHideToGrid(kendoGrid); // show filter menus/inputs if column re-shown or hidden
	      bindColumnResizeToGrid(kendoGrid); // expand/contract inputs as column width changes
	    }
	    // The binding to window resize always needs to the refreshed, as the callback function keeps a reference to the DOM
	    // element
	    bindColumnResizeToWindow(kendoGrid, attrs, scope, elm); // expand/contract inputs as column width changes with browser re-size
	  }
	
	  /**
	   * If column is removed/re-shown then hide/re-show the <td> containing the
	   * filter menu and input.
	   *
	   * @param kendoGrid
	   * @param scope
	   * @param elm
	   * @param originalColumns
	   */
	  function bindColumnShowHideToGrid(kendoGrid) {
	    function columnShowHideCallback(event) {
	      var columns = event.sender.columns;
	      var tableHeader = event.sender.thead;
	      for (var k = 0; k < columns.length; k++) {
	        if (event.column.field === columns[k].field) {
	          var column = tableHeader.find('.fis-grid-filter-row td').eq(k);
	          column.toggleClass('fis-grid-filter-cell-hidden', event.column.hidden);
	        }
	      }
	    }
	    // Binding another function to this event using the bind() does not override
	    // existing callbacks that has been set in the options when creating the kendoGrid
	    kendoGrid.bind('columnShow', columnShowHideCallback);
	    kendoGrid.bind('columnHide', columnShowHideCallback);
	  }
	
	  /**
	   * Inputs should expand/contract as column width changes
	   * @param kendoGrid
	   * @param elm
	   * @param originalColumns
	   */
	  function bindColumnResizeToGrid(kendoGrid) {
	    function gridColumnResizeHandler(e) {
	      // get the columns new width
	      var columnWidth = e.newWidth;
	      // get the current header object and update its internal input element
	      var columnsToCheck = e.sender.columns;
	      var indexFound = -1;
	      var hiddenColumnsInBetween = 0;
	      var indexModifier = 0;
	      // if there are detail tables, add one to the index(compensate for extra unresizable column)
	      if (e.sender.thead.find('.k-hierarchy-cell.k-header').length > 0) {
	        indexModifier = 1;
	      }
	      for (var i = 0; i < columnsToCheck.length; i++) {
	        var col = columnsToCheck[i];
	        if (col.hidden) {
	          hiddenColumnsInBetween++;
	        }
	        if (col === e.column) {
	          indexFound = i + indexModifier;
	          break;
	        }
	      }
	      if (!_.isUndefined(e.column)) {
	        var minWidth = _.isNumber(e.column.minWidth) ? e.column.minWidth : 70; // 70 is the default minWidth
	        if (columnWidth < minWidth) {
	          columnWidth = minWidth;
	          // Apply the new minWidth to the header and the body table (not directly, but to the colgroup>col elem
	          // Note hidden columns do not have a <col> item in the colgroup, however a <td> is present for them in every <tr>
	          e.sender.thead.siblings('colgroup').children().eq(indexFound - hiddenColumnsInBetween).width(columnWidth);
	          e.sender.tbody.siblings('colgroup').children().eq(indexFound - hiddenColumnsInBetween).width(columnWidth);
	
	          // Adjust the overall width of the tables in the body and header of the grid
	          // This is necessary as the overall table width has been adjusted to meet the column width when the current column
	          // has a width of e.newWidth, but we changed that width to meet our minWidth requirements
	          var diff = columnWidth - e.newWidth;
	          var headerTable = e.sender.thead.parent();
	          var bodyTable = e.sender.tbody.parent();
	          headerTable.width(parseFloat(headerTable.width()) + diff);
	          bodyTable.width(parseFloat(bodyTable.width()) + diff);
	          // Trigger another event
	          e.column.width = columnWidth;
	          e.oldWidth = e.newWidth;
	          e.newWidth = columnWidth;
	          e.sender.trigger('columnResize', e);
	          return;
	        }
	      }
	      var liveFilterCell = e.sender.thead.find('.fis-grid-filter-cell').eq(indexFound);
	      // generically apply the elements size
	      applyElementSize(liveFilterCell, columnWidth);
	    }
	    kendoGrid.bind('columnResize', gridColumnResizeHandler);
	    // need to kill this handler when the grid is destroyed
	  }
	
	  /**
	   * Inputs should expand/contract as column width changes on all visible tables
	   * @param kendoGrid
	   * @param elm
	   * @param originalColumns
	   */
	  function bindColumnResizeToWindow(kendoGrid, attrs, scope, elm) {
	    var windowResizeNameSpace = fisGridUtilService.getGridName(attrs, scope, kendoGrid) + 'windowResizeNamespace';
	    function windowColumnResizeHandler() {
	      if (elm.find('.fis-grid-filter-cell').length > 0) {
	        applyElementResizeToTable(elm);
	      }
	    }
	    var viewWindow = angular.element($window);
	
	    // Unbind any potential existing event handlers first
	    viewWindow.off('resize.' + windowResizeNameSpace);
	
	    viewWindow.on('resize.' + windowResizeNameSpace, windowColumnResizeHandler);
	    scope.$on('$destroy', function () {
	      viewWindow.off('resize.' + windowResizeNameSpace);
	    });
	  }
	
	  /*
	   * This function runs through all of a tables filter objects, and resizes each
	   * @param {type} table
	   */
	  function applyElementResizeToTable(table) {
	    if (!_.isUndefined(table)) {
	      var elementsToResize = table.find('.fis-grid-filter-cell');
	      for (var i = 0; i < elementsToResize.length; i++) {
	        var elem = elementsToResize.eq(i);
	        // eslint-disable-next-line no-negated-condition
	        if (elem.css('display') !== 'none') {
	          // SDHTML-10950 This was causing the kendo widget icons not to show after resize
	          applyElementSize(elem, elem.outerWidth());
	        } else {
	          // This is a workaround and should be re-evaluated. 180 should not be hardcoded. SDHTML-11209. Currently icons do not always display correctly.
	          applyElementSize(elem, 180);
	        }
	      }
	    }
	  }
	
	  /**
	   * @name doFilter
	   * @param {JSON, JSON}
	   *
	   * @description Applies the JSON criteria to the grid's dataSource.filter object.
	   */
	  function doFilter(criteria, dataSource) {
	    dataSource.filter(criteria);
	  }
	
	  function buildLiveFilteringFeature(kendoGrid, scope, elm, attrs, originalColumns, rebuilding) {
	    buildColumnConstraints(kendoGrid.dataSource, scope, originalColumns, attrs); // builds the constraints for the dropdown menu
	    buildLiveFilterCriteria(kendoGrid.dataSource, scope, originalColumns, rebuilding); // builds the ng-model for each input
	    buildGridLiveFilterRow(kendoGrid, elm, scope, originalColumns, attrs, fisGridUtilService.getGridName(attrs, scope, kendoGrid), rebuilding); // validates the criteria object before sending it to the dataSource.filter to do the filtering
	    bindLiveFilterEvents(kendoGrid, scope, elm, originalColumns, attrs, rebuilding); // bind various events to live filter grids
	  }
	
	  return {
	    restrict: 'E',
	    replace: true,
	    scope: {
	      gridColumns: '&gridColumns',
	      kendoGrid: '&getKendoGrid',
	      gridAttrs: '&gridAttrs',
	      filters: '&getFilters'
	      // callBack: '&callBack'
	    },
	    template: '<tr role="row" class="fis-grid-filter-row"></tr>',
	    link: function link(scope, elem) {
	      /*
	       SDHTML-11899
	       Inputs not resizing correctly when browser is resized under certain
	       conditions (see ticket for conditions). To fix this, get the width
	       of each table header and use it to set the width of the live filter
	       row cells. A Timeout is needed to get the widths of the header cells.
	       */
	      fisPubSubService.subscribe('fisTabsBar.tabOpened', function () {
	        var tabTimeout = $timeout(function () {
	          // timeout needed to get width of header columns
	          elem.siblings().find('th').each(function (index, header) {
	            elem.find('td').each(function () {
	              $(this).css('width', header.offsetWidth);
	            });
	          });
	          applyElementResizeToTable(elem);
	        }, 10);
	        scope.$on('$destroy', function () {
	          $timeout.cancel(tabTimeout);
	        });
	      });
	
	      /*
	       // SDHTML-10742
	       Inputs not resizing correctly when browser is resized under certain
	       conditions (see ticket for conditions). To fix this, get the width
	       of each table header and use it to set the width of the live filter
	       row cells. A Timeout is needed to get the widths of the header cells.
	       */
	      fisPubSubService.subscribe('fisTabsBar.tabClosed', function () {
	        var tabTimeout = $timeout(function () {
	          // timeout needed to get width of header columns
	          elem.siblings().find('th').each(function (index, header) {
	            elem.find('td').each(function () {
	              var width = header.offsetWidth;
	              if (width == 0) {
	                // eslint-disable-line eqeqeq
	                width = 210;
	              }
	              $(this).css('width', width);
	            });
	          });
	          applyElementResizeToTable(elem);
	        }, 10);
	        scope.$on('$destroy', function () {
	          $timeout.cancel(tabTimeout);
	        });
	      });
	
	      /*
	       SDHTML-11899
	       Inputs not resizing correctly when browser is resized under certain
	       conditions (see ticket for conditions). To fix this, get the width
	       of each table header and use it to set the width of the live filter
	       row cells. A Timeout is needed to get the widths of the header cells.
	       */
	      fisPubSubService.subscribe('fisResponsiveService.browserResized', function () {
	        var resizeTimeout = $timeout(function () {
	          elem.siblings().find('th').each(function (index, header) {
	            elem.find('td').each(function () {
	              $(this).css('width', header.offsetWidth);
	            });
	          });
	        }, 10);
	        applyElementResizeToTable(elem);
	        scope.$on('$destroy', function () {
	          $timeout.cancel(resizeTimeout);
	        });
	      });
	
	      /**
	       * Binds enter key and fire applyFiltering on enter
	       * @param component -widget or input filter field
	       * @param scope
	       */
	      scope.filterInputKeyDown = function (event) {
	        if (event.keyCode === 13) {
	          // ENTER
	          scope.applyFiltering();
	          event.target.focus();
	          // stop event bubbling for issue on IE where event opens mega menu.SDHTML-7811
	          event.preventDefault();
	        } else if (event.keyCode === 9) {
	          // TAB
	          /*
	           applyfiltering only if the live filter apply button is not present
	           */
	          if (!scope.liveFilteringApplyButton) {
	            scope.applyFiltering();
	          }
	        } else if ((event.keyCode === 8 || event.keyCode === 46) && angular.element(event.currenTarget).val() === '') {
	          // BACKSPACE || DELETE
	          // Check whether a backspace or delete key has been pressed first to avoid unnecessary angular.element calls
	          // eslint-disable-next-line no-use-before-define
	          doFilter({}, kendoDataSource); // send an empty object to the grid's filter so that all data is reloaded
	        }
	      };
	
	      /**
	       * This function performs the filtering for a grid with live filtering.
	       */
	      scope.applyFiltering = function () {
	        var criteriaCopy = angular.copy(scope.liveFilterCriteria);
	        criteriaCopy = fisGridUtilService.removeEmptySearchCriteria(criteriaCopy); // cannot send empty values
	        if (criteriaCopy.operands.length === 0) {
	          if (!_.isUndefined(kendoGrid.dataSource.filter()) && kendoGrid.dataSource.filter().filters.length > 0) {
	            // eslint-disable-line no-use-before-define
	            // The new "filter" says anything should be shown and the grid does not already show anything
	            // (equals "The grid currently filters the content, so the filters.length > 0)
	            // This prevents the grid from reloading data if e.g. the constraint of an empty filter input changes
	            doFilter({}, kendoGrid.dataSource); // eslint-disable-line no-use-before-define
	            // SDHTML-13602: The following fixes issue caused by IE having and handling scrollbar width differently
	            // Kendo inserts a temporal div while loading/orgrid returns an empty set.
	            // We alter the width of this div to prevent unnecessary scrollbar
	            var width = $('.k-grid-content').find('div')[0].clientWidth;
	            $('.k-grid-content div').css('width', width - 20); // 20 being the with of scrollbar on IE
	          }
	        } else {
	          // eslint-disable-next-line no-use-before-define
	          var criteriaToKendoFilter = fisGridUtilService.buildGridFilterObject(kendoGrid.dataSource, criteriaCopy, scope, gridAttrs); // do the filtering
	          if (!_.isEqual(criteriaToKendoFilter, kendoDataSource._filter)) {
	            // eslint-disable-line no-use-before-define
	            // Only do filtering if the new filter is different than the current one
	            // Especially usefull to not trigger the search when changing constraint of an empty field
	            // if other fields are filled
	            doFilter(criteriaToKendoFilter, kendoGrid.dataSource); // eslint-disable-line no-use-before-define
	          }
	        }
	      };
	
	      /**
	       * Reloads the grid if all the filter inputs are empty.
	       */
	      scope.checkFilterInputValue = function () {
	        var empty = true; // eslint-disable-line no-unused-vars
	        for (var i = 0; i < scope.liveFilterCriteria.operands.length; i++) {
	          var operand = scope.liveFilterCriteria.operands[i];
	          if (operand.value !== null && operand.value.length !== 0) {
	            empty = false;
	          } else if (operand.value === null) {
	            operand.value = '';
	          }
	        }
	      };
	
	      /**
	       * @name showFilterMenu
	       * @param {Object} $event. The Event object
	       * @param {Number} id fisid of the filter menu to be shown
	       * @param {String} gridName name of the grid to which the menu belongs
	       *
	       * @description Displays the filter menu for the relevant cell. If it is already open
	       * it will be closed.
	       */
	      scope.showFilterMenu = function ($event, id, gridName) {
	        var filterMenu = $('ul[fisid="' + id + '"][data-parent="' + gridName + '"]');
	        var initiallyVisible = filterMenu.is(':visible');
	        hideFilterMenu(); // eslint-disable-line no-use-before-define
	        if (!initiallyVisible) {
	          // The menu currently was not already open. This would have meant that
	          // the user wants to close it by clicking the filter icon a second time
	
	          $event.preventDefault();
	          $event.stopImmediatePropagation();
	
	          var windowScrollTop = $(window).scrollTop(); // if window scrolled then need to minus this from the height so that menu stays in correct place
	          var target = $($event.currentTarget);
	          var offset = target.offset();
	          // + outerHeight() pushes the overflow list beneath the overflow tab and - windowScrollTop ensures menu stays in same place if scrolling down
	          var dd_top = offset.top + target.outerHeight() - windowScrollTop; // eslint-disable-line camelcase
	          $('body').append(filterMenu); // must append it to the body for IE to work
	          filterMenu.show();
	          var left = target.offset().left + 4; // align the menu with the icon
	          filterMenu.css({ // eslint-disable-line quote-props
	            width: 50 + 'px',
	            top: dd_top + 'px', // eslint-disable-line camelcase
	            position: 'fixed', // must be fixed so that it follows the window contract and expand
	            left: left, // align LHS with filter icon
	            'z-index': '99999' // this is needed for grids inside a modal dialog
	          });
	          setEventHandlers(true); // eslint-disable-line no-use-before-define
	        }
	      };
	
	      /**
	       * Sets the constraint selected by the user from the dropdown
	       * menu.
	       *
	       * Also sets the checkmark for the selected constraint.
	       *
	       * The dropdown menu is closed on selection.
	       *
	       * @param constraint - the selected constraint
	       * @param filterMenuId
	       */
	      scope.applyConstraint = function (constraint, filterMenuId) {
	        var index = parseInt(constraint.position, 10);
	        // var menu = scope.columnConstraints.constraints[index];
	        scope.liveFilterCriteria.operands[index].constraint = constraint.method; // Set the new constraint
	        var valueIsFilled = !_.isUndefined(scope.liveFilterCriteria.operands[index].value) && scope.liveFilterCriteria.operands[index].value != ''; // eslint-disable-line eqeqeq
	        var noApplyButton = !fisUtilService.booleanCheck(scope.liveFilteringApplyButton, false);
	        if (valueIsFilled && noApplyButton) {
	          scope.applyFiltering();
	        }
	        hideFilterMenu(filterMenuId); // eslint-disable-line no-use-before-define
	      };
	
	      /**
	       * Returns a default placeholder corresponding to the default constraint
	       * for the input at the columnIndex.
	       *
	       * If there is no default constraint found then there can be no placeholder
	       * so Not Found is returned instead.
	       * @param columnIndex
	       * @returns {*}
	       */
	      scope.getPlaceholder = function (columnIndex) {
	        // Currently selected constraint
	        var currentConstraint = scope.liveFilterCriteria.operands[columnIndex].constraint; // this can never be null because default always set in setDefaultColumnConstraint()
	        if (!_.isUndefined(currentConstraint)) {
	          for (var i = 0; i < scope.columnConstraints.constraints[columnIndex].values.length; i++) {
	            if (!_.isUndefined(scope.columnConstraints.constraints[columnIndex].values[i].placeholder)) {
	              return scope.columnConstraints.constraints[columnIndex].values[i].placeholder;
	            } else if (scope.columnConstraints.constraints[columnIndex].values[i].method === currentConstraint || scope.columnConstraints.constraints[columnIndex].values[i].method === getCorrectLiveFilterOperator(currentConstraint)) {
	              return scope.columnConstraints.constraints[columnIndex].values[i].label;
	            }
	          }
	        }
	        return 'Not Found';
	      };
	
	      /*
	       * Applies filtering to a grid with live-filtering when
	       * the 'apply' button is clicked.
	       */
	      scope.applyFilterValues = function () {
	        scope.applyFiltering();
	      };
	
	      /**
	       * Clears all values in the filter inputs for grids with fis-live-filtering
	       * and reloads the grid.
	       * This should always reload the grid data, although no change in the filter may have been detected!
	       * (see documentation statement)
	       */
	      scope.clearFilterValues = function () {
	        var dataSource = kendoDataSource; // eslint-disable-line no-use-before-define
	        // eslint-disable-next-line no-use-before-define
	        if (gridAttrs.fisFilters) {
	          // reset default filters
	          var criteriaToKendoFilter = {};
	          fisGridUtilService.getGridFilterObject(scope.filters, criteriaToKendoFilter, gridAttrs, dataSource, scope); // eslint-disable-line no-use-before-define
	          doFilter(criteriaToKendoFilter, dataSource);
	          // eslint-disable-next-line no-use-before-define
	          buildLiveFilterCriteria(dataSource, scope, originalColumns); // updates widgets/inputs with default values...
	        } else {
	          // go through normal clearing
	          doFilter({}, dataSource); // send an empty object to the grid's filter so that all data is reloaded
	          for (var i = 0; i < scope.liveFilterCriteria.operands.length; i++) {
	            scope.liveFilterCriteria.operands[i].value = '';
	          }
	        }
	      };
	
	      var gridColumns = scope.gridColumns();
	      var originalColumns = buildOriginalColumns(gridColumns);
	
	      var gridAttrs = scope.gridAttrs();
	      var kendoGrid = scope.kendoGrid();
	
	      var kendoDataSource = kendoGrid.dataSource;
	      var gridName = fisGridUtilService.getGridName(gridAttrs, scope, kendoGrid); // eslint-disable-line no-unused-vars
	
	      scope.filters = scope.filters(); // Retrieving filters from fisGrid
	
	      // if(gridAttrs.fisFilters){
	      if (gridAttrs.fisFilters) {
	        scope.$parent.changeFilter = function (newCriteria) {
	          _.each(newCriteria.operands, function (criteriaOperand) {
	            _.each(scope.liveFilterCriteria.operands, function (operand) {
	              operand.value = '';
	              if (operand.property === criteriaOperand.property) {
	                operand.value = criteriaOperand.value;
	              }
	            });
	          });
	          var criteriaToKendoFilter = fisGridUtilService.buildGridFilterObject(kendoDataSource, newCriteria, scope, gridAttrs);
	          if (!_.isEqual(criteriaToKendoFilter, kendoDataSource._filter)) {
	            // Only do filtering if the new filter is different than the current one
	            // Especially usefull to not trigger the search when changing constraint of an empty field
	            // if other fields are filled
	            doFilter(criteriaToKendoFilter, kendoGrid.dataSource);
	          }
	        };
	      }
	
	      scope.liveFilterCriteria = {};
	      scope.columnConstraints = {};
	      scope.filterMenuContainerIds = []; // keep a dynamic collection of all the filter menu ids for this grid
	      buildLiveFilteringFeature(kendoGrid, scope, elem, gridAttrs, originalColumns);
	      if (gridAttrs.kReorderable === 'true') {
	        var showLoadingIndicator = angular.isDefined(fisConfig.widgets) && angular.isDefined(fisConfig.widgets.fisGrid) && fisConfig.widgets.fisGrid.showLoadingIndicator !== false && fisConfig.widgets.fisGrid.showLoadingIndicator !== 'false';
	        var avoidReordering = function avoidReordering(reorderingEvent) {
	          var gridWidget = reorderingEvent.sender;
	          // Avoid reordering if either the current column has the custom property "reorderable" set to false
	          // or the column at the destination index has reorderable false
	          return reorderingEvent.column.reorderable === false || gridWidget.columns[reorderingEvent.newIndex].reorderable === false;
	        };
	
	        // Column reordering is activated and fisLiveFiltering => we need to recreate liveFilterRow on column reordering
	        kendoGrid.bind('columnReorder', function (event) {
	          var gridWidget = event.sender;
	          // Using a function on the grid scope check whether this reordering is allowed
	          if (!avoidReordering(event)) {
	            // Reordering not avoided, so adjust live filtering
	            var startColumn = hasExtraColumns(gridAttrs).number;
	            if (showLoadingIndicator) {
	              // Show the user that the header is not finished yet, if we want to display loading indicators
	              kendo.ui.progress(gridWidget.thead, true);
	            }
	            $timeout(function () {
	              // Wait until kendo completed the column reordering (DOM manipulation completed, kendoGrid.columns array adapted)
	
	              // After a timeout rebuild the live filtering feature completely (new row, new constraint arrays, ...)
	              // Cut out possible extra columns from the start and remove the last row, which is the row for clear/apply button
	              buildLiveFilteringFeature(gridWidget, scope, elem, gridAttrs, gridWidget.columns.slice(startColumn, -1), true);
	              kendo.ui.progress(gridWidget.thead, false);
	            }, 0);
	          }
	        });
	      }
	
	      /**
	       * @name hideFilterMenu
	       *
	       * @description Hides the filter menu specified by the containerId.
	       * If this is undefined, then hides all open filter menus.
	       *
	       * @param containerId hide only the
	       */
	      var hideFilterMenu = function hideFilterMenu(containerId) {
	        if (_.isString(containerId)) {
	          $('ul[fisid=' + containerId + ']').hide(); // hide the specified menu
	        } else {
	          $('ul[fisid^=filterMenuContainer_]').hide(); // else hide all possible filter menus
	        }
	        setEventHandlers(false); // eslint-disable-line no-use-before-define
	      };
	
	      /**
	       * @name setEventHandlers
	       * @param {boolean} bind whether to bind or unbind the event handlers
	       *
	       * @description Binds und unbinds custom handlers
	       * to the window's click and scroll event, so that liveFilter menu closes
	       * when clicking outside or scrolling.
	       */
	      var setEventHandlers = function setEventHandlers(bind) {
	        var eventNamespace = fisGridUtilService.getGridName(gridAttrs, scope, kendoGrid) + 'LiveFilterNameSpace';
	
	        var clickHandler = function clickHandler(e) {
	          e.stopPropagation(); // without this, the items in the menu become links
	          if (!$(e.target).hasClass('fis-grid-filter-menu-item-container')) {
	            hideFilterMenu();
	          }
	        };
	        return function (bind) {
	          // eslint-disable-line wrap-iife
	          var viewWindow = angular.element($window);
	          if (bind) {
	            viewWindow.on('click.' + eventNamespace, clickHandler);
	            viewWindow.on('scroll.' + eventNamespace, hideFilterMenu);
	          } else {
	            viewWindow.off('click.' + eventNamespace);
	            viewWindow.off('scroll.' + eventNamespace);
	          }
	        }(bind);
	      };
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 49 */
/*!*********************************!*\
  !*** ./grid/pager.directive.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$parse", "fisI18nService", function ($parse, fisI18nService) {
	  'ngInject';
	
	  return {
	    replace: true,
	    scope: {
	      getDataSource: '=fisDataSource',
	      pagerEvaluatedPageSizes: '=fisPagerEvaluatedPageSizes',
	      pagerPrevPage: '=fisPagerPrevPage',
	      onPaginationFn: '=fisOnPaginationFn'
	    },
	    link: function link(scope, element, attrs) {
	      /**
	       * Name:buildPaginationEvent
	       * Description:This method builds an event object that will be passed into the fis-on-pagination event handler,
	       * that is called every time a page is changed the fisGrid
	       */
	      scope._buildPaginationEvent = function (nextPage, prevPage, totalPages) {
	        var event = {};
	
	        var numNextPage = parseInt(nextPage, 10);
	        var numPrevPage = parseInt(prevPage, 10);
	
	        event.totalPages = totalPages;
	
	        event.nextPage = numNextPage;
	        event.previousPage = prevPage === undefined ? 1 : numPrevPage;
	
	        return event;
	      };
	
	      element.find('.k-pager-sizes').remove();
	
	      var pagerOpts = {
	        dataSource: scope.getDataSource(),
	        pageSizes: scope.pagerEvaluatedPageSizes,
	        change: function change(event) {
	          // Reset the previous selection index to avoid a unintended shift selection after paginating
	          scope.previousSelection = undefined;
	          // Code for the fis-on-pagination event handler
	          if (!_.isUndefined(attrs.fisOnPaginationFn) && _.isFunction(scope.onPaginationFn)) {
	            // eslint-disable-line no-undef
	            var e = scope._buildPaginationEvent(event.index, scope.pagerPrevPage, event.sender.dataSource.totalPages());
	            scope.pagerPrevPage = e.nextPage;
	            scope.onPaginationFn({ event: e });
	          }
	        },
	        messages: {
	          display: fisI18nService.translate(['fisPager', 'display'], '{0} - {1} of {2} items'),
	          empty: fisI18nService.translate(['fisPager', 'empty'], 'No items to display'),
	          allPages: fisI18nService.translate(['fisPager', 'allPages'], 'All'),
	          page: fisI18nService.translate(['fisPager', 'page'], 'Page'),
	          of: fisI18nService.translate(['fisPager', 'of'], 'of {0}'),
	          itemsPerPage: fisI18nService.translate(['fisPager', 'itemsPerPage'], 'items per page'),
	          first: fisI18nService.translate(['fisPager', 'first'], 'Go to the first page'),
	          previous: fisI18nService.translate(['fisPager', 'previous'], 'Go to the previous page'),
	          next: fisI18nService.translate(['fisPager', 'next'], 'Go to the next page'),
	          last: fisI18nService.translate(['fisPager', 'last'], 'Go to the last page'),
	          refresh: fisI18nService.translate(['fisPager', 'refresh'], 'Refresh')
	        }
	      };
	
	      for (var attr in attrs) {
	        if (attr.substring(0, 6) === 'kpager') {
	          var kendoAttribute = attr.substring(6);
	          kendoAttribute = kendoAttribute.substring(0, 6).toLowerCase() + kendoAttribute.substring(6);
	          if (attrs[attr] === 'true') {
	            pagerOpts[kendoAttribute] = true;
	          } else {
	            pagerOpts[kendoAttribute] = $parse(attrs[attr])(scope.$parent);
	          }
	        }
	      }
	      element.kendoPager(pagerOpts);
	
	      scope.$parent.setKendoPager(element.data('kendoPager')); // for use in parent/grid.
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 50 */
/*!***************************!*\
  !*** ./language/index.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _base = __webpack_require__(/*! ../base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _dropdown = __webpack_require__(/*! ../dropdown */ 8);
	
	var _dropdown2 = _interopRequireDefault(_dropdown);
	
	var _languageChooser = __webpack_require__(/*! ./language-chooser.directive */ 51);
	
	var _languageChooser2 = _interopRequireDefault(_languageChooser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.language', [_base2.default, _dropdown2.default]);
	
	ngModule.directive('fisLanguageChooser', _languageChooser2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 51 */
/*!************************************************!*\
  !*** ./language/language-chooser.directive.js ***!
  \************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisI18nService", "$filter", "fisUniqueIdService", "$timeout", "fisMemoryUtilService", function (fisI18nService, $filter, fisUniqueIdService, $timeout, fisMemoryUtilService) {
	  'ngInject';
	
	  return {
	    template: '<input fis-unique-id="language-chooser" />',
	    restrict: 'EA',
	    replace: true,
	    transclude: false,
	    link: function link(scope, element) {
	      function addUniqueIdToAnimationContainer() {
	        var dropdownAnimationContainers = $('.k-list-container');
	        for (var i = 0; i < dropdownAnimationContainers.length; i++) {
	          fisUniqueIdService.generateUniqueId(scope, $(dropdownAnimationContainers[i]), {}, 'language-list-container');
	        }
	      }
	
	      fisI18nService.supportedLanguages.then(function (supportedLanguages) {
	        var data = [];
	        data.push({ label: fisI18nService.translate('choose.language', 'Choose Language'), value: '' });
	        var currentLanguage = fisI18nService.locale();
	        var selected = 0;
	        for (var i = 0; i < supportedLanguages.length; i++) {
	          if (supportedLanguages[i].value === currentLanguage) {
	            selected = i + 1;
	          }
	          data.push(supportedLanguages[i]);
	        }
	
	        function onChange() {
	          var onChangeTimeout = $timeout(function () {
	            fisI18nService.locale(element.val());
	          });
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, onChangeTimeout, $timeout);
	        }
	
	        element.kendoDropDownList({
	          dataTextField: 'label',
	          dataValueField: 'value',
	          dataSource: data,
	          index: selected,
	          open: addUniqueIdToAnimationContainer,
	          change: onChange
	        });
	
	        // set width of the drop-down list
	        var selectWidth = element.css('width');
	        // set size of widget override size
	        element.closest('.k-widget').width(selectWidth);
	        element.data('kendoDropDownList').list.css('min-width', selectWidth);
	      });
	    }
	  };
	}];

/***/ }),
/* 52 */
/*!**************************!*\
  !*** ./menubar/index.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _base = __webpack_require__(/*! ../base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _menuBar = __webpack_require__(/*! ./menu-bar.directive */ 53);
	
	var _menuBar2 = _interopRequireDefault(_menuBar);
	
	var _secondaryMenu = __webpack_require__(/*! ./secondary-menu.directive */ 54);
	
	var _secondaryMenu2 = _interopRequireDefault(_secondaryMenu);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.menubar', [_base2.default]);
	
	ngModule.directive('fisMenuBar', _menuBar2.default);
	ngModule.directive('fisSecondaryMenu', _secondaryMenu2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 53 */
/*!***************************************!*\
  !*** ./menubar/menu-bar.directive.js ***!
  \***************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return {
	    // eslint-disable-next-line no-multi-str
	    template: '<div class="k-content">\
	                <ul id="menu"></ul>\
	            </div>',
	    restrict: 'EA',
	    replace: true,
	    scope: false,
	    require: 'fisData',
	    link: function link(scope, element, attrs, fisData) {
	      /**
	       * @name addId
	       * @description Method that adds in an id if the application is running in test mode
	       * @param id the id to add in
	       * @return returns string to add into the page
	       * @methodOf fisMenuBar
	       * @private
	       */
	      function addId(id) {
	        if (fis.initParams().appStage === 'T') {
	          return 'id="' + id + '"';
	        } else {
	          // eslint-disable-line no-else-return
	          return '';
	        }
	      }
	
	      // load the navigation via promise
	      scope.menuItems = {};
	      var prom = fisData.fetchData();
	      prom.then(function (result) {
	        scope.menuItems = result;
	      }, function (result) {
	        console.warn('Problem loading data: ' + result);
	      });
	
	      /**
	       * @name parseNavigation
	       * @description recursive parsing function to build up the menu function
	       * @param menuItems the array of menu items to recursively build up a menu structure
	       * @param before text to be used in contruction of the rest call to open the page
	       * @return returns the menu to add into the page
	       * @methodOf fisMenuBar
	       * @private
	       */
	      function parseNavigation(menuItems, before) {
	        var content = '';
	        angular.forEach(menuItems, function (itm, path) {
	          if (!itm.id) {
	            itm.id = itm.label.toLowerCase().replace(' ', '-');
	          }
	          var beginning = '';
	          if (before !== undefined) {
	            // eslint-disable-line no-negated-condition
	            beginning = before + '/' + itm.id;
	          } else {
	            beginning = '/' + itm.id;
	          }
	          if (!itm.path) {
	            var a = [];
	            for (var i = 0; i < path.length; i++) {
	              a.push(path[i].id);
	            }
	            a.push(itm.id);
	            itm.path = beginning; // + '/' + a.join('/');
	          }
	          if (!itm.secondaryNav) {
	            var nestedNess = itm.path.split('/');
	            if (itm.children && itm.children.length > 0 && nestedNess.length < 4) {
	              content = content + '<li ' + addId(itm.id) + '>' + itm.label + '<ul>' + parseNavigation(itm.children, beginning) + '</ul></li>';
	            } else {
	              if (itm.partial) {
	                // eslint-disable-line no-lonely-if
	                content = content + '<li><a ' + addId(itm.id) + ' href="#' + itm.path + '">' + itm.label + '</a></li>';
	              }
	            }
	          }
	        });
	        return content;
	      }
	
	      // watch the menuItems for changes
	      scope.$watch('menuItems', function (newMenuItems) {
	        var direction = 'default';
	        var orientation = 'horizontal';
	        if (attrs.fisMenuOrientation === 'left') {
	          direction = 'left';
	          orientation = 'vertical';
	        } else if (attrs.fisMenuOrientation === 'right') {
	          direction = 'right';
	          orientation = 'vertical';
	        } else if (attrs.fisMenuOrientation === 'top') {
	          direction = 'top';
	        }
	        if (newMenuItems) {
	          // create the menu structure here
	          var content = parseNavigation(newMenuItems.data);
	          var menu = element.find('#menu');
	          menu.html(content).kendoMenu({
	            orientation: orientation,
	            direction: direction,
	            select: function select() {
	              // explicitly close the menu after opening a partial
	              menu.data('kendoMenu').close();
	            }
	          });
	        }
	      }, true);
	    }
	  };
	};

/***/ }),
/* 54 */
/*!*********************************************!*\
  !*** ./menubar/secondary-menu.directive.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisPubSubService", "fisViewService", "$rootScope", "$controller", "$timeout", "$compile", "$sce", function (fisPubSubService, fisViewService, $rootScope, $controller, $timeout, $compile, $sce) {
	  'ngInject';
	
	  // Add required classes to given item
	
	  function addItemClasses(item, isFirstRow) {
	    var className = '';
	    if (isFirstRow) {
	      className = 'fis-secondary-menu-top ';
	    }
	    setItemCustomClasses(item, className);
	  }
	
	  // Binds a css class to an item using the kendo ui standard parameter
	  function setItemCustomClasses(item, className) {
	    if (item) {
	      if (item.cls) {
	        className += item.cls;
	      }
	      item.cssClass = className;
	    }
	  }
	
	  var body = angular.element('body');
	  var MENU_ADDED_EVENT = 'fisSecondaryMenuAdded';
	  var MENU_REMOVED_EVENT = 'fisSecondaryMenuRemoved';
	
	  $rootScope.$on(MENU_ADDED_EVENT, function () {
	    body.addClass('fis-secondary-menu-present');
	  });
	
	  $rootScope.$on(MENU_REMOVED_EVENT, function () {
	    body.removeClass('fis-secondary-menu-present');
	  });
	
	  return {
	    // eslint-disable-next-line no-multi-str
	    template: '<div ng-show="secondaryMenuBarItems != null" class="k-content">\
	                <ul></ul>\
	            </div>',
	
	    restrict: 'EA',
	
	    replace: true,
	
	    scope: {},
	
	    link: function link(scope, element) {
	      element.addClass('fis-secondary-menu');
	      var ulElem = element.find('ul');
	
	      fisPubSubService.subscribe('fisFirstSecondaryItemOpened', function () {
	        markItemSelected(ulElem.find('li:eq(0)'));
	      });
	
	      function markItemSelected(listItem) {
	        ulElem.find('.fis-state-selected').removeClass('fis-state-selected');
	        $(listItem).addClass('fis-state-selected');
	        var parent = $('.k-state-active', element);
	        if (parent.length > 0) {
	          // highlight childs parent
	          $(parent[0].parentElement).addClass('fis-state-selected');
	        }
	      }
	
	      function onOpen(e) {
	        e.preventDefault();
	        markItemSelected(e.item);
	
	        var path = angular.element(e.item).children('.k-link').attr('href');
	        if (path) {
	          // pass the params to the open call
	          scope.$parent.open(path, {}, scope.secondaryMenuBarItems[0].params);
	          menu.close(); // eslint-disable-line no-use-before-define
	        }
	      }
	
	      var menu = ulElem.kendoMenu({
	        openOnClick: true,
	        select: onOpen,
	        hoverDelay: 10
	      }).data('kendoMenu');
	
	      function addValidItems(children, firstRow) {
	        var ret = [];
	
	        if (children) {
	          _.each(children, function (item) {
	            addItemClasses(item, firstRow);
	            var trustedHTML = $sce.getTrustedHtml(item.label);
	            if (item.items) {
	              var itemClone = _.clone(item);
	
	              itemClone.items = addValidItems(item.items, false);
	              if (item.icon) {
	                delete itemClone.icon;
	                itemClone.spriteCssClass = item.icon;
	              }
	              if (item.label) {
	                item.encoded = false;
	                item.label = trustedHTML;
	                item.text = trustedHTML;
	                if (item.label.indexOf('{{') > -1) {
	                  item.text = item.label = item.label.replace(/{|}/g, '');
	                }
	              }
	              if (itemClone.isValid === true) {
	                ret.push(itemClone);
	              }
	            } else {
	              if ((item.partial || item.action || item.actionController) && item.cls !== 'hide' && (!item.id || item.id.indexOf(':') === -1)) {
	                // eslint-disable-line no-lonely-if
	                if (item.icon) {
	                  item.spriteCssClass = item.icon;
	                }
	                if (item.label) {
	                  item.encoded = false;
	                  item.label = trustedHTML;
	                  item.text = trustedHTML;
	                  if (item.label.indexOf('{{') > -1) {
	                    item.text = item.label = item.label.replace(/{|}/g, '');
	                  }
	                }
	                markHierarchyValid(item);
	                if (item.isValid === true) {
	                  ret.push(item);
	                }
	              }
	            }
	          });
	        }
	        return ret;
	      }
	
	      function filterChildren(children) {
	        if (children) {
	          _.each(children, function (item) {
	            if (item.items) {
	              var itemClone = _.clone(item);
	
	              itemClone.items = filterChildren(item.items);
	
	              if (item.partial && item.cls !== 'hide') {
	                item.isValid = true;
	                markHierarchyValid(item);
	                if (!hasValidChildren(item.items)) {
	                  item.items = null;
	                }
	              }
	            } else {
	              if ((item.partial || item.action || item.actionController) && item.cls !== 'hide') {
	                // eslint-disable-line no-lonely-if
	                item.isValid = true;
	                markHierarchyValid(item);
	              }
	            }
	          });
	        }
	      }
	
	      function hasValidChildren(children) {
	        var isValid = false;
	
	        for (var i = 0; i < children.length; i++) {
	          var child = children[i];
	          if ((child.partial || child.action || hasValidChildren(child.items)) && child.cls !== 'hide') {
	            isValid = true;
	            break;
	          }
	        }
	
	        return isValid;
	      }
	
	      fisPubSubService.subscribe('shell.navChanged', function () {
	        scope.reloadSecondaryMenu = true;
	      }, true);
	
	      fisPubSubService.subscribe('fisAfterNavItemAdded', function () /* nav*/{
	        scope.reloadSecondaryMenu = true;
	      }, true);
	
	      fisPubSubService.subscribe('fisAfterNavItemRemoved', function () /* nav*/{
	        scope.reloadSecondaryMenu = true;
	        menu.element.children().remove();
	      }, true);
	
	      fisPubSubService.subscribe('fisSecondaryMenuClicked', function (navItem) {
	        if (navItem.secondaryNav === 'menubar') {
	          var childrenLength = menu.element.children().length;
	
	          filterChildren(navItem.children);
	          var filteredChildren = addValidItems(navItem.children, true);
	
	          scope.secondaryMenuBarItems = filteredChildren;
	
	          // get the params from navItem and set it on scope
	          if (scope.secondaryMenuBarItems && scope.secondaryMenuBarItems.length > 0 && navItem.params && !jQuery.isEmptyObject(navItem.params)) {
	            scope.secondaryMenuBarItems[0].params = navItem.params;
	          }
	          if (scope.label !== navItem.label) {
	            menu.element.children().remove();
	            childrenLength = 0;
	          }
	
	          if (scope.label !== navItem.label && childrenLength === 0) {
	            menu.append(scope.secondaryMenuBarItems, ulElem);
	          }
	          scope.label = navItem.label;
	
	          if (scope.reloadSecondaryMenu === true) {
	            menu.element.children().remove();
	            menu.append(scope.secondaryMenuBarItems, ulElem);
	            scope.reloadSecondaryMenu = false;
	          }
	
	          if (scope.secondaryMenuBarItems && scope.secondaryMenuBarItems.length > 0) {
	            addActionControllerToMenuItems(filteredChildren, menu.element.children());
	            scope.$parent.$emit(MENU_ADDED_EVENT);
	          } else {
	            scope.$parent.$emit(MENU_REMOVED_EVENT);
	          }
	        } else {
	          scope.secondaryMenuBarItems = null;
	          scope.$parent.$emit(MENU_REMOVED_EVENT);
	        }
	      }, true);
	
	      function addActionControllerToMenuItems(navItems, menuItems) {
	        for (var i = 0; i < navItems.length; i++) {
	          var navItem = navItems[i];
	          var menuItem = menuItems[i];
	          if (navItem.items) {
	            var menuItemChildren = angular.element(menuItem).find('li');
	            addActionControllerToMenuItems(navItem.items, menuItemChildren);
	          } else {
	            var angMenuItem = angular.element(menuItem);
	            var menuItemScope = angMenuItem.scope();
	            if (navItem && menuItem && navItem.actionController) {
	              angMenuItem.attr('ng-controller', navItem.actionController);
	              angMenuItem.attr('ng-click', navItem.action);
	              $compile(angMenuItem)(menuItemScope);
	            }
	          }
	        }
	      }
	
	      function markHierarchyValid(item) {
	        var path = item.path;
	        var tempPath = path;
	        if (tempPath) {
	          tempPath = tempPath.substring(0, tempPath.lastIndexOf('/'));
	          if (tempPath !== '') {
	            var navItem = fisViewService.findNavItem(tempPath);
	            if (navItem) {
	              navItem.isValid = true;
	              markHierarchyValid(navItem);
	            }
	          }
	        }
	      }
	
	      fisPubSubService.subscribe('fisViewPanelReplaceVetoed', function (params) {
	        var navItem = params.viewPanel.navItem;
	        if (navItem && navItem.path) {
	          // Remove fis-state-selected from current selected and add to new current selected navigation item
	          ulElem.find('.fis-state-selected').removeClass('fis-state-selected');
	          ulElem.find('a[href="' + navItem.path + '"]').closest('.fis-secondary-menu-top').addClass('fis-state-selected');
	        }
	      });
	
	      fisPubSubService.subscribe('fisViewPanelClosed', function () /* params*/{
	        if (scope.$parent.viewPanels() && scope.$parent.viewPanels().length === 0) {
	          scope.secondaryMenuBarItems = null;
	          scope.$parent.$emit(MENU_REMOVED_EVENT);
	        }
	      });
	
	      fisPubSubService.subscribe('fisActiveViewPanelChanged', function (params) {
	        var navItem = params.currentNavItem;
	        if (!navItem || navItem.secondaryNav !== 'menubar' && navItem.isStatic !== true) {
	          scope.secondaryMenuBarItems = null;
	          scope.$parent.$emit(MENU_REMOVED_EVENT);
	        }
	        if (navItem && navItem.path) {
	          // Remove fis-state-selected from current selected and add to new current selected navigation item
	          ulElem.find('.fis-state-selected').removeClass('fis-state-selected');
	          ulElem.find('a[href="' + navItem.path + '"]').closest('.fis-secondary-menu-top').addClass('fis-state-selected');
	        }
	      });
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 55 */
/*!*************************!*\
  !*** ./number/index.js ***!
  \*************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _base = __webpack_require__(/*! ../base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _numberField = __webpack_require__(/*! ./number-field.directive */ 56);
	
	var _numberField2 = _interopRequireDefault(_numberField);
	
	var _numberFormat = __webpack_require__(/*! ./number-format.directive */ 57);
	
	var _numberFormat2 = _interopRequireDefault(_numberFormat);
	
	var _numberFormat3 = __webpack_require__(/*! ./number-format.provider */ 58);
	
	var _numberFormat4 = _interopRequireDefault(_numberFormat3);
	
	var _number = __webpack_require__(/*! ./number.filter */ 59);
	
	var _number2 = _interopRequireDefault(_number);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.number', [_base2.default]);
	
	ngModule.directive('fisNumberField', _numberField2.default);
	ngModule.directive('fisNumberFormat', _numberFormat2.default);
	ngModule.provider('fisNumberFormatService', _numberFormat4.default);
	ngModule.filter('fisNumber', _number2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 56 */
/*!******************************************!*\
  !*** ./number/number-field.directive.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisFieldDirectiveFactory", "fisNumberFormatService", "$compile", "fisMemoryUtilService", "$timeout", function (fisFieldDirectiveFactory, fisNumberFormatService, $compile, fisMemoryUtilService, $timeout) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	    clearPlaceholder: true,
	    editTemplate: '<input fis-unique-id fis-input="input" kendo-numeric-text-box k-options="numberOptions" ng-model="<%= field.attrs.ngModelInput %> " k-change="callChangeFn"/>',
	    viewTemplate: '{{numericfieldValue()}}<% if(field.attrs.fisSuffix) {%> {{ fisSuffix }}<% } %>',
	    link: function link(scope, element, attrs) {
	      scope.placeholderValue = '';
	      var inputElem = element.find('input').length > 0 ? element.find('input') : element;
	      var suffixElementCreated = false;
	      var min;
	      var max;
	
	      element.find('input').removeAttr('placeholder');
	
	      // we tie into the input focus so that we can move the cursor to the end of the text on focus
	      // this is due to issues around formatting that result in the cursor being placed in the middle
	      // of the number next to the decimal point.
	      var inputFocus = function inputFocus(event) {
	        // if all the required fields are available
	        if (event && event.currentTarget && event.currentTarget.value) {
	          // we use timeout to allow formatting to happen first, then moving of the cursor
	          $timeout(function () {
	            // we get the length of the text in the input
	            var valLength = event.currentTarget.value.length;
	            event.currentTarget.setSelectionRange(valLength, valLength);
	          }, 0);
	        }
	      };
	      element.find('input').on('focus', inputFocus);
	
	      inputElem.attr('autocomplete', 'off'); // disable auto-fill for Edge browser
	      var ngModel = inputElem.controller('ngModel');
	
	      function parser(value) {
	        if (value === '') {
	          return '';
	        } else {
	          // eslint-disable-line no-else-return
	          // the parsefloat function expects the decimal point to be a period
	          // we have to manually substitute here
	          if (value.indexOf(',') >= 0) {
	            value = value.replace(',', '.');
	          }
	          var parsedVal = parseFloat(value);
	          if (!_.isUndefined(attrs.fisNumberFormat) && attrs.fisNumberFormat.indexOf('xp') !== -1) {
	            parsedVal = parsedVal ? parsedVal / 100 : parsedVal;
	          }
	          // the following calculation is required due to a native floating point precision issue
	          // example 0.1234/100 will result into 0.001239999999, 0.1+0.2 will be 0.300000000004
	          // refer to http://stackoverflow.com/questions/588004/is-floating-point-math-broken
	          parsedVal = +parsedVal.toFixed(scope.numberOptions.decimals); // eslint-disable-line no-implicit-coercion
	          return _.isNaN(parsedVal) ? undefined : parsedVal;
	        }
	      }
	
	      ngModel.$formatters.push(function (val) {
	        if (_.isUndefined(val)) {
	          var widget = element.find('input[kendo-numeric-text-box]').data('kendoNumericTextBox');
	          if (widget) {
	            widget.value(null);
	          }
	          return null;
	        } else {
	          // eslint-disable-line no-else-return
	          if (!_.isUndefined(attrs.fisNumberFormat) && attrs.fisNumberFormat.indexOf('xp') !== -1) {
	            // eslint-disable-line no-lonely-if
	            if (val === null) {
	              return null;
	            } else {
	              // eslint-disable-line no-else-return
	              return val * 100;
	            }
	          }
	        }
	        return val;
	      });
	
	      // Add validators for min and max
	      ngModel.$validators.min = function (value) {
	        if (!_.isUndefined(attrs.fisNumberFormat) && attrs.fisNumberFormat.indexOf('xp') !== -1) {
	          value *= 100;
	        }
	        if (!_.isUndefined(min) && value < min) {
	          return false;
	        }
	        return true;
	      };
	
	      ngModel.$validators.max = function (value) {
	        if (!_.isUndefined(attrs.fisNumberFormat) && attrs.fisNumberFormat.indexOf('xp') !== -1) {
	          value *= 100;
	        }
	        if (!_.isUndefined(max) && value > max) {
	          return false;
	        }
	        return true;
	      };
	
	      ngModel.$parsers.push(parser);
	
	      scope.numberOptions = {
	        format: attrs.fisNumberFormat || fisNumberFormatService.getDefaultFormat(),
	        decimals: _.isUndefined(attrs.fisDecimals) ? 20 : attrs.fisDecimals,
	        culture: attrs.fisLocale,
	        step: attrs.step || 1,
	        spinners: getBooleanFalseValue(attrs.spinners),
	        min: null,
	        max: null,
	        spin: function spin(e) {
	          // console.log('spin fired on: '+e.sender.element.attr('fisid'));
	          // We force the spin to trigger a change
	          // stops need for debounce setting, or to manully update the model value
	          // only negative is a widget refresh that occurs while clicking on the new row,
	          // but its better than an infinite spin
	          if (e.sender && e.sender.element) {
	            e.sender.element.trigger('change');
	          }
	        }
	      };
	
	      scope.numericfieldValue = function () {
	        var modelValue = scope.$eval(attrs.ngModelInput);
	        var ret = '';
	        if (_.isNumber(modelValue)) {
	          if (!_.isUndefined(attrs.fisNumberFormat) && attrs.fisNumberFormat.indexOf('xp') !== -1) {
	            modelValue = modelValue ? modelValue * 100 : modelValue;
	          }
	          ret = fisNumberFormatService.formatNumber(modelValue, scope.fisNumberFormat, scope.fisLocale);
	        } else if (!_.isUndefined(modelValue)) {
	          ret = modelValue;
	        }
	        return ret;
	      };
	
	      scope.$watch('numberOptions', function (numberOptions) {
	        executeAfterWidgetCreation(function (widget) {
	          if (numberOptions) {
	            widget.setOptions(numberOptions);
	          }
	          var value = ngModel.$modelValue;
	          if (!_.isUndefined(attrs.fisNumberFormat) && attrs.fisNumberFormat.indexOf('xp') !== -1 && value) {
	            value *= 100;
	          }
	          widget._change(value);
	        });
	      }, true);
	
	      scope.fisSuffix = attrs.fisSuffix;
	      attrs.$observe('ngChangeInput', function (newValue) {
	        scope.changeInputFn = scope[newValue];
	      });
	      scope.callChangeFn = function (val) {
	        if (scope.changeInputFn) {
	          scope.changeInputFn(val);
	        }
	      };
	      function createSuffixElement() {
	        var inputParent = inputElem.parent();
	        inputParent.find('.k-select').wrap('<span class="fis-number-field-suffix-wrap"></span>');
	        var compiled = $compile('<span ng-if="fisSuffix" class="add-on" title="{{fisSuffix}}">{{ fisSuffix }}</span>')(scope);
	        inputParent.find('.fis-number-field-suffix-wrap').prepend(compiled);
	      }
	
	      function getEvaluatedValue(value, callFn) {
	        var returnValue = callFn(value);
	        if (_.isNaN(returnValue) || _.isUndefined(returnValue)) {
	          returnValue = scope.$eval(value);
	        }
	        return returnValue;
	      }
	      attrs.$observe('fisDecimals', function (value) {
	        if (!_.isUndefined(value)) {
	          var parsedValue = getEvaluatedValue(value, getParsedValue);
	          scope.numberOptions.decimals = _.isUndefined(parsedValue) ? 20 : parsedValue;
	        }
	      });
	
	      attrs.$observe('step', function (value) {
	        if (!_.isUndefined(value)) {
	          scope.numberOptions.step = getEvaluatedValue(value, getParsedValue) || 1;
	        }
	      });
	
	      attrs.$observe('minInput', function (value) {
	        if (!_.isUndefined(value)) {
	          min = getEvaluatedValue(value, parseFloat);
	        }
	      });
	      attrs.$observe('maxInput', function (value) {
	        if (!_.isUndefined(value)) {
	          max = getEvaluatedValue(value, parseFloat);
	        }
	      });
	
	      attrs.$observe('spinners', function (value) {
	        if (!_.isUndefined(value)) {
	          // eslint-disable-line no-negated-condition
	          scope.numberOptions.spinners = getBooleanFalseValue(value);
	        } else {
	          scope.numberOptions.spinners = true;
	        }
	      });
	
	      attrs.$observe('placeholderInput', function (value) {
	        executeAfterWidgetCreation(function () {
	          if (!_.isUndefined(value) && value !== '') {
	            element.find('input:eq(0)').attr('placeholder', value);
	          } else {
	            // maybe remove the placeholder attr if it goes back to empty state?
	          }
	        });
	      });
	
	      attrs.$observe('readonlyInput', function (value) {
	        if (!_.isUndefined(value)) {
	          value = getParsedValue(value, false);
	          executeAfterWidgetCreation(function (widget) {
	            if (widget) {
	              widget.readonly(value);
	            }
	          });
	        }
	      });
	      function getParsedValue(value, defaultValue) {
	        try {
	          value = JSON.parse(value);
	        } catch (e) {
	          value = defaultValue;
	        }
	        return value;
	      }
	
	      function executeAfterWidgetCreation(callbackFn) {
	        //  element.find('input[kendo-numeric-text-box]').kendoNumericTextBox(scope.numberOptions);
	        var kwidget = element.find('input[kendo-numeric-text-box]').data('kendoNumericTextBox');
	        if (kwidget) {
	          callbackFn(kwidget);
	        } else {
	          scope.$on('kendoWidgetCreated', function (event, widget) {
	            if (widget) {
	              callbackFn(widget);
	            }
	          });
	        }
	        /*
	        Ensures that single quotes are removed from fis-number-field placeholder literals
	        that have spaces, e.g. Is equal
	        SDHTML-9783
	        TODO we need to get rid of this, we have access to the change and spin events on kendo,
	        so we should try adjust the value there...
	         */
	        $timeout(function () {
	          var inputs = element.find('input');
	          _.each(inputs, function (input) {
	            var placeholder = $(input).attr('placeholder');
	            if (!_.isUndefined(placeholder) && placeholder !== '') {
	              var newPlace = placeholder.replace(/\'/g, ''); // eslint-disable-line no-useless-escape
	              if (newPlace !== '') {
	                $(input).attr('placeholder', newPlace);
	              }
	              newPlace = null;
	            }
	            placeholder = null;
	          });
	        });
	      }
	
	      /*
	      Returns boolean equivalent of string value 'false'
	       */
	      function getBooleanFalseValue(val) {
	        return val === 'false' ? false : val;
	      }
	
	      attrs.$observe('fisSuffix', function (value) {
	        executeAfterWidgetCreation(function (widget) {
	          if (widget) {
	            scope.fisSuffix = value;
	            if (!_.isUndefined(value)) {
	              if (!suffixElementCreated && value) {
	                createSuffixElement();
	                suffixElementCreated = true;
	              }
	            }
	          }
	        });
	      });
	
	      attrs.$observe('fisSize', function (value) {
	        executeAfterWidgetCreation(function () {
	          var inputParent = inputElem.parent();
	          inputParent.addClass('input-append');
	          if (attrs.fisSize) {
	            // fix width
	            inputParent.addClass('input-' + value);
	            inputParent.find('input').addClass('input-' + value);
	          } else {
	            inputParent.addClass('input-large');
	            inputParent.find('input').addClass('input-large');
	          }
	        });
	      });
	
	      scope.$watch('fisDisabled', function (value) {
	        if (!_.isUndefined(value)) {
	          value = getParsedValue(value, false);
	          executeAfterWidgetCreation(function (widget) {
	            if (widget) {
	              widget.enable(!value);
	            }
	          });
	        }
	      });
	      if (fis.initParams().appStage === 'T') {
	        executeAfterWidgetCreation(function () {
	          element.find('.k-icon.k-i-arrow-60-up').attr('fisid', inputElem.attr('fisid') + '_increaseNumberButton');
	          element.find('.k-icon.k-i-arrow-60-down').attr('fisid', inputElem.attr('fisid') + '_decreaseNumberButton');
	          element.find('input:eq(0)').attr('fisid', inputElem.attr('fisid') + '_formattedNumberField');
	        });
	      }
	      scope.$on('$destroy', function () {
	        element.find('input').off('focus', inputFocus);
	        var kendoWidget = element.find('input[kendo-numeric-text-box]').data('kendoNumericTextBox');
	        if (kendoWidget) {
	          kendoWidget.destroy();
	        }
	      });
	    }
	  });
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 57 */
/*!*******************************************!*\
  !*** ./number/number-format.directive.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$filter", "fisNumberFormatService", function ($filter, fisNumberFormatService) {
	  'ngInject';
	
	  return {
	    link: function link(scope, element, attributes) {
	      var inputElem = element.find('input').length > 0 ? element.find('input') : element;
	
	      var isKendoNumericTextBox = !_.isUndefined($(inputElem).attr('kendo-numeric-text-box'));
	      if (!isKendoNumericTextBox) {
	        var ngModel = inputElem.controller('ngModel');
	        if (!ngModel) {
	          ngModel = element.controller('ngModel');
	        }
	        var numberFormatter = function numberFormatter(value) {
	          var ret = '';
	
	          // Only format if we actually have a value
	          if (value) {
	            ret = fisNumberFormatService.formatNumber(ngModel.$modelValue, scope.fisNumberFormat, scope.fisLocale);
	          }
	          return ret;
	        };
	        ngModel.$formatters.unshift(numberFormatter);
	
	        var numberParser = function numberParser(viewValue) {
	          var num;
	
	          if (viewValue) {
	            if (_.isNumber(viewValue)) {
	              num = viewValue;
	            } else {
	              num = kendo.parseFloat(viewValue, attributes.fisLocale);
	            }
	            var widget = inputElem.data('kendoNumericTextBox');
	            if (widget) {
	              if (_.isNumber(widget.options.decimals) && widget.options.decimals > 0) {
	                num = num.toFixed(widget.options.decimals);
	              }
	              if (_.isNumber(widget.options.min) && num < widget.options.min) {
	                widget.value(null);
	              }
	              if (_.isNumber(widget.options.max) && num > widget.options.max) {
	                widget.value(null);
	              }
	            }
	            return num;
	          }
	
	          return viewValue;
	        };
	        ngModel.$parsers.unshift(numberParser);
	
	        // This overwrites the field value function used in the view template
	        scope.fieldValue = function () {
	          var ret = '';
	          if (_.isNumber(ngModel.$modelValue)) {
	            ret = fisNumberFormatService.formatNumber(ngModel.$modelValue, scope.fisNumberFormat, scope.fisLocale);
	          } else if (!_.isUndefined(ngModel.$modelValue)) {
	            ret = ngModel.$modelValue;
	          }
	          return ret;
	        };
	      }
	
	      attributes.$observe('fisLocale', function (value) {
	        scope.fisLocale = value;
	        if (scope.numberOptions) {
	          scope.numberOptions.culture = value;
	        }
	        if (ngModel && ngModel.$modelValue) {
	          // eslint-disable-line block-scoped-var
	          // Change model Value so angular triggers a reformat
	          // This does not change the actual value of the ngModel
	          ngModel.$modelValue += 1; // eslint-disable-line block-scoped-var
	        }
	      });
	
	      attributes.$observe('fisNumberFormat', function (val) {
	        var userFormat = val;
	        if (val.indexOf('sp') !== -1 || val.indexOf('xp') !== -1) {
	          var format = val.substring(2);
	          try {
	            if (format !== '') {
	              // eslint-disable-line no-negated-condition
	              val = '#.';
	              var decimals = parseInt(format); // eslint-disable-line radix
	              if (_.isNaN(decimals)) {
	                throw new Error('Invalid number format: ' + userFormat);
	              }
	              for (var i = 0; i < decimals; i++) {
	                val += '#';
	              }
	            } else {
	              val = '#';
	            }
	            val += ' \\%';
	          } catch (err) {
	            throw new Error('Invalid number format: ' + userFormat);
	          }
	        }
	        if (_.isEmpty(val)) {
	          // the number entered should be displayed according to default formating if fis-number-format=""
	          val = fisNumberFormatService.getDefaultFormat();
	        }
	        scope.fisNumberFormat = val;
	        if (scope.numberOptions) {
	          scope.numberOptions.format = val;
	        }
	        if (ngModel && ngModel.$modelValue) {
	          // eslint-disable-line block-scoped-var
	          // Change model Value so angular triggers a reformat
	          // This does not change the actual value of the ngModel
	          ngModel.$modelValue += 1; // eslint-disable-line block-scoped-var
	        }
	      });
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 58 */
/*!******************************************!*\
  !*** ./number/number-format.provider.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  /**
	   * @private
	   */
	
	  var self = this;
	
	  /**
	   * @name $get
	   * @methodOf fisNumberFormatServiceProvider
	   * @description <p>Factory method to create instance of fisNumberFormatService.</p>
	   */
	  self.$get = ['fisI18nService', 'fisPubSubService', 'fisConfig', function (fisI18nService, fisPubSubService, fisConfig) {
	    /**
	     * @private
	     */
	    var service = {}; // to be returned
	
	    var defaultFormat = '#.####################';
	
	    if (!angular.isUndefined(fisConfig.widgets) && !angular.isUndefined(fisConfig.widgets.fisNumberFormat) && !angular.isUndefined(fisConfig.widgets.fisNumberFormat.defaultFormat)) {
	      defaultFormat = fisConfig.widgets.fisNumberFormat.defaultFormat;
	    }
	
	    function _getLocale(locale) {
	      var ret;
	
	      if (locale) {
	        ret = locale;
	      } else {
	        // empty locale, use the one from the i18n service
	        ret = fisI18nService.locale();
	      }
	
	      return ret;
	    }
	
	    service.getDefaultLocale = function () {
	      return _getLocale();
	    };
	
	    service._getDefaultFormatString = function () {
	      var ret;
	
	      if (locale) {
	        // eslint-disable-line no-undef
	        ret = locale; // eslint-disable-line no-undef
	      } else {
	        // empty locale, use the one from the i18n service
	        ret = fisI18nService.locale();
	      }
	
	      return ret;
	    };
	
	    service.getDefaultFormat = function () {
	      return defaultFormat;
	    };
	
	    /**
	     * @name formatNumber
	     * @methodOf fisNumberFormatService
	     * @param number The number to format. If the number is empty, an empty string is returned.
	     * @param formatString The string to use for the kendo formatting. If empty, the currently configured default value is used.
	     * @param locale The locale to use for the formatting. If empty, the currently configured locale is used.
	     * @description <p>Returns the formatted number</p>
	     */
	    service.formatNumber = function (number, formatString, locale) {
	      if (_.isString(number)) {
	        var parsedValue = kendo.parseFloat(number);
	        if (_.isNumber(parsedValue)) {
	          number = parsedValue;
	        }
	      }
	
	      if (!_.isNumber(number) || _.isNaN(number)) {
	        return '';
	      }
	
	      if (_.isUndefined(formatString) || formatString.length === 0) {
	        formatString = defaultFormat;
	      }
	
	      if (angular.isString(formatString) && (formatString.indexOf('xp') === 0 || formatString.indexOf('sp') === 0)) {
	        formatString = service.getCustomFormat(formatString);
	      }
	      var formattedValue = kendo.toString(number, formatString, _getLocale(locale));
	
	      return formattedValue;
	    };
	
	    service.getCustomFormat = function (val) {
	      if (val.indexOf('xp') === 0) {
	        return val.replace('xp', 'p');
	      }
	      var format = val.substring(2);
	      try {
	        if (format !== '') {
	          // eslint-disable-line no-negated-condition
	          val = '#.';
	          var decimals = parseInt(format); // eslint-disable-line radix
	          if (_.isNaN(decimals)) {
	            throw new Error('Invalid number format: ' + userFormat); // eslint-disable-line no-undef
	          }
	          for (var i = 0; i < decimals; i++) {
	            val += '#';
	          }
	        } else {
	          val = '#';
	        }
	        val += ' \\%';
	      } catch (err) {
	        throw new Error('Invalid number format: ' + userFormat); // eslint-disable-line no-undef
	      }
	      return val;
	    };
	    return service;
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 59 */
/*!*********************************!*\
  !*** ./number/number.filter.js ***!
  \*********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisNumberFormatService", function (fisNumberFormatService) {
	  'ngInject';
	
	  return function (number, format, locale) {
	    return fisNumberFormatService.formatNumber(number, format, locale);
	  };
	}];

/***/ }),
/* 60 */
/*!***********************!*\
  !*** ./tabs/index.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _base = __webpack_require__(/*! ../base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _data = __webpack_require__(/*! ../data */ 9);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _overflow = __webpack_require__(/*! ./overflow.service */ 61);
	
	var _overflow2 = _interopRequireDefault(_overflow);
	
	var _tabbedComponentList = __webpack_require__(/*! ./tabbed-component-list.directive */ 62);
	
	var _tabbedComponentList2 = _interopRequireDefault(_tabbedComponentList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.tabs', [_base2.default, _data2.default]);
	
	ngModule.service('fisOverflowService', _overflow2.default);
	ngModule.directive('fisTabbedComponentList', _tabbedComponentList2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 61 */
/*!**********************************!*\
  !*** ./tabs/overflow.service.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var const_visible_tab = 'visible'; // eslint-disable-line camelcase
	  var const_overflow_tab = 'overflow'; // eslint-disable-line camelcase
	  var self = this;
	  /**
	   * @name calculateVisibleTab
	   * @description Take a list of  tab objects and returns ones that are visible and ones in the overflow
	   * @param [tabs,threshold] pass in a list of tabs,and the threshold that once exceeded the overflow will kick in
	   */
	  this.calculateVisibleTabs = function (tabs, threshold) {
	    var retObj = {};
	    retObj[const_overflow_tab] = []; // eslint-disable-line camelcase
	    retObj[const_visible_tab] = []; // eslint-disable-line camelcase
	    var totalSpaceTaken = 0;
	    var tabIndex = 0;
	    var activeTabIndex = -1; // eslint-disable-line no-unused-vars
	    var availableSpace = threshold;
	    _.each(tabs, function (tab) {
	      if (self.validateTab(tab) === false) {
	        throw new Error('Invalid overflow tab object provided');
	      }
	      totalSpaceTaken += tab.width;
	      availableSpace -= tab.width;
	      tab.index = tabIndex;
	      var greater = threshold > totalSpaceTaken; // eslint-disable-line no-unused-vars
	      if (threshold > totalSpaceTaken) {
	        retObj[const_visible_tab].push(tab);
	      } else {
	        if (tab.active === false) {
	          // eslint-disable-line no-lonely-if
	          retObj[const_overflow_tab].push(tab);
	          activeTabIndex = tabIndex;
	          availableSpace += tab.width;
	          totalSpaceTaken -= tab.width;
	        }
	      }
	      tabIndex++;
	    });
	
	    // there is still no space even when the tabs have been moved to the overflow tabs
	    // this is as a result of the active tab which was left behind, as it cannot be put into the overflow menu
	    if (availableSpace <= 0) {
	      // only move items from the beginning  up until the active tab index
	      var visibleTabs = retObj[const_visible_tab];
	
	      while (availableSpace <= 0) {
	        var lastVisibleIndex = visibleTabs.length - 1;
	        var tmpTab = visibleTabs[lastVisibleIndex];
	        if (!_.isUndefined(tmpTab)) {
	          // eslint-disable-line no-negated-condition
	          availableSpace += tmpTab.width;
	          retObj[const_overflow_tab].push(tmpTab);
	          retObj[const_visible_tab].splice(lastVisibleIndex, 1);
	        } else {
	          break;
	        }
	      }
	    }
	
	    return retObj;
	  };
	
	  /**
	   * @name isSpaceAvailable
	   * @description Take a list of  tab objects and the threshold and return  a 'true' if there is space and a 'false' if there is no space
	   * @param [tabs,threshold] pass in a list of tabs,with the available space and the threshold
	   */
	  this.isSpaceAvailable = function (tabs, threshold) {
	    var totalSpaceTaken = 0;
	    _.each(tabs, function (tab) {
	      if (self.validateTab(tab) === false) {
	        throw new Error('Invalid overflow tab object provided');
	      }
	      totalSpaceTaken += tab.width;
	    });
	
	    return threshold > totalSpaceTaken;
	  };
	
	  /**
	   * @name availableSpace
	   * @description Take a list of  tab objects and the threshold and return  the amount of space left
	   * @param [tabs,threshold] pass in a list of tabs,with the available space and the threshold
	   */
	  this.availableSpace = function (tabs, threshold) {
	    var totalSpaceTaken = 0;
	    _.each(tabs, function (tab) {
	      if (self.validateTab(tab) === false) {
	        throw new Error('Invalid overflow tab object provided');
	      }
	      totalSpaceTaken += tab.width;
	    });
	
	    return threshold - totalSpaceTaken;
	  };
	
	  /**
	   * @name validateTab
	   * @description Takes an object as input and validates if the object is in the correct format
	   * @param [tab] pass in an object that will be validated to see if it is in the correct tab object format
	   */
	  this.validateTab = function (tab) {
	    return !_.isUndefined(tab.active) && !_.isUndefined(tab.width);
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 62 */
/*!*************************************************!*\
  !*** ./tabs/tabbed-component-list.directive.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* global jQuery, _, $ */
	
	
	exports.default = ["fisKendoDataSourceFactory", "$compile", "$timeout", "$parse", "$window", "fisOverflowService", "fisUtilService", "fisUniqueIdService", "fisPubSubService", "fisMemoryUtilService", "fisKendoUtilService", "$sanitize", function (fisKendoDataSourceFactory, $compile, $timeout, $parse, $window, fisOverflowService, fisUtilService, fisUniqueIdService, fisPubSubService, fisMemoryUtilService, fisKendoUtilService, $sanitize) {
	  'ngInject';
	
	  // CONSTANTS
	
	  var overflow = {
	    tabMaxWidth: 220,
	    tabsWidthBuffer: 90,
	    tabstripWidthBuffer: 140,
	    tabstripWidthBufferMaxWidthTab: 240,
	    tabstripWidthBufferAfterResize: 280
	  };
	
	  function exposeWidgetAPI(scope, attrs, kendoTabStrip) {
	    // Exposing tabStrip
	    var myStrip = $parse(attrs.fisTabbedComponentList).assign;
	    if (myStrip) {
	      // fisTabbedComponentList has its own scope, exposing tabbedComponentList API to its parent scope
	      myStrip(scope.$parent, kendoTabStrip);
	    }
	
	    // Exposing API:
	    kendoTabStrip.overflowTabs = scope.overflowTabs;
	    kendoTabStrip.closeTab = scope.closeTab;
	    kendoTabStrip.addTab = scope.addTab;
	    kendoTabStrip.moveOverflowTabToTabstrip = scope.moveOverflowTabToTabstrip;
	  }
	
	  return {
	
	    restrict: 'AEC',
	
	    require: ['fisData', '?fisRefresh'],
	
	    template: '<div class="kendo-tab-strip" k-ng-delay="noptions"></div>',
	
	    scope: {
	      callBackFn: '&fisOnClose'
	    },
	
	    link: function link(scope, element, attrs, ctrls) {
	      // make sure the tab index is always set by default.
	      scope.openTabIndex = 0;
	      if (isNaN(parseInt(attrs.fisOpenTabIndex, 10))) {
	        // now check if its a variable
	        try {
	          // It's a variable reference or function, so evaluate it
	          scope.openTabIndex = $parse(attrs.fisOpenTabIndex)(scope);
	        } catch (e) {
	          // Expression is not parse-able, throw error on console if required or
	          // pass it to error handling callback function if provided on scope
	          /* if (!_.isUndefined(scope.onErrorFn) && _.isFunction(scope.onErrorFn)) {
	              scope.onErrorFn({data: e, status: null, errorType: "Non parse-able expression"});
	          } else {
	              //throw error on console
	              throw new Error(e);
	          }*/
	        }
	      } else {
	        scope.openTabIndex = attrs.fisOpenTabIndex ? Number(attrs.fisOpenTabIndex) : 0;
	      }
	
	      var validTabPositions = ['left', 'right', 'top', 'bottom'];
	      var tabPosition = validTabPositions.indexOf(attrs.fisTabPosition) > -1 ? attrs.fisTabPosition : 'top';
	
	      // make sure that closeable is always set by default
	      scope.closeable = attrs.fisCloseable && attrs.fisCloseable !== 'false' ? true : false; // eslint-disable-line no-unneeded-ternary
	
	      var fisData = ctrls[0];
	      var fisRefresh = ctrls[1];
	
	      scope.overflowTabs = {};
	
	      var getTabStripItemsElement = function getTabStripItemsElement(parent) {
	        return (parent || element).find('.k-tabstrip-items:first');
	      };
	
	      scope.ready = true;
	      scope.resizeTimeOut = {};
	      // check for fis-on-select and store callback function for further processing
	      if (!_.isUndefined(attrs.fisOnSelect)) {
	        var funcName = attrs.fisOnSelect.substring(0, attrs.fisOnSelect.indexOf('('));
	        scope.onSelect = funcName;
	        scope.firstSelectDone = false;
	      }
	
	      var dataSource = fisKendoDataSourceFactory.createListDataSource(fisData.fetchData);
	
	      // this is to determine if there is a need to add the fis-hotkey directive
	      dataSource.bind('requestEnd', function (e) {
	        var respData = e.response.data;
	        var respDataLength = respData.length;
	        var shortCuts = '';
	        _.each(respData, function (resp, index) {
	          if (!_.isUndefined(resp.hotkey) && !_.isNull(resp.hotkey)) {
	            shortCuts += resp.hotkey;
	
	            if (index + 1 !== respDataLength) {
	              shortCuts += ',';
	            }
	          }
	        });
	
	        // add the fis-hotkey directive if this condition is true, by getting a hold of the compiled template and adding
	        // the fis-hotkey and further compiling
	        if (shortCuts !== '') {
	          var tabElement = element.find('.kendo-tab-strip');
	          var hotKeyElem = $('<div></div>');
	          hotKeyElem.attr('fis-on-hotkey-event', 'openTabByHotkey(e)');
	          hotKeyElem.attr('fis-hotkey', shortCuts);
	          hotKeyElem.attr('fis-custom-hotkey', 'false');
	          $compile(hotKeyElem)(scope);
	          tabElement.append(hotKeyElem);
	        }
	      });
	      var viewWindow = angular.element($window);
	
	      scope.openTabByHotkey = function () {
	        var hotkey = this.fisHotKeyPressedKey;
	
	        if (!_.isUndefined(hotkey)) {
	          var index = getTabStripItemsElement().find('li[hotkey="' + hotkey + '"]').index();
	          kendoTabstrip.select(index); // eslint-disable-line no-use-before-define
	        }
	      };
	
	      var getOverflowTabItemIndexes = function getOverflowTabItemIndexes() {
	        var tabstripId;
	        for (var prop in scope.overflowTabs) {
	          // eslint-disable-line guard-for-in
	          tabstripId = prop;
	        }
	        var overflowTabs = scope.overflowTabs[tabstripId] ? scope.overflowTabs[tabstripId] : [];
	
	        var overflowTabIndices = [];
	        _.each(kendoTabstrip.items(), function (item) {
	          // eslint-disable-line no-use-before-define
	          var itemIndex = jQuery(item).attr('index');
	          if (itemIndex) {
	            for (var i = 0; i < overflowTabs.length; i++) {
	              if (item.title === overflowTabs[i]) {
	                overflowTabIndices.push(parseInt(itemIndex, 10));
	                break;
	              }
	            }
	          }
	        });
	        return overflowTabIndices;
	      };
	
	      var itemOverflowTabIndex = function itemOverflowTabIndex(index) {
	        var overflowTabItemIndex = getOverflowTabItemIndexes();
	        for (var i = 0; i < overflowTabItemIndex.length; i++) {
	          if (overflowTabItemIndex[i] === index) {
	            return i;
	          }
	        }
	      };
	
	      var getNonOverflowTabItemIndexes = function getNonOverflowTabItemIndexes() {
	        var tabstripId;
	        for (var prop in scope.overflowTabs) {
	          // eslint-disable-line guard-for-in
	          tabstripId = prop;
	        }
	        var overflowTabs = scope.overflowTabs[tabstripId] ? scope.overflowTabs[tabstripId] : [];
	
	        var allItemIndices = [];
	        var overflowTabIndices = [];
	        _.each(kendoTabstrip.items(), function (item) {
	          // eslint-disable-line no-use-before-define
	          var itemIndex = jQuery(item).attr('index');
	          if (itemIndex) {
	            allItemIndices.push(parseInt(itemIndex, 10));
	            for (var i = 0; i < overflowTabs.length; i++) {
	              if (item.title === overflowTabs[i]) {
	                overflowTabIndices.push(parseInt(itemIndex, 10));
	                break;
	              }
	            }
	          }
	        });
	
	        return _.difference(allItemIndices, overflowTabIndices);
	      };
	
	      // To store previous tab index
	      var previousTabIndex = -1;
	      var indexToSelect = -1;
	      var selectTimeout = null;
	
	      var getTabFromIndex = function getTabFromIndex(tabIndex) {
	        var requiredItem;
	        _.each(kendoTabstrip.items(), function (item) {
	          // eslint-disable-line no-use-before-define
	          var itemIndex = parseInt(jQuery(item).attr('index'), 10);
	          if (itemIndex === tabIndex) {
	            requiredItem = item;
	          }
	        });
	        return requiredItem;
	      };
	
	      var fetchRequiredItem = function fetchRequiredItem(action) {
	        var nonOverflowItemIndex = getNonOverflowTabItemIndexes();
	        if (action === 'home') {
	          indexToSelect = nonOverflowItemIndex[0];
	        } else if (action === 'end') {
	          indexToSelect = nonOverflowItemIndex[nonOverflowItemIndex.length - 1];
	        } else if (action === 'prev') {
	          if (previousTabIndex === nonOverflowItemIndex[0]) {
	            indexToSelect = nonOverflowItemIndex[nonOverflowItemIndex.length - 1];
	          } else {
	            indexToSelect = nonOverflowItemIndex[nonOverflowItemIndex.indexOf(previousTabIndex) - 1];
	          }
	        } else {
	          if (previousTabIndex === nonOverflowItemIndex[nonOverflowItemIndex.length - 1]) {
	            // eslint-disable-line no-lonely-if
	            indexToSelect = nonOverflowItemIndex[0];
	          } else {
	            indexToSelect = nonOverflowItemIndex[nonOverflowItemIndex.indexOf(previousTabIndex) + 1];
	          }
	        }
	        previousTabIndex = indexToSelect;
	        return getTabFromIndex(indexToSelect);
	      };
	
	      var getItem = function getItem(action) {
	        var item = fetchRequiredItem(action);
	        if (jQuery(item).hasClass('k-state-disabled')) {
	          item = getItem(action);
	        }
	        return item;
	      };
	
	      var keyDownHandler = function keyDownHandler(e) {
	        var key = e.keyCode;
	        var action;
	
	        if (jQuery(e.target).attr('data-role') !== 'tabstrip') {
	          return;
	        }
	
	        switch (key) {// eslint-disable-line default-case
	          case 35:
	            action = 'end';
	            break;
	          case 36:
	            action = 'home';
	            break;
	          case 37:
	          case 38:
	            action = 'prev';
	            break;
	          case 39:
	          case 40:
	            action = 'next';
	            break;
	        }
	
	        if (action) {
	          e.stopPropagation();
	          var itemToSelect = getItem(action);
	          kendoTabstrip.select(itemToSelect); // eslint-disable-line no-use-before-define
	        }
	      };
	
	      // Bind keydown handler to handle keyboard navigation
	      element.on('keydown', keyDownHandler);
	
	      function onSelect(e) {
	        var previousOpenIndex = previousTabIndex;
	        var itemIndex = jQuery(e.item).attr('index');
	        if (itemIndex) {
	          previousTabIndex = parseInt(itemIndex, 10);
	          var tabName = e.item.textContent;
	          if ($(e.item).find('.fis-close').length > 0) {
	            tabName = tabName.slice(0, -1).trim();
	          }
	          var contentElement = angular.element(e.contentElement);
	          var partial = _.find(scope.data, function (elem) {
	            var parsedHtmlTabLabel = $.parseHTML(elem.label)[0].data;
	            return parsedHtmlTabLabel === tabName;
	          });
	          if (tabName && tabName !== '') {
	            if (!_.contains(scope.loaded, tabName)) {
	              // eslint-disable-line no-negated-condition
	              var childElem;
	              if (partial && partial.partial) {
	                childElem = $compile('<div><div class="fis-tab-data" ng-include="\'' + fisUtilService.appendCacheQueryParameter(partial.partial) + '\'"></div></div>')(scope.$parent);
	              } else if (partial && partial.template) {
	                childElem = $compile('<div>' + partial.template + '</div>')(scope.$parent);
	              }
	              var childScope = childElem.scope();
	              if (partial && partial.args) {
	                // ... we assign it to the tabArgs attribute so that it becomes available in the tab.
	                childScope.tabArgs = partial.args;
	              } else {
	                childScope.tabArgs = {};
	              }
	
	              contentElement.children().eq(0).remove();
	              contentElement.append(childElem);
	              $compile(contentElement)(scope.$parent);
	              $timeout(function () {
	                scope.$apply();
	              });
	              scope.loaded.push(tabName);
	            } else {
	              // if the tab is already loaded then set the tabArgs correctly on scope
	              if (partial && partial.args) {
	                // eslint-disable-line no-lonely-if
	                $timeout(function () {
	                  contentElement.children().eq(0).scope().tabArgs = partial.args;
	                });
	              } else {
	                $timeout(function () {
	                  contentElement.children().eq(0).scope().tabArgs = {};
	                });
	              }
	            }
	            // invoke callback event with the kendo event object('e')
	            if (!_.isUndefined(scope.onSelect)) {
	              if (scope.firstSelectDone) {
	                var selectFn = scope.$parent.$eval(scope.onSelect);
	                if (selectFn) {
	                  selectFn(e);
	                }
	              } else {
	                scope.firstSelectDone = true;
	              }
	            }
	          }
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, selectTimeout, $timeout);
	
	          fisPubSubService.publish('fisTabbedComponentList.tabChanged', { newIndex: previousTabIndex, oldIndex: previousOpenIndex });
	        }
	      }
	
	      function onShow() {
	        // Broadcast a stretchToBottom command to all subscopes, so potential stretchToBottom directives can do so
	        scope.$parent.$broadcast('stretchToBottom');
	      }
	
	      function addUniqueId(tabItem, contentItem) {
	        var tabElem = angular.element(tabItem);
	        var contentElem = angular.element(contentItem);
	        var itemId = tabElem.text();
	        if (itemId) {
	          contentElem.attr('fis-unique-id', 'content_' + itemId.replace(', ', '_'));
	          $compile(contentItem)(scope.$parent);
	        }
	      }
	
	      function addUniqueIds(kTabStrip) {
	        var tabs = kTabStrip.tabGroup.children();
	        _.each(tabs, function (eachTab, index) {
	          var contentItem = kTabStrip.contentElement(index);
	          addUniqueId(eachTab, contentItem);
	        });
	      }
	
	      attrs.$observe('fisCloseable', function (value) {
	        scope.closeable = JSON.parse(value);
	      });
	
	      attrs.fisOpenTabIndex = attrs.fisOpenTabIndex || '0';
	      attrs.$observe('fisOpenTabIndex', function (value) {
	        // First check whether it's a variable reference instead of a number
	        if (isNaN(parseInt(value, 10))) {
	          try {
	            // It's a variable reference or function, so evaluate it
	            value = $parse(value)(scope);
	          } catch (e) {
	            // Expression is not parse-able, throw error on console if required or
	            // pass it to error handling callback function if provided on scope
	            /* if (!_.isUndefined(scope.onErrorFn) && _.isFunction(scope.onErrorFn)) {
	                scope.onErrorFn({data: e, status: null, errorType: "Non parse-able expression"});
	            } else {
	                //throw error on console
	                throw new Error(e);
	            }*/
	          }
	        }
	
	        // If it's undefined at this point, initialize it to 0
	        if (value === undefined) {
	          value = 0;
	        }
	
	        scope.openTabIndex = value;
	      });
	
	      function handleOverflowIndexSelection(index) {
	        var item = getTabFromIndex(index);
	        if (!_.isUndefined(item)) {
	          scope.moveOverflowTabToTabstripOnClick(null, item.title, scope.overflowTabs);
	        }
	      }
	
	      function handleNonOverflowIndexSelection(index) {
	        var nonOverflowTabIndexes = getNonOverflowTabItemIndexes();
	        if (nonOverflowTabIndexes.indexOf(index) !== -1) {
	          kendoTabstrip.select(index); // eslint-disable-line no-use-before-define
	        }
	      }
	
	      var openIndexWatch = scope.$watch('openTabIndex', function (newIndex) {
	        if (newIndex !== undefined && newIndex !== '') {
	          // eslint-disable-next-line no-use-before-define
	          if (kendoTabstrip.select().length === 0) {
	            // first time selection
	            kendoTabstrip.select(newIndex); // eslint-disable-line no-use-before-define
	          } else {
	            var itemIndexToShow = parseInt(newIndex, 10);
	            if (scope.overflowTabs && scope.overflowTabs.length !== 0) {
	              var overflowIndex = itemOverflowTabIndex(itemIndexToShow);
	              if (!_.isUndefined(overflowIndex)) {
	                // eslint-disable-line no-negated-condition
	                handleOverflowIndexSelection(itemIndexToShow);
	              } else {
	                handleNonOverflowIndexSelection(itemIndexToShow);
	              }
	            } else {
	              handleNonOverflowIndexSelection(itemIndexToShow);
	            }
	          }
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, openIndexWatch);
	
	      var tabstrip = element.find('.kendo-tab-strip');
	
	      tabstrip.kendoTabStrip({
	        select: onSelect,
	        show: onShow,
	        scrollable: false,
	        tabPosition: tabPosition,
	        animation: {
	          open: {
	            effects: 'fadeIn' // recommended by kendo to use if tabPosition property used
	          }
	        }
	      });
	
	      // set kendo tabstrip navigatable as false to disable kendo key handling
	      var setOptionsTimeout = $timeout(function () {
	        kendoTabstrip.setOptions({ navigatable: false }); // eslint-disable-line no-use-before-define
	      });
	      fisMemoryUtilService.cancelTimeoutOnDestroy(scope, setOptionsTimeout, $timeout);
	
	      var kendoTabstrip = tabstrip.data('kendoTabStrip');
	
	      scope.$on('$destroy', function () {
	        // unbind event handlers
	        element.off('keydown', keyDownHandler);
	        viewWindow.unbind('click', clickHandler); // eslint-disable-line no-use-before-define
	        viewWindow.unbind('resize', resizeHandler); // eslint-disable-line no-use-before-define
	        viewWindow.unbind('resizeEnd', resizeEndHandler); // eslint-disable-line no-use-before-define
	        $(window).unbind('scroll', scrollHandler); // eslint-disable-line no-use-before-define
	        // Unsubscribe fisPubSubService
	        unsubscribe(); // eslint-disable-line no-use-before-define
	        // destroy kendoTabstrip
	        fisMemoryUtilService.destroyKendoWidgets(kendoTabstrip);
	        angular.element('ul#overflowContainer' + kendoTabstrip.tabstripId + ':visible').remove();
	      });
	
	      function onDataFetch(fetched) {
	        scope.data = fetched.data;
	        var tabstrip = element.find('.kendo-tab-strip');
	
	        var itemLabels = [];
	
	        scope.loaded = [];
	        scope.isShown = false;
	        // Remove the existing tabs
	        kendoTabstrip.remove(kendoTabstrip.tabGroup.children());
	        var itemCnt = 0;
	        var labelText = [];
	        var labelHotkey = [];
	        _.each(fetched.data, function (dataElement, index) {
	          itemLabels[index] = dataElement.label = $sanitize(dataElement.label);
	          kendoTabstrip.append({
	            text: '<div id="label" class="fis-tabbed-label">' + dataElement.label + '</div>',
	            content: '<div></div>',
	            encoded: false
	          });
	
	          if (_.isUndefined(dataElement.hotkey) || _.isNull(dataElement.hotkey)) {
	            labelText.push(dataElement.label);
	          } else {
	            labelText.push(dataElement.label + ' - ' + dataElement.hotkey);
	            labelHotkey.push(dataElement.hotkey);
	          }
	        });
	
	        var items = getTabStripItemsElement(tabstrip).find('.k-item');
	        _.each(items, function (item) {
	          angular.element(item).attr('title', $.parseHTML(labelText[itemCnt])[0].data);
	          angular.element(item).attr('hotkey', labelHotkey[itemCnt]);
	          angular.element(item).attr('index', itemCnt);
	          itemCnt++;
	        });
	
	        var labels = tabstrip.find('div#label');
	
	        // SDHTML-11965: fisTabbedComponentList - Selectively make few tabs closeable and remaining non-closeable
	        // If the valid(true/false) value is provided in the JSON data for closeable atrribute for tabs, it will get precedence over fisCloseable attribute.
	        _.each(labels, function (label, index) {
	          var closeableVal = scope.data[index].closeable;
	          closeableVal = angular.isDefined(closeableVal) ? JSON.parse(closeableVal) : closeableVal;
	          if (!_.isBoolean(closeableVal)) {
	            var compiledClose = $compile('<span class="fis-cover"><span fis-unique-id class="fis-close" ng-if="closeable" aria-label="close" ng-click=\'close($event)\'>&times;</span></span>')(scope); // eslint-disable-line block-scoped-var
	            angular.element(label).append(compiledClose); // eslint-disable-line block-scoped-var
	          } else if (closeableVal) {
	            var compiledClose = $compile('<span class="fis-cover"><span fis-unique-id class="fis-close" aria-label="close" ng-click=\'close($event)\'>&times;</span></span>')(scope); // eslint-disable-line block-scoped-var, no-redeclare
	            angular.element(label).append(compiledClose); // eslint-disable-line block-scoped-var
	          }
	        });
	
	        kendoTabstrip.select(scope.openTabIndex);
	
	        addUniqueIds(kendoTabstrip);
	
	        exposeWidgetAPI(scope, attrs, kendoTabstrip);
	
	        if (attrs.fisOverflow !== 'false') {
	          /* ********* start building overflow JSON *********/
	
	          var tabstripId = addUniqueTabstripIds(tabstrip); // unique id for each tabstrip
	          var tabsJSON = []; // holds the tabs for each tabstrip in the overflowTabs object
	
	          scope.overflowTabs[tabstripId] = tabsJSON;
	          scope.overflowCaretWidth = '20px';
	
	          /* *********finished building overflow JSON *********/
	          kendoTabstrip.tabstripId = tabstripId;
	          // The overflow
	          kendoTabstrip.append({
	            text: '<div id="overflow' + tabstripId + '" fisid="overflow' + tabstripId + '"><div ng-style="{textAlign:\'center\', width:overflowCaretWidth}" class="dropdown" name="dropdownContainer">' + '<a class="dropdown-toggle fis-tabbed-overflow-menu-caret" ng-click="showOverflowMenu($event,overflowTabs)"><b class="caret" ng-class="caretDirection()"></b></a>' + '<ul class="dropdown-menu pull-right fis-tabbed-overflow-menu-tab-container" name="tabbedComponentListOverflowContainer" id="overflowContainer' + tabstripId + '" role="menu">' + '<li ng-repeat="item in overflowTabs[tabstripId]" class="fis-tabbed-overflow-menu-tab">' + '<div fis-unique-id ng-click=showOverflowTabItem(item) title={{item}} >' + '{{item}}' + '</div>' + '</li>' + '</ul>' + '</div>',
	            content: '',
	            encoded: false
	          });
	
	          if (tabPosition == 'left' || tabPosition == 'right') {
	            // eslint-disable-line eqeqeq
	            scope.overflowCaretWidth = parseFloat(kendoTabstrip.element.find('ul').width());
	          }
	
	          addShowOverflowFunction(tabstripId);
	          addMoveOverflowTabFunction(tabstripId);
	          var reorganizeTimeout = $timeout(function () {
	            addStylingAndUniqeIdToOverflowTab(tabstripId);
	            // bug SDHTML-16444 - CPU utilization issue
	            var visible = scope.$watch(function () {
	              return element.is(':visible');
	            }, function (newValue) {
	              if (newValue === true) {
	                resizeList(); // if browser opens in any mode other than full-size then call resize to add/remove tabs
	              }
	            });
	            fisMemoryUtilService.cancelWatchOnDestroy(scope, visible);
	
	            removeLinksFromOverflowTab(tabstripId); // calling resize here somehow adds links to tabs in menu.
	            hideOverflowIfNoMoreTabs(tabstripId);
	            bindClickToWindow(tabstripId); // hide menu if open and user clicks elsewhere
	          });
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, reorganizeTimeout, $timeout);
	        }
	      }
	
	      /**
	       * @name bindClickToWindow
	       * @param {Number} tabstripId. The ID of the current tabstrip
	       *
	       * @description Binds click event to the browser window. If
	       * the overflow menu is open and the user clicks anywhere else
	       * on the page then the menu is automatically closed
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      var clickHandler = function clickHandler(e) {
	        e.stopPropagation(); // without this, the tabs in the menu become links
	        if (!$(e.target).hasClass('fis-tabbed-overflow-menu-tab-container')) {
	          // we don't want the menu itself to close!
	          hideOverflowMenu(e.data.tabstripId);
	        }
	      };
	
	      function bindClickToWindow(tabstripId) {
	        viewWindow.bind('click', { tabstripId: tabstripId }, clickHandler);
	      }
	
	      /**
	       * @name addStylingToOverflowTab
	       * @param {Number} tabstripId. The ID of the current tabstrip
	       *
	       * @description Floats the overflow tab to the end of the
	       * tabstrip and gives it a unique id.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function addStylingAndUniqeIdToOverflowTab(tabstripId) {
	        var overflowTab = getTabStripItemsElement().find('li.k-last').addClass('fis-tabbed-overflow-container');
	        overflowTab.attr('id', 'overflowTab' + tabstripId + ''); // eslint-disable-line no-implicit-coercion
	      }
	
	      /**
	       * @name removeLinksFromOverflowTab
	       * @param {Number} tabstripId. The ID of the current tabstrip
	       *
	       * @description Ensures that the tabs in the overflow
	       * menu do not have links because these interfere with
	       * the styling.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function removeLinksFromOverflowTab(tabstripId) {
	        $('#overflowContainer' + tabstripId + ' li').each(function () {
	          $(this).find('a').replaceWith(function () {
	            return this.innerHTML;
	          });
	        });
	      }
	
	      /**
	       * @name addShowOverflowFunction
	       * @param {Number} tabstripId. The ID of the current tabstrip
	       *
	       * @description Adds a compiled ng-click function to the overflow
	       * container that enables the display of the overflow menu.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function addShowOverflowFunction(tabstripId) {
	        // eslint-disable-next-line no-implicit-coercion
	        var prevLi = getTabStripItemsElement(tabstrip).find('#overflow' + tabstripId + '').closest('li'); // get the first list item in the overflow for this tabstrip
	        prevLi.attr('ng-click', 'showOverflowMenu($event, overflowTabs)'); // and add an ng-click attribute to it to show the overflow menu
	        var compiledOverflow = $compile(prevLi[0])(scope); // compile
	        angular.element(prevLi).replaceWith(compiledOverflow); // and replace the current DOM element with the compiled element
	      }
	
	      /**
	       * @name addMoveOverflowTabFunction
	       * @param {Number} tabstripId. The ID of the current tabstrip
	       * @description Adds a compiled ng-click function to the overflow tab
	       * that enables the moving of the tab back to the tabstrip.
	       * @methodOf fisTabbedComponentList
	       */
	      function addMoveOverflowTabFunction(tabstripId) {
	        // eslint-disable-next-line no-implicit-coercion
	        var overflowMenu = tabstrip.find('#overflowContainer' + tabstripId + ''); // get the overflow container for this tabstrip (the <ul>)
	        var overflowLi = overflowMenu.closest('li'); // get the list item(s)
	        /*
	         * and add an ng-click attribute to the item(s) to add the selected tab back to tabstrip
	         */
	        overflowLi.attr('ng-click', 'moveOverflowTabToTabstripOnClick($event, item, overflowTabs)');
	        var compiledMenu = $compile('<ul fis-unique-id="fis-overflow-menu_' + tabstripId + '" style="z-index: 1" class="dropdown-menu pull-right fis-tabbed-overflow-menu-tab-container" id="overflowContainer' + tabstripId + '" role="menu"><li sq-unique-id="{{item}}_' + tabstripId + '" title="{{item}}" class="fis-tabbed-label fis-tabbed-overflow-menu-tab" ng-click="moveOverflowTabToTabstripOnClick($event, item, overflowTabs)" ng-repeat="item in viewOverflowTabs(overflowTabs)">{{item}}</li></ul>')(scope);
	        angular.element(overflowMenu).replaceWith(compiledMenu); // and replace the current DOM element with the compile element
	      }
	
	      /**
	       * @name showOverflowMenu
	       * @param {Object} $event. The Event object
	       * @param {Object} overflowTabsObject. The overflowTabs object
	       * @description Gets the overflow container for the relevant tabstrip
	       * and adds it to the DOM.
	       * @methodOf fisTabbedComponentList
	       */
	      scope.showOverflowMenu = function ($event, overflowTabsObject) {
	        if (overflowTabsObject !== undefined) {
	          var tabstripId;
	          for (var prop in overflowTabsObject) {
	            // eslint-disable-line guard-for-in
	            tabstripId = prop; // get the id of the JSON tabstrip object
	          }
	          $event.preventDefault();
	          $event.stopImmediatePropagation();
	          var overflow = $('#overflowContainer' + tabstripId + ''); // eslint-disable-line no-implicit-coercion
	          var windowScrollTop = $(window).scrollTop(); // if window scrolled then need to minus this from the height so that menu stays in correct place
	          var target = $('.fis-tabbed-overflow-menu-caret') && $($event.currentTarget);
	          var offset = target.offset();
	          var left;
	          // + outerHeight() pushes the overflow list beneath the overflow tab and - windowScrollTop ensures menu stays in same place if scrolling down
	          if (tabPosition == 'left' || tabPosition == 'right') {
	            // eslint-disable-line eqeqeq
	            var dd_top = offset.top + target.outerHeight() - windowScrollTop - parseFloat(overflow.height()); // eslint-disable-line camelcase, block-scoped-var
	            if (tabPosition == 'left') {
	              // eslint-disable-line eqeqeq
	              left = target.offset().left;
	            } else {
	              left = target.offset().left - 180;
	            }
	          } else {
	            var dd_top = offset.top + target.outerHeight() - windowScrollTop; // eslint-disable-line camelcase, block-scoped-var, no-redeclare
	            if (tabPosition == 'bottom') {
	              // eslint-disable-line eqeqeq
	              var dd_top = offset.top + target.outerHeight() - windowScrollTop - parseFloat(overflow.height()); // eslint-disable-line camelcase, block-scoped-var, no-redeclare
	            }
	            left = target.offset().left - 180;
	          }
	
	          $('body').append(overflow); // must append it to the body for IE to work
	          overflow.toggle();
	          // this value + the others (220) must be here, they cannot be constants. If they are, when sidebar is unpinned, they are undefined!
	
	          overflow.css({
	            'width': 220 + 'px', // tabs longer than this have an ellipsis and a tooltip
	            'top': dd_top + 'px', // eslint-disable-line camelcase, block-scoped-var
	            'position': 'fixed', // must be fixed so that it follows the window contract and expand
	            'left': left, // right-aligned with right border of overflow container
	            'z-index': 10009 // if list in a modal dialog then it needs a higher z-index
	          });
	        }
	      };
	
	      scope.caretDirection = function () {
	        return 'fis-caret-position-' + tabPosition;
	      };
	
	      /**
	       * @name scroll
	       * @description Closes the overflow menu if it is open
	       * and window is scrolling.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      var scrollHandler = function scrollHandler() {
	        var tabstripId;
	        for (var prop in scope.overflowTabs) {
	          // eslint-disable-line guard-for-in
	          tabstripId = prop; // get the id of the JSON tabstrip object
	        }
	        hideOverflowMenu(tabstripId);
	      };
	
	      $(window).bind('scroll', scrollHandler);
	
	      /**
	       * @name viewOverflowTabs
	       * @param {Object} overflowTabsObject.
	       * @description Returns an array of tabs currently in the overflow
	       * for display in the overflow list (using ng-repeat).
	       *
	       * Returns an empty array if the overflowTabsObject is undefined.
	       * @methodOf fisTabbedComponentList
	       */
	      scope.viewOverflowTabs = function (overflowTabsObject) {
	        if (overflowTabsObject !== undefined) {
	          var tabstripId;
	          for (var prop in overflowTabsObject) {
	            // eslint-disable-line guard-for-in
	            tabstripId = prop; // get the id of the JSON tabstrip object
	          }
	          return scope.overflowTabs[tabstripId];
	        }
	        return [];
	      };
	
	      /**
	       * @name moveOverflowTabToTabstripOnClick
	       * @param {Object} $event.  The event object.
	       * @param {String} item. The title of the tab to move.
	       * @param {Object} overflowTabsObject. The overflowTabs object.
	       *
	       * @description Shows the incoming tab on the tabstrip and hides the
	       * next lowest visible tab.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      scope.moveOverflowTabToTabstripOnClick = function ($event, item, overflowTabsObject) {
	        if (overflowTabsObject !== undefined) {
	          var tabstripId;
	          for (var prop in overflowTabsObject) {
	            // eslint-disable-line guard-for-in
	            tabstripId = prop; // get the id of the JSON tabstrip object
	          }
	          // calculate and move the amount  tabs that need to be moved in order to swap in the the 'tabToShow'
	          var tmpTabs;
	          var wrappedTabs;
	          var currentTabStrip;
	          var threshold;
	
	          currentTabStrip = getTabStripItemsElement();
	          threshold = calculateContainerWidth(currentTabStrip);
	
	          var selectedTab = currentTabStrip.find('li[title="' + item + '"]:not(.k-last)');
	
	          do {
	            tmpTabs = currentTabStrip.find('li[title]:not([title="' + item + '"]):not(.k-last):visible');
	            wrappedTabs = wrapTabObjects(tmpTabs);
	
	            var tabToHide = tmpTabs[tmpTabs.length - 1];
	            if (!_.isUndefined(tabToHide) && !_.isUndefined(tabToHide.title) && tabToHide.title.length > 0) {
	              // only the active tab is left on the tabstrip
	              scope.overflowTabs[tabstripId].unshift($(tabToHide).attr('title'));
	
	              _.each(kendoTabstrip.items(), function (tab) {
	                // eslint-disable-line no-loop-func
	                if (tab.title === tabToHide.title) {
	                  $(tab).hide();
	                }
	              });
	              tmpTabs.splice(tmpTabs.length - 1, 1);
	              tmpTabs.push(selectedTab[0]);
	              wrappedTabs = wrapTabObjects(tmpTabs);
	            }
	          } while (fisOverflowService.isSpaceAvailable(wrappedTabs, threshold) === false && tabPosition !== 'left' && tabPosition !== 'right'); // eslint-disable-line no-unmodified-loop-condition
	
	          // get a hold of the tab that needs to be shown
	          var tabToShow = getTabStripItemsElement().find('li[title="' + item + '"]:hidden');
	          var tabToShowIndex = scope.overflowTabs[tabstripId].indexOf(tabToShow.attr('title')); // get the index of the tab to sho
	          // show the tab that has been selected in the overflow menu and set it as the selected tab
	          setTabAsSelected(item);
	          scope.overflowTabs[tabstripId].splice(tabToShowIndex, 1); // and remove it from  list
	          showTabOnTabstrip(tabstripId, item);
	
	          hideOverflowIfNoMoreTabs(tabstripId);
	        }
	      };
	
	      /**
	       * @name moveOverflowTabToTabstrip
	       * @param {String} tabstripId. The current tabstrip
	       * @param {String} title. The title of the tab to move.
	       *
	       * @description Removes the incoming tab from the overflow and places
	       * it back on the tabstrip
	       *
	       * This function is part of the exposed API as well.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      scope.moveOverflowTabToTabstrip = function (tabstripId, title) {
	        var overflowTimeout = $timeout(function () {
	          if (tabstripId == '' || !tabstripId) {
	            // eslint-disable-line eqeqeq
	            console.warn('Invalid TabStrip ID... ', tabstripId);
	            return;
	          }
	          var tabToShow = getTabStripItemsElement().find('> li[title="' + title + '"]:hidden').not('.k-last').show();
	          if (tabToShow.length > 0) {
	            var tabToShowIndex = scope.overflowTabs[tabstripId].indexOf(title); // get the index of the tab to show
	            if (tabToShowIndex > -1) {
	              setTabAsSelected(title);
	              scope.overflowTabs[tabstripId].splice(tabToShowIndex, 1); // and remove it from  list
	            }
	
	            var currentTabStrip;
	            var threshold;
	            var tmpTabs;
	            var wrappedTabs;
	            currentTabStrip = element.find('.k-tabstrip');
	            threshold = calculateContainerWidth(currentTabStrip);
	
	            do {
	              tmpTabs = getTabStripItemsElement().find('li[title]:not([title="' + title + '"]):not(.k-last):visible');
	              wrappedTabs = wrapTabObjects(tmpTabs);
	
	              var tabToHide = tmpTabs[tmpTabs.length - 1];
	              if (!_.isUndefined(tabToHide)) {
	                // only the active tab is left on the tabstrip
	                if (!_.contains(scope.overflowTabs[tabstripId], $(tabToHide).attr('title'))) {
	                  scope.overflowTabs[tabstripId].unshift($(tabToHide).attr('title'));
	
	                  _.each(kendoTabstrip.items(), function (tab) {
	                    // eslint-disable-line no-loop-func
	                    if (tab.title === tabToHide.title) {
	                      $(tab).hide();
	                    }
	                  });
	                }
	              }
	
	              if (!scope.$$phase) {
	                scope.$apply();
	              }
	            } while (fisOverflowService.isSpaceAvailable(wrappedTabs, threshold) === false);
	
	            scope.$apply();
	          }
	        });
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, overflowTimeout, $timeout);
	      };
	
	      /**
	      * @name addTab
	      * @param {object}.
	      * @description add the tab in the tabStrip.
	      * @methodOf fisTabbedComponentList
	      */
	      scope.addTab = function (newTab) {
	        var newTabObj = angular.copy(newTab);
	        var tabstrip = element.find('.kendo-tab-strip');
	        var kendoTabStrip = tabstrip.data('kendoTabStrip');
	        var tabItems = tabstrip.data('kendoTabStrip').tabGroup.children();
	        var idx;
	
	        if (!angular.isUndefined(newTabObj.idx)) {
	          // eslint-disable-line no-negated-condition
	          idx = parseInt(newTabObj.idx, 10);
	
	          // if index is not valid, assign last index in tabStrip
	          if (isNaN(idx) || idx > tabItems.length) {
	            console.warn('Entered value is not a valid integer.....');
	            idx = tabItems.last().index();
	          }
	        } else {
	          idx = tabItems.last().index();
	        }
	
	        if (newTabObj.label && (newTabObj.partial || newTabObj.template)) {
	          kendoTabStrip.insertBefore({
	            text: '<div id="label" class="fis-tabbed-label">' + newTabObj.label + '</div>',
	            contentUrl: newTabObj.partial,
	            encoded: false
	          }, tabItems.eq(idx));
	          // reassigning index attribute to all the tabs
	          var itemCnt = 0;
	          var items = tabstrip.find('.k-item').not('.k-last');
	          _.each(items, function (item) {
	            angular.element(item).attr('index', itemCnt);
	            itemCnt++;
	          });
	          kendoTabstrip.tabGroup.children().eq(idx).attr('title', newTabObj.label);
	
	          var validArg;
	          if ('tabArgs' in newTabObj && newTabObj.tabArgs != '') {
	            // eslint-disable-line eqeqeq
	            validArg = eval('(' + newTabObj.tabArgs + ')'); // eslint-disable-line no-eval
	            if (validArg && (typeof validArg === 'undefined' ? 'undefined' : _typeof(validArg)) === 'object') {
	              newTabObj.args = validArg;
	              delete newTabObj.tabArgs;
	            }
	          } else {
	            delete newTabObj.tabArgs;
	          }
	
	          scope.data.splice(idx, 0, newTabObj);
	          kendoTabStrip.select(idx);
	          var newTabElem = kendoTabStrip.tabGroup.children().eq(idx);
	          var newContentElem = kendoTabStrip.contentElement(idx);
	          addUniqueId(newTabElem, newContentElem);
	
	          kendoTabStrip.tabGroup.children().eq(idx).addClass('k-state-active');
	          var tabLabel = kendoTabStrip.tabGroup.children().eq(idx).find('.fis-tabbed-label');
	
	          if (newTabObj.closeable) {
	            var closeableVal = newTabObj.closeable; // eslint-disable-line no-unused-vars
	            var compiledClose = $compile('<span class="fis-cover"><span fis-unique-id class="fis-close" aria-label="close" ng-click=\'close($event)\'> &times;</span></span>')(scope);
	            angular.element(tabLabel).append(compiledClose);
	          }
	          resizeList();
	        }
	        // newTabObj = {};
	      };
	
	      /**
	       * @name closeTab
	       * @param {String} tabId. tabId. The id of the tab to close.
	       * @description Close the tab in the tabStrip.
	       * @methodOf fisTabbedComponentList
	       */
	      scope.closeTab = function (tabId) {
	        var tabstrip = element.find('.kendo-tab-strip');
	        var tab = getTabStripItemsElement(tabstrip).find('> li[title=\'' + tabId + '\']');
	        if (!tab) {
	          return;
	        }
	        var newSelectedTab;
	        var selectedTab = kendoTabstrip.select();
	
	        if (tab[0] === selectedTab[0]) {
	          newSelectedTab = tab.next().length ? tab.next() : tab.prev();
	        }
	
	        // Remove tab from overflow if it is there
	        var tabstripId = tabstrip.attr('fisid');
	        var oTabs = scope.overflowTabs[tabstripId];
	        var tabTitle = tab.attr('title');
	        var indexOfTabToRemove = _.indexOf(oTabs, tabTitle);
	        if (indexOfTabToRemove > -1) {
	          oTabs.splice(indexOfTabToRemove, 1);
	        }
	
	        var closeCurrentTab;
	        var remIdx = scope.loaded.indexOf(tabTitle);
	        if (attrs.fisOnClose && !angular.isUndefined(scope.callBackFn) && !angular.isUndefined(tab) && tab.length > 0) {
	          var paramsObj = {
	            currentTabElem: selectedTab,
	            nextTabElem: newSelectedTab
	          };
	          closeCurrentTab = scope.callBackFn({ tabParams: paramsObj });
	          tabCloseHandler(closeCurrentTab, newSelectedTab, tab); // eslint-disable-line no-use-before-define
	        } else {
	          closeCurrentTabFromTabstrip(tab, newSelectedTab); // eslint-disable-line no-use-before-define
	        }
	        if (remIdx && remIdx > -1) {
	          scope.loaded.splice(remIdx, 1);
	        }
	        resizeList();
	      };
	
	      scope.close = function ($event) {
	        var tab = $($event.target).closest('li');
	        var newSelectedTab;
	
	        var selectedTab = kendoTabstrip.select();
	
	        if (tab[0] === selectedTab[0]) {
	          var nextTab = tab.next();
	          var itemIndex = jQuery(nextTab).attr('index'); // eslint-disable-line block-scoped-var
	          if (!_.isUndefined(nextTab) && itemIndex) {
	            // eslint-disable-line block-scoped-var
	            var overflowIndex = itemOverflowTabIndex(parseInt(itemIndex, 10)); // eslint-disable-line block-scoped-var
	            if (_.isUndefined(overflowIndex) || overflowIndex === 0) {
	              newSelectedTab = nextTab;
	            } else {
	              newSelectedTab = getTabFromIndex(getOverflowTabItemIndexes()[0]);
	            }
	          } else {
	            var prevTab = tab.prev().length ? tab.prev() : tab.next();
	            var itemIndex = jQuery(prevTab).attr('index'); // eslint-disable-line block-scoped-var, no-redeclare
	            if (itemOverflowTabIndex(parseInt(itemIndex, 10)) === 0) {
	              newSelectedTab = prevTab;
	            } else {
	              var overFlowTabItemIndex = getOverflowTabItemIndexes();
	              newSelectedTab = overFlowTabItemIndex[0] ? getTabFromIndex(overFlowTabItemIndex[0]) : prevTab;
	            }
	          }
	        }
	
	        var closeCurrentTab;
	        var remTabName = tab.attr('title');
	        var remIdx = scope.loaded.indexOf(remTabName);
	        if (attrs.fisOnClose && !angular.isUndefined(scope.callBackFn) && !angular.isUndefined(tab) && tab.length > 0) {
	          $event.stopPropagation();
	          var paramsObj = {
	            currentTabElem: selectedTab,
	            nextTabElem: newSelectedTab,
	            eventObj: $event
	          };
	          closeCurrentTab = scope.callBackFn({ tabParams: paramsObj });
	          tabCloseHandler(closeCurrentTab, newSelectedTab, tab); // eslint-disable-line no-use-before-define
	        } else {
	          closeCurrentTabFromTabstrip(tab, newSelectedTab); // eslint-disable-line no-use-before-define
	        }
	        if (remIdx && remIdx > -1) {
	          scope.loaded.splice(remIdx, 1);
	        }
	        resizeList();
	      };
	
	      var tabCloseHandler = function tabCloseHandler(closeCurrentTab, newSelectedTab, tab) {
	        if (!angular.isUndefined(closeCurrentTab) && fisKendoUtilService.isPromiseObject(closeCurrentTab)) {
	          closeCurrentTab.then(function (result) {
	            if (angular.isUndefined(result) || result !== false) {
	              closeCurrentTabFromTabstrip(tab, newSelectedTab); // eslint-disable-line no-use-before-define
	            }
	          });
	        } else if (angular.isUndefined(closeCurrentTab) || closeCurrentTab !== false) {
	          closeCurrentTabFromTabstrip(tab, newSelectedTab); // eslint-disable-line no-use-before-define
	        }
	      };
	
	      var closeCurrentTabFromTabstrip = function closeCurrentTabFromTabstrip(tab, newSelectedTab) {
	        kendoTabstrip.remove(tab);
	        if (newSelectedTab) {
	          kendoTabstrip.select(newSelectedTab);
	        }
	        /*
	         * If a tab is closed and there are tabs on the overflow then
	         * call resizeList() to see if there is enough space
	         * on the tabstrip to move them out.
	         */
	        resizeList();
	      };
	
	      fisData.addAfterFetchListener(onDataFetch);
	
	      var refresh = function refresh(event) {
	        // do not execute the event if event.preventDefault() has been called before
	        if (event && event.defaultPrevented) {
	          return;
	        }
	        // Need to add a timeout here to ensure any digest operations on the scope happened before
	        var datasourceTimeout = $timeout(function () {
	          dataSource.read();
	        });
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, datasourceTimeout, $timeout);
	      };
	
	      // listen for the fisRefresh event coming from a parent scope
	      scope.$on('fisRefresh', refresh);
	
	      // redefine the fisRefresh function if it is put on the same element
	      if (fisRefresh) {
	        fisRefresh.trigger = refresh;
	      }
	
	      dataSource.read();
	
	      /**
	       * @name addUniqueTabstripIds
	       * @description Calls fisUniqueIdService to create a unique id the tabstrip
	       * and returns it.
	       * @methodOf fisTabbedComponentList
	       */
	      function addUniqueTabstripIds(tabStrip) {
	        var idBase = attrs.fisTabbedComponentList || attrs.name || '';
	        return fisUniqueIdService.generateUniqueIdForce(scope, tabStrip, {}, idBase);
	      }
	
	      /**
	       * @name resizeHandler
	       *
	       * @description In the event of a browser resize, triggers a custom
	       * event to wait for the end of the resize.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      var resizeHandler = function resizeHandler() {
	        $(this).trigger('resizeEnd');
	      };
	
	      viewWindow.bind('resize', resizeHandler);
	
	      /**
	       * @name bind
	       * @description If the attribute fis-overflow is not false then
	       * this function ensures that all tabs are added back to the tabstrip
	       * at the end of the resize up, provided there is enough room on the tabstrip,
	       * or moved to the overflow at the end of resize down.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      var resizeEndHandler = function resizeEndHandler() {
	        if (attrs.fisOverflow !== 'false') {
	          var tabstripId = scope.overflowTabs[0];
	          for (var prop in scope.overflowTabs) {
	            // eslint-disable-line guard-for-in
	            tabstripId = prop; // get the id of the JSON tabstrip object
	          }
	          resizeList();
	          // eslint-disable-next-line no-implicit-coercion
	          $('#overflowContainer' + tabstripId + '').css('display', 'none'); // hide the overflow menu if screen is dragged.
	        }
	      };
	
	      viewWindow.bind('resizeEnd', resizeEndHandler);
	
	      function unwrapTabs(tabs) {
	        var retTabs = [];
	        _.each(tabs, function (tab) {
	          retTabs.push(tab.rawTab.title);
	        });
	        return retTabs;
	      }
	
	      /**
	       * @name resizeList
	       *
	       * @description Adds tabs to overflow or moves them back to tabstrip
	       * depending on the amount of space available.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function resizeList() {
	        if (scope.ready) {
	          var tabstripId;
	          for (var prop in scope.overflowTabs) {
	            // eslint-disable-line guard-for-in
	            tabstripId = prop; // get the id of the JSON tabstrip object
	          }
	          var currentTabStrip = element.find('.k-tabstrip');
	          var containerWidth = calculateContainerWidth(currentTabStrip);
	          if (containerWidth < 0) {
	            // sometimes width < 0 if tabstrip in a modal dialog so wait for DOM to load
	            var resizeTimeout = $timeout(function () {
	              containerWidth = parseFloat(currentTabStrip.width());
	              doResize(containerWidth, tabstripId);
	            }, 0);
	            fisMemoryUtilService.cancelTimeoutOnDestroy(scope, resizeTimeout, $timeout);
	          } else {
	            doResize(containerWidth, tabstripId);
	          }
	        }
	      }
	
	      /**
	       * Calculates the amount of space available versus the number
	       * of tabs on the tabstrip.
	       *
	       *
	       * @param containerWidth
	       * @param tabstripId
	       */
	      function doResize(containerWidth, tabstripId) {
	        var currentTabStrip = getTabStripItemsElement();
	        var rawTabs = currentTabStrip.find('li:not(.fis-tabbed-overflow-menu-tab):not(.k-last)');
	        var wrappedTabs = wrapTabObjects(rawTabs);
	        var result = fisOverflowService.calculateVisibleTabs(wrappedTabs, containerWidth);
	        var rawVisibleTabs = unwrapTabs(result.visible);
	        var rawOverflowTabs = unwrapTabs(result.overflow);
	        var tabsMoved = 0;
	
	        _.each(result.overflow, function (tab) {
	          scope.moveTabToOverflow(tabstripId, tab.title); // move the tab to overflow
	          hideTabOnTabstrip(tab.index);
	          showOverflowIfHasTabs(tabstripId);
	          tabsMoved += 1;
	        });
	
	        var rawTabsToMoveBack = _.filter(rawVisibleTabs, function (tab) {
	          return _.contains(scope.overflowTabs[tabstripId], tab);
	        });
	
	        if (!_.isUndefined(rawTabsToMoveBack) && _.isArray(rawVisibleTabs) && rawTabs.length > 0 && rawTabsToMoveBack.length > 0) {
	          scope.moveTabFromOverflow(tabstripId, rawTabsToMoveBack);
	          /*
	           * Now that moving of tabs from overflow is finished, re-calculate visible/overflow tabs
	           * and place results onto the overflow.
	           */
	          result = fisOverflowService.calculateVisibleTabs(wrappedTabs, containerWidth);
	          rawOverflowTabs = unwrapTabs(result.overflow);
	          scope.overflowTabs[tabstripId] = rawOverflowTabs;
	        }
	        hideOverflowIfNoMoreTabs(tabstripId); // this needs to be checked everytime we do the resize.
	        /*
	         * When resizing up, check if there is enough room to add tabs back to the tabstrip
	         */
	        var enoughRoom = tabstripWidthAfterResizingFinished(null, containerWidth);
	        if (enoughRoom) {
	          var tabs = $('[fisid=' + tabstripId + '] li:not(.fis-tabbed-overflow-menu-tab):not(.k-last):not(#overflowTab' + tabstripId + ')'); // yes so get all the tabs for this tabstrip, visible and hidden
	          $.each(tabs, function (index) {
	            // for each tab
	            showAllTabsOnTabstrip(index); // add it back to the tabstrip
	            scope.overflowTabs[tabstripId].length = 0; // and empty the scope overflow
	          });
	          hideOverflowTab(tabstripId);
	        }
	      }
	
	      /**
	       * @name showOverflowIfHasTabs
	       * @param {String} tabstripId. The current tabstrip.
	       *
	       * @description Show the overflow tab if there are
	       * tabs on the overflow.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function showOverflowIfHasTabs(tabstripId) {
	        if (scope.overflowTabs[tabstripId] !== undefined && scope.overflowTabs[tabstripId].length > 0) {
	          getTabStripItemsElement().find('.fis-tabbed-overflow-container').show();
	        }
	      }
	
	      /**
	       * @name hideOverflowIfNoMoreTabs
	       * @param {String} tabstripId. The current tabstrip.
	       *
	       * @description Hide the overflow tab if there are no more
	       * tabs on the overflow.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function hideOverflowIfNoMoreTabs(tabstripId) {
	        if (scope.overflowTabs[tabstripId] !== undefined && scope.overflowTabs[tabstripId].length === 0) {
	          getTabStripItemsElement().find('.fis-tabbed-overflow-container').hide();
	        }
	      }
	
	      /**
	       * @name moveTabFromOverflow
	       * @param {Number} tabstripId. The current tabstrip.
	       * @param {Array} tab. The tabs currently in the overflow.
	       *
	       * @description Returns tabs from the overflow to the tabstrip. This is only
	       * done if there is enough room on the tabstrip.
	       */
	      scope.moveTabFromOverflow = function (tabstripId, tabs) {
	        var reversed = reverseTabs(tabs); // reverse the scope tabs so that they are added in the same order they were removed
	
	        for (var k = 0; k < reversed.length; k++) {
	          // for each item...
	          var currentTabStrip = element.find('.k-tabstrip');
	          var containerWidth = calculateContainerWidth(currentTabStrip);
	          var rawTabs = getTabStripItemsElement().find('li:not(.fis-tabbed-overflow-menu-tab):not(.k-last):visible');
	          var wrappedTabs = wrapTabObjects(rawTabs);
	          var enoughSpace = fisOverflowService.isSpaceAvailable(wrappedTabs, containerWidth);
	          if (enoughSpace) {
	            // if there is enough space on the tabstrip
	            showTabOnTabstrip(tabstripId, reversed[k]); // then add it
	          }
	        }
	      };
	
	      /**
	       * @name moveTabToOverflow
	       * @param {Number} tabstripId. The current tabstrip.
	       * @param {String} tabTitle. The tab to move.
	       *
	       * @description Checks to see if the incoming tab is not already on the overflow and
	       * if not moves from the tabstrip.
	       */
	      scope.moveTabToOverflow = function (tabstripId, tabTitle) {
	        if (tabTitle.length > 0 && !_.contains(scope.overflowTabs[tabstripId], tabTitle)) {
	          // ng-repeat in the template does not like duplicates
	          scope.overflowTabs[tabstripId].push(tabTitle); // add the tab's title to the overflow array
	        }
	      };
	
	      /**
	       *@name tabstripWidthAfterResizingFinished
	       *@param {Number} tabstripId. The id of the current tabstrip.
	       *
	       *@description Returns true if the total space taken up by the tabs is greater
	       *than the amount of space available for the tabstrip, else returns false.
	       *
	       *@methodOf fisTabbedComponentList
	       */
	      function tabstripWidthAfterResizingFinished(tabstripId, containerWidth) {
	        var totalSpaceAvailable;
	        if (containerWidth === null) {
	          var currentTabStrip = element.find('div [fisid=' + tabstripId + ']');
	          totalSpaceAvailable = calculateContainerWidth(currentTabStrip);
	        } else {
	          totalSpaceAvailable = containerWidth;
	        }
	        // get the next visible tabs but not the overflow tab nor the <li>s belonging to the <ul> inside the overflow tab
	        var rawTabs = getTabStripItemsElement().find('li:not(.k-last):visible');
	        var totalSpaceTaken = overflow.tabstripWidthBufferAfterResize;
	        /*
	         * get the width of each tab to calculate
	         * the total amount of space taken up.
	         */
	        angular.forEach(rawTabs, function (rawTab) {
	          totalSpaceTaken += calculateTabWidth(rawTab);
	        });
	
	        return totalSpaceAvailable > totalSpaceTaken;
	      }
	
	      /**
	       *@name calculateContainerWidth
	       *@param {Object} currentTabstrip.
	       *
	       *@description Returns the width of the Div containing the tabstrip.
	       * The extra width ensures there is always some space on the tabstrip.
	       *
	       *@methodOf fisTabbedComponentList
	       */
	      function calculateContainerWidth(currentTabstrip) {
	        var extraSpace = overflow.tabsWidthBuffer;
	        var totalContainerWidth = fisUtilService.calculateContainerWidth(currentTabstrip);
	        return totalContainerWidth - extraSpace;
	      }
	
	      /**
	       * @name calculateTabWidth
	       * @param {Object} rawTab.
	       *
	       * @description Returns the width of each tab on the tabstrip.
	       * The width returned is constrained to the max width.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function calculateTabWidth(rawTab) {
	        var tabElement = angular.element(rawTab);
	        var width = parseFloat(tabElement.width());
	        if (width > overflow.tabMaxWidth) {
	          width = overflow.tabMaxWidth;
	        }
	        return width;
	      }
	
	      /**
	       * @name atLeastOneTabHasMaxWidth
	       * @param {Array} rawTabs.
	       *
	       * @description Returns true if at least one tab on
	       * the tabstrip has a max width >= max tab width.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function atLeastOneTabHasMaxWidth(rawTabs) {
	        // eslint-disable-line no-unused-vars
	        var longTab = false;
	        for (var k = 0; k < rawTabs.length; k++) {
	          var tabElement = angular.element(rawTabs[k]);
	          var width = parseFloat(tabElement.width());
	          if (width >= overflow.tabMaxWidth) {
	            longTab = true;
	            break;
	          }
	        }
	        return longTab;
	      }
	
	      /**
	       * @name hideTabOnTabstrip
	       * @param {Number} indexOfTabToHide.
	       *
	       * @description Hides the tab at the specified index
	       * on the tabstrip.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function hideTabOnTabstrip(indexOfTabToHide) {
	        $(kendoTabstrip.items()[indexOfTabToHide]).attr('style', 'display:none'); // hide the tab. Note that hide() does not work. Nor does adding a class with display:none
	      }
	
	      /**
	       * @name setTabAsSelected
	       * @param {Number} tabstripId. The current tabstrip
	       * @param {String} tabTitle
	       *
	       * @description Sets the tab as selected on the tabstrip.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function setTabAsSelected(tabTitle) {
	        var indexOfTabOnTabstrip = getTabStripItemsElement().find('li[title="' + tabTitle + '"]').index();
	        kendoTabstrip.select(indexOfTabOnTabstrip);
	      }
	
	      /**
	       * @name showTabOnTabstrip
	       * @param {Number} tabstripId the current tab strip.
	       * @param {String} tabToShow. The title of the tab to add.
	       *
	       * @description Shows the tab back on the tabstrip on browser
	       * resize up.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function showTabOnTabstrip(tabstripId, tabToShow) {
	        var tab = getTabStripItemsElement().find('li[title="' + tabToShow + '"]');
	        var tabTitle = tab.attr('title'); // get its title
	        if (tabTitle === tabToShow) {
	          // if the title of the hidden tab is the same as the title to the tabToShow...
	          var position = tab.index(); // then get its position on the list
	          $(kendoTabstrip.items()[position]).show(); // and show it
	        }
	      }
	
	      /**
	       * @name showAllTabsOnTabstrip
	       * @param {Number} indexOfTabToShow. The current tab strip.
	       *
	       * @description Shows all the on the tabstrip.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function showAllTabsOnTabstrip(indexOfTabToShow) {
	        $(kendoTabstrip.items()[indexOfTabToShow]).show();
	      }
	
	      /**
	       * @name reverseTabs
	       * @param {Array} tabs. The tabs to reverse.
	       *
	       * @description Returns the incoming array in reverse order.
	       */
	      function reverseTabs(tabs) {
	        var reversedTabs = _.toArray(tabs.slice(0));
	        return reversedTabs.reverse();
	      }
	
	      /**
	       * @name hideOverflowTab
	       * @param {Number} tabstripId the current tab strip.
	       *
	       * @description Hides the overflow tab if there is one present
	       */
	      function hideOverflowTab() {
	        getTabStripItemsElement().find('.fis-tabbed-overflow-container').css('display', 'none'); // hide the overflow tab
	      }
	
	      /**
	       * @name hideOverflowMenu
	       * @param {Number} tabstripId the current tab strip.
	       *
	       * @description Hides the overflow menu.
	       */
	      function hideOverflowMenu(tabstripId) {
	        $('#overflowContainer' + tabstripId + '').hide(); // eslint-disable-line no-implicit-coercion
	      }
	
	      /**
	       * @name wrapTabObject
	       *
	       * @description Returns the wrapped tab object.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function wrapTabObject(rawTab) {
	        var retTab = {};
	        retTab.rawTab = rawTab;
	        retTab.width = calculateTabWidth(rawTab);
	        retTab.title = rawTab.title;
	        retTab.active = $(rawTab).hasClass('k-state-active');
	
	        return retTab;
	      }
	
	      /**
	       * @name wrapTabObjects
	       *
	       * @description Returns the wrapped tab objects.
	       *
	       * @methodOf fisTabbedComponentList
	       */
	      function wrapTabObjects(rawTabs) {
	        var retTabs = [];
	
	        _.each(rawTabs, function (rawTab) {
	          // this is a fix to prevent incorrect <li> from being populated into the wrapped tabs
	          if (rawTab.title.length > 0) {
	            var tmpWrappedTab = wrapTabObject(rawTab);
	            retTabs.push(tmpWrappedTab);
	          }
	        });
	
	        return retTabs;
	      }
	
	      /*
	       * If a modal dialog is opened using a directive and it contains
	       * a tabbed component list then listen
	       * for the event broadcast by fisModalDialogService and call resizeList().
	       *
	       * This ensures that the tabbed comp list is loaded in the DOM and so things
	       * like tabstrip and tab width can be properly read.
	       */
	      var unsubscribe = fisPubSubService.subscribe('fisModalDialogHasTabbedCompList', function () /* event*/{
	        resizeList();
	      });
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ }),
/* 63 */
/*!***************************!*\
  !*** ./treeview/index.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	__webpack_require__(/*! @ruf/kendo-ui */ 3);
	
	var _base = __webpack_require__(/*! ../base */ 5);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _data = __webpack_require__(/*! ../data */ 9);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _treeNode = __webpack_require__(/*! ./tree-node.directive */ 64);
	
	var _treeNode2 = _interopRequireDefault(_treeNode);
	
	var _treeView = __webpack_require__(/*! ./tree-view.directive */ 65);
	
	var _treeView2 = _interopRequireDefault(_treeView);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.kendo.treeview', [_base2.default, _data2.default]);
	
	ngModule.directive('fisTreeNode', _treeNode2.default);
	ngModule.directive('fisTreeView', _treeView2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 64 */
/*!*****************************************!*\
  !*** ./treeview/tree-node.directive.js ***!
  \*****************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return {
	    restrict: 'C',
	    scope: true,
	    link: function link() {}
	  };
	};

/***/ }),
/* 65 */
/*!*****************************************!*\
  !*** ./treeview/tree-view.directive.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "$parse", "fisKendoDataSourceFactory", "$timeout", "fisI18nService", "fisUniqueIdService", "fisMemoryUtilService", function ($compile, $parse, fisKendoDataSourceFactory, $timeout, fisI18nService, fisUniqueIdService, fisMemoryUtilService) {
	  'ngInject';
	
	  // function that gathers IDs of checked nodes and checked leaves
	
	  function checkedNodeIds(nodes, checkedNodes, checkedLeaves) {
	    for (var i = 0; i < nodes.length; i++) {
	      if (nodes[i].checked) {
	        checkedNodes.push(nodes[i].id);
	      }
	
	      if (nodes[i].hasChildren) {
	        checkedNodeIds(nodes[i].children.view(), checkedNodes, checkedLeaves);
	      } else {
	        if (nodes[i].checked) {
	          // eslint-disable-line no-lonely-if
	          checkedLeaves.push(nodes[i].id);
	        }
	      }
	    }
	  }
	
	  function getPagingLabel(attrs) {
	    var label;
	    if (!_.isUndefined(attrs.fisPageLabel)) {
	      label = attrs.fisPageLabel;
	    }
	    return label;
	  }
	
	  function isLazyLoading(attrs) {
	    var lazyLoading = false;
	    if (!_.isUndefined(attrs.fisLazyLoading)) {
	      if (attrs.fisLazyLoading === 'true') {
	        lazyLoading = true;
	      }
	    }
	    return lazyLoading;
	  }
	
	  function getPageSize(attrs) {
	    var pageSize;
	    if (!_.isUndefined(attrs.fisPageSize)) {
	      pageSize = attrs.fisPageSize;
	    }
	    return pageSize;
	  }
	
	  return {
	
	    restrict: 'AEC',
	
	    require: ['fisData', '?fisRefresh'],
	
	    scope: {
	      clickFn: '&fisOnClick',
	      expandFn: '&fisOnExpand',
	      collapseFn: '&fisOnCollapse',
	      checkboxSelect: '&fisCheckboxOnSelect',
	      checkFn: '&fisOnCheck'
	    },
	
	    template: '<div class="treeView"></div>',
	
	    controller: ['$scope', function ($scope) {
	      $scope.page = 1;
	
	      $scope.showMoreEnabled = true;
	
	      $scope.showMore = function () {
	        if ($scope.showMoreEnabled) {
	          $scope.page += 1;
	        }
	      };
	
	      $scope.checkedNodes = '';
	
	      $scope.getSelectedNodes = function () {
	        return $scope.checkedNodes;
	      };
	
	      $scope.setSelectedNodesAndLeaves = function (checkedNodes, checkedLeaves /* , attrs*/) {
	        $scope.checkboxSelect({
	          nodes: checkedNodes.join(','),
	          leaves: checkedLeaves.join(',')
	        });
	      };
	
	      $scope.setSelectedNodesAndLeavesOnModel = function (checkedNodes, checkedLeaves) {
	        // Setting values of checked nodes and checked leaves on parent scope
	        if ($scope.$parent.checked) {
	          if (checkedNodes && checkedNodes.length > 0) {
	            $scope.$parent.checked.nodes = checkedNodes;
	          } else {
	            $scope.$parent.checked.nodes = [];
	          }
	
	          if (checkedLeaves && checkedLeaves.length > 0) {
	            $scope.$parent.checked.leaves = checkedLeaves;
	          } else {
	            $scope.$parent.checked.leaves = [];
	          }
	        }
	      };
	    }],
	
	    link: function link(scope, element, attrs, ctrls) {
	      var fisData = ctrls[0];
	      var fisRefresh = ctrls[1];
	      var isQuickActionMenuRendered = false;
	
	      function onDataBound(event) {
	        var node;
	
	        if (_.isUndefined(event.node)) {
	          // Bound the root node
	          node = element;
	        } else {
	          node = event.node;
	        }
	
	        var quickActionDataPresent = !_.isUndefined(attrs.fisQuickActionData && attrs.fisQuickActionData.length > 0);
	        var quickActionDataPresentForBranch = !_.isUndefined(attrs.fisQuickActionDataBranch && attrs.fisQuickActionDataBranch.length > 0);
	        if (!isQuickActionMenuRendered && (quickActionDataPresent || quickActionDataPresentForBranch)) {
	          var treeViewElement = element.find('.treeView');
	          treeViewElement.addClass('fis-quick-action-menu');
	          // we pass the fisId down onto the quick action menu so it can use it to seed its menu items
	          if (!_.isUndefined(attrs.fisId)) {
	            treeViewElement.attr('fis-id', attrs.fisId + '_qam');
	          }
	          if (quickActionDataPresent) {
	            treeViewElement.attr('fis-quick-action-data', attrs.fisQuickActionData);
	          }
	          if (quickActionDataPresentForBranch) {
	            treeViewElement.attr('fis-quick-action-data-branch', attrs.fisQuickActionDataBranch);
	          }
	
	          $compile(treeViewElement)(scope);
	          isQuickActionMenuRendered = true;
	        }
	
	        var clickElements = node.find('span[ng-click]').not('.fis-tree-node');
	
	        if (clickElements && clickElements.length && clickElements.length > 0) {
	          // Add tree node and compile the node with the parent scope.
	          clickElements.addClass('fis-tree-node');
	          var children = $compile(clickElements)(scope.$parent);
	
	          var treeElement = element.find('.treeView').data('kendoTreeView');
	
	          // Loop through all of the created children
	          _.each(children, function (item) {
	            // Get each child's scope, which was created by fis-tree-node
	            var childScope = angular.element(item).scope();
	
	            // Check whether there's data
	            if (treeElement && treeElement.dataSource.at(0)) {
	              // Set the data to the child scope
	              childScope.nodeData = treeElement.dataItem(item);
	            }
	          });
	        }
	
	        var kInElements = node.find('.k-in');
	        _.each(kInElements, function (kIn) {
	          var nodeElement = angular.element(kIn);
	          fisUniqueIdService.generateUniqueId(scope, nodeElement, {}, nodeElement.text());
	        });
	
	        var checkboxes = node.find('input[type="checkbox"]');
	
	        _.each(checkboxes, function (checkbox) {
	          var checkboxElement = angular.element(checkbox);
	          fisUniqueIdService.generateUniqueId(scope, checkboxElement, {}, 'cb_' + checkboxElement.attr('id'));
	        });
	      }
	
	      function onRequestEnd(event) {
	        if (_.isUndefined(scope.oldData)) {
	          scope.oldData = event.response.data;
	        } else {
	          var dataTimeout = $timeout(function () {
	            var firstItemInTree = element.find('.k-first');
	            if (firstItemInTree.length) {
	              // eslint-disable-next-line no-use-before-define
	              tree.data('kendoTreeView').insertBefore(scope.oldData, firstItemInTree); // Some data returned - have to add old data
	            } else {
	              // eslint-disable-next-line no-use-before-define
	              tree.data('kendoTreeView').append(scope.oldData); // No data returned - have to add old data
	              disableShowMore(); // Disable showMore element
	            }
	            if (event.response.data.length < scope.pageSize) {
	              disableShowMore();
	            }
	            scope.oldData = scope.oldData.concat(event.response.data);
	          });
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, dataTimeout, $timeout);
	        }
	      }
	
	      function onExpand(e) {
	        scope.expandFn({ event: e, node: treeView.dataItem(e.node) }); // eslint-disable-line no-use-before-define
	        if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	          scope.$apply();
	        }
	      }
	
	      function onCollapse(e) {
	        scope.collapseFn({ event: e, node: treeView.dataItem(e.node) }); // eslint-disable-line no-use-before-define
	        if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	          scope.$apply();
	        }
	      }
	
	      function onCheck(e) {
	        scope.checkFn({ event: e, node: treeView.dataItem(e.node) }); // eslint-disable-line no-use-before-define
	        if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	          scope.$apply();
	        }
	      }
	
	      function disableShowMore() {
	        scope.showMoreEnabled = false;
	        var showMoreElement = element.find('.treePaging');
	        showMoreElement.removeClass('treePaging');
	        showMoreElement.addClass('treePagingDisabled');
	        element.find('.fis-legacy-i-arrow_down').remove();
	      }
	
	      function getQuickActionChevron() {
	        if (!_.isUndefined(attrs.fisQuickActionData && attrs.fisQuickActionData.length > 0)) {
	          return '# if(!item.items && !item.hasItems) { # ' + '<span class="qactions-target icon-chevron-down " qaid="#: item.id #" />' + '# } #';
	        }
	      }
	
	      function getQuickActionChevronForBranch() {
	        if (!_.isUndefined(attrs.fisQuickActionDataBranch && attrs.fisQuickActionDataBranch.length > 0)) {
	          return '# if(item.items || item.hasItems) { # ' + '<span class="qactions-target qactions-branch icon-chevron-down " qaid="#: item.id #" />' + '# } #';
	        }
	      }
	
	      function createTreeTemplate() {
	        var buffer = ['<span'];
	
	        if (!_.isUndefined(attrs.fisOnClick)) {
	          buffer.push(' ng-click="');
	          buffer.push(attrs.fisOnClick);
	          buffer.push('" ');
	        }
	
	        buffer.push('>');
	        buffer.push('#: item.title #');
	        buffer.push('</span>');
	
	        // adding quickActions menu
	        buffer.push(getQuickActionChevron());
	
	        buffer.push(getQuickActionChevronForBranch());
	
	        return kendo.template(buffer.join(''));
	      }
	      // removed disabled on checkbox to fix issue SDHTML-16950, SDHTML-16949 this will be removed once kendo fixes it own issue.
	      function createCheckboxTemplate() {
	        var template = '<input type="checkbox" ' + '# if (item.id) {# id="#: item.id#" # }' + ' if (item.checked) {# checked #  }' + ' if (item.enabled == false) {# class=\"fis-cursor-not-allowed k-state-disabled\" onclick=\"return false;\" onkeydown=\"return false;\" #  }' + // eslint-disable-line no-useless-escape
	        '#></input>';
	        return kendo.template(template);
	      }
	
	      function createCheckBoxOptions(attrs) {
	        var fisCheckChildren = true;
	        if (!_.isUndefined(attrs.fisCheckChildren)) {
	          if (attrs.fisCheckChildren === 'false') {
	            fisCheckChildren = false;
	          }
	        }
	        return {
	          checkChildren: fisCheckChildren,
	          template: createCheckboxTemplate()
	        };
	      }
	
	      var treeView = element.find('.treeView');
	
	      var treeViewElement = angular.element(treeView);
	
	      // Setup loading indicator
	      fisData.addBeforeFetchListener(function () {
	        kendo.ui.progress(treeViewElement, true);
	      });
	
	      fisData.addAfterFetchListener(function () {
	        kendo.ui.progress(treeViewElement, false);
	        addSgIDs(element, attrs);
	      });
	
	      var dataSourceOptions = {};
	
	      var expect;
	      var lazyLoading = isLazyLoading(attrs);
	      if (lazyLoading) {
	        expect = {
	          id: function id(data) {
	            if (!_.isEmpty(data)) {
	              return data.id;
	            }
	            return;
	          }
	        };
	      } else {
	        expect = {
	          q: 'filter.filters[0].value'
	        };
	      }
	
	      // In the case of serverSide Paging :
	      var pageSize = getPageSize(attrs);
	      if (!_.isUndefined(pageSize)) {
	        expect.limit = parseInt(pageSize, 10);
	        expect.offset = scope.page;
	        scope.pageSize = expect.limit; // storing pageSize on scope
	      }
	
	      var dataSource = fisKendoDataSourceFactory.createHierarchicalDataSource(fisData.fetchData, expect, dataSourceOptions, attrs);
	      dataSource.bind('requestEnd', onRequestEnd);
	      var inlineTemplate = createTreeTemplate();
	
	      var tree;
	
	      // to fix SDHTML-8743 sgTreeView - callback function specified using sg-on-click is not always called
	      function bindClikOnKiIn(treeView) {
	        if (!_.isUndefined(attrs.fisOnClick)) {
	          $timeout(function () {
	            var kIn = angular.element(treeView.element[0]).find('.k-in');
	            angular.forEach(kIn, function (elm) {
	              var ngClickAttrVal = elm.children[1].attributes['ng-click'].value;
	              var childScope = angular.element(elm.children[1]).scope();
	              $(elm).attr('ng-click', ngClickAttrVal);
	              $(elm.children[1]).removeAttr('ng-click');
	              $compile(elm)(childScope);
	              $(elm.children[1]).unbind('click');
	            });
	          }, 0);
	        }
	      }
	
	      if (!_.isUndefined(attrs.fisCheckbox)) {
	        // eslint-disable-line no-negated-condition
	        // SDHTML-14743 -- adding timeout to wait for treeview data to load
	
	        var initTimeout = $timeout(function () {
	          tree = treeViewElement.kendoTreeView({
	            dataSource: dataSource,
	            checkboxes: createCheckBoxOptions(attrs),
	            dataTextField: ['title'],
	            loadOnDemand: lazyLoading,
	            dataSpriteCssClassField: ['icon'],
	            dataBound: onDataBound,
	            template: inlineTemplate,
	            expand: onExpand,
	            collapse: onCollapse,
	            check: onCheck
	          });
	          treeView = treeViewElement.data('kendoTreeView');
	          bindClikOnKiIn(treeView);
	
	          treeView.dataSource.bind('change', function () {
	            var checkedNodes = [];
	            var checkedLeaves = [];
	
	            checkedNodeIds(treeView.dataSource.view(), checkedNodes, checkedLeaves);
	
	            scope.setSelectedNodesAndLeaves(checkedNodes, checkedLeaves, attrs);
	
	            scope.setSelectedNodesAndLeavesOnModel(checkedNodes, checkedLeaves);
	          });
	        });
	
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, initTimeout, $timeout);
	      } else {
	        tree = treeViewElement.kendoTreeView({
	          dataSource: dataSource,
	          autoBind: false,
	          dataTextField: ['title'],
	          loadOnDemand: lazyLoading,
	          dataSpriteCssClassField: ['icon'],
	          dataBound: onDataBound,
	          template: inlineTemplate,
	          expand: onExpand,
	          collapse: onCollapse
	        });
	
	        treeView = treeViewElement.data('kendoTreeView');
	        bindClikOnKiIn(treeView);
	
	        dataSource.read();
	      }
	
	      var refresh = function refresh(event) {
	        // do not execute the event if event.preventDefault() has been called before
	        if (event && event.defaultPrevented) {
	          return;
	        }
	        // Need to add a timeout here to ensure any digest operations on the scope happened before
	        var refreshTimeout = $timeout(function () {
	          // set  oldData to  undefined so on requestEnd oldData is not appended
	          delete scope.oldData;
	          dataSource.read();
	        });
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, refreshTimeout, $timeout);
	      };
	      // listen for the fisRefresh event coming from a parent scope
	      scope.$on('fisRefresh', refresh);
	
	      // redefine the fisRefresh function if it is put on the same element
	      if (fisRefresh) {
	        fisRefresh.trigger = refresh;
	      }
	
	      $('.k-treeview > .k-group').addClass('k-treeview-lines');
	      function addSgIDs(element, attrs) {
	        if (fis.initParams().appStage === 'T') {
	          var idTimeOut = $timeout(function () {
	            var icons = element.find('.k-icon');
	            var nodeSgID = element.find('.k-in').attr('fisid');
	            var treeName = '';
	            if (attrs.name) {
	              treeName = attrs.name; // name is/should be unique per page
	              icons.each(function (index) {
	                $(this).attr('fisid', 'fis-tree-view-' + treeName + '-icon-' + index + ''); // eslint-disable-line no-implicit-coercion
	              });
	            } else {
	              treeName = nodeSgID; // Name not Provide use node fisid to create unique id
	              icons.each(function (index) {
	                $(this).attr('fisid', 'fis-tree-view-' + treeName[index] + '-icon-' + index + ''); // eslint-disable-line no-implicit-coercion
	              });
	            }
	          }, 0);
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, idTimeOut, $timeout);
	        }
	      }
	      addSgIDs(element, attrs);
	
	      scope.selectNode = function (nodePath) {
	        var nodes = treeView.dataSource.view();
	        var selectedNode;
	        selectedNode = getNodeToSelect(nodes, nodePath);
	        if (selectedNode) {
	          treeView.select(treeView.findByUid(selectedNode.uid));
	        }
	        return selectedNode;
	      };
	
	      var found = false; // eslint-disable-line no-unused-vars
	      var selectedNode;
	
	      function getNodeToSelect(nodes, nodePath) {
	        var tempNodePath = nodePath;
	        var tempNode; // eslint-disable-line no-unused-vars
	
	        for (var i = 0; i < nodes.length; i++) {
	          var currentNode = nodes[i];
	          if (tempNodePath.indexOf(currentNode.id) === 0) {
	            var currentNodePath = tempNodePath.substring(0, tempNodePath.indexOf('/'));
	            if (currentNodePath !== '') {
	              tempNodePath = tempNodePath.substring(currentNodePath.length + 1);
	              tempNode = currentNode;
	            }
	            if (nodePath === tempNodePath) {
	              found = true;
	              selectedNode = currentNode;
	              break;
	            } else {
	              if (currentNode.hasChildren) {
	                // eslint-disable-line no-lonely-if
	                getNodeToSelect(currentNode.children.view(), tempNodePath);
	                if (selectedNode) {
	                  break;
	                }
	              }
	            }
	          }
	        }
	        return selectedNode;
	      }
	
	      function createShowMoreComponent(attrs) {
	        var buffer = ['<div id="showMore" class="treePaging" ng-click="showMore()" ng-disabled="!showMoreEnabled">'];
	        buffer.push('<i class="fis-legacy-icon fis-legacy-i-arrow_down" />');
	        var label = getPagingLabel(attrs);
	        if (_.isUndefined(label) || label.length === 0) {
	          buffer.push(fisI18nService.translate('fisTreeView.showMore', 'Show More'));
	        } else {
	          buffer.push(label); // override default
	        }
	        buffer.push('<i class="fis-legacy-icon fis-legacy-i-arrow_down" />');
	        buffer.push('</div>');
	        return buffer.join('');
	      }
	
	      // If progressive loading - add component
	      if (!_.isUndefined(getPageSize(attrs))) {
	        var showMoreComponent = createShowMoreComponent(attrs);
	        showMoreComponent = $compile(showMoreComponent)(scope);
	        fisUniqueIdService.generateUniqueId(scope, showMoreComponent, attrs, 'showMore');
	        $(showMoreComponent).insertAfter(treeViewElement);
	      }
	
	      var pageWatch = scope.$watch('page', function (newVal, oldVal) {
	        if (newVal !== oldVal) {
	          var pageSize = getPageSize(attrs);
	          if (!_.isUndefined(pageSize)) {
	            expect.limit = parseInt(pageSize, 10);
	            expect.offset = scope.page;
	          }
	          dataSource.read();
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, pageWatch);
	
	      function exposeWidgetAPI(scope, attrs, treeView) {
	        var myTreeView = $parse(attrs.fisTreeView).assign;
	        if (myTreeView) {
	          myTreeView(scope.$parent, treeView);
	        }
	        treeView.selectNode = scope.selectNode;
	      }
	
	      exposeWidgetAPI(scope, attrs, treeView);
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 11)))

/***/ })
/******/ ]);
//# sourceMappingURL=fis-kendo-components.js.map;
/*!
 * 
 * @ruf/fis-widgets
 * Version: 4.5.0
 * 
 * © 2018
 * Fidelity National Information Services, Inc. and/or its subsidiaries - All Rights Reserved worldwide.
 * This document is protected under the trade secret and copyright laws as the property of Fidelity National Information Services, Inc. and/or its subsidiaries.
 * Copying, reproduction or distribution should be limited and only to employees with a “need to know” to do their job. Any disclosure of this document to third parties is strictly prohibited.
 * 
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _fisCoreComponents = __webpack_require__(/*! @ruf/fis-core-components */ 3);
	
	var _fisCoreComponents2 = _interopRequireDefault(_fisCoreComponents);
	
	__webpack_require__(/*! ./styles/index.less */ 4);
	
	var _components = __webpack_require__(/*! ./components */ 5);
	
	var _components2 = _interopRequireDefault(_components);
	
	var _controllers = __webpack_require__(/*! ./controllers */ 87);
	
	var _controllers2 = _interopRequireDefault(_controllers);
	
	var _directives = __webpack_require__(/*! ./directives */ 91);
	
	var _directives2 = _interopRequireDefault(_directives);
	
	var _filters = __webpack_require__(/*! ./filters */ 125);
	
	var _filters2 = _interopRequireDefault(_filters);
	
	var _services = __webpack_require__(/*! ./services */ 129);
	
	var _services2 = _interopRequireDefault(_services);
	
	var _utils = __webpack_require__(/*! ./utils */ 135);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets', [_fisCoreComponents2.default, _components2.default, _controllers2.default, _directives2.default, _filters2.default, _services2.default, _utils2.default]); // loading jquery before angular
	
	
	if (false) {
	  // eslint-disable-line
	  require('jasmine-jquery'); // source of setFixtures
	  require('angular-mocks');
	  require('@ruf/fis-mocks');
	}
	
	exports.default = ngModule.name;

/***/ }),
/* 1 */
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ (function(module, exports) {

	module.exports = jQuery;

/***/ }),
/* 2 */
/*!**************************!*\
  !*** external "angular" ***!
  \**************************/
/***/ (function(module, exports) {

	module.exports = angular;

/***/ }),
/* 3 */
/*!*****************************!*\
  !*** external "'fis.core'" ***!
  \*****************************/
/***/ (function(module, exports) {

	module.exports = 'fis.core';

/***/ }),
/* 4 */
/*!***************************!*\
  !*** ./styles/index.less ***!
  \***************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 5 */
/*!*****************************!*\
  !*** ./components/index.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _accordion = __webpack_require__(/*! ./accordion */ 6);
	
	var _accordion2 = _interopRequireDefault(_accordion);
	
	var _actionBar = __webpack_require__(/*! ./action-bar */ 10);
	
	var _actionBar2 = _interopRequireDefault(_actionBar);
	
	var _clickIcon = __webpack_require__(/*! ./click-icon */ 13);
	
	var _clickIcon2 = _interopRequireDefault(_clickIcon);
	
	var _dropdownMenu = __webpack_require__(/*! ./dropdown-menu */ 16);
	
	var _dropdownMenu2 = _interopRequireDefault(_dropdownMenu);
	
	var _fixedMenu = __webpack_require__(/*! ./fixed-menu */ 19);
	
	var _fixedMenu2 = _interopRequireDefault(_fixedMenu);
	
	var _footer = __webpack_require__(/*! ./footer */ 22);
	
	var _footer2 = _interopRequireDefault(_footer);
	
	var _forms = __webpack_require__(/*! ./forms */ 24);
	
	var _forms2 = _interopRequireDefault(_forms);
	
	var _header = __webpack_require__(/*! ./header */ 51);
	
	var _header2 = _interopRequireDefault(_header);
	
	var _hotkey = __webpack_require__(/*! ./hotkey */ 53);
	
	var _hotkey2 = _interopRequireDefault(_hotkey);
	
	var _imageSelect = __webpack_require__(/*! ./image-select */ 56);
	
	var _imageSelect2 = _interopRequireDefault(_imageSelect);
	
	var _infoPanel = __webpack_require__(/*! ./info-panel */ 59);
	
	var _infoPanel2 = _interopRequireDefault(_infoPanel);
	
	var _listBuilder = __webpack_require__(/*! ./list-builder */ 62);
	
	var _listBuilder2 = _interopRequireDefault(_listBuilder);
	
	var _message = __webpack_require__(/*! ./message */ 65);
	
	var _message2 = _interopRequireDefault(_message);
	
	var _pageHeader = __webpack_require__(/*! ./page-header */ 68);
	
	var _pageHeader2 = _interopRequireDefault(_pageHeader);
	
	var _panel = __webpack_require__(/*! ./panel */ 72);
	
	var _panel2 = _interopRequireDefault(_panel);
	
	var _quickActionMenu = __webpack_require__(/*! ./quick-action-menu */ 75);
	
	var _quickActionMenu2 = _interopRequireDefault(_quickActionMenu);
	
	var _quickActions = __webpack_require__(/*! ./quick-actions */ 78);
	
	var _quickActions2 = _interopRequireDefault(_quickActions);
	
	var _summary = __webpack_require__(/*! ./summary */ 80);
	
	var _summary2 = _interopRequireDefault(_summary);
	
	var _summaryItem = __webpack_require__(/*! ./summary-item */ 82);
	
	var _summaryItem2 = _interopRequireDefault(_summaryItem);
	
	var _userInfo = __webpack_require__(/*! ./user-info */ 84);
	
	var _userInfo2 = _interopRequireDefault(_userInfo);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components', [_accordion2.default, _actionBar2.default, _clickIcon2.default, _dropdownMenu2.default, _fixedMenu2.default, _footer2.default, _forms2.default, _header2.default, _hotkey2.default, _imageSelect2.default, _infoPanel2.default, _listBuilder2.default, _message2.default, _pageHeader2.default, _panel2.default, _quickActionMenu2.default, _quickActions2.default, _summary2.default, _summaryItem2.default, _userInfo2.default]);
	
	exports.default = ngModule.name;

/***/ }),
/* 6 */
/*!***************************************!*\
  !*** ./components/accordion/index.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _accordion = __webpack_require__(/*! ./accordion.directive */ 7);
	
	var _accordion2 = _interopRequireDefault(_accordion);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.accordion', []);
	
	ngModule.directive('fisAccordion', _accordion2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 7 */
/*!*****************************************************!*\
  !*** ./components/accordion/accordion.directive.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "fisI18nService", "fisUtilService", "$parse", "$window", "$document", "$timeout", "fisMemoryUtilService", function ($compile, fisI18nService, fisUtilService, $parse, $window, $document, $timeout, fisMemoryUtilService) {
	  'ngInject';
	
	  return {
	    transclude: true,
	
	    require: ['fisData', '?fisRefresh'],
	
	    template: '<div class="accordion" role="tablist" fis-pub-sub></div>',
	
	    scope: {
	      openPanelIndex: '=?fisOpenPanelIndex'
	    },
	
	    link: function link(scope, element, attrs, ctrls) {
	      var fisData = ctrls[0];
	      var fisRefresh = ctrls[1];
	
	      scope.fisFixedHeight = attrs.fisFixedHeight;
	      var totalHeight = attrs.fisFixedHeight;
	      var contentHeight = attrs.fisContentHeight;
	      var parentId = attrs.name;
	      var accordion = element.find('.accordion');
	
	      var assignable = Boolean($parse(attrs.fisOpenPanelIndex).assign);
	
	      var accordionElement = angular.element(accordion);
	      accordionElement.attr('id', parentId + '_parent');
	
	      if (totalHeight && totalHeight !== '') {
	        accordionElement.css('height', totalHeight + 'px');
	        accordionElement.css('overflow', 'auto');
	      }
	
	      var data;
	      var promise = fisData.fetchData();
	
	      var updateIndex = true;
	
	      // TODO: Is this ever unsubscribing?
	      scope.subscribe('fisSidebarVisibilityChanged', function (e) {
	        if (scope.fisFixedHeight === 'sidebar') {
	          if (e.newValue === true) {
	            scope.setHeight();
	          }
	        }
	      });
	
	      function isLazyLoading(attrs) {
	        var lazyLoading = false;
	        if (!_.isUndefined(attrs.fisLazyLoading)) {
	          if (attrs.fisLazyLoading === 'true') {
	            lazyLoading = true;
	          }
	        }
	        return lazyLoading;
	      }
	
	      promise.then(function (result) {
	        data = result.data;
	        scope.$evalAsync(function () {
	          buildAccordion(data);
	        });
	      }, function (result) {
	        console.warn('Problem loading data: ' + result);
	      });
	
	      function buildAccordion(data) {
	        accordion.empty();
	
	        var accordionTemplate = populate(data, parentId, contentHeight, isLazyLoading(attrs));
	        var accElem = $compile(angular.element(accordionTemplate))(scope);
	        // we must append first so the element is connected to its parent
	        accordion.append(accElem);
	        // now we can compile it properly and all necessary parent connections are available
	        $compile(accElem)(scope.$parent);
	
	        if (!scope.openPanelIndex || scope.openPanelIndex >= data.length) {
	          scope.openPanelIndex = 0;
	        }
	
	        var collapsibleElements = collapseAccordion(element, scope.openPanelIndex, scope, data);
	        populatePanelsWithExtraArgs(element, data, collapsibleElements);
	
	        scope.setHeight();
	      }
	
	      function setOpenPanelIndex(index) {
	        if (assignable) {
	          scope.$apply(function () {
	            scope.openPanelIndex = index;
	          });
	        }
	      }
	
	      function collapseAccordion(element, index, scope) {
	        var collapsableElements = element.find('.accordion-body');
	        var counter = 0;
	        angular.forEach(collapsableElements, function (collapsable) {
	          collapsable = angular.element(collapsable);
	          var accordion = $(collapsable).parents('.accordion ');
	          var headers = accordion.find('.accordion-heading');
	          var panels = accordion.find('.accordion-body');
	          if (counter === index) {
	            // expand the panel indicated in the fis-open-panel-index attr
	
	            expandcollapsePanel(false, panels, headers);
	            expandcollapsePanel(true, collapsable, $(headers[index]));
	            var currentAttrValue = $(headers[index]).find('.accordion-toggle').attr('href');
	            var accordionBodyElement = accordion.find(currentAttrValue);
	            addIncludedContent(accordionBodyElement, index);
	            $timeout(function () {
	              updateIndex = false;
	              setOpenPanelIndex(parseInt(index, 10));
	              updateIndex = true;
	            });
	          } else if (index < 0) {
	            expandcollapsePanel(false, panels, headers);
	          }
	
	          counter += 1;
	        });
	
	        scope.collapseHandler = function ($event) {
	          // Grab current anchor value
	          var currentAttrValue = $($event.currentTarget).find('.accordion-toggle').attr('href');
	          var accordionBodyElement = $('.accordion ' + currentAttrValue);
	          var accordion = accordionBodyElement.parents('.accordion ');
	          var headers = accordionBodyElement.closest('.accordion').find('.accordion-heading');
	          var panels = $(accordion).find('.accordion-body');
	          if ($($event.currentTarget).is('.fis-accordion-heading-wrapper-active')) {
	            expandcollapsePanel(false, panels, headers);
	            // closing the only open panel - openPanelIndex must be -1
	            $timeout(function () {
	              updateIndex = false;
	              setOpenPanelIndex(-1);
	              updateIndex = true;
	            });
	          } else {
	            expandcollapsePanel(false, panels, headers);
	            expandcollapsePanel(true, accordionBodyElement, $($event.currentTarget));
	            var index = getIndexFromId(currentAttrValue);
	            addIncludedContent(accordionBodyElement, index);
	            $timeout(function () {
	              updateIndex = false;
	              setOpenPanelIndex(parseInt(index, 10));
	              updateIndex = true;
	            });
	          }
	          // e.preventDefault();
	        };
	
	        return collapsableElements;
	      }
	
	      function addIncludedContent(accordionBodyElement, index) {
	        var dataPartial = data[index].partial;
	        if (dataPartial) {
	          var innerElement = accordionBodyElement.find('.accordion-inner');
	          var innerScope = innerElement.scope();
	          // clean up before appending
	          innerElement.empty();
	
	          var contentBuffer = ['<div>'];
	          var content = dataPartial;
	          content = fisUtilService.appendCacheQueryParameter(content);
	          addContentToInclude(contentBuffer, content);
	          contentBuffer.push('</div>');
	          var accordionContent = contentBuffer.join('');
	          accordionContent = angular.element(accordionContent);
	          innerElement.append($compile(accordionContent)(innerScope));
	          $timeout(function () {
	            scope.$apply();
	          });
	        }
	      }
	
	      /**
	       * This function populates each panel with extra data if it is present in the main accordion
	       * JSON data.
	       *
	       * @param element - the accordion
	       * @param data - the accordion data that may contain extra args data
	       * @param panels - collection of panels belonging to the accordion
	       */
	      function populatePanelsWithExtraArgs(element, dataList, panels) {
	        angular.forEach(dataList, function (data, index) {
	          if (!_.isUndefined(data.args)) {
	            var dataArgs = data.args;
	            var panel = panels[index];
	            panel = angular.element(panel);
	            var childScope = panel.scope(); // create a new scope for each panel
	            childScope.panelArgs = dataArgs;
	          }
	        });
	      }
	
	      function getIndexFromId(id) {
	        if (id) {
	          var arr = id.split('_');
	          var lastIndex = arr.length - 1;
	          if (lastIndex > -1) {
	            return arr[lastIndex];
	          }
	        }
	        return 0;
	      }
	
	      function addHeader(headerValue, contentId, parentId) {
	        var buffer = ['<div><div ng-click="collapseHandler($event)" role="tab" class="fis-accordion-heading accordion-heading" '];
	        buffer.push(' fis-unique-id="' + fisI18nService.translate(headerValue, headerValue) + '"');
	        buffer.push('aria-controls="' + contentId + '"');
	        buffer.push(' >');
	        buffer.push('<div class="accordion-toggle " data-parent="#');
	        buffer.push(parentId);
	        buffer.push('_parent" href="#' + contentId + '">');
	        buffer.push('<span class="fis-accordion-caret" ');
	        if (fis.initParams().appStage === 'T') {
	          // In test stage add the id as fisid attribute as well
	          buffer.push('" fisid="');
	          buffer.push(contentId);
	          buffer.push('_caret" ');
	        }
	        buffer.push('/>');
	        buffer.push(fisI18nService.translate(headerValue, headerValue));
	        buffer.push('</div></div></div>');
	        return buffer.join('');
	      }
	
	      function addContent(contentValue, panelIndex, contentId, height, lazyLoading) {
	        var buffer = ['<div id="'];
	        buffer.push(contentId);
	        if (fis.initParams().appStage === 'T') {
	          // In test stage add the id as fisid attribute as well
	          buffer.push('" fisid="');
	          buffer.push(contentId);
	        }
	        buffer.push('" class="accordion-body fis-tab-data" role="tabpanel"><div class="fis-accordion-inner-wrapper"><div class="accordion-inner"');
	        if (height && height !== '') {
	          buffer.push(' style="height:' + height + 'px; overflow:auto;" ');
	        }
	        buffer.push('>');
	        if (!lazyLoading || scope.openPanelIndex === panelIndex) {
	          // if not lazy-loading or the current panel should be opened on start then add content
	          if (contentValue.indexOf('.html') > 0) {
	            // check if partial is passed or template is passed
	            addContentToInclude(buffer, contentValue);
	          } else {
	            buffer.push(contentValue);
	          }
	        }
	        buffer.push('</div></div></div>');
	        return buffer.join('');
	      }
	
	      function populate(list, parentId, height, lazyLoading) {
	        var buffer = [];
	        var counter = 0;
	        var content = null;
	        buffer.push('<div class="accordion-group">');
	        angular.forEach(list, function (data) {
	          var contentId = parentId + '_collapse_' + counter;
	          buffer.push(addHeader(data.label, contentId, parentId));
	          // if the partial is provided,set the content to the partial otherwise set the content to template
	          if (data.partial) {
	            content = data.partial;
	            content = fisUtilService.appendCacheQueryParameter(content);
	          } else {
	            content = data.template;
	          }
	          buffer.push(addContent(content, counter, contentId, height, lazyLoading));
	          counter += 1;
	        });
	        buffer.push('</div>');
	        return buffer.join('');
	      }
	
	      angular.element($window).bind('resize', function () {
	        scope.setHeight();
	      });
	
	      scope.setHeight = function () {
	        var heightTimeout = $timeout(function () {
	          if (scope.fisFixedHeight !== 'sidebar' && scope.fisFixedHeight !== 'viewPanel') {
	            return;
	          }
	          var docHeight;
	          var windoHeight;
	          var margin = 0;
	          var accordion = element.find('.accordion');
	          accordion.height(500);
	          if (scope.fisFixedHeight === 'sidebar') {
	            var sidebar = element.closest('.fis-sidebar');
	            windoHeight = parseInt(sidebar.find('.fis-sidebar-content').height(), 10);
	            docHeight = parseInt(sidebar.find('.sidebar-list').height(), 10);
	            margin = 0;
	          }
	          if (scope.fisFixedHeight === 'viewPanel') {
	            windoHeight = parseInt($($window).height(), 10);
	            docHeight = parseInt($document.height(), 10);
	            margin = 0;
	          }
	          adjustHeight(accordion, docHeight, windoHeight, margin); // eslint-disable-line
	        }, 0);
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, heightTimeout, $timeout);
	      };
	
	      var adjustHeight = function adjustHeight(accordion, docHeight, windoHeight, margin) {
	        var activePanels = element.find('.fis-accordion-heading-wrapper-active');
	        if (activePanels.length === 0) {
	          accordion.css('height', 'auto');
	          accordion.css('overflow', 'auto');
	          return;
	        }
	        scope.fixedHeight = docHeight - parseInt(accordion.height(), 10);
	        var newElementHeight = windoHeight - scope.fixedHeight - margin;
	        // margin for border margin padding
	        if (newElementHeight < 120) {
	          newElementHeight = 120;
	        }
	
	        var notActivePanels = accordion.find('.fis-accordion-heading-wrapper-not-active');
	        var notActivePanelHeight = notActivePanels.length * 35;
	        var activePanelHeight = activePanels.length * 34;
	        // 5 for border margin padding
	        var computedHeight = newElementHeight - (notActivePanelHeight + activePanelHeight + 5);
	        if (computedHeight < 50) {
	          computedHeight = 50;
	        }
	        var activePanelBody = activePanels.next('.accordion-body').find('.fis-accordion-inner-wrapper');
	        activePanelBody.css('height', computedHeight);
	        activePanelBody.css('overflow', 'auto');
	        accordion.css('height', newElementHeight);
	        accordion.css('overflow', 'auto');
	      };
	
	      function addContentToInclude(buffer, contentValue) {
	        buffer.push('<ng-include src="\'');
	        buffer.push(contentValue);
	        buffer.push('\'"/>');
	      }
	
	      /**
	       * Collapses/Expends the incoming panel.
	       * @param isExpending - is the panel expendin/collapsing
	       * @param panel - the panel to collapse
	       */
	      function expandcollapsePanel(isExpending, panel, panelHeader) {
	        if (isExpending) {
	          // Open up the hidden content panel
	          panel.slideDown(300).addClass('open');
	        } else {
	          // Close content panel
	          panel.slideUp(300).removeClass('open');
	        }
	        // var panelHeader =
	        if (panelHeader) {
	          updateHeader(isExpending, panelHeader);
	        }
	      }
	
	      function updateHeader(isExpending, panelHeader) {
	        if (isExpending) {
	          panelHeader.addClass('fis-accordion-heading-wrapper-active').removeClass('fis-accordion-heading-wrapper-not-active');
	          panelHeader.attr('aria-expanded', true);
	          panelHeader.find('.fis-accordion-heading').addClass('fis-accordion-heading-active').removeClass('fis-accordion-heading-not-active');
	          panelHeader.find('.fis-accordion-caret').addClass('fis-accordion-caret-active').removeClass('fis-accordion-caret-not-active');
	        } else {
	          panelHeader.removeClass('fis-accordion-heading-wrapper-active').addClass('fis-accordion-heading-wrapper-not-active');
	          panelHeader.attr('aria-expanded', false);
	          panelHeader.find('.fis-accordion-heading').removeClass('fis-accordion-heading-active').addClass('fis-accordion-heading-not-active');
	          panelHeader.find('.fis-accordion-caret').removeClass('fis-accordion-caret-active').addClass('fis-accordion-caret-not-active');
	        }
	        scope.setHeight();
	      }
	
	      // watch fisOpenPanelIndex
	      // changes made to this method in order to fix defect # SDHTML-14283
	      // defect ticket url: https://www.csa.sungard.com/jira/browse/SDHTML-14283
	      var isNormalInteger = function isNormalInteger(str) {
	        return (/^\+?(0|[1-9]\d*)$/.test(str)
	        );
	      };
	
	      var openPanelIndexWatch = scope.$watch('openPanelIndex', function (newIndex, oldIndex) {
	        if (newIndex !== oldIndex && updateIndex) {
	          var isValidIndex = isNormalInteger(newIndex);
	          newIndex = isValidIndex && newIndex < data.length ? newIndex : 0;
	          // close the open panel
	          var openPanel = element.find('.open');
	          var headers = element.find('.accordion-heading');
	          if (openPanel.length) {
	            expandcollapsePanel(false, $(openPanel), headers);
	          }
	
	          // open the new panel
	          if (isValidIndex) {
	            var collapsable = element.find('.accordion-body')[newIndex];
	            var header = $(headers[newIndex]);
	            var currentAttrValue = $(header).find('.accordion-toggle').attr('href');
	            var index = getIndexFromId(currentAttrValue);
	            if (collapsable) {
	              updateIndex = true;
	              expandcollapsePanel(true, $(collapsable), header);
	              addIncludedContent($(collapsable), index);
	            }
	          }
	        }
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, openPanelIndexWatch);
	
	      var refresh = function refresh(event) {
	        // do not execute the event if event.preventDefault() has been called before
	        if (event && event.defaultPrevented) {
	          return;
	        }
	
	        // Need to add a timeout here to ensure any digest operations on the scope happened before
	        var refreshTimeout = $timeout(function () {
	          buildAccordion(data, true);
	        });
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, refreshTimeout, $timeout);
	      };
	      // listen for the fisRefresh event coming from a parent scope
	      scope.$on('fisRefresh', refresh);
	
	      // redefine the fisRefresh function if it is put on the same element
	      if (fisRefresh) {
	        fisRefresh.trigger = refresh;
	      }
	    }
	  };
	}];
	
	__webpack_require__(/*! ./accordion.styles.less */ 9);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 8)))

/***/ }),
/* 8 */
/*!********************!*\
  !*** external "_" ***!
  \********************/
/***/ (function(module, exports) {

	module.exports = _;

/***/ }),
/* 9 */
/*!****************************************************!*\
  !*** ./components/accordion/accordion.styles.less ***!
  \****************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 10 */
/*!****************************************!*\
  !*** ./components/action-bar/index.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _actionBar = __webpack_require__(/*! ./action-bar.directive */ 11);
	
	var _actionBar2 = _interopRequireDefault(_actionBar);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.action-bar', []);
	
	ngModule.directive('fisActionBar', _actionBar2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 11 */
/*!*******************************************************!*\
  !*** ./components/action-bar/action-bar.directive.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisConfig", "$parse", "$compile", "fisMemoryUtilService", function (fisConfig, $parse, $compile, fisMemoryUtilService) {
	  'ngInject';
	
	  function clearBlocks(primaryBlock, secondaryBlock, tertiaryBlock) {
	    primaryBlock.empty();
	    secondaryBlock.empty();
	    tertiaryBlock.empty();
	  }
	  function setAttributesToButton(elemToAdd, action) {
	    var keys = Object.keys(action);
	    angular.forEach(keys, function (key) {
	      if (key !== 'label') {
	        elemToAdd.attr(key, action[key]);
	      }
	    });
	    elemToAdd.append(action.label);
	  }
	
	  function addButtonToBlock(element, elemToAdd, buttonClass, scope) {
	    var primaryBlock = element.find('div.fis-primary-block');
	    var secondaryBlock = element.find('div.fis-secondary-block');
	    var tertiaryBlock = element.find('div.fis-tertiary-block');
	
	    if (elemToAdd.attr('fis-button')) {
	      var state = $parse(elemToAdd.attr('fis-button'))(scope);
	      if (state === 'primary') {
	        primaryBlock.append(elemToAdd);
	      } else if (state === 'secondary') {
	        secondaryBlock.append(elemToAdd);
	      } else if (state === 'tertiary') {
	        tertiaryBlock.append(elemToAdd);
	      } else {
	        // Default is secondary, even if not specified
	        secondaryBlock.append(elemToAdd);
	      }
	    } else if (buttonClass === 'fis-primary') {
	      primaryBlock.append($compile(angular.element(elemToAdd))(scope));
	    } else if (buttonClass === 'fis-secondary') {
	      secondaryBlock.append($compile(angular.element(elemToAdd))(scope));
	    } else if (buttonClass === 'fis-tertiary') {
	      tertiaryBlock.append($compile(angular.element(elemToAdd))(scope));
	    }
	  }
	  return {
	    restrict: 'C',
	    replace: true,
	    transclude: true,
	    require: '?fisData',
	    template: '<div class="clearfix">\n\t\t\t\t\t<div class="fis-block">\n\t\t\t\t\t\t<div class="fis-primary-block"></div>\n\t\t\t\t\t\t<div class="fis-secondary-block"></div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class="fis-tertiary-block"></div>\n\t\t\t</div>',
	
	    compile: function compile(elem, attrs, transcludeFn) {
	      return function (scope, element, attrs, fisData) {
	        var primaryBlock = element.find('div.fis-primary-block');
	        var secondaryBlock = element.find('div.fis-secondary-block');
	        var tertiaryBlock = element.find('div.fis-tertiary-block');
	        var data = [];
	        if (fisData) {
	          var dataWatch = scope.$watch(attrs.fisData, function () {
	            fisData.fetchData().then(function (result) {
	              clearBlocks(primaryBlock, secondaryBlock, tertiaryBlock);
	              data = result.data;
	              if (angular.isArray(data)) {
	                angular.forEach(data, function (action) {
	                  var elemToAdd = angular.element('<button/>');
	                  setAttributesToButton(elemToAdd, action);
	                  addButtonToBlock(element, elemToAdd, action.class, scope);
	                });
	              }
	            });
	          });
	          fisMemoryUtilService.cancelWatchOnDestroy(scope, dataWatch);
	        }
	
	        transcludeFn(scope, function (clone) {
	          var transcludedButtons = clone.filter(':button');
	          angular.forEach(transcludedButtons, function (elem) {
	            if (angular.element(elem).attr('fis-button')) {
	              var state = $parse(angular.element(elem).attr('fis-button'))(scope);
	
	              if (state === 'primary') {
	                primaryBlock.append(elem);
	              } else if (state === 'secondary') {
	                secondaryBlock.append(elem);
	              } else if (state === 'tertiary') {
	                tertiaryBlock.append(elem);
	              } else {
	                // Default is secondary, even if not specified
	                secondaryBlock.append(elem);
	              }
	            } else if (angular.element(elem).hasClass('fis-primary')) {
	              primaryBlock.append(elem);
	            } else if (angular.element(elem).hasClass('fis-secondary')) {
	              secondaryBlock.append(elem);
	            } else if (angular.element(elem).hasClass('fis-tertiary')) {
	              tertiaryBlock.append(elem);
	            }
	          });
	        });
	        if (fisConfig.primaryActionsFirst === true) {
	          element.addClass('fis-primary-first');
	        }
	      };
	    }
	  };
	}];
	
	__webpack_require__(/*! ./action-bar.styles.less */ 12);

/***/ }),
/* 12 */
/*!******************************************************!*\
  !*** ./components/action-bar/action-bar.styles.less ***!
  \******************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 13 */
/*!****************************************!*\
  !*** ./components/click-icon/index.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _clickIcon = __webpack_require__(/*! ./click-icon.component */ 14);
	
	var _clickIcon2 = _interopRequireDefault(_clickIcon);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.click-icon', []);
	
	ngModule.component('fisClickIcon', _clickIcon2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 14 */
/*!*******************************************************!*\
  !*** ./components/click-icon/click-icon.component.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! ./click-icon.styles.less */ 15);
	
	exports.default = {
	  bindings: {
	    clickFn: '&fisMethod' // ,
	    // icon: '<' This breaks old functionality, and its not documented anywhere that it operates from a scope object
	  },
	  template: '<i class="clickIcon {{$ctrl.icon}}" ng-click="$ctrl.clickIcon($event)"></i>',
	  controller: ['fisConfig', '$attrs', function (fisConfig, $attrs) {
	    var ctrl = this;
	
	    /*
	      SILENCING THE FOLLOWING CODE, I see no feature mentioned on the wiki for this and it broke old functionality
	      ctrl.$onChanges = function (changes) {
	      ctrl.icon = changes.icon.currentValue;
	      resolveIcon();
	    };
	     function resolveIcon() {
	      if (!ctrl.icon) {
	        // default icon
	        if (fisConfig && fisConfig.clickIconConfig) {
	          ctrl.icon = fisConfig.clickIconConfig.default;
	        } else {
	          ctrl.icon = 'glyphicon glyphicon-stop';
	        }
	      }
	    }*/
	    ctrl.icon = $attrs.icon ? $attrs.icon : 'glyphicon glyphicon-stop';
	
	    ctrl.clickIcon = function ($event) {
	      if ($event) {
	        $event.stopPropagation();
	      }
	      // {event:$event} this object literal exposes all key fields to receiving method (fis-method fn)
	      // e.g. fis-method="openFixedMenu(event)" -> event corresponds to event key below
	      if (angular.isFunction(ctrl.clickFn)) {
	        ctrl.clickFn({ event: $event });
	      }
	    };
	  }]
	}; /**
	    * @name fisClickIcon
	    * @description The fisClickIcon directive will add a clickable icon to the DOM with a user specified method
	    *
	    */

/***/ }),
/* 15 */
/*!******************************************************!*\
  !*** ./components/click-icon/click-icon.styles.less ***!
  \******************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 16 */
/*!*******************************************!*\
  !*** ./components/dropdown-menu/index.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _dropdownMenu = __webpack_require__(/*! ./dropdown-menu.component */ 17);
	
	var _dropdownMenu2 = _interopRequireDefault(_dropdownMenu);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.dropdown-menu', []);
	
	ngModule.component('fisDropdownMenu', _dropdownMenu2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 17 */
/*!*************************************************************!*\
  !*** ./components/dropdown-menu/dropdown-menu.component.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! ./dropdown-menu.styles.less */ 18);
	
	exports.default = {}; /**
	                       * @name fisDropdownMenu
	                       * @description The fisDropdownMenu directive will add a clickable icon to the DOM with a user specified method
	                       *
	                       */

/***/ }),
/* 18 */
/*!************************************************************!*\
  !*** ./components/dropdown-menu/dropdown-menu.styles.less ***!
  \************************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 19 */
/*!****************************************!*\
  !*** ./components/fixed-menu/index.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _fixedMenu = __webpack_require__(/*! ./fixed-menu.directive */ 20);
	
	var _fixedMenu2 = _interopRequireDefault(_fixedMenu);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.fixed-menu', []);
	
	ngModule.directive('fisFixedMenu', _fixedMenu2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 20 */
/*!*******************************************************!*\
  !*** ./components/fixed-menu/fixed-menu.directive.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	fisFixedMenu.$inject = ["$window", "fisPubSubService", "fisFixedMenuService", "fisUniqueIdService"];
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = fisFixedMenu;
	
	__webpack_require__(/*! ./fixed-menu.styles.less */ 21);
	
	var _jquery = __webpack_require__(/*! jquery */ 1);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _underscore = __webpack_require__(/*! underscore */ 8);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function fisFixedMenu($window, fisPubSubService, fisFixedMenuService, fisUniqueIdService) {
	  'ngInject';
	
	  return {
	    restrict: 'EA',
	    replace: 'true',
	    scope: {},
	    template: '<div class="fixedMenu"></div>',
	    controller: ['$element', '$scope', function (element, $scope) {
	      $scope.closeQuickActions = function () {
	        if ($scope.onClose) {
	          $scope.onClose();
	        }
	        element.css('display', 'none');
	      };
	    }],
	
	    link: function link(scope, elem, attrs) {
	      // Checks to see if jQuery has an 'outside' function, and adds one if not.
	      // TODO: This needs to be moved to a central location, as it is currently in 3 locations.
	      if (!elem.outside) {
	        (function ($) {
	          $.fn.outside = function (ename, cb) {
	            return this.each(function () {
	              var self = this;
	
	              $(document).on(ename, function tempo(e) {
	                if (e.target !== self && !$.contains(self, e.target)) {
	                  cb.apply(self, [e]);
	                  if (!self.parentNode) $(document.body).off(ename, tempo);
	                }
	              });
	            });
	          };
	        })(_jquery2.default);
	      }
	
	      var closeMenu = function closeMenu() {
	        if (scope.onClose) {
	          scope.onClose();
	        }
	        elem.css('display', 'none');
	      };
	
	      // this registers an 'unclick' which ensures the popup closes when clicking elsewhere
	      elem.outside('click', function () {
	        if (closeMenu) {
	          closeMenu();
	        }
	      });
	
	      // also add a scroll listener that closes the menu when scrolling down the page
	      $window.addEventListener('scroll', closeMenu);
	
	      // when clicking on the tab close icon, it consumes the event and fires this event, we must close here also
	      fisPubSubService.subscribe('fisTabsBar.tabClosed', closeMenu);
	
	      var callMe = function callMe(configObj) {
	        elem.css('display', 'inline');
	        elem.css('left', configObj.position.left).css('top', configObj.position.top + 'px');
	        scope.onClose = configObj.onClose;
	        createMenu(configObj);
	      };
	
	      fisFixedMenuService.register(attrs.id, callMe);
	
	      function createMenu(data) {
	        elem.empty();
	        var menu = createMenuItems(data.items);
	        var menuElement = angular.element(menu);
	        menuElement.on('click', 'a', {}, function (event) {
	          var nodeId = attrs.id;
	          var nodeElement = angular.element(event.target);
	          var idToUse = nodeElement.text();
	          if (!_underscore2.default.isUndefined(nodeElement.attr('id'))) {
	            idToUse = nodeElement.attr('id');
	          }
	          if (!_underscore2.default.isUndefined(nodeElement.attr('method'))) {
	            data.methods[nodeElement.attr('method')](nodeId, idToUse);
	          }
	          scope.closeQuickActions();
	        });
	        elem.append(menuElement);
	      }
	
	      function createMenuItems(items) {
	        var menu = '<div class="dropdown open"><ul class="dropdown-menu">';
	
	        _underscore2.default.each(items, function (item) {
	          var callTarget = '';
	          if (!_underscore2.default.isUndefined(item.method) && item.method.length > 0) {
	            callTarget = 'method="' + item.method + '"';
	          }
	
	          var uniqueId = '';
	          if (!_underscore2.default.isUndefined(item.id) && item.id.length > 0) {
	            uniqueId = 'id="' + item.id + '"';
	          }
	
	          var menuItem = '<li><a ' + uniqueId + ' class="fixedMenuItem" ' + callTarget + '>' + item.label + '</a></li>';
	          var menuItemElement = angular.element(menuItem);
	
	          fisUniqueIdService.generateUniqueId(scope, menuItemElement, {}, item.label);
	
	          menu += menuItemElement[0].outerHTML;
	        });
	
	        menu += '</ul></div>';
	
	        return menu;
	      }
	
	      scope.$on('$destroy', function () {
	        $window.removeEventListener('scroll', closeMenu);
	        closeMenu = undefined;
	      });
	    }
	  };
	} /**
	   * @name fisFixedMenu
	   * @description The fisFixedMenu directive will provide a fixed position menu
	   *
	   */

/***/ }),
/* 21 */
/*!******************************************************!*\
  !*** ./components/fixed-menu/fixed-menu.styles.less ***!
  \******************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 22 */
/*!************************************!*\
  !*** ./components/footer/index.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _footer = __webpack_require__(/*! ./footer.component */ 23);
	
	var _footer2 = _interopRequireDefault(_footer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.footer', []);
	
	ngModule.component('fisFooter', _footer2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 23 */
/*!***********************************************!*\
  !*** ./components/footer/footer.component.js ***!
  \***********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * @name fisFooter
	 * @description
	 <p>This directive can be used to add a footer zone to a container such as fis-panel or a form.
	 The footer can be used for having primary, secondary and tertiary actions. This directive defines
	 an optional attribute fis-summary-text that can be used to add summary text to the footer zone.
	 </p>
	 */
	exports.default = {
	  template: '<footer class="fis-footer" fis-unique-id="footer"><p ng-if="$ctrl.summary">{{$ctrl.summary}}</p><span ng-transclude></span></footer>',
	  transclude: true,
	  bindings: {
	    summary: '@fisSummaryText'
	  }
	};

/***/ }),
/* 24 */
/*!***********************************!*\
  !*** ./components/forms/index.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _checkboxField = __webpack_require__(/*! ./checkbox-field */ 25);
	
	var _checkboxField2 = _interopRequireDefault(_checkboxField);
	
	var _emailField = __webpack_require__(/*! ./email-field */ 28);
	
	var _emailField2 = _interopRequireDefault(_emailField);
	
	var _field = __webpack_require__(/*! ./field */ 31);
	
	var _field2 = _interopRequireDefault(_field);
	
	var _fields = __webpack_require__(/*! ./fields */ 33);
	
	var _fields2 = _interopRequireDefault(_fields);
	
	var _form = __webpack_require__(/*! ./form */ 35);
	
	var _form2 = _interopRequireDefault(_form);
	
	var _passwordField = __webpack_require__(/*! ./password-field */ 38);
	
	var _passwordField2 = _interopRequireDefault(_passwordField);
	
	var _radioField = __webpack_require__(/*! ./radio-field */ 40);
	
	var _radioField2 = _interopRequireDefault(_radioField);
	
	var _searchField = __webpack_require__(/*! ./search-field */ 43);
	
	var _searchField2 = _interopRequireDefault(_searchField);
	
	var _textField = __webpack_require__(/*! ./text-field */ 45);
	
	var _textField2 = _interopRequireDefault(_textField);
	
	var _textareaField = __webpack_require__(/*! ./textarea-field */ 48);
	
	var _textareaField2 = _interopRequireDefault(_textareaField);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.forms', [_checkboxField2.default, _emailField2.default, _field2.default, _fields2.default, _form2.default, _passwordField2.default, _radioField2.default, _searchField2.default, _textField2.default, _textareaField2.default]);
	
	exports.default = ngModule.name;

/***/ }),
/* 25 */
/*!**************************************************!*\
  !*** ./components/forms/checkbox-field/index.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _checkboxField = __webpack_require__(/*! ./checkbox-field.directive */ 26);
	
	var _checkboxField2 = _interopRequireDefault(_checkboxField);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.forms.checkbox-field', []);
	
	ngModule.directive('fisCheckboxField', _checkboxField2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 26 */
/*!*********************************************************************!*\
  !*** ./components/forms/checkbox-field/checkbox-field.directive.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "fisFieldDirectiveFactory", "fisMemoryUtilService", "$timeout", function ($compile, fisFieldDirectiveFactory, fisMemoryUtilService, $timeout) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	    viewTemplate: '{{fieldValue().join(",")}}',
	    fieldValue: function fieldValue($scope, $element, $attrs, models) {
	      // models will contain a ngModel for each checkbox, just get their labels and return an array if the value is true
	      var ret = [];
	      var count = $element.find('.fis-input').length;
	      angular.forEach(models, function (ngModel) {
	        if (!_underscore2.default.isUndefined(ngModel)) {
	          if (!_underscore2.default.isUndefined(ngModel.$modelValue)) {
	            if (count === 1) {
	              setLabelValues(ret, ngModel);
	            } else if (ngModel.$modelValue && ngModel.$viewValue && count > 1) {
	              setLabelValues(ret, ngModel);
	            }
	          }
	        }
	      });
	
	      function setLabelValues(ret, ngModel) {
	        if (ngModel.fisLabel) {
	          ret.push(ngModel.fisLabel); // fis-input automatically decorates ngModel with fisLabel is an 'fis-label' attribute is present on the checkbox input element.
	        } else {
	          ret.push(ngModel.$modelValue); // show values as user don't provided label for checkbox input element
	        }
	      }
	
	      return ret;
	    },
	    require: '?fisData',
	    compile: function compile(element, attrs, transclude, origElem) {
	      return function link(scope, element, attrs, fisData) {
	        var type = 'checkbox';
	        var model = attrs.ngModel || attrs.ngModelInput;
	        // making sure ngModel is not applied on the field element itself
	        delete attrs.ngModel;
	
	        function createCheckboxTemplate(element, origElem, model, type) {
	          var editContainer = element.find('.fis-inputs');
	          var inputs = origElem.find('input');
	          // flag will handle "not to over-write" ng-model-input for multiple input elements
	          // and move -input attributes to element for single input element in fis-components after compile
	          var isMultipleInputElements = true;
	          if (inputs.length === 0) {
	            inputs = angular.element('<input/>');
	            isMultipleInputElements = false;
	          }
	          var inputIdx = 0;
	          angular.forEach(inputs, function (input) {
	            // decorate the input
	            input = angular.element(input);
	
	            var localModel = input.attr('ng-model');
	            if (!localModel && !model) {
	              throw new Error('One of the checkbox inputs is missing a ng-model attribute. ' + input);
	            }
	            var finalModel = localModel;
	            if (!finalModel) {
	              finalModel = model;
	              // create a model based on the one given to the field if input has a name
	              if (input.attr('name')) {
	                finalModel += '.' + input.attr('name');
	              }
	            }
	            input.attr('ng-model', finalModel);
	            input.attr('fis-unique-id', '');
	            if (isMultipleInputElements) {
	              input.attr('fis-input', 'input' + inputIdx++);
	            } else {
	              input.attr('fis-input', 'input');
	            }
	            input.attr('ng-true-value', origElem.attr('ng-true-value-input'));
	            input.attr('ng-false-value', origElem.attr('ng-false-value-input'));
	
	            // check if individual checkbox fields contains 'fis-disabled' attribute
	            var disabledAttr = input.attr('fis-disabled');
	
	            if (!_underscore2.default.isUndefined(disabledAttr)) {
	              // eslint-disable-line
	              // Disable/Enable individual checkbox based on 'fis-disabled' attribute value
	              input.attr('ng-disabled', disabledAttr);
	            } else {
	              // Disable/Enable checkboxes based on 'fisDisabled' attribute value of component level div
	              input.attr('ng-disabled', 'fisDisabled');
	            }
	
	            input.attr('type', type);
	            input.attr('ng-change', origElem.attr('ng-change-input'));
	
	            // append to template
	            var label = '<span class="checkbox-label">' + (input.attr('fis-label') || '') + '</span>';
	            // setting custom label for checkbox field
	            setCustomLabelForCheckbox(input, scope.$eval(finalModel));
	            editContainer.append(angular.element('<label class="fis-checkbox ' + type + ' ' + type + '-' + (attrs.fisInline !== undefined && (attrs.fisInline === '' || attrs.fisInline.toLowerCase() === 'true') && 'inline' || '') + '"></label>').append(input[0]).append('<span class="checkbox-icon"></span>').append(label));
	          });
	          $compile(editContainer)(scope);
	        }
	
	        /*
	          This function sets the fis-true and fis-false-label values
	        */
	        function setCustomLabelForCheckbox(input, CtrlValue) {
	          var inputTrueLabel = element.attr('fis-true-value-label');
	          var inputFalseLabel = element.attr('fis-false-value-label');
	          if (!_underscore2.default.isUndefined(input) && input.length > 0 && !_underscore2.default.isUndefined(CtrlValue)) {
	            /* eslint-disable eqeqeq */
	            if ((input.attr('ng-true-value') == CtrlValue || CtrlValue == true || input[0].checked) && !_underscore2.default.isUndefined(inputTrueLabel) && inputTrueLabel !== '') {
	              input.attr('fis-label', inputTrueLabel);
	            } else if ((input.attr('ng-false-value') == CtrlValue || CtrlValue == false || !input[0].checked) && !_underscore2.default.isUndefined(inputFalseLabel) && inputFalseLabel !== '') {
	              input.attr('fis-label', inputFalseLabel);
	            }
	            /* eslint-enable eqeqeq */
	          }
	          // heapspace cleanup
	          inputTrueLabel = undefined;
	          inputFalseLabel = undefined;
	        }
	
	        // Remove checkbox element from DOM
	        function removeCheckBoxElement() {
	          var checkboxElem = element.find('.fis-checkbox');
	          angular.forEach(checkboxElem, function (checkbox) {
	            $(checkbox).remove();
	          });
	        }
	
	        function fetchDataAndCreateTemplate() {
	          fisData.fetchData().then(function (result) {
	            removeCheckBoxElement();
	            var data = result.data;
	            for (var i = 0; i < data.length; i++) {
	              var name = data[i].name;
	              var label = data[i].label;
	              origElem.append('<input name="' + name + '" fis-label="' + label + '"/>');
	            }
	            createCheckboxTemplate(element, origElem, model, type);
	          });
	        }
	
	        if (fisData) {
	          fetchDataAndCreateTemplate();
	        } else {
	          createCheckboxTemplate(element, origElem, model, type);
	        }
	
	        function setAndUpdateLabel(newVal) {
	          var checkboxElem = element.find('.fis-input');
	          if (!_underscore2.default.isUndefined(checkboxElem) && checkboxElem.length === 1) {
	            setCustomLabelForCheckbox(checkboxElem, newVal);
	            updateDomLabelValue(checkboxElem);
	          }
	          // heapspace cleanup
	          checkboxElem = undefined;
	        }
	
	        if (attrs.fisData && attrs.fisData.indexOf(':') < 0) {
	          try {
	            var fisDataWatch = scope.$watch(attrs.fisData, function (newValue, oldValue) {
	              if (!_underscore2.default.isNaN(newValue) && newValue !== oldValue) {
	                fetchDataAndCreateTemplate();
	              }
	            });
	            fisMemoryUtilService.cancelWatchOnDestroy(scope, fisDataWatch);
	          } catch (e) {
	            console.warn('Cannot watch on fis-data expression ', attrs.fisData);
	          }
	        }
	
	        // This function is used to update the label for single checkbox fields whenever its model value gets changed
	        function updateDomLabelValue(checkboxElem) {
	          var nonEditLabelElem = element.find('.control-label-view');
	          if (!_underscore2.default.isUndefined(nonEditLabelElem) && !_underscore2.default.isUndefined(checkboxElem) && !_underscore2.default.isUndefined(checkboxElem.attr('fis-label')) && nonEditLabelElem.length > 0) {
	            nonEditLabelElem[0].innerHTML = checkboxElem.attr('fis-label');
	          }
	          // heapspace cleanup
	          nonEditLabelElem = undefined;
	        }
	
	        var inputWatch = scope.$watch(attrs.ngModelInput, function (newVal, oldVal) {
	          if (newVal !== oldVal) {
	            $timeout(function () {
	              setAndUpdateLabel(newVal);
	            });
	          }
	        }, true);
	        fisMemoryUtilService.cancelWatchOnDestroy(scope, inputWatch);
	
	        // Destroy checkbox element when scope destroyed
	        scope.$on('$destroy', function () {
	          removeCheckBoxElement();
	        });
	      };
	    }
	  });
	}];
	
	__webpack_require__(/*! ./checkbox-field.styles.less */ 27);
	
	var _underscore = __webpack_require__(/*! underscore */ 8);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 27 */
/*!********************************************************************!*\
  !*** ./components/forms/checkbox-field/checkbox-field.styles.less ***!
  \********************************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 28 */
/*!***********************************************!*\
  !*** ./components/forms/email-field/index.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _emailField = __webpack_require__(/*! ./email-field.directive */ 29);
	
	var _emailField2 = _interopRequireDefault(_emailField);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.forms.email-field', []);
	
	ngModule.directive('fisEmailField', _emailField2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 29 */
/*!***************************************************************!*\
  !*** ./components/forms/email-field/email-field.directive.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "fisFieldDirectiveFactory", function ($compile, fisFieldDirectiveFactory) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	    editTemplate: '\n      <% if (field.attrs.fisPrefix){ %><span class="add-on"><%- field.attrs.fisPrefix %></span> <% } %>\n        <input fis-input="input" type="email" class="input-<%= field.attrs.fisSize %>"/>\n      <% if (field.attrs.fisSuffix){ %><span class="add-on"><%- field.attrs.fisSuffix %></span> <% } %>',
	    viewTemplate: '\n      <% if (field.attrs.fisPrefix){ %><span class="add-on"><%- field.attrs.fisPrefix %></span> <% } %>\n        <a>{{fieldValue()}}</a>\n      <% if (field.attrs.fisSuffix){ %><span class="add-on"><%- field.attrs.fisSuffix %></span> <% } %>',
	    link: function link(scope, element, attrs) {
	      var wrap = element.find('.fis-inputs');
	      if (attrs.fisPrefix) {
	        wrap.addClass('input-prepend');
	      }
	      if (attrs.fisSuffix) {
	        wrap.addClass('input-append');
	      }
	
	      /* since fieldValue() function is not resolved when _.template() is called in the FieldDirective,
	      href="mailto:{{fieldValue}} cannot be added in the viewTemplate's <a> tag. Adding an angular expression
	      in the link function needs an extra compile*/
	
	      var aElem = angular.element(element).find('.fis-view-value').find('a');
	      aElem.attr('href', 'mailto:{{fieldValue()}}');
	      $compile(aElem)(scope);
	    }
	  });
	}];
	
	__webpack_require__(/*! ./email-field.styles.less */ 30);

/***/ }),
/* 30 */
/*!**************************************************************!*\
  !*** ./components/forms/email-field/email-field.styles.less ***!
  \**************************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 31 */
/*!*****************************************!*\
  !*** ./components/forms/field/index.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _field = __webpack_require__(/*! ./field.directive */ 32);
	
	var _field2 = _interopRequireDefault(_field);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.forms.field', []);
	
	ngModule.directive('fisField', _field2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 32 */
/*!***************************************************!*\
  !*** ./components/forms/field/field.directive.js ***!
  \***************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisFieldDirectiveFactory", function (fisFieldDirectiveFactory) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	    transclude: true,
	    editTemplate: '<div ng-transclude></div>' // TODO: replace with compile with transclude function that appends to .controls
	  });
	}];

/***/ }),
/* 33 */
/*!******************************************!*\
  !*** ./components/forms/fields/index.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _fields = __webpack_require__(/*! ./fields.directive */ 34);
	
	var _fields2 = _interopRequireDefault(_fields);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.forms.fields', []);
	
	ngModule.directive('fisFields', _fields2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 34 */
/*!*****************************************************!*\
  !*** ./components/forms/fields/fields.directive.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisScopeUtils", function (fisScopeUtils) {
	  'ngInject';
	
	  /**
	   * @name extractAttributes
	   * @description Function to extract the different types of attributes as fisAttrs, ngAttrs, htmlAttrs from the given list.
	   * @param attrs The list of attributes to get categorized.
	   * @return array returns array of extracted attributes
	   * @methodOf fis.widgets
	   */
	
	  function extractAttributes(attrs) {
	    // sg attributes - needed by SunGard form
	    // components.
	    var fisAttrs = {};
	
	    // ng attributes - angular attrs that should
	    // pass-through
	    var ngAttrs = {};
	
	    // base HTML attributes like id, name or HTML5
	    // data-* etc.
	    var htmlAttrs = {};
	
	    _underscore2.default.each(_underscore2.default.keys(attrs.$attr), function (key) {
	      if (key.match(/^sg/)) {
	        fisAttrs[key] = attrs[key];
	      } else if (key.match(/^ng/)) {
	        // attrs.$attr contains mapping of normalized attribute name to
	        // denormalized name. ex. "ngInit":"ng-init"
	        // get the denormalized attribute name to be copied to target
	        // and add to target element
	        // targetElem.attr(attrs.$attr[key], attrs[key]);
	        var origKey = attrs.$attr[key];
	        ngAttrs[origKey] = attrs[key];
	      } else {
	        htmlAttrs[key] = attrs[key];
	      }
	    });
	
	    return {
	
	      fisAttrs: fisAttrs,
	      ngAttrs: ngAttrs,
	      htmlAttrs: htmlAttrs
	
	    };
	  }
	
	  var htmlText = '<div\n      <% _.each(data.htmlAttrs, function(value, key) { %>\n        <%= key %>="<%= value %>"\n      <% }); %>\n      >\n      <fieldset ng-class="{\'form-horizontal\': !isStacked}">\n        <%= data.contents %>\n      </fieldset>\n    </div>';
	
	  var tmpl = _underscore2.default.template(htmlText);
	
	  return {
	    restrict: 'EA',
	    scope: true,
	    controller: ['$scope', function ($scope) {
	      $scope.fisDisabled = false;
	      $scope.fisEditMode = true;
	      $scope.isStacked = false;
	      /**
	       * @description Function that allows setting and getting whether the labels are stacked or not
	       * @param {Boolean} [state] Optional. True if the labels are to be stacked on top of the input element
	       * @returns Returns whether the labels are stacked or not.
	       */
	      $scope.stackedLabels = function (state) {
	        // state != null tests for undefined and null
	        if (state != null) {
	          // eslint-disable-line
	          $scope.isStacked = Boolean(state); // convert to boolean
	        }
	        return $scope.isStacked;
	      };
	
	      /**
	       * @description Function that allows setting and getting the disabled state of inner fields
	       * @param {Boolean} [state] Optional. True if the fields within this fieldset are to be disabled
	       * @returns Returns whether the fields are disabled or not.
	       */
	      $scope.disabledFields = function (state) {
	        // state != null tests for undefined and null
	        if (state != null) {
	          // eslint-disable-line
	          $scope.fisDisabled = Boolean(state);
	        }
	        return $scope.fisDisabled;
	      };
	
	      /**
	       * @description Function that allows setting and getting the editable state of inner fields
	       * @param {Boolean} [state] Optional. True if the fields within this fieldset should be editable
	       * @returns Returns whether the fields are editable or not.
	       */
	      $scope.editMode = function (state) {
	        // state != null tests for undefined and null
	        if (state != null) {
	          // eslint-disable-line
	          $scope.fisEditMode = Boolean(state); // convert to boolean
	        }
	        return $scope.fisEditMode;
	      };
	    }],
	    compile: function compile(element, attrs) {
	      var contents = element.html();
	      var props = extractAttributes(attrs);
	      props.contents = contents;
	      var markup = tmpl({ data: props });
	      element.replaceWith(markup);
	
	      return function (scope, elem, attrs) {
	        elem.addClass('fis-fields');
	        scope.fisDisabled = scope.$eval(attrs.fisDisabled) || false;
	        scope.fisEditMode = scope.$eval(attrs.fisEditMode) || true;
	        scope.isStacked = scope.$eval(attrs.fisStacked) || false;
	
	        var labelSize = attrs.fisSizeLabel;
	        if (labelSize != undefined) {
	          // eslint-disable-line
	          if (labelSize == '') {
	            // eslint-disable-line
	            labelSize = 'large';
	          }
	          elem.addClass('fis-label-size-' + labelSize);
	        }
	
	        fisScopeUtils.watch(scope.$parent, attrs.fisDisabled, scope.disabledFields);
	        fisScopeUtils.watch(scope.$parent, attrs.fisStacked, scope.stackedLabels);
	        fisScopeUtils.watch(scope.$parent, attrs.fisEditMode, scope.editMode, true);
	      };
	    }
	  };
	}];
	
	var _underscore = __webpack_require__(/*! underscore */ 8);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 35 */
/*!****************************************!*\
  !*** ./components/forms/form/index.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _form = __webpack_require__(/*! ./form.directive */ 36);
	
	var _form2 = _interopRequireDefault(_form);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.forms.form', []);
	
	ngModule.directive('form', _form2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 36 */
/*!*************************************************!*\
  !*** ./components/forms/form/form.directive.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return {
	    restrict: 'E',
	    link: function link(scope, element, attrs) {
	      scope.$watch(attrs.name + '.$dirty', function (newValue, oldValue) {
	        if (newValue !== oldValue && newValue === true) {
	          scope.$emit('fisFormDirty', attrs.name);
	        } else if (newValue !== oldValue && newValue === false) {
	          scope.$emit('fisFormClean', attrs.name);
	        }
	      });
	
	      scope.$watch(attrs.name + '.$invalid', function (newValue, oldValue) {
	        if (newValue !== oldValue && newValue === true) {
	          // console.log('form invalid emitted...');
	          scope.$emit('fisFormInvalid', attrs.name);
	        } else if (newValue !== oldValue && newValue === false) {
	          scope.$emit('fisFormValid', attrs.name);
	          // console.log('form valid emitted...');
	        }
	      });
	    }
	  };
	};
	
	__webpack_require__(/*! ./form.styles.less */ 37);

/***/ }),
/* 37 */
/*!************************************************!*\
  !*** ./components/forms/form/form.styles.less ***!
  \************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 38 */
/*!**************************************************!*\
  !*** ./components/forms/password-field/index.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _passwordField = __webpack_require__(/*! ./password-field.directive */ 39);
	
	var _passwordField2 = _interopRequireDefault(_passwordField);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.forms.password-field', []);
	
	ngModule.directive('fisPasswordField', _passwordField2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 39 */
/*!*********************************************************************!*\
  !*** ./components/forms/password-field/password-field.directive.js ***!
  \*********************************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisFieldDirectiveFactory", function (fisFieldDirectiveFactory) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	    editTemplate: '<% if (field.attrs.fisPrefix){ %><span class="add-on"><%- field.attrs.fisPrefix %></span> <% } %>\n      <input ng-focus="removeInputEvent()" fis-input="input" type="password"\n      class="input-<%= field.attrs.fisSize %>"\n      />\n      <% if (field.attrs.fisSuffix){ %><span class="add-on"><%- field.attrs.fisSuffix %></span> <% } %>',
	    viewTemplate: '<% if (field.attrs.fisPrefix){ %><span class="add-on"><%- field.attrs.fisPrefix %></span> <% } %>\n      {{fieldValue() | obfuscate}}\n      <% if (field.attrs.fisSuffix){ %><span class="add-on"><%- field.attrs.fisSuffix %></span> <% } %>',
	    link: function link(scope, element, attrs) {
	      var wrap = element.find('.fis-inputs');
	      if (attrs.fisPrefix) {
	        wrap.addClass('input-prepend');
	      }
	      if (attrs.fisSuffix) {
	        wrap.addClass('input-append');
	      }
	    }
	  });
	}];

/***/ }),
/* 40 */
/*!***********************************************!*\
  !*** ./components/forms/radio-field/index.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _radioField = __webpack_require__(/*! ./radio-field.directive */ 41);
	
	var _radioField2 = _interopRequireDefault(_radioField);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.forms.radio-field', []);
	
	ngModule.directive('fisRadioField', _radioField2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 41 */
/*!***************************************************************!*\
  !*** ./components/forms/radio-field/radio-field.directive.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "fisFieldDirectiveFactory", "fisMemoryUtilService", function ($compile, fisFieldDirectiveFactory, fisMemoryUtilService) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	    fieldValue: function fieldValue($scope, $element, $attrs, models) {
	      var ret = [];
	      var selectedViewValue;
	      if (!_underscore2.default.isUndefined(models) && models.length > 0) {
	        selectedViewValue = String(models[0].$modelValue);
	      }
	      var inputs = $element.find('input');
	
	      angular.forEach(inputs, function (input) {
	        input = angular.element(input);
	        var inputValue = input.attr('value');
	        // selectedViewValue may be undefined if no radio button selected
	        if (inputValue === selectedViewValue) {
	          var inputLabel = input.attr('fis-label');
	          if (!_underscore2.default.isUndefined(inputLabel)) {
	            ret = inputLabel;
	          }
	        }
	      });
	
	      if (ret.length === 0) {
	        ret = '';
	      }
	
	      return ret;
	    },
	    require: '?fisData',
	    compile: function compile(element, attrs, transclude, origElem) {
	      return function link(scope, element, attrs, fisData) {
	        var type = 'radio';
	        var model = attrs.ngModel || attrs.ngModelInput;
	        // making sure ngModel is not applied on the field element itself
	        delete attrs.ngModel;
	
	        function createRadioTemplate(element, origElem, model, type) {
	          var container = element.find('.fis-inputs');
	          var inputs = origElem.find('input');
	          var inputIdx = 0;
	          angular.forEach(inputs, function (input) {
	            // decorate the input
	            input = angular.element(input);
	
	            var localModel = input.attr('ng-model') || model;
	            input.attr('tabindex', '0');
	            input.attr('role', 'radio');
	
	            if (!localModel) {
	              throw new Error('One of the checkbox inputs is missing a ng-model attribute. ' + input);
	            }
	
	            // create a model based on the one given to the field if input has a name
	            if (input.attr('name')) {
	              localModel += '.' + input.attr('name');
	            }
	
	            input.attr('ng-model', localModel);
	            if (!input.attr('name')) {
	              input.attr('name', localModel);
	            }
	            input.attr('fis-unique-id', '');
	            input.attr('fis-input', 'input' + inputIdx++);
	
	            // check if field has required constraint or not.
	            if (attrs.required != null && attrs.required != undefined) {
	              // eslint-disable-line
	              input.attr('required', attrs.required);
	            } else if (attrs.fisRequired != null && attrs.fisRequired != undefined) {
	              // eslint-disable-line
	              var isRequired = attrs.fisRequired === 'true';
	              input.attr('required', isRequired);
	            }
	
	            var disabledAttr = input.attr('fis-disabled');
	
	            if (!_underscore2.default.isUndefined(disabledAttr)) {
	              // eslint-disable-line no-negated-condition
	              input.attr('ng-disabled', disabledAttr);
	            } else {
	              input.attr('ng-disabled', 'fisDisabled');
	            }
	
	            input.attr('type', type);
	            input.attr('ng-change', origElem.attr('ng-change-input'));
	
	            // append to template
	            var label = '<span class="radio-label">' + (input.attr('fis-label') || '') + '</span>';
	            container.append(angular.element('<label class="fis-radio ' + type + ' ' + type + '-' + (attrs.fisInline !== undefined && (attrs.fisInline === '' || attrs.fisInline.toLowerCase() === 'true') && 'inline' || '') + '"></label>').append(input[0]).append('<span class="radio-icon"></span>').append(label));
	          });
	          $compile(container)(scope);
	        }
	
	        // Remove radio element from DOM
	        function removeRadioElement() {
	          var radioElem = element.find('.fis-radio');
	          angular.forEach(radioElem, function (radio) {
	            $(radio).remove();
	          });
	        }
	
	        function fetchDataAndCreateTemplate() {
	          fisData.fetchData().then(function (result) {
	            removeRadioElement();
	            var data = result.data;
	            for (var i = 0; i < data.length; i++) {
	              var value = data[i].value;
	              var label = data[i].label;
	              if (typeof value === 'string') {
	                origElem.append('<input value="' + value + '" fis-label="' + label + '"/>');
	              } else {
	                origElem.append('<input ng-value="' + value + '" fis-label="' + label + '"/>');
	              }
	            }
	            createRadioTemplate(element, origElem, model, type);
	          });
	        }
	
	        if (fisData) {
	          fetchDataAndCreateTemplate();
	        } else {
	          createRadioTemplate(element, origElem, model, type);
	        }
	
	        if (attrs.fisData && attrs.fisData.indexOf(':') < 0) {
	          try {
	            var fisDataWatch = scope.$watch(attrs.fisData, function (newValue, oldValue) {
	              if (!_underscore2.default.isNaN(newValue) && newValue !== oldValue) {
	                fetchDataAndCreateTemplate();
	              }
	            });
	            fisMemoryUtilService.cancelWatchOnDestroy(scope, fisDataWatch);
	          } catch (e) {
	            console.warn('Cannot watch on fis-data expression ', attrs.fisData);
	          }
	        }
	
	        // Destroy checkbox element when scope destroyed
	        scope.$on('$destroy', function () {
	          removeRadioElement();
	        });
	      };
	    }
	  });
	}];
	
	__webpack_require__(/*! ./radio-field.styles.less */ 42);
	
	var _underscore = __webpack_require__(/*! underscore */ 8);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 42 */
/*!**************************************************************!*\
  !*** ./components/forms/radio-field/radio-field.styles.less ***!
  \**************************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 43 */
/*!************************************************!*\
  !*** ./components/forms/search-field/index.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _searchField = __webpack_require__(/*! ./search-field.directive */ 44);
	
	var _searchField2 = _interopRequireDefault(_searchField);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.forms.search-field', []);
	
	ngModule.directive('fisSearchField', _searchField2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 44 */
/*!*****************************************************************!*\
  !*** ./components/forms/search-field/search-field.directive.js ***!
  \*****************************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisFieldDirectiveFactory", function (fisFieldDirectiveFactory) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	    editTemplate: '<% if (field.attrs.fisPrefix){ %><span class="add-on"><%- field.attrs.fisPrefix %></span> <% } %>\n      <input fis-input="input" type="search"\n        class="input-<%= field.attrs.fisSize %>"\n      />\n      <% if (field.attrs.fisSuffix){ %><span class="add-on"><%- field.attrs.fisSuffix %></span> <% } %>',
	    viewTemplate: '<% if (field.attrs.fisPrefix){ %><span class="add-on"><%- field.attrs.fisPrefix %></span> <% } %>\n      {{fieldValue()}}\n      <% if (field.attrs.fisSuffix){ %><span class="add-on"><%- field.attrs.fisSuffix %></span> <% } %>',
	    link: function link(scope, element, attrs) {
	      var wrap = element.find('.fis-inputs');
	      if (attrs.fisPrefix) {
	        wrap.addClass('input-prepend');
	      }
	      if (attrs.fisSuffix) {
	        wrap.addClass('input-append');
	      }
	    }
	  });
	}];

/***/ }),
/* 45 */
/*!**********************************************!*\
  !*** ./components/forms/text-field/index.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _textField = __webpack_require__(/*! ./text-field.directive */ 46);
	
	var _textField2 = _interopRequireDefault(_textField);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.forms.text-field', []);
	
	ngModule.directive('fisTextField', _textField2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 46 */
/*!*************************************************************!*\
  !*** ./components/forms/text-field/text-field.directive.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisFieldDirectiveFactory", function (fisFieldDirectiveFactory) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	    editTemplate: '<% if (field.attrs.fisPrefix){ %><span class="add-on"><%- field.attrs.fisPrefix %></span> <% } %>\n      <input fis-input="input" type="text" role="textbox" aria-disabled="{{setAriaDisabled()}}"\n        class="form-control input-<%= field.attrs.fisSize %>"\n      />\n      <% if (field.attrs.fisSuffix){ %><span class="add-on"><%- field.attrs.fisSuffix %></span> <% } %>',
	    viewTemplate: '<% if (field.attrs.fisPrefix){ %><span class="add-on"><%- field.attrs.fisPrefix %></span> <% } %>\n      {{fieldValue()}}\n      <% if (field.attrs.fisSuffix){ %><span class="add-on"><%- field.attrs.fisSuffix %></span> <% } %>',
	    link: function link(scope, element, attrs) {
	      var wrap = element.find('.fis-inputs');
	
	      if (attrs.fisPrefix) {
	        wrap.addClass('input-prepend');
	      }
	
	      if (attrs.fisSuffix) {
	        wrap.addClass('input-append');
	      }
	      function isDisabled() {
	        return scope.$eval(attrs.fisDisabled);
	      }
	      scope.setAriaDisabled = function () {
	        return Boolean(isDisabled());
	      };
	    }
	  });
	}];
	
	__webpack_require__(/*! ./text-field.styles.less */ 47);

/***/ }),
/* 47 */
/*!************************************************************!*\
  !*** ./components/forms/text-field/text-field.styles.less ***!
  \************************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 48 */
/*!**************************************************!*\
  !*** ./components/forms/textarea-field/index.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _textareaField = __webpack_require__(/*! ./textarea-field.directive */ 49);
	
	var _textareaField2 = _interopRequireDefault(_textareaField);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.forms.textarea-field', []);
	
	ngModule.directive('fisTextareaField', _textareaField2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 49 */
/*!*********************************************************************!*\
  !*** ./components/forms/textarea-field/textarea-field.directive.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisFieldDirectiveFactory", function (fisFieldDirectiveFactory) {
	  'ngInject';
	
	  return fisFieldDirectiveFactory.create({
	    editTemplate: '<textarea fis-input="input" role="textbox" aria-multiline="true" class="input-<%= field.attrs.fisSize %>">{{fieldValue()}}</textarea>',
	    viewTemplate: '<div class="input-<%= field.attrs.fisSize %>"><p>{{fieldValue()}}</p></div>',
	    link: function link(scope, element, attrs) {
	      var wrap = element.find('textarea');
	      var viewDiv = element.find('.fis-view-value > div');
	      var defaultCss = {
	        'max-height': '',
	        'overflow-y': '',
	        'overflow-x': ''
	      };
	
	      wrap.css('resize', 'none');
	      attrs.$observe('fisResizable', function (newVal) {
	        if (document && document.documentMode && document.documentMode > 9) {
	          if (newVal === 'horizontal') {
	            $(wrap).resizable({
	              handles: 'e'
	            });
	            $(wrap).next().addClass('fis-resize-handler-ie-horizontal ui-icon ui-icon-gripsmall-diagonal-se');
	          } else if (newVal === 'vertical') {
	            $(wrap).resizable({
	              handles: 's'
	            });
	            $(wrap).next().addClass('fis-resize-handler-ie-vertical ui-icon ui-icon-gripsmall-diagonal-se');
	          } else if (newVal === 'both') {
	            $(wrap).resizable({
	              handles: 'se'
	            });
	            $(wrap).next().addClass('fis-resize-handler-ie-both');
	          }
	        } else if (newVal === 'horizontal' || newVal === 'vertical' || newVal === 'both') {
	          wrap.css('resize', newVal);
	        }
	      });
	
	      viewDiv.css(defaultCss);
	      attrs.$observe('fisViewModeMaxHeight', function (newVal) {
	        var css = {};
	        if (!isNaN(newVal) && newVal >= 0) {
	          css = {
	            'max-height': newVal + 'px',
	            'overflow-x': 'hidden',
	            'overflow-y': 'auto'
	          };
	        } else {
	          css = defaultCss;
	        }
	        viewDiv.css(css);
	      });
	      // heapspace cleanup
	      scope = undefined;
	      element = undefined;
	      attrs = undefined;
	    }
	  });
	}];
	
	__webpack_require__(/*! ./textarea-field.styles.less */ 50);

/***/ }),
/* 50 */
/*!********************************************************************!*\
  !*** ./components/forms/textarea-field/textarea-field.styles.less ***!
  \********************************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 51 */
/*!************************************!*\
  !*** ./components/header/index.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _header = __webpack_require__(/*! ./header.directive */ 52);
	
	var _header2 = _interopRequireDefault(_header);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.header', []);
	
	ngModule.directive('fisHeader', _header2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 52 */
/*!***********************************************!*\
  !*** ./components/header/header.directive.js ***!
  \***********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return {
	    template: '<header class="fis-header"><h2>{{title}}</h2><div class="fis-controls" ng-transclude></div></header>',
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    scope: {
	      title: '@fisTitle',
	      icon: '@fisIcon'
	    }
	  };
	};

/***/ }),
/* 53 */
/*!************************************!*\
  !*** ./components/hotkey/index.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _hotkey = __webpack_require__(/*! ./hotkey.directive */ 54);
	
	var _hotkey2 = _interopRequireDefault(_hotkey);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.hotkey', []);
	
	ngModule.directive('fisHotkey', _hotkey2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 54 */
/*!***********************************************!*\
  !*** ./components/hotkey/hotkey.directive.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$parse", "$window", "$timeout", "$location", "fisPubSubService", function ($parse, $window, $timeout, $location, fisPubSubService) {
	  'ngInject';
	
	  var hotkeys = [];
	  var hotKeyMap = {};
	  var fireFunction = true;
	
	  function bindHotkey(scopeVal, hotkey, fn, attrs, elem) {
	    // custom filter - changes scope depending on which type of element has focus when shortcut invoked
	    _keymaster2.default.filter = function (event) {
	      var tagName = (event.target || event.srcElement).tagName;
	      if (tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA') {
	        _keymaster2.default.setScope('input');
	      } else {
	        _keymaster2.default.setScope('normal');
	      }
	      return true;
	    };
	    // global = true --> shortcut must work whether in or out of input tags
	    if (!_underscore2.default.isUndefined(attrs.fisGlobal) && attrs.fisGlobal === 'true') {
	      // Add binding to input scope
	      (0, _keymaster2.default)(hotkey, 'input', function (hotkey) {
	        if (fireFunction && elem.is(':visible')) {
	          if (!_underscore2.default.isUndefined(attrs.fisOnHotkeyEvent)) {
	            transformKeyToString(hotkey, scopeVal);
	          }
	          scopeVal.$apply(fn(scopeVal, {}));
	          return false;
	        }
	      });
	    }
	    // add binding to normal scope
	    (0, _keymaster2.default)(hotkey, 'normal', function (hotkey) {
	      if (fireFunction && elem.is(':visible')) {
	        if (!_underscore2.default.isUndefined(attrs.fisOnHotkeyEvent)) {
	          transformKeyToString(hotkey, scopeVal);
	        }
	        scopeVal.$apply(fn(scopeVal, {}));
	        return false;
	      }
	    });
	  }
	
	  function transformKeyToString(hotkey, scope) {
	    var key = String.fromCharCode(hotkey.keyCode);
	    var retStr = '';
	    var specialKeys = [];
	    if (hotkey.shiftKey) {
	      specialKeys.push('shift');
	    }
	    if (hotkey.altKey) {
	      specialKeys.push('alt');
	    }
	    if (hotkey.metaKey) {
	      specialKeys.push('meta');
	    }
	    if (hotkey.ctrlKey) {
	      specialKeys.push('ctrl');
	    }
	    if (hotkey.altGraphKey) {
	      specialKeys.push('altGraph');
	    }
	    _underscore2.default.each(specialKeys, function (specialkey) {
	      retStr += specialkey + '+';
	    });
	    retStr += key;
	    scope.fisHotKeyPressedKey = retStr.toLowerCase();
	  }
	
	  function getPanelId() {
	    var hash = $window.location.hash.substring(2);
	    // if hash part contains another #, then use the path only till there
	    if (hash.indexOf('#') !== -1) {
	      hash = hash.substring(0, hash.indexOf('#'));
	    }
	    var path = hash.replace(/\//g, '_');
	    return path;
	  }
	
	  // This code is used to bind/unbind the hotkeys whenever user switch tabs
	  fisPubSubService.subscribe('fisActiveViewPanelChanged', function () {
	    bindUnbindHotkeys();
	  });
	
	  // This code is used to bind/unbind the hotkeys whenever user closes a tab
	  fisPubSubService.subscribe('fisViewPanelClosed', function () {
	    bindUnbindHotkeys();
	  });
	
	  function bindUnbindHotkeys() {
	    $timeout(function () {
	      var curPanelId = getPanelId();
	      var num;
	
	      for (var curPanel in hotKeyMap) {
	        if (curPanel !== curPanelId) {
	          // eslint-disable-line
	          // unbinding hotkeys
	          var curObj = hotKeyMap[curPanel];
	          for (num = 0; num < curObj.length; num++) {
	            _keymaster2.default.unbind(curObj[num].hotkey, 'normal');
	            _keymaster2.default.unbind(curObj[num].hotkey, 'input');
	          }
	        } else {
	          var existingObj = hotKeyMap[curPanelId];
	          if (existingObj) {
	            // binding hotkeys
	            for (num = 0; num < existingObj.length; num++) {
	              bindHotkey(existingObj[num].scope, existingObj[num].hotkey, existingObj[num].eventHandler, existingObj[num].attrs, existingObj[num].elem);
	            }
	          }
	        }
	      }
	      hotkeys = [];
	    });
	  }
	
	  return {
	    restrict: 'AEC',
	    link: function link(scope, elem, attrs) {
	      var fn = $parse(attrs.ngClick);
	      var oldVal;
	      var fisCustomHotkey = true;
	
	      if (!_underscore2.default.isUndefined(attrs.fisOnHotkeyEvent)) {
	        fn = $parse(attrs.fisOnHotkeyEvent);
	      }
	      if (!fn) {
	        return;
	      }
	
	      // Listen to changes of fisHotkey attributes (get's also triggered first time)
	      attrs.$observe('fisHotkey', function (newVal) {
	        // Unbind previous bindings to this element to prevent multiple triggering
	        if (!_underscore2.default.isUndefined(oldVal)) {
	          _keymaster2.default.unbind(oldVal, 'normal');
	          _keymaster2.default.unbind(oldVal, 'input');
	        }
	        if (attrs.fisCustomHotkey) {
	          fisCustomHotkey = attrs.fisCustomHotkey;
	        }
	
	        bindHotkey(scope, newVal, fn, attrs, elem);
	        var tempObj = {};
	        tempObj.eventHandler = fn;
	        tempObj.hotkey = newVal;
	        tempObj.scope = scope;
	        tempObj.attrs = attrs;
	        tempObj.elem = elem;
	        oldVal = newVal;
	
	        // by default all hot keys will be considered as user defined unless user use fis-custom-hotkey = 'false'
	        if (fisCustomHotkey == true) {
	          // eslint-disable-line
	          hotkeys.push(tempObj);
	        }
	
	        var panelId = getPanelId();
	        if (panelId && hotkeys.length > 0) {
	          hotKeyMap[panelId] = hotkeys;
	        }
	      });
	
	      // Observe disable to remove the binding from disabled elements
	      attrs.$observe('disabled', function (newVal) {
	        if (_underscore2.default.isBoolean(newVal)) {
	          fireFunction = !newVal;
	        }
	      });
	
	      // Observe fisGlobal to add the binding for input, select and textarea elements
	      attrs.$observe('fisGlobal', function (newVal) {
	        if (!angular.isUndefined(newVal)) {
	          _keymaster2.default.unbind(attrs.fisHotkey, 'normal');
	          _keymaster2.default.unbind(attrs.fisHotkey, 'input');
	          bindHotkey(scope, attrs.fisHotkey, fn, attrs, elem);
	        }
	      });
	    }
	  };
	}];
	
	var _keymaster = __webpack_require__(/*! keymaster */ 55);
	
	var _keymaster2 = _interopRequireDefault(_keymaster);
	
	var _underscore = __webpack_require__(/*! underscore */ 8);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 55 */
/*!**********************!*\
  !*** external "key" ***!
  \**********************/
/***/ (function(module, exports) {

	module.exports = key;

/***/ }),
/* 56 */
/*!******************************************!*\
  !*** ./components/image-select/index.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _imageSelect = __webpack_require__(/*! ./image-select.directive */ 57);
	
	var _imageSelect2 = _interopRequireDefault(_imageSelect);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.image-select', []);
	
	ngModule.directive('fisImageSelect', _imageSelect2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 57 */
/*!***********************************************************!*\
  !*** ./components/image-select/image-select.directive.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var counter = 0;
	  return {
	    restrict: 'AE',
	    require: 'ngModel',
	    replace: false,
	    scope: {
	      localModel: '=ngModel',
	      fisSrc: '@',
	      fisPosition: '@',
	      fisAlt: '@'
	    },
	    template: '<div class="fis-image-select">' + '<label for="{{uid}}" ng-class="{sgimagedesaturate: !localModel}"><img alt="{{fisAlt}}"/><span class="fis-image-select-icon"></span></label>' + '<input type="checkbox" id="{{uid}}" ng-model="localModel" fis-unique-id="fis-image-select"/>' + '</div>',
	    link: function link(scope, element, attrs) {
	      var image = element.find('img');
	      scope.uid = 'fis-image-select-' + counter++;
	      if (attrs.fisSrc) {
	        image.attr('src', attrs.fisSrc);
	      }
	      if (attrs.fisSize) {
	        element.find('.fis-image-select').addClass('fis-image-select-' + attrs.fisSize);
	      }
	      if (scope.fisPosition) {
	        element.find('.fis-image-select').addClass('fis-position-' + scope.fisPosition);
	      }
	    }
	  };
	};
	
	__webpack_require__(/*! ./image-select.styles.less */ 58);

/***/ }),
/* 58 */
/*!**********************************************************!*\
  !*** ./components/image-select/image-select.styles.less ***!
  \**********************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 59 */
/*!****************************************!*\
  !*** ./components/info-panel/index.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _infoPanel = __webpack_require__(/*! ./info-panel.directive */ 60);
	
	var _infoPanel2 = _interopRequireDefault(_infoPanel);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.info-panel', []);
	
	ngModule.directive('fisInfoPanel', _infoPanel2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 60 */
/*!*******************************************************!*\
  !*** ./components/info-panel/info-panel.directive.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisMemoryUtilService", "fisInfoPanelConfigService", "$timeout", function (fisMemoryUtilService, fisInfoPanelConfigService, $timeout) {
	  'ngInject';
	
	  return {
	    template: '<div ng-hide="displayMessageOnPanel()" ng-class="msgClass()" ng-click="showDetails()">\n                  <button ng-show="closeable" fis-unique-id="closeButton" type="button" class="close" aria-label="close" ng-click="dismissMessages(); stopAnimation(); $event.stopPropagation();"><i class="glyphicon glyphicon-remove"></i></button>\n                  <ul><li aria-live="polite" aria-atomic="false" ng-repeat="msg in messages" ng-bind-html="msg.message || msg.msg"></li></ul>\n                  </div>',
	    restrict: 'ACE',
	    replace: true,
	    scope: true,
	    controller: ['$scope', '$element', function ($scope, $element) {
	      var types = ['info', 'success', 'warning', 'error'];
	      var classes = ['alert fis-info glyphicon glyphicon-info-sign', 'alert fis-success glyphicon glyphicon-ok', 'alert fis-warning glyphicon glyphicon-warning-sign', 'alert fis-error glyphicon glyphicon-warning-sign'];
	
	      var elementSizeCssClass;
	      var elementPositionCssClass;
	      // Read config file for fisInfoPanel customization
	      var infoPanelConfigDef = {};
	
	      infoPanelConfigDef = fisInfoPanelConfigService.getAnimationTimeout();
	
	      function setElementSize() {
	        if ($element.hasClass(elementSizeCssClass)) {
	          $element.removeClass(elementSizeCssClass);
	        }
	        elementSizeCssClass = undefined;
	        var size = $scope.infoPanelDef.size || infoPanelConfigDef.size;
	        var position = $scope.infoPanelDef.position || infoPanelConfigDef.position;
	        if (size) {
	          elementSizeCssClass = 'fis-info-panel-size-' + size;
	        } else if (position) {
	          elementSizeCssClass = 'fis-info-panel-size-default';
	        }
	
	        if (elementSizeCssClass) {
	          $element.addClass(elementSizeCssClass);
	        }
	      }
	
	      function setElementPosition() {
	        if ($element.hasClass(elementPositionCssClass)) {
	          $element.removeClass(elementPositionCssClass);
	        }
	        elementPositionCssClass = undefined;
	        var position = $scope.infoPanelDef.position || infoPanelConfigDef.position;
	        if (position) {
	          elementPositionCssClass = 'fis-info-panel-position-' + position;
	        }
	        if (elementPositionCssClass) {
	          $element.addClass(elementPositionCssClass);
	        }
	      }
	
	      function removeInfoPanel() {
	        if ($scope.messages && $scope.messages.length !== 0) {
	          if ($scope.dismissMessages) {
	            $scope.dismissMessages();
	          }
	        }
	        $element.css('visibility', 'hidden');
	        $element.off('mouseenter mouseleave');
	
	        // $scope.removeMessageFromCacheForPath();
	      }
	
	      function insertInfoPanel() {
	        $element.stop(true, false);
	        $element.css('opacity', '1');
	        $element.css('display', 'block');
	        $element.css('visibility', 'visible');
	      }
	
	      function handleAnimation(timeout) {
	        $timeout(function () {
	          $element.fadeOut(timeout, removeInfoPanel);
	        });
	        $element.hover(function () {
	          $element.stop(true, false).fadeOut();
	          $element.stop(true, true).fadeIn(0);
	        }, function () {
	          $element.fadeOut(timeout, removeInfoPanel);
	        });
	      }
	
	      function showAnimation() {
	        var timeout;
	        if ($scope.infoPanelDef.animation) {
	          timeout = $scope.infoPanelDef.animation.timeout;
	        } else if (infoPanelConfigDef.animation) {
	          timeout = infoPanelConfigDef.animation.timeout;
	        }
	        if (timeout) {
	          if (angular.isObject(timeout)) {
	            timeout = parseInt(timeout[$scope.messages[0].type], 10);
	          } else if (angular.isString(timeout)) {
	            timeout = parseInt(timeout, 10);
	          }
	        } else {
	          timeout = 10000;
	        }
	
	        if (timeout !== 0) {
	          if ($element.is(':visible')) {
	            handleAnimation(timeout);
	          } else {
	            var animationTimeout = $timeout(function () {
	              handleAnimation(timeout);
	            }, 0);
	            fisMemoryUtilService.cancelTimeoutOnDestroy($scope, animationTimeout, $timeout);
	          }
	        }
	        $scope.timeout = timeout;
	      }
	
	      function handleClickHandler() {
	        if (angular.isFunction($scope.infoPanelDef.clickHandler)) {
	          $scope.showDetails = function () {
	            $scope.stopAnimation();
	            $scope.infoPanelDef.clickHandler($scope.infoPanelDef.response);
	          };
	        }
	      }
	
	      function applyConfigurationToInfoPanel() {
	        setElementSize();
	        setElementPosition();
	        showAnimation();
	        handleClickHandler();
	      }
	
	      function configureInfoPanel() {
	        if (!_.isUndefined($scope.infoPanelDef) && !$scope.infoPanelDef.isMessageShown) {
	          $element.stop(true, false).fadeOut();
	          insertInfoPanel();
	          $scope.infoPanelDef.isMessageShown = true;
	          applyConfigurationToInfoPanel();
	        }
	      }
	
	      $scope.msgClass = function () {
	        if ($scope.messages && $scope.messages.length === 0) {
	          return 'hide';
	        }
	        var typeIdx = 0;
	        angular.forEach($scope.messages, function (val) {
	          typeIdx = Math.max(typeIdx, types.indexOf(val.type));
	        });
	
	        configureInfoPanel();
	        // Add closing x to error message if timeout = 0 --> no timeout period
	        if ($scope.timeout === 0 && typeIdx === 3) {
	          $scope.closeable = true;
	        } else {
	          $scope.closeable = typeIdx <= 3;
	        }
	        return classes[typeIdx];
	      };
	
	      $scope.stopAnimation = function () {
	        $element.stop(true, true).fadeOut(0);
	        $element.off('mouseenter mouseleave');
	        removeInfoPanel();
	      };
	
	      var messagesWatch = $scope.$watch('messages', function (messages) {
	        if (messages && messages.length === 0 && $element.is(':visible')) {
	          removeInfoPanel();
	        }
	      }, true);
	      fisMemoryUtilService.cancelWatchOnDestroy($scope, messagesWatch);
	    }],
	    compile: function compile() {
	      return function (scope, element) {
	        if (!element.hasClass('fis-info-panel')) {
	          element.addClass('fis-info-panel');
	        }
	      };
	    }
	  };
	}];
	
	__webpack_require__(/*! ./info-panel.styles.less */ 61);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 8)))

/***/ }),
/* 61 */
/*!******************************************************!*\
  !*** ./components/info-panel/info-panel.styles.less ***!
  \******************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 62 */
/*!******************************************!*\
  !*** ./components/list-builder/index.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _listBuilder = __webpack_require__(/*! ./list-builder.directive */ 63);
	
	var _listBuilder2 = _interopRequireDefault(_listBuilder);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.list-builder', []);
	
	ngModule.directive('fisListBuilder', _listBuilder2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 63 */
/*!***********************************************************!*\
  !*** ./components/list-builder/list-builder.directive.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisI18nService", "$compile", "$timeout", "fisSortService", "$parse", "fisUniqueIdService", "fisMemoryUtilService", "fisElementUtils", "fisPubSubService", function (fisI18nService, $compile, $timeout, fisSortService, $parse, fisUniqueIdService, fisMemoryUtilService, fisElementUtils, fisPubSubService) {
	  'ngInject';
	
	  /**
	   * Order items in list so they are in the same order as they appear in base
	   * E.g. Calling ([F,D,A], [A,B,C,D,E,F]) => list will be [A,D,F]
	   *      Calling ([F,D,A], [F,E,D,C,B,A]) => list will be [F,D,A]
	   */
	
	  function applyOrderBasedOn(list, base) {
	    if (_underscore2.default.isUndefined(list) || list.length === 0) {
	      return;
	    }
	    var prevList = _underscore2.default.pluck(list, 'value');
	    list.length = 0;
	    _underscore2.default.each(base, function (item) {
	      if (prevList.indexOf(item.value) > -1) {
	        list.push(item);
	      }
	    });
	  }
	
	  function orderObjectList($scope, list) {
	    if ($scope.fisSort === 'alphabetical-asc' || $scope.fisSort === 'alphabetical-desc') {
	      fisSortService.sort(list, $scope.fisSort, $scope.caseSensitiveSorting);
	    } else if ((_underscore2.default.isUndefined($scope.fisSort) || $scope.fisSort === 'natural') && $scope.fisManualOrder === 'false') {
	      // No sort-order specified or natural sort order AND fisManualOrder is false
	      // => we need to make sure that the items in target are in the same order as in allData array
	      if ($scope.isGroupedList) {
	        for (var group in $scope.groupedAllDataUnindexed) {
	          if (list && list.length > 0 && list[0].group === group) {
	            applyOrderBasedOn(list, $scope.groupedAllDataUnindexed[group]);
	          }
	        }
	      } else {
	        applyOrderBasedOn(list, $scope.allDataUnindexed);
	      }
	    }
	  }
	
	  return {
	    restrict: 'EA',
	    template: '<div class="fis-list-builder">\n                <!--Left hand ListBox-->\n                <div class="fis-list-builder-left-container">\n                    <p class="fis-list-builder-title" fis-unique-id="leftListBoxTitle{{uniqueSeed}}" ng-if="showLabel">{{ labelLeft }}</p>\n                    <input id="left_filter_box" ng-disabled="fisDisabled" ng-if="showFilter" fis-unique-id="leftSearchFilter{{uniqueSeed}}" ng-model="filterLeft.text" class="fis-list-builder-search-filter" name="fis-list-builder-search" type="search" placeholder="Filter..."/>\n                    <div class="fis-list-builder-left-inner-container">\n                    <div class="k-loading-mask" ng-if="isLoading.left"><span class="k-loading-text">Loading...</span>\n                    <div class="k-loading-image"></div>\n                        <div class="k-loading-color"></div>\n                    </div>\n                    <div class="fis-list-builder-left" fis-unique-id="leftListBox{{uniqueSeed}}">\n                    <div ng-if="isGroupedList">\n                    <div ng-repeat="(groupName,data) in visibleGroupLeftData track by groupName">\n                        <span ng-if="data.length"><strong fis-unique-id="group_name_left">{{groupName}}</strong></span>\n                        <ul><li ng-init="getClassList(item.class)" fis-unique-id="left_{{item.label.trim()}}{{uniqueSeed}}" ng-class="{ \'fis-list-builder-option\': !isSelected(item, \'left\'), \'fis-list-builder-option-selected\': isSelected(item, \'left\'), \'fisDisabled\':fisDisabled, \'{{classList.list}}\':{{classList.isClassPresent}}}"\n                             ng-repeat="item in data track by item.value"\n                             ng-click="fisDisabled || changeItemWrapper(item, \'left\')" ng-dblclick="fisDisabled || changeItemWrapper(item, \'left\'); fisDisabled || moveToRightBox();"\n                            unselectable="on"\n                            >{{item.label.trim()}}</li></ul></div>\n                    </div>\n                    <div ng-if="!isGroupedList" >\n                        <ul><li ng-init="getClassList(item.class)" fis-unique-id="left_{{item.label.trim()}}{{uniqueSeed}}" ng-class="{ \'fis-list-builder-option\': !isSelected(item, \'left\'), \'fis-list-builder-option-selected\': isSelected(item, \'left\'), \'fisDisabled\':fisDisabled, \'{{classList.list}}\':{{classList.isClassPresent}}}"\n                         ng-repeat="item in visibleLeftData track by item.value"\n                         ng-click="fisDisabled || changeItemWrapper(item, \'left\')" ng-dblclick="fisDisabled || changeItemWrapper(item, \'left\'); fisDisabled || moveToRightBox();"\n                        unselectable="on"\n                        >{{item.label.trim()}}</li></ul>\n                    </div>\n                </div>\n                </div>\n                 </div>\n                <!--Buttons -->\n                <div class="fis-list-builder-holder fis-list-builder-holder-middle" >\n                    <div class="fis-list-builder-middle-floater"></div>\n                    <div class="fis-list-builder-middle">\n                        <div ng-click="fisDisabled || moveAllToRightBox()" ng-class="{\'fis-list-builder-button\':true, \'fisDisabled\': fisDisabled}" fis-unique-id="moveAllRightButtonListBox{{uniqueSeed}}" aria-label="move all to right"><div class="fis-list-builder-right-right-icon"></div></div>\n                        <div class="fis-list-builder-spacer"/>\n                        <div ng-click="fisDisabled || moveToRightBox()" ng-class="{\'fis-list-builder-button\':true, \'fisDisabled\': fisDisabled}" fis-unique-id="moveRightButtonListBox{{uniqueSeed}}" aria-label="move to right"><div class="fis-list-builder-right-icon"></div></div>\n                        <div class="fis-list-builder-spacer"/>\n                        <div ng-click="fisDisabled || moveToLeftBox()" ng-class="{\'fis-list-builder-button\':true, \'fisDisabled\': fisDisabled}" fis-unique-id="moveLeftButtonListBox{{uniqueSeed}}" aria-label="move to left"><div class="fis-list-builder-left-icon"></div></div>\n                        <div class="fis-list-builder-spacer"/>\n                        <div ng-click="fisDisabled || moveAllToLeftBox()" ng-class="{\'fis-list-builder-button\':true, \'fisDisabled\': fisDisabled}" fis-unique-id="moveAllLeftButtonListBox{{uniqueSeed}}" aria-label="move all to left"><div class="fis-list-builder-left-left-icon"></div></div>\n                    </div>\n                </div>\n                    <!--Right hand ListBox-->\n                    <div class="fis-list-builder-right-container">\n                    <p class="fis-list-builder-title" fis-unique-id="rightListBoxTitle{{uniqueSeed}}" ng-if="showLabel">{{ labelRight }}</p>\n                    <input id="right_filter_box" ng-disabled="fisDisabled" ng-if="showFilter" fis-unique-id="rightSearchFilter{{uniqueSeed}}" ng-model="filterRight.text" class="fis-list-builder-search-filter" name="fis-list-builder-search" type="search" placeholder="Filter..." />\n                    <div class="fis-list-builder-right-inner-container">\n                    <div class="k-loading-mask" ng-if="isLoading.right"><span class="k-loading-text">Loading...</span>\n                    <div class="k-loading-image"></div>\n                        <div class="k-loading-color"></div>\n                    </div>\n                    <div class="fis-list-builder-right" fis-unique-id="rightListBox{{uniqueSeed}}">\n                    <div ng-if="isGroupedList">\n                        <div ng-repeat="(groupName,data) in visibleGroupRightData">\n                        <span ng-if="data.length"><strong fis-unique-id="group_name_right">{{groupName}}</strong></span>                        <ul><li ng-init="getClassList(item.class)" fis-unique-id="right_{{item.label.trim()}}{{uniqueSeed}}" ng-class="{ \'fis-list-builder-option\': !isSelected(item, \'right\'), \'fis-list-builder-option-selected\': isSelected(item, \'right\'), \'fisDisabled\':fisDisabled, \'{{classList.list}}\':{{classList.isClassPresent}}}"\n                        ng-repeat="item in data track by item.value" class= {{}}\n                        unselectable="on"\n                        ng-click="fisDisabled || changeItemWrapper(item, \'right\')" ng-dblclick="fisDisabled || changeItemWrapper(item, \'right\');fisDisabled || moveToLeftBox();"\n                        >{{item.label.trim()}}</li></ul></div>\n                    </div>\n                    <div ng-if="!isGroupedList">\n                        <ul><li ng-init="getClassList(item.class)" fis-unique-id="right_{{item.label.trim()}}{{uniqueSeed}}" ng-class="{ \'fis-list-builder-option\': !isSelected(item, \'right\'), \'fis-list-builder-option-selected\': isSelected(item, \'right\'), \'fisDisabled\':fisDisabled, \'{{classList.list}}\':{{classList.isClassPresent}}}"\n                        ng-repeat="item in visibleRightData track by item.value"\n                        unselectable="on"\n                        ng-click="fisDisabled || changeItemWrapper(item, \'right\')" ng-dblclick="fisDisabled || changeItemWrapper(item, \'right\');fisDisabled || moveToLeftBox();"\n                        >{{item.label.trim()}}</li></ul>\n                    </div>\n                    </div>\n                    </div>\n                </div>\n                <span ng-class="{\'fisDisabled\': fisDisabled}"></span>\n                <div class="fis-list-builder-holder fis-list-builder-holder-updown" name="fis-list-builder-holder-right">\n                    <div class="fis-list-builder-updown-floater"></div>\n                    <div class="fis-list-builder-updown" ng-if="showUpDownButtons">\n                        <div ng-click="fisDisabled || moveSelectedUpOrDown(true)" ng-class="{\'fisDisabled\': fisDisabled}" class = "fis-list-builder-button fis-list-builder-button-up" fis-unique-id="upButtonListBox{{uniqueSeed}}" aria-label="move selected item up" ><div class="fis-list-builder-up-icon" ></div></div>\n                        <div class="fis-list-builder-spacer"/>\n                        <div ng-click="fisDisabled || moveSelectedUpOrDown(false)" ng-class="{\'fisDisabled\': fisDisabled}" class = "fis-list-builder-button" fis-unique-id="downButtonListBox{{uniqueSeed}}" aria-label="move selected item down"><div class="fis-list-builder-down-icon"></div></div>\n                    </div>\n                </div>\n                </div>',
	    require: ['fisData', '?fisRefresh', '?fisReinit'],
	    scope: {
	      selectedRightData: '=?fisSelectedData',
	      fisManualOrder: '@',
	      labelLeft: '@fisLabelLeft',
	      uniqueSeed: '@fisUniqueIdSeed',
	      labelRight: '@fisLabelRight',
	      fisCustomFilterLeft: '&fisCustomFilterLeft',
	      fisDisabled: '@fisDisabled'
	    },
	
	    controller: ['$element', '$scope', '$attrs', function (element, $scope, attrs) {
	      // Used for shift selection
	      $scope.lastItemClicked = {
	        left: {},
	        right: {}
	      };
	      $scope.rightData = [];
	      $scope.leftData = [];
	      $scope.allData = {}; // All data in an object, indexed by value
	      $scope.allDataUnindexed = []; // All data in an array, not indexed
	      $scope.filterRight = {};
	      $scope.filterRight.text = '';
	
	      $scope.filterLeft = {};
	      $scope.filterLeft.text = '';
	
	      $scope.showLabel = false;
	      $scope.showFilter = false;
	      $scope.leftLabel = undefined;
	      $scope.rightLabel = undefined;
	      $scope.showUpDownButtons = true;
	
	      $scope.ctrlPressed = false;
	      $scope.shiftPressed = false;
	
	      $scope.isGroupedList = false;
	      $scope.groupListLeft = {};
	      $scope.visibleGroupLeftData = {};
	      $scope.groupListRight = {};
	      $scope.visibleGroupRightData = {};
	      $scope.movingDataFromLeft = true;
	      $scope.movingDataFromRight = true;
	      $scope.groupedAllDataUnindexed = [];
	      // To determine the css class to set
	      $scope.isSelected = function (item, direction) {
	        return _underscore2.default.contains($scope['selectedItem' + capitalize(direction)], item);
	      };
	
	      function capitalize(text) {
	        return text.charAt(0).toUpperCase() + text.slice(1);
	      }
	
	      $scope.classList = {};
	      $scope.classList.list = '';
	      $scope.classList.isClassPresent = false;
	
	      $scope.getClassList = function (listClass) {
	        // $scope.classList.list = listClass;
	        if (typeof listClass === 'string') {
	          $scope.classList.list = listClass.replace(/,/g, ' ');
	        } else if (angular.isArray(listClass)) {
	          $scope.classList.list = listClass.toString().replace(/,/g, ' ');
	        }
	        $scope.classList.isClassPresent = !angular.isUndefined(listClass);
	      };
	
	      /**
	       * Processes an item selection, adds it to the selectedItem(Left||Right) Array
	       * @param item The item that was newly selected
	       * @param direction left or right, defining the box the item is in
	       * @returns {*} The new selectedItem(Left||Right) array containing all items currently selected
	       */
	      function changeItem(item, direction) {
	        var array = $scope['selectedItem' + capitalize(direction)];
	        var items = $scope['visible' + capitalize(direction) + 'Data'];
	        var shiftStart = $scope.lastItemClicked[direction].start;
	        var shiftEndOld = $scope.lastItemClicked[direction].endOld;
	
	        if ($scope.isGroupedList) {
	          items = getAllGroupedItems(direction, true); // eslint-disable-line
	        }
	
	        if (!_underscore2.default.contains(array, item)) {
	          if ($scope.ctrlPressed !== true && $scope.shiftPressed !== true) {
	            array = [];
	          }
	
	          if ($scope.shiftPressed === true && !_underscore2.default.isUndefined(shiftStart)) {
	            if (!_underscore2.default.isUndefined(shiftEndOld)) {
	              array = unselectOldShiftSelection(items, shiftStart, shiftEndOld, array);
	            }
	            array = selectForShiftPressed(items, item, shiftStart, array);
	          } else {
	            array.push(item);
	          }
	        } else if (_underscore2.default.contains(array, item) && array.length > 1) {
	          array = [];
	          array.push(item);
	        }
	
	        return array;
	      }
	
	      /**
	       * Called when an item in a list get's clicked
	       * @param item The item that was clicked
	       * @param direction left or right, defining the box the item is in
	       */
	      $scope.changeItemWrapper = function (item, direction) {
	        prepareForNewShiftSelect(direction);
	
	        $scope['selectedItem' + capitalize(direction)] = changeItem(item, direction);
	
	        rememberForNextShiftSelect(item, direction);
	      };
	
	      // This function is returns a array of all the items in Left/Right column of the List builder widget
	      var getAllGroupedItems = function getAllGroupedItems(direction, changeItem) {
	        var tempGroupedObject = {};
	        var tempselectionArray = [];
	
	        if (changeItem) {
	          tempGroupedObject = $scope['visibleGroup' + capitalize(direction) + 'Data'];
	        } else if (direction === 'left') {
	          tempGroupedObject = $.extend(true, {}, $scope.groupListLeft);
	          getDataAfterClearFilter(tempGroupedObject, $scope.visibleGroupRightData); // eslint-disable-line
	        } else {
	          tempGroupedObject = $.extend(true, {}, $scope.groupListRight);
	          getDataAfterClearFilter(tempGroupedObject, $scope.visibleGroupLeftData); // eslint-disable-line
	        }
	
	        for (var group in tempGroupedObject) {
	          // eslint-disable-line
	          tempselectionArray = tempselectionArray.concat(tempGroupedObject[group]);
	        }
	        return tempselectionArray;
	      };
	
	      function prepareForNewShiftSelect(direction) {
	        if (!$scope.shiftPressed) {
	          // New Potential Shift Selection Started
	          $scope.lastItemClicked[direction].start = undefined;
	          $scope.lastItemClicked[direction].endOld = undefined;
	        }
	      }
	
	      function rememberForNextShiftSelect(item, direction) {
	        if ($scope.shiftPressed) {
	          // This shift selection was processed, remember for potential later de-selection
	          $scope.lastItemClicked[direction].endOld = item;
	        } else {
	          // Remember shift selection start
	          $scope.lastItemClicked[direction].start = item;
	        }
	      }
	
	      function selectForShiftPressed(items, item, lastClickedItem, array) {
	        // Need to find out which items to put into the array now - the newly selected one could be
	        // above or below the previously selected one
	        var selectAllOnwards = false;
	        if (array && !$scope.isGroupedList) {
	          array.length = 0;
	        }
	
	        for (var i = 0; i < items.length; i++) {
	          var itemInList = items[i];
	
	          if (!selectAllOnwards && (itemInList === item || itemInList === lastClickedItem)) {
	            array.push(itemInList);
	            selectAllOnwards = true;
	          } else if (selectAllOnwards) {
	            // Item in the middle - push to the selected items
	            array.push(itemInList);
	
	            if (itemInList === item || itemInList === lastClickedItem) {
	              break;
	            }
	          }
	        }
	        return array;
	      }
	
	      function unselectOldShiftSelection(items, shiftStart, shiftEndOld, array) {
	        var unselectAllOnwards = false;
	        for (var i = 0; i < items.length; i++) {
	          var currentItem = items[i];
	
	          if (!unselectAllOnwards && (currentItem === shiftStart || currentItem === shiftEndOld)) {
	            if (currentItem === shiftEndOld) {
	              // Deselect
	              remove(array, currentItem);
	            }
	
	            unselectAllOnwards = true;
	          } else if (unselectAllOnwards) {
	            if (currentItem !== shiftStart) {
	              // Deselect
	              remove(array, currentItem);
	            }
	
	            if (currentItem === shiftStart || currentItem === shiftEndOld) {
	              return array;
	            }
	          }
	        }
	      }
	
	      function remove(array, item) {
	        var index = array.indexOf(item);
	
	        if (index > -1) {
	          array.splice(index, 1);
	        }
	      }
	
	      // TODO: Move to utility service
	      $scope.moveElement = function (array, index, delta) {
	        // This method moves an element within the array
	        // index = the array item you want to move
	        // delta = the direction and number of spaces to move the item.
	        //
	        // For example:
	        // moveElement(myarray, 5, -1); // move up one space
	        // moveElement(myarray, 2, 1); // move down one space
	        //
	        // Returns true for success, false for error.
	        var index2;
	        var tempItem;
	
	        // Make sure the index is within the array bounds
	        if (index < 0 || index >= array.length) {
	          return false;
	        }
	
	        // Make sure the target index is within the array bounds
	        index2 = index + delta;
	        if (index2 < 0 || index2 >= array.length || index2 === index) {
	          return false;
	        }
	
	        // Move the elements in the array
	        tempItem = array[index2];
	        array[index2] = array[index];
	        array[index] = tempItem;
	
	        return true;
	      };
	
	      $scope.moveSelectedUpOrDown = function (isUp) {
	        var selectedItems = $scope.selectedItemRight;
	        var array;
	        if (selectedItems.length === 0) {
	          return;
	        }
	
	        if ($scope.isGroupedList) {
	          for (var group in $scope.visibleGroupRightData) {
	            if (selectedItems && selectedItems.length === 1) {
	              if (group === selectedItems[0].group) {
	                array = [];
	                array = array.concat($scope.visibleGroupRightData[group]);
	                moveItemsUpOrDown(isUp, array, selectedItems, $scope.visibleGroupRightData[group]); // eslint-disable-line
	              }
	            }
	          }
	        } else {
	          array = [];
	          array = array.concat($scope.rightData);
	          moveItemsUpOrDown(isUp, array, selectedItems); // eslint-disable-line
	        }
	      };
	
	      var moveItemsUpOrDown = function moveItemsUpOrDown(isUp, array, selectedItems, target) {
	        if (!isUp) {
	          array.reverse();
	        }
	
	        if (selectedItems.length > 0) {
	          _underscore2.default.each(array, function (element, listIndex) {
	            if (_underscore2.default.contains(selectedItems, element)) {
	              $scope.moveElement(array, listIndex, -1);
	            }
	          });
	        }
	
	        if (!isUp) {
	          array.reverse();
	        }
	
	        if ($scope.isGroupedList) {
	          target.length = 0;
	          angular.forEach(array, function (item) {
	            target.push(item);
	          });
	        } else {
	          $scope.rightData = array;
	        }
	      };
	      /**
	       * Move items from source to target array (e.g. from leftData to RightData)
	       * @param selectedItems The items to be moved
	       * @param source The source array
	       * @param target The target array
	       */
	      $scope.moveTo = function (selectedItems, source, target) {
	        var copySelectedItems = [];
	        var sortNeeded = false;
	        var isGroupedSource = false;
	        var isGroupedTarget = false;
	        angular.forEach(selectedItems, function (selectedItem) {
	          copySelectedItems.push(selectedItem);
	        });
	
	        if (copySelectedItems.length > 1) {
	          if ($scope.fisSort === 'add-top' || $scope.fisSort === 'add-bottom' || $scope.fisSort === 'natural') {
	            // Order selected items in same way as they appear in source. Thus the order we selected them does not
	            // effect their later order in target
	            if ($scope.isGroupedList) {
	              source = source[copySelectedItems[0].group]; // taking the group value from first item in array as we know all items belong to same group
	              isGroupedSource = true;
	            }
	            applyOrderBasedOn(copySelectedItems, source);
	          }
	          if ($scope.fisSort === 'add-top' || $scope.fisSort === 'natural') {
	            // As we add the items one by one to the target list, we need to do this
	            // in reverse order if we've got multiple selected items, to move them
	            // as a block and keep the order of the items inside that block
	            // e.g. (listBuilder with add-top, mark A, B, C and move to right will otherwise result in C, B, A in right list)
	            copySelectedItems = copySelectedItems.reverse();
	          }
	        }
	        // iterate over the copy otherwise the same array is modified using the splice method below
	        _underscore2.default.each(copySelectedItems, function (selectedItem) {
	          if ($scope.isGroupedList) {
	            if (!isGroupedTarget) {
	              target = target[selectedItem.group];
	              isGroupedTarget = true;
	            }
	            if (!isGroupedSource) {
	              source = source[selectedItem.group];
	              isGroupedSource = true;
	            }
	          }
	          if (selectedItem !== undefined && !_underscore2.default.contains(target, selectedItem)) {
	            if ($scope.fisSort === 'add-bottom' || $scope.fisSort === 'add-top') {
	              // Add-Top and Add-Bottom strategy is handled by fisSortService
	              fisSortService.addItemToList(target, selectedItem, $scope.fisSort);
	            } else {
	              // Otherwise simply add the new item to the beginning. Alphabetical ordering will happen due do watches
	              // Natural sort order will happen below
	              target.unshift(selectedItem);
	              sortNeeded = true;
	            }
	
	            // remove from left box
	            _underscore2.default.each(source, function (item, index) {
	              if (!_underscore2.default.isUndefined(item) && selectedItem.value === item.value) {
	                source.splice(index, 1);
	              }
	            });
	          }
	        });
	
	        if (sortNeeded && $scope.fisManualOrder === 'false') {
	          orderObjectList($scope, target);
	        }
	      };
	
	      // This function is used to set the status of loading icons for the ListBuilder
	      $scope.setLoadingIconsStatus = function (icon, status) {
	        if (icon === 'left') {
	          $scope.isLoading.left = status;
	        } else if (icon === 'right') {
	          $scope.isLoading.right = status;
	        } else if (icon === 'both') {
	          $scope.isLoading.left = status;
	          $scope.isLoading.right = status;
	        }
	      };
	
	      /**
	       * Move all currently selected items in the left box to the right box
	       */
	      $scope.moveToRightBox = function () {
	        if (!_underscore2.default.isEmpty($scope.selectedItemLeft)) {
	          // We're only able to move something to the right, if we selected something on the left
	          $scope.setLoadingIconsStatus('both', true);
	          var moveTimeout = $timeout(function () {
	            if ($scope.isGroupedList) {
	              var tempSelectionMap = getSelectionItemsToMove($scope.selectedItemLeft); // eslint-disable-line
	              for (var group in tempSelectionMap) {
	                // eslint-disable-line
	                $scope.moveTo(tempSelectionMap[group], $scope.visibleGroupLeftData, $scope.visibleGroupRightData);
	              }
	              $scope.movingDataFromLeft = true;
	              makeDeepCopyObject($scope.groupListRight, $scope.visibleGroupRightData); // eslint-disable-line
	            } else {
	              $scope.moveTo($scope.selectedItemLeft, $scope.leftData, $scope.rightData);
	            }
	            $scope.selectedItemLeft = [];
	            $scope.filterBothData();
	            $scope.setLoadingIconsStatus('both', false);
	            fisPubSubService.publish('fis.lb.moved-selected-right', { leftdata: $scope.leftData, rightdata: $scope.rightData });
	          });
	          fisMemoryUtilService.cancelTimeoutOnDestroy($scope, moveTimeout, $timeout);
	        }
	      };
	
	      // This function is used to get the grouped selectionItems to be moved from left to right and vice versa
	      var getSelectionItemsToMove = function getSelectionItemsToMove(selectedItems) {
	        var tempSelectionMap = {};
	        for (var count = 0; count < selectedItems.length; count++) {
	          if (angular.isUndefined(tempSelectionMap[selectedItems[count].group])) {
	            tempSelectionMap[selectedItems[count].group] = [];
	          }
	          tempSelectionMap[selectedItems[count].group].push(selectedItems[count]);
	        }
	        return tempSelectionMap;
	      };
	
	      /**
	       * Move all currently selected items in the right box to the left box
	       */
	      $scope.moveToLeftBox = function () {
	        if (!_underscore2.default.isEmpty($scope.selectedItemRight)) {
	          // We're only able to move something to the left, if we selected something on the right
	          $scope.setLoadingIconsStatus('both', true);
	          var moveTimeout = $timeout(function () {
	            if ($scope.isGroupedList) {
	              var tempSelectionMap = getSelectionItemsToMove($scope.selectedItemRight);
	              for (var group in tempSelectionMap) {
	                // eslint-disable-line
	                $scope.moveTo(tempSelectionMap[group], $scope.visibleGroupRightData, $scope.visibleGroupLeftData);
	              }
	              $scope.movingDataFromRight = true;
	              makeDeepCopyObject($scope.groupListLeft, $scope.visibleGroupLeftData); // eslint-disable-line
	            } else {
	              $scope.moveTo($scope.selectedItemRight, $scope.rightData, $scope.leftData);
	            }
	            $scope.selectedItemRight = [];
	            $scope.filterBothData();
	            $scope.setLoadingIconsStatus('both', false);
	            fisPubSubService.publish('fis.lb.moved-selected-left', { leftdata: $scope.leftData, rightdata: $scope.rightData });
	          });
	          fisMemoryUtilService.cancelTimeoutOnDestroy($scope, moveTimeout, $timeout);
	        }
	      };
	
	      // This function is used to make the deep copy of the javascript objects
	      var makeDeepCopyObject = function makeDeepCopyObject(target, source) {
	        for (var group in source) {
	          // eslint-disable-line
	          var valArray = _underscore2.default.pluck(target[group], 'value');
	          for (var count = 0; count < source[group].length; count++) {
	            if (valArray.indexOf(source[group][count].value) < 0) {
	              target[group].push(source[group][count]);
	            }
	          }
	        }
	      };
	
	      /**
	       * Move all items from the right to the left box
	       */
	      $scope.moveAllToLeftBox = function () {
	        $scope.setLoadingIconsStatus('both', true);
	        var moveTimeout = $timeout(function () {
	          if ($scope.isGroupedList) {
	            for (var group in $scope.visibleGroupRightData) {
	              // eslint-disable-line
	              $scope.moveTo($scope.visibleGroupRightData[group], $scope.visibleGroupRightData, $scope.visibleGroupLeftData);
	            }
	            $scope.movingDataFromRight = true;
	            makeDeepCopyObject($scope.groupListLeft, $scope.visibleGroupLeftData);
	          } else {
	            $scope.moveTo($scope.visibleRightData, $scope.rightData, $scope.leftData);
	          }
	          $scope.filterBothData();
	          $scope.setLoadingIconsStatus('both', false);
	          fisPubSubService.publish('fis.lb.moved-all-left', { leftdata: $scope.leftData, rightdata: $scope.rightData });
	        });
	        fisMemoryUtilService.cancelTimeoutOnDestroy($scope, moveTimeout, $timeout);
	      };
	
	      /**
	       * Move all items from the left to the right box
	       */
	      $scope.moveAllToRightBox = function () {
	        $scope.setLoadingIconsStatus('both', true);
	        var moveTimeout = $timeout(function () {
	          if ($scope.isGroupedList) {
	            for (var group in $scope.visibleGroupLeftData) {
	              // eslint-disable-line
	              $scope.moveTo($scope.visibleGroupLeftData[group], $scope.visibleGroupLeftData, $scope.visibleGroupRightData);
	            }
	            $scope.movingDataFromLeft = true;
	            makeDeepCopyObject($scope.groupListRight, $scope.visibleGroupRightData);
	          } else {
	            $scope.moveTo($scope.visibleLeftData, $scope.leftData, $scope.rightData);
	          }
	          $scope.filterBothData();
	          $scope.setLoadingIconsStatus('both', false);
	          fisPubSubService.publish('fis.lb.moved-all-right', { leftdata: $scope.leftData, rightdata: $scope.rightData });
	        });
	        fisMemoryUtilService.cancelTimeoutOnDestroy($scope, moveTimeout, $timeout);
	      };
	
	      /**
	       * Update the visible items for the list boxes depending on the data in the rightData
	       * and leftData and the filter
	       */
	      $scope.filterBothData = function () {
	        filterLeftData(); // eslint-disable-line
	        filterRightData(); // eslint-disable-line
	      };
	
	      /**
	       * Set the visible data for the left listbox, based on the items currently in leftData and the filter
	       */
	      var filterLeftData = function filterLeftData() {
	        if (_underscore2.default.isEmpty($scope.leftData) && !$scope.isGroupedList) {
	          $scope.visibleLeftData = $scope.leftData;
	          if (!$scope.dataInLoadingPhase) {
	            $scope.setLoadingIconsStatus('left', false);
	          }
	        } else if (_underscore2.default.isEmpty($scope.groupListLeft) && $scope.isGroupedList) {
	          $scope.visibleGroupLeftData = $.extend(true, {}, $scope.groupListLeft);
	          if (!$scope.dataInLoadingPhase) {
	            $scope.setLoadingIconsStatus('left', false);
	          }
	        } else {
	          $scope.setLoadingIconsStatus('left', true);
	          var filterTimeout = $timeout(function () {
	            // Start filter-work inside a timeout, so angular first displays the loading indicator
	            var filterText = $scope.filterLeft.text.toLowerCase();
	            var filterByText = _underscore2.default.isString(filterText) && filterText.length > 0;
	            var useCustomFilter = !_underscore2.default.isUndefined(attrs.fisCustomFilterLeft) && attrs.fisCustomFilterLeft.length > 0;
	            var group;
	
	            if (filterByText || useCustomFilter) {
	              if ($scope.isGroupedList) {
	                var filterResult = [];
	                filterResult = _underscore2.default.filter(getAllGroupedItems('left'), function (item) {
	                  return (!filterByText || item.label.toLowerCase().indexOf(filterText) !== -1 || item.group.toLowerCase().indexOf(filterText) !== -1) && (!useCustomFilter || $scope.fisCustomFilterLeft({ item: item }));
	                });
	                for (group in $scope.visibleGroupLeftData) {
	                  // eslint-disable-line
	                  $scope.visibleGroupLeftData[group].length = 0;
	                }
	                for (var count = 0; count < filterResult.length; count++) {
	                  if (angular.isUndefined($scope.visibleGroupLeftData[filterResult[count].group])) {
	                    $scope.visibleGroupLeftData[filterResult[count].group] = [];
	                  }
	                  $scope.visibleGroupLeftData[filterResult[count].group].push(filterResult[count]);
	                }
	                $scope.movingDataFromLeft = false;
	              } else {
	                $scope.visibleLeftData = _underscore2.default.filter($scope.leftData, function (item) {
	                  return (!filterByText || item.label.toLowerCase().indexOf(filterText) !== -1) && (!useCustomFilter || $scope.fisCustomFilterLeft({ item: item }));
	                });
	              }
	            } else if ($scope.isGroupedList && !$scope.movingDataFromLeft) {
	              // get the remaining data to show after clearing the filter option
	              getDataAfterClearFilter($scope.groupListLeft, $scope.visibleGroupRightData); // eslint-disable-line
	              $scope.visibleGroupLeftData = $.extend(true, {}, $scope.groupListLeft);
	              $scope.movingDataFromLeft = true;
	            } else {
	              $scope.visibleLeftData = $scope.leftData;
	            }
	
	            if ($scope.isGroupedList) {
	              for (group in $scope.visibleGroupLeftData) {
	                // eslint-disable-line
	                orderObjectList($scope, $scope.visibleGroupLeftData[group]);
	              }
	            } else {
	              orderObjectList($scope, $scope.visibleLeftData);
	            }
	            $scope.setLoadingIconsStatus('left', false);
	          });
	          fisMemoryUtilService.cancelTimeoutOnDestroy($scope, filterTimeout, $timeout);
	        }
	      };
	      $scope.$watch('filterLeft.text', filterLeftData);
	      $scope.$watch('leftData', filterLeftData, true);
	
	      /**
	       * Set the visible data for the right listbox, based on the items currently in rightData and the filter
	       */
	      var filterRightData = function filterRightData() {
	        if (_underscore2.default.isEmpty($scope.rightData) && !$scope.isGroupedList) {
	          $scope.visibleRightData = $scope.rightData;
	        } else if (_underscore2.default.isEmpty($scope.groupListRight) && $scope.isGroupedList) {
	          $scope.visibleGroupRightData = $.extend(true, {}, $scope.groupListRight);
	        } else {
	          $scope.setLoadingIconsStatus('right', true);
	          var filterTimeout = $timeout(function () {
	            // Start filter-work inside a timeout, so angular first displays the loading indicator
	            var filterText = $scope.filterRight.text.toLowerCase();
	            var group;
	
	            if (_underscore2.default.isString(filterText) && filterText.length > 0) {
	              if ($scope.isGroupedList) {
	                var filterResult = [];
	                filterResult = _underscore2.default.filter(getAllGroupedItems('right'), function (item) {
	                  return item.label.toLowerCase().indexOf(filterText) !== -1 || item.group.toLowerCase().indexOf(filterText) !== -1;
	                });
	
	                for (group in $scope.visibleGroupRightData) {
	                  // eslint-disable-line
	                  $scope.visibleGroupRightData[group] = [];
	                }
	                for (var count = 0; count < filterResult.length; count++) {
	                  if (angular.isUndefined($scope.visibleGroupRightData[filterResult[count].group])) {
	                    $scope.visibleGroupRightData[filterResult[count].group] = [];
	                  }
	                  $scope.visibleGroupRightData[filterResult[count].group].push(filterResult[count]);
	                }
	                $scope.movingDataFromRight = false;
	              } else {
	                $scope.visibleRightData = _underscore2.default.filter($scope.rightData, function (item) {
	                  return item.label.toLowerCase().indexOf(filterText) !== -1;
	                });
	              }
	            } else if ($scope.isGroupedList && !$scope.movingDataFromRight) {
	              // get the reamining data to show after clearing the filter option
	              getDataAfterClearFilter($scope.groupListRight, $scope.visibleGroupLeftData); // eslint-disable-line
	              $scope.visibleGroupRightData = $.extend(true, {}, $scope.groupListRight);
	              $scope.movingDataFromRight = true;
	            } else {
	              $scope.visibleRightData = $scope.rightData;
	            }
	
	            if ($scope.isGroupedList) {
	              for (group in $scope.visibleGroupRightData) {
	                // eslint-disable-line
	                orderObjectList($scope, $scope.visibleGroupRightData[group]);
	              }
	            } else {
	              orderObjectList($scope, $scope.visibleRightData);
	            }
	            $scope.setLoadingIconsStatus('right', false);
	          });
	          fisMemoryUtilService.cancelTimeoutOnDestroy($scope, filterTimeout, $timeout);
	        }
	      };
	      $scope.$watch('filterRight.text', filterRightData);
	
	      var getDataAfterClearFilter = function getDataAfterClearFilter(source, target) {
	        for (var group in target) {
	          if (source[group] && source[group].length > 0) {
	            for (var count = 0; count < source[group].length; count++) {
	              for (var num = 0; num < target[group].length; num++) {
	                if (source[group][count].label.trim() === target[group][num].label.trim()) {
	                  source[group].splice(count, 1);
	                  count--;
	                  break;
	                }
	              }
	            }
	          }
	        }
	      };
	
	      $scope.$watch('selectedRightData', function (newValue) {
	        var selectionChangeTimeout = $timeout(function () {
	          if (!_underscore2.default.isEmpty($scope.allData) && !$scope.isGroupedList) {
	            // only apply after we have the reference data
	            if (_underscore2.default.isUndefined($scope.leftData)) {
	              $scope.leftData = [];
	            }
	            // Get the value of the elements currently in the left column (correct ordering!)
	            var leftvalsPrev = _underscore2.default.pluck($scope.leftData, 'value');
	
	            // Clear the data arrays
	            $scope.rightData.length = 0;
	            $scope.leftData.length = 0;
	
	            // Get the values of all items we are handling in this listBuilder
	            var allvals = _underscore2.default.pluck($scope.allDataUnindexed, 'value'); // use unindexed alldata to maintain order as mapped/ index alldata changes order
	
	            // Assuming newValue is an array containing all value properties of items that should be on the right side
	            // "calculate" the difference from these new right-sided values and all values to get the new left values
	            // ordered how they appear in allvals (natural order)
	            var leftvalsNew = _underscore2.default.difference(allvals, newValue);
	
	            var leftvals;
	
	            if ($scope.fisSort === 'natural') {
	              leftvals = leftvalsNew; // In natural ordering we explicitly want the items to be in the order present in source
	            } else {
	              // Unite the leftvalsPrev and leftValsNew, to 1) get all values present in both arrays and 2) keep the order present in leftvalsPrev
	              // Respect the previous sort order.
	              var addedToRight = _underscore2.default.difference(leftvalsNew, leftvalsPrev);
	
	              if (addedToRight.length > 0) {
	                var inter = _underscore2.default.intersection(leftvalsPrev, leftvalsNew);
	                leftvals = inter.concat(addedToRight);
	              } else {
	                leftvals = _underscore2.default.intersection(leftvalsPrev, leftvalsNew);
	              }
	            }
	
	            _underscore2.default.each(newValue, function (value) {
	              if (!angular.isUndefined(value)) {
	                $scope.rightData.push($scope.allData[value]);
	              }
	            });
	            _underscore2.default.each(leftvals, function (value) {
	              if (!angular.isUndefined(value)) {
	                $scope.leftData.push($scope.allData[value]);
	              }
	            });
	
	            orderObjectList($scope, $scope.leftData); // order after filter
	            orderObjectList($scope, $scope.rightData); // order after filter
	          }
	        }, 0);
	        fisMemoryUtilService.cancelTimeoutOnDestroy($scope, selectionChangeTimeout, $timeout);
	      }, true);
	
	      $scope.$watch('rightData', function (newValue, oldValue) {
	        if (!(newValue.length === oldValue.length && newValue.length === 0)) {
	          $scope.leftData = _underscore2.default.union($scope.leftData, $scope.rightData);
	
	          var selectedLabels = [];
	          if (!_underscore2.default.isUndefined($scope.rightData)) {
	            selectedLabels = _underscore2.default.pluck($scope.rightData, 'value');
	          }
	
	          $scope.leftData = _underscore2.default.filter($scope.leftData, function (item) {
	            if (item) {
	              return !_underscore2.default.contains(selectedLabels, item.value);
	            }
	            return false;
	          });
	          filterRightData();
	        }
	      });
	
	      // add a watch on fisData when it does not contain a ':' character (meaning when it is not parameterized)
	      // If fis-data contains a ':', it cannot be watched on since angular does not allow special character in watch experssion
	      // For such cases, we should instead observe the fis-param attribute. And broadcast 'reinit' event on change of that.
	      if (attrs.fisData && attrs.fisData.indexOf(':') < 0) {
	        try {
	          var dataWatch = $scope.$parent.$watch(attrs.fisData, function (data) {
	            if (!angular.isUndefined($scope.selectedRightData) && $scope.selectedRightData.length > 0 && !$scope.isGroupedList) {
	              $scope.rightData.length = 0;
	              angular.forEach($scope.selectedRightData, function (index) {
	                angular.forEach(data, function (item) {
	                  if (item.value === index) {
	                    $scope.rightData.push(item);
	                  }
	                });
	              });
	            }
	          }, true);
	          fisMemoryUtilService.cancelWatchOnDestroy($scope, dataWatch);
	        } catch (e) {
	          console.warn('Cannot watch on fis-data expression ', attrs.fisData);
	        }
	      }
	
	      $scope.$watch('visibleRightData', function (newValue, oldValue) {
	        if (_underscore2.default.difference(newValue, oldValue).length !== 0 || _underscore2.default.difference(oldValue, newValue).length !== 0) {
	          if (_underscore2.default.isUndefined($scope.selectedRightData)) {
	            $scope.selectedRightData = [];
	          }
	          $scope.selectedRightData.length = 0;
	          // var visibleVals = _.pluck(scope.visibleRightData, 'value');
	          var vals = _underscore2.default.pluck($scope.rightData, 'value');
	          _underscore2.default.each(vals, function (value) {
	            if (!angular.isUndefined(value)) {
	              $scope.selectedRightData.push(value);
	            }
	          });
	        }
	      }, true);
	
	      $scope.$watch('visibleGroupRightData', function (newValue, oldValue) {
	        if (_underscore2.default.difference(newValue, oldValue).length !== 0 || _underscore2.default.difference(oldValue, newValue).length !== 0) {
	          if (_underscore2.default.isUndefined($scope.selectedRightData)) {
	            $scope.selectedRightData = [];
	          }
	          $scope.selectedRightData.length = 0;
	          // var visibleVals = _.pluck(scope.visibleRightData, 'value');
	          for (var group in $scope.visibleGroupRightData) {
	            // eslint-disable-line
	            var vals = _underscore2.default.pluck($scope.visibleGroupRightData[group], 'value');
	            _underscore2.default.each(vals, function (value) {
	              if (!angular.isUndefined(value)) {
	                $scope.selectedRightData.push(value);
	              }
	            });
	          }
	        }
	      }, true);
	    }],
	    link: function link(scope, element, attrs, ctrls) {
	      scope.caseSensitiveSorting = attrs.fisSortCaseSensitive === 'true';
	      scope.fisDisabled = false;
	
	      var selectedDataforGroupList = scope.selectedRightData || [];
	      var fisData = ctrls[0];
	      var fisRefresh = ctrls[1];
	      var fisReinit = ctrls[2];
	
	      scope.size = parseInt(attrs.fisSize, 10);
	      scope.fisSort = attrs.fisSort ? attrs.fisSort : 'natural';
	
	      // change the width if necessary
	      var ITEM_WIDTH = 21;
	      var DEFAULT_ITEM_SIZE = 7;
	      var itemSize;
	      var noManualOrder = !_underscore2.default.isUndefined(scope.fisManualOrder) && scope.fisManualOrder === 'false';
	      var alphabeticalSorting = !_underscore2.default.isUndefined(scope.fisSort) && (scope.fisSort === 'alphabetical-asc' || scope.fisSort === 'alphabetical-desc');
	      if (noManualOrder || alphabeticalSorting) {
	        scope.showUpDownButtons = false;
	      }
	      if (attrs.fisSize !== undefined && attrs.fisSize > DEFAULT_ITEM_SIZE) {
	        itemSize = attrs.fisSize;
	      } else {
	        itemSize = DEFAULT_ITEM_SIZE;
	      }
	      var listBuilderHeight = itemSize * ITEM_WIDTH;
	
	      var listBoxes = element.find('.fis-list-builder-left, .fis-list-builder-right, .fis-list-builder-holder');
	      _underscore2.default.each(listBoxes, function (elem) {
	        elem = angular.element(elem);
	        elem.css('height', listBuilderHeight);
	      });
	
	      function removeByValue(list, value) {
	        list = _underscore2.default.reject(list, function (item) {
	          return item.value === value;
	        });
	        return list;
	      }
	
	      function applyData(data, update) {
	        if (update) {
	          scope.allDataUnindexed = _underscore2.default.clone(data);
	          // the scenario where data is selected and new data is applied
	          scope.allData = _underscore2.default.indexBy(data, 'value');
	          _underscore2.default.each(scope.selectedRightData, function (value) {
	            var existingRights = _underscore2.default.pluck(scope.rightData, 'value');
	            if (!_underscore2.default.isUndefined(scope.allData[value])) {
	              // eslint-disable-line no-negated-condition
	              if (!_underscore2.default.contains(existingRights, value)) {
	                scope.rightData.push(scope.allData[value]);
	              }
	            } else {
	              scope.rightData = removeByValue(scope.rightData, value);
	            }
	          });
	        }
	        // sort selected data
	        orderObjectList(scope, scope.rightData);
	        var rightDataChain = _underscore2.default.chain(scope.rightData);
	
	        if (!rightDataChain.isUndefined().value() && rightDataChain.size().value() > 0) {
	          // Only check whether elements from the left list need to be removed when there is at least
	          // one element in the right data array
	
	          var rawLeft = data;
	          var rightValues = _underscore2.default.pluck(scope.rightData, 'value');
	          _underscore2.default.each(rightValues, function (value) {
	            rawLeft = removeByValue(rawLeft, value);
	          });
	          scope.leftData = angular.copy(rawLeft);
	        } else {
	          scope.leftData = angular.copy(data);
	          if (_underscore2.default.isUndefined(scope.rightData)) {
	            // Initialize the right data as an empty array, if it's undefined
	            scope.rightData = [];
	          }
	        }
	
	        var options = $('div.fis-list-builder option');
	
	        _underscore2.default.each(options, function (option) {
	          option = angular.element(option);
	          option.toggleClass('fis-list-builder-option');
	        });
	
	        scope.dataInLoadingPhase = false;
	        // Hide the loading indicator (if the left/right data arrays did not change, no $watch below might get fired to this dataApply())
	        scope.setLoadingIconsStatus('both', false);
	      }
	
	      function groupDataForGroupList(obj) {
	        var reducedArray = obj.reduce(function (finalResult, current) {
	          if (selectedDataforGroupList.indexOf(current.value) > -1) {
	            finalResult.rightBoxData = finalResult.rightBoxData || [];
	            finalResult.leftBoxData = finalResult.leftBoxData || [];
	            finalResult.rightBoxData.push(current);
	          } else {
	            finalResult.leftBoxData = finalResult.leftBoxData || [];
	            finalResult.rightBoxData = finalResult.rightBoxData || [];
	            finalResult.leftBoxData.push(current);
	          }
	
	          return finalResult;
	        }, {});
	        return reducedArray;
	      }
	
	      scope.selectedItemLeft = [];
	      scope.selectedItemRight = [];
	      scope.dataInLoadingPhase = true;
	      // Show loading indicator by default
	      scope.isLoading = { left: true, right: false };
	
	      var getData = function getData() {
	        fisData.fetchData().then(function (result) {
	          scope.isGroupedList = attrs.fisGroupedList === 'true';
	          if (scope.isGroupedList) {
	            // Sorting Logic for group names
	            if (scope.fisSort && (scope.fisSort === 'alphabetical-asc' || scope.fisSort === 'alphabetical-desc')) {
	              result.data = result.data.sort(function (a, b) {
	                var nameA = a.data[0].group.toLowerCase();
	                var nameB = b.data[0].group.toLowerCase();
	                if (scope.fisSort === 'alphabetical-asc') {
	                  if (nameA < nameB) {
	                    // sort string ascending
	                    return -1;
	                  } else if (nameA > nameB) {
	                    return 1;
	                  }
	                } else if (scope.fisSort === 'alphabetical-desc') {
	                  if (nameA < nameB) {
	                    // sort string descending
	                    return 1;
	                  } else if (nameA > nameB) {
	                    return -1;
	                  }
	                }
	                return 0; // default return value (no sorting)
	              });
	            }
	
	            for (var count = 0; count < result.data.length; count++) {
	              scope.groupListLeft[result.data[count].data[0].group] = groupDataForGroupList(result.data[count].data).leftBoxData;
	              scope.groupListRight[result.data[count].data[0].group] = groupDataForGroupList(result.data[count].data).rightBoxData;
	              scope.visibleGroupRightData[result.data[count].data[0].group] = groupDataForGroupList(result.data[count].data).rightBoxData;
	
	              // sort data before its attached to list
	              if (scope.fisSort === 'alphabetical-asc' || scope.fisSort === 'alphabetical-desc') {
	                fisSortService.sort(scope.groupListLeft[result.data[count].data[0].group], scope.fisSort, scope.caseSensitiveSorting);
	              }
	            }
	            // Creating a deep copy of the original object
	            scope.visibleGroupLeftData = $.extend(true, {}, scope.groupListLeft);
	            scope.groupedAllDataUnindexed = $.extend(true, {}, scope.groupListLeft);
	            scope.dataInLoadingPhase = false;
	            // Hide the loading indicator
	            scope.setLoadingIconsStatus('both', false);
	          } else {
	            // sort data before its attached to list
	            if (scope.fisSort === 'alphabetical-asc' || scope.fisSort === 'alphabetical-desc') {
	              fisSortService.sort(result.data, scope.fisSort, scope.caseSensitiveSorting);
	            }
	            applyData(result.data, true);
	          }
	
	          // Here, we are checking if the browser is IE-10 or IE-11
	          // if yes, then bind input event for listBuilder filter input field to 'clearModelValueIE' function
	          if (document && document.documentMode && document.documentMode > 9) {
	            element.find('input').bind('input', clearModelValueIE); // eslint-disable-line
	          }
	          fisPubSubService.publish('fis.lb.data-loaded', { data: result.data });
	        }, function (result) {
	          console.warn('Problem loading data: ' + result);
	        });
	      };
	
	      // get initial data;
	      getData();
	
	      var keydownListener = function keydownListener(event) {
	        if (event.ctrlKey || event.metaKey) {
	          scope.ctrlPressed = true;
	        }
	        if (event.shiftKey) {
	          scope.shiftPressed = true;
	        }
	      };
	
	      // Register key listeners for CTRL and SHIFT selection
	      var keyupListener = function keyupListener() {
	        scope.ctrlPressed = false;
	        scope.shiftPressed = false;
	      };
	
	      // This function will only gets called in IE browser's
	      // This is used to clear the Model value in case user clicks on 'X' icon of filter field of ListBuilder
	      var clearModelValueIE = function clearModelValueIE() {
	        if (this.value === '') {
	          if (this.id === 'left_filter_box') {
	            scope.filterLeft.text = '';
	          } else if (this.id === 'right_filter_box') {
	            scope.filterRight.text = '';
	          }
	          if (!scope.$$phase) {
	            scope.$apply();
	          }
	        }
	      };
	
	      $(window).bind('keydown', keydownListener);
	      $(window).bind('keyup', keyupListener);
	
	      // Unregister the key listeners when the scope is destroyed
	      scope.$on('$destroy', function () {
	        $(window).unbind('keydown', keydownListener);
	        $(window).unbind('keyup', keyupListener);
	      });
	
	      fisData.addDataChangedListener(function (data) {
	        scope.setLoadingIconsStatus('left', true);
	        var loaderTimeout = $timeout(function () {
	          // Execute inside a timeout, so angular first performs the displaying of the loading indicator
	          applyData(data, true);
	        });
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, loaderTimeout, $timeout);
	      });
	
	      fisData.addAfterFetchListener(function () {
	        scope.dataFetchedComplete = true;
	      });
	
	      // Grab the elements needed for centering the buttons dynamically
	      var leftContainer = element.find('.fis-list-builder-left-container');
	      var middle = element.find('.fis-list-builder-holder-middle');
	      var rightContainer = element.find('.fis-list-builder-right-container');
	      var upDown = element.find('.fis-list-builder-holder-updown');
	
	      // Wait for the $digest cycle to be over
	      var listBuilderTimeout2 = $timeout(function () {
	        var marginTop = 0;
	        if (scope.showLabel) {
	          // Take the higher label height into account
	          marginTop += Math.max(leftContainer.find('.fis-list-builder-title').outerHeight(), rightContainer.find('.fis-list-builder-title').outerHeight());
	        }
	        if (scope.showFilter) {
	          // Take the higher filter box height into account
	          marginTop += Math.max(leftContainer.find('.fis-list-builder-search-filter').outerHeight(), rightContainer.find('.fis-list-builder-search-filter').outerHeight());
	        }
	        // marginTop represents spacing above the listbox
	        setFloaterStyling(middle, marginTop);
	        setFloaterStyling(upDown, marginTop);
	      });
	      fisMemoryUtilService.cancelTimeoutOnDestroy(scope, listBuilderTimeout2, $timeout);
	      /*
	       If the labels are present in the attrs then set flag to true so that
	       the ng-if condition to show the labels is met.
	       */
	      scope.showLabel = !_underscore2.default.isUndefined(attrs.fisLabelLeft) || !_underscore2.default.isUndefined(attrs.fisLabelRight);
	
	      /*
	       If the filter attribute is present in the attrs then set flag to true so that
	       the ng-if condition to show the labels is met.
	        We also need to set the width of the filter inputs.
	       */
	      if (!_underscore2.default.isUndefined(attrs.fisFilterable)) {
	        scope.showFilter = true;
	
	        // Wait for the $digest cycle to finish
	        var listBuilderTimeout3 = $timeout(function () {
	          var search = element.find('.fis-list-builder-search-filter');
	          var title = element.find('.fis-list-builder-title');
	          /*
	           input[type=search] have left and right padding. These are
	           preventing the input from extending the entire width of the list
	           box so remove the padding.
	           */
	          var paddingLeft = parseInt(search.css('padding-left').replace('px', ''), 10);
	          var paddingRight = parseInt(search.css('padding-right').replace('px', ''), 10);
	          var totalPadding = paddingLeft + paddingRight;
	          _underscore2.default.each(search, function () {
	            search.css({
	              // please note removing this styling into a stylesheet does not work!
	              width: parseFloat(title.width()) - totalPadding + 'px'
	            });
	          });
	        });
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, listBuilderTimeout3, $timeout);
	      }
	
	      function setFloaterStyling(buttonContainer, floaterMargin) {
	        // this function attempts to size a floater with the intention of positioning buttons correctly
	        var buttonContainerChildren = buttonContainer.children('div');
	        var buttonDiv = buttonContainerChildren.filter(':not([class*="-floater"])');
	        var buttonFloater = buttonContainerChildren.filter('[class*="-floater"]');
	
	        if (floaterMargin > 0) {
	          buttonContainer.css({
	            'margin-top': floaterMargin
	          });
	        }
	        var floaterHeight = (buttonContainer.outerHeight() - buttonDiv.outerHeight()) / 2;
	        buttonFloater.css('height', floaterHeight + 'px');
	      }
	
	      var refresh = function refresh(event) {
	        // do not execute the event if event.preventDefault() has been called before
	        if (event && event.defaultPrevented) {
	          return;
	        }
	        scope.filterBothData();
	      };
	      // listen for the fisRefresh event coming from a parent scope
	      scope.$on('fisRefresh', refresh);
	
	      // redefine the fisRefresh function if it is put on the same element
	      if (fisRefresh) {
	        fisRefresh.trigger = refresh;
	      }
	
	      if (fisReinit) {
	        fisReinit.trigger = function () {
	          // Wait for the $digest cycle to be over
	          var reinitTimeout = $timeout(function () {
	            getData();
	          }, 0);
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, reinitTimeout, $timeout);
	        };
	      }
	
	      var params = {};
	      params = fisElementUtils.copyProperties(attrs, 'fisParam', params);
	      _underscore2.default.each(params, function (val, key) {
	        var capitalKey = key.charAt(0).toUpperCase() + key.slice(1);
	        var attrToObserve = 'fisParam' + capitalKey;
	        attrs.$observe(attrToObserve, function () {
	          scope.$broadcast('fisReinit');
	        });
	      });
	
	      function applyDisabledClass(val, element) {
	        if (val) {
	          element.addClass('fis-list-builder-disabled');
	        } else {
	          element.removeClass('fis-list-builder-disabled');
	        }
	      }
	
	      scope.$parent.$watch(attrs.fisDisabled, function (value) {
	        if (!_underscore2.default.isUndefined(value)) {
	          try {
	            scope.fisDisabled = JSON.parse(value);
	            applyDisabledClass(scope.fisDisabled, element);
	          } catch (e) {
	            console.error('fis-disabled should be a boolean value');
	          }
	        }
	      }, true);
	
	      attrs.$observe('fisDisabled', function (value) {
	        if (!_underscore2.default.isUndefined(value)) {
	          try {
	            scope.fisDisabled = JSON.parse(value);
	          } catch (e) {
	            scope.fisDisabled = scope.$parent.$eval(value);
	          }
	          applyDisabledClass(scope.fisDisabled, element);
	        }
	      });
	    }
	  };
	}];
	
	__webpack_require__(/*! ./list-builder.styles.less */ 64);
	
	var _underscore = __webpack_require__(/*! underscore */ 8);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 64 */
/*!**********************************************************!*\
  !*** ./components/list-builder/list-builder.styles.less ***!
  \**********************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 65 */
/*!*************************************!*\
  !*** ./components/message/index.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _message = __webpack_require__(/*! ./message.component */ 66);
	
	var _message2 = _interopRequireDefault(_message);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.message', []);
	
	ngModule.component('fisMessage', _message2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 66 */
/*!*************************************************!*\
  !*** ./components/message/message.component.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! ./message.styles.less */ 67);
	
	exports.default = {
	  template: '<div class="alert alert-info" ng-class="$ctrl.isVisible">\n                <button ng-show="{{$ctrl.fisDismiss}}" type="button" class="close" ng-click="$ctrl.close();$ctrl.fisOnClose()">&times;</button>\n                <div ng-transclude></div>\n                <div ng-repeat="message in $ctrl.messages">\n                {{::message}}\n                </div>\n            </div>',
	  transclude: true,
	  replace: true,
	  require: {
	    fisData: '?fisData'
	  },
	  bindings: {
	    fisOnClose: '&',
	    fisDismiss: '<fisDismiss'
	  },
	  controller: [function () {
	    var cntrl = this;
	    cntrl.$onInit = function () {
	      if (cntrl.fisData) {
	        cntrl.fisData.fetchData().then(function (result) {
	          cntrl.messages = result.data;
	        });
	      }
	    };
	
	    cntrl.$onChanges = function (changes) {
	      cntrl.fisDismiss = changes.fisDismiss.currentValue !== undefined && changes.fisDismiss.currentValue !== false;
	
	      if (changes.fisData) {
	        if (cntrl.fisData.fetchData) {
	          cntrl.fisData.fetchData().then(function (result) {
	            cntrl.messages = cntrl.messages.concat(result.data);
	          });
	        } else {
	          cntrl.messages = cntrl.fisData;
	        }
	      }
	    };
	
	    cntrl.close = function () {
	      cntrl.isVisible = 'hide';
	    };
	  }]
	
	}; /**
	    * @name fisMessage
	    * @desc Displays the messages entered by user in a information panel. The messages can either be entered directly as
	    *       content or using fis-data.
	    *       By default the panel cannot be closed but user can override this by providing the attribute "fis-dismiss" to be true
	    *
	    */

/***/ }),
/* 67 */
/*!************************************************!*\
  !*** ./components/message/message.styles.less ***!
  \************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 68 */
/*!*****************************************!*\
  !*** ./components/page-header/index.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _pageHeader = __webpack_require__(/*! ./page-header.component */ 69);
	
	var _pageHeader2 = _interopRequireDefault(_pageHeader);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.page-header', []);
	
	ngModule.component('fisPageHeader', _pageHeader2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 69 */
/*!*********************************************************!*\
  !*** ./components/page-header/page-header.component.js ***!
  \*********************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! ./page-header.styles.less */ 70);
	
	var _pageHeaderTemplate = __webpack_require__(/*! ./page-header.template.html */ 71);
	
	var _pageHeaderTemplate2 = _interopRequireDefault(_pageHeaderTemplate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @name fisPageHeader
	 * @description Defining directive for  Page header
	 * @methodOf fis.widgets.directives
	 */
	function PageHeaderController() {
	  var ctrl = this;
	
	  ctrl.$onChanges = function (changes) {
	    if (changes.subtitle) {
	      if (ctrl.subtitle && ctrl.subtitle.indexOf('{{') >= 0) {
	        ctrl.subtitle = ctrl.subtitle.replace(/{|}/g, '');
	      }
	    }
	  };
	}
	
	exports.default = {
	  template: _pageHeaderTemplate2.default,
	  transclude: true,
	  bindings: {
	    title: '@fisTitle',
	    subtitle: '@fisSubtitle'
	  },
	  controller: PageHeaderController
	};

/***/ }),
/* 70 */
/*!********************************************************!*\
  !*** ./components/page-header/page-header.styles.less ***!
  \********************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 71 */
/*!**********************************************************!*\
  !*** ./components/page-header/page-header.template.html ***!
  \**********************************************************/
/***/ (function(module, exports) {

	module.exports = "<header class=\"fis-page-header\">\n  <h1>{{ $ctrl.title }}\n    <small><span ng-bind-html=\"$ctrl.subtitle\"></span></small>\n  </h1>\n  <div class=\"fis-controls\" ng-transclude></div>\n</header>\n";

/***/ }),
/* 72 */
/*!***********************************!*\
  !*** ./components/panel/index.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _panel = __webpack_require__(/*! ./panel.directive */ 73);
	
	var _panel2 = _interopRequireDefault(_panel);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.panel', []);
	
	ngModule.directive('fisPanel', _panel2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 73 */
/*!*********************************************!*\
  !*** ./components/panel/panel.directive.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisPubSubService", "$timeout", "fisElementUtils", function (fisPubSubService, $timeout, fisElementUtils) {
	  'ngInject';
	
	  return {
	    restrict: 'ACE',
	    scope: {
	      title: '@fisTitle',
	      summary: '@fisFooterText',
	      contentHeight: '@fisContentHeight'
	    },
	    template: '<div><header fis-header fis-title="{{title}}"></header><div fis-scrollable fis-unique-id="sg_panel_content" class="fis-panel-content" fis-height="{{contentHeight}}" ></div><fis-footer fis-summary-text="{{summary}}"></fis-footer></div>',
	    transclude: true,
	    compile: function compile(tElement, tAttrs, transclude) {
	      return function (scope, element, attrs) {
	        var footer = element.find('> div fis-footer');
	        var header = element.find('> div > header');
	        var contents = element.find('.fis-panel-content');
	        var innerDiv;
	
	        /* Lito: I commented this line because of ticket SDHTML-14447 and SDHTML-14353.
	        *  The stretchToBottom variable never gets true becasue the attrs.fisHeight i smissing.
	        *  Because of this 'stretch-bottom-panel' class never gets injected to the element
	        *  This causing styling bugs for stretch panel and stretched tabs
	        *
	        *  Akho:uncommented as it cause more issues for stretchToBottom, Lito will look at above mentioned bugs.
	        */
	        var stretchToBottom = !_underscore2.default.isUndefined(attrs.fisStretchToBottom) && (_underscore2.default.isUndefined(attrs.fisHeight) || attrs.fisHeight === '');
	
	        // it returns true if fisStretchToBottom is present
	        // var stretchToBottom = !_.isUndefined(attrs.fisStretchToBottom);
	
	        // add the fis-panel class
	        element.addClass('fis-panel');
	
	        var setStretchToBottomStyle = function setStretchToBottomStyle() {
	          element.addClass('stretch-bottom-panel');
	          // Set the contents top and bottom property to perfectly align with the header and footer
	          var top = 0;
	          var bottom = 0;
	
	          if (header.length > 0 && header.is(':visible')) {
	            top = header.outerHeight();
	          }
	          if (footer.length > 0 && angular.element(footer[0].firstChild).is(':visible')) {
	            bottom = angular.element(footer[0].firstChild).outerHeight();
	          }
	          contents.css('top', top);
	          contents.css('bottom', bottom);
	
	          // Reset the element height, if we would shrink the panel too much
	          if (bottom + top + contents.outerHeight() > element.innerHeight()) {
	            element.innerHeight(bottom + top + contents.outerHeight());
	          }
	        };
	
	        var setStretchToBottomStyleIfApplicable = function setStretchToBottomStyleIfApplicable() {
	          $timeout(function () {
	            // Wait for digest to complete, so that header and footer changes have happened
	            // in the DOM by angular
	            if (stretchToBottom && element.hasClass('stretched-to-bottom')) {
	              setStretchToBottomStyle();
	            }
	          });
	        };
	
	        transclude(scope.$parent, function (clone) {
	          var cloneHeader = clone.filter('header');
	          if (cloneHeader.length) {
	            // there is a header in the transclusion replace the header in the element by it
	            header.replaceWith(cloneHeader);
	            header = cloneHeader;
	          } else {
	            // make sure header is shown only if a title is provided
	            fisElementUtils.invokeAndObserve(attrs, 'fisTitle', function (title) {
	              if (title) {
	                header.show();
	              } else {
	                header.hide();
	              }
	              setStretchToBottomStyleIfApplicable();
	            });
	          }
	          var cloneFooter = clone.filter('fis-footer');
	          if (cloneFooter.length) {
	            // there is a footer in the transclusion replace the header in the element by it
	            footer.replaceWith(cloneFooter);
	            footer = cloneFooter;
	          } else {
	            // make sure footer is shown only if a summary is provided
	            fisElementUtils.invokeAndObserve(attrs, 'fisFooterText', function (summary) {
	              if (summary) {
	                footer.show();
	              } else {
	                footer.hide();
	              }
	              setStretchToBottomStyleIfApplicable();
	            });
	          }
	          // add everything but header and footer elements to the content div
	          contents.append(clone.not(cloneHeader).not(cloneFooter));
	        });
	
	        // Special adjustment for some css values so that child elements behave as expected
	        // when fisStretchToBottom is set
	        if (stretchToBottom) {
	          // Subscribe to broadcasts by a fisStretchToBottom directive above in scope hierarchy
	          // scope.$on('fisStretchToBottom.applied', function(event, args){
	
	          var unsubs = [];
	          var recalcDimensions = function recalcDimensions() {
	            if (element.is(':visible')) {
	              if (element.hasClass('stretched-to-bottom') || element.hasClass('stretch-bottom-panel') /* args.isStretched*/) {
	                  // The panel has been stretched to the bottom
	                  // SDHTML-17228 called setStretchToBottomStyle(); on resize event. to calculate panel dimension.
	                  setStretchToBottomStyle();
	                  stretchToBottom = false;
	                }
	            }
	          };
	          unsubs.push(fisPubSubService.subscribe('shell.sizeChange', recalcDimensions));
	          unsubs.push(fisPubSubService.subscribe('shell.condensedToggle', recalcDimensions));
	          unsubs.push(fisPubSubService.subscribe('fisThemeChanged', recalcDimensions));
	
	          /* Instead of calling recalcDimensions() method on panelContentLoaded
	          *  We have to publish a shell.sizeChange event so, every individual widgets or components'
	          *  Those are used inside panel with stretchToBottom directive on it can subscribe shell.sizeChange
	          *  Event and call their height calculation function that is bound to shell.sizeChange event.
	          *  To Fix SDHTML-17169 we have to make this change.
	          */
	          scope.$on('$panelContentLoaded', function () {
	            fisPubSubService.publish('shell.sizeChange', {});
	            // passing empty object because here we don't need to take care for window height and width here.
	            // it will be taken care by publish event in shell.controller.js
	          });
	          $timeout(function () {
	            // SDHTML-17137
	            setStretchToBottomStyle();
	          });
	          // Unsubscribe on destruction
	          scope.$on('$destroy', function () {
	            if (unsubs) {
	              _underscore2.default.each(unsubs, function (unsub) {
	                unsub();
	              });
	            }
	          });
	        }
	
	        // if a height is set for the whole panel...
	        fisElementUtils.invokeAndObserve(attrs, 'fisHeight', function (height) {
	          if (stretchToBottom || !height) {
	            return;
	          }
	          // the position of the root panel element should be relative
	          // so that absolute positioning inside it is relative to it.
	          element.css('position', 'relative');
	          // the footer should stick to the bottom
	          footer.css({
	            position: 'absolute',
	            bottom: 0
	          });
	          // the inner div should stretch across all available space within the root element
	          innerDiv = element.find('> div');
	          innerDiv.css({
	            position: 'absolute',
	            top: 0,
	            bottom: 0,
	            left: 0,
	            right: 0
	          });
	          // the content area's height should be the distance between the header and the footer
	          scope.contentHeight = innerDiv.innerHeight() - header.outerHeight() - footer.outerHeight();
	        });
	
	        /*  SDHTML-10108: In Panel widget, fis-content-height seems to be not working.
	         *  There was a change made to fisCSSDirective.js (the directive for fisHeight and other css attributes), that makes it mandatory to publish
	         *  an event (heightAdjusted) when the height attribute changes, so as to update its css value. Hence need to add this block to publish heightAdjusted event
	         *  with false as the value, indicating that there was no local calculation for height.
	         */
	        fisElementUtils.invokeAndObserve(attrs, 'fisContentHeight', function () {
	          fisPubSubService.publish('heightAdjusted', false);
	        });
	      };
	    }
	  };
	}];
	
	__webpack_require__(/*! ./panel.styles.less */ 74);
	
	var _underscore = __webpack_require__(/*! underscore */ 8);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 74 */
/*!********************************************!*\
  !*** ./components/panel/panel.styles.less ***!
  \********************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 75 */
/*!***********************************************!*\
  !*** ./components/quick-action-menu/index.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _quickActionMenu = __webpack_require__(/*! ./quick-action-menu.directive */ 76);
	
	var _quickActionMenu2 = _interopRequireDefault(_quickActionMenu);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.quick-action-menu', []);
	
	ngModule.directive('fisQuickActionMenu', _quickActionMenu2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 76 */
/*!*********************************************************************!*\
  !*** ./components/quick-action-menu/quick-action-menu.directive.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "fisQuickActionsService", function ($compile, fisQuickActionsService) {
	  'ngInject';
	
	  return {
	    restrict: 'AEC',
	    link: function link(scope, element, attrs) {
	      var tpl = angular.element('<div class="qactions-container"><div class="qactions-transclude"></div><span class="qactions-chevron"></span></div>');
	      var quickActionScope = scope.$parent;
	      var useKendoWrap = false;
	      var clickTarget = 'span.qactions-target.icon-chevron-down';
	
	      element.attr({ 'tabindex': '0', 'aria-haspopup': true, 'aria-pressed': false });
	      if (!element.hasClass('fis-quick-action-menu')) {
	        element.addClass('fis-quick-action-menu');
	      }
	
	      if (!_.isUndefined(attrs.fisAttachToBody)) {
	        useKendoWrap = true;
	      }
	
	      // Manual transclusion
	      if (!_.isUndefined(attrs.fisQuickActionWrap)) {
	        clickTarget = null;
	
	        var transcludedContent = element.children();
	        element.children().remove();
	        element.append(tpl);
	        element.find('div.qactions-transclude').append(transcludedContent);
	      }
	
	      var chevronElements = element.find('span.qactions-target.icon-chevron-down');
	
	      if (chevronElements.length === 0) {
	        var chevronFloat = element.find('span.qactions-chevron');
	        var quickActionElem = angular.element('<span class="qactions-target icon-chevron-down " qaid="' + attrs.fisId + '" />');
	        if (!_.isUndefined(attrs.fisQuickActionWrap)) {
	          // eslint-disable-line no-negated-condition
	          chevronFloat.append(quickActionElem);
	        } else {
	          element.append(quickActionElem);
	        }
	        quickActionScope = scope;
	      }
	
	      element.on('click', 'span.qactions-target.icon-chevron-down.qactions-branch', chevronClicked);
	      scope.quickActionsMenuElementForBranch = fisQuickActionsService.addQuickActionMenu($compile, quickActionScope, element, attrs.fisQuickActionDataBranch);
	
	      element.on('click', clickTarget, chevronClicked);
	      scope.quickActionsMenuElement = fisQuickActionsService.addQuickActionMenu($compile, quickActionScope, element, attrs.fisQuickActionData);
	
	      function chevronClicked(event) {
	        var chevronElement;
	
	        if (!event) {
	          event = window.event;
	        }
	        event.preventDefault();
	        event.stopPropagation();
	
	        if (angular.element(event.target).hasClass('qactions-target')) {
	          chevronElement = event.target;
	        } else {
	          chevronElement = element.find('span.qactions-target.icon-chevron-down');
	        }
	        var chevronElementForBranch = angular.element(chevronElement).hasClass('qactions-branch');
	
	        var hiddenElement = chevronElementForBranch ? scope.quickActionsMenuElementForBranch : scope.quickActionsMenuElement;
	
	        var nodeId = angular.element(chevronElement).attr('qaid');
	        var wrappedChevron = angular.element(chevronElement);
	
	        if (useKendoWrap) {
	          fisQuickActionsService.openQuickActionMenuOnBody(hiddenElement, wrappedChevron, nodeId);
	        } else {
	          fisQuickActionsService.openQuickActionMenu(hiddenElement, wrappedChevron, nodeId);
	        }
	
	        quickActionScope.chevron = wrappedChevron;
	        quickActionScope.hiddenElement = hiddenElement;
	
	        fisQuickActionsService.registerClickHandlers(hiddenElement, wrappedChevron);
	      }
	    }
	  };
	}];
	
	__webpack_require__(/*! ./quick-action-menu.styles.less */ 77);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 8)))

/***/ }),
/* 77 */
/*!********************************************************************!*\
  !*** ./components/quick-action-menu/quick-action-menu.styles.less ***!
  \********************************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 78 */
/*!*******************************************!*\
  !*** ./components/quick-actions/index.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _quickActions = __webpack_require__(/*! ./quick-actions.directive */ 79);
	
	var _quickActions2 = _interopRequireDefault(_quickActions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.quick-actions', []);
	
	ngModule.directive('fisQuickActions', _quickActions2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 79 */
/*!*************************************************************!*\
  !*** ./components/quick-actions/quick-actions.directive.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$sanitize", "fisUniqueIdService", function ($sanitize, fisUniqueIdService) {
	  'ngInject';
	
	  return {
	
	    restrict: 'ACE',
	
	    require: 'fisData',
	
	    template: '<div></div>',
	
	    controller: ['$element', '$scope', 'fisQuickActionsService', function (element, $scope, fisQuickActionsService) {
	      $scope.closeQuickActions = function () {
	        var elementToPass = $scope.hiddenElement ? $scope.hiddenElement : element;
	        fisQuickActionsService.closeQuickActionMenu(elementToPass, $scope.chevron);
	      };
	    }],
	    link: function link(scope, element, attrs, fisData) {
	      fisData.addDataChangedListener(function (data) {
	        element.find('div.dropdown').remove();
	        applyDataAndCreateMenu(data);
	      });
	
	      function getNodeId() {
	        var nodeId = element.attr('qaid');
	        return nodeId;
	      }
	
	      var promise = fisData.fetchData();
	
	      promise.then(function (result) {
	        var data = result.data;
	        applyDataAndCreateMenu(data);
	      }, function (result) {
	        console.warn('Problem loading data: ' + result);
	      });
	
	      function applyDataAndCreateMenu(data) {
	        var menu = createMenu(data);
	        var menuElement = angular.element(menu);
	        menuElement.on('click', 'a', {}, function (event) {
	          var nodeId = getNodeId();
	          var nodeElement = angular.element(event.target);
	          if (!_underscore2.default.isUndefined(nodeElement.attr('path'))) {
	            var parameter = { nodeId: nodeId };
	            scope.open(nodeElement.attr('path'), event, parameter);
	          } else if (!_underscore2.default.isUndefined(nodeElement.attr('method'))) {
	            scope[nodeElement.attr('method')](nodeId, nodeElement.text());
	          } else if (!_underscore2.default.isUndefined(nodeElement.attr('dialog'))) {
	            scope.openDialog(nodeElement.attr('dialog'));
	          }
	
	          scope.closeQuickActions();
	        });
	        element.append(menuElement);
	      }
	
	      function createMenu(data) {
	        var menu = '<div class="dropdown open"><ul class="dropdown-menu">';
	
	        _underscore2.default.each(data, function (dataItem) {
	          var callTarget = '';
	
	          if (!_underscore2.default.isUndefined(dataItem.path) && dataItem.path.length > 0) {
	            callTarget = 'path="' + $sanitize(dataItem.path) + '"';
	          } else if (!_underscore2.default.isUndefined(dataItem.method) && dataItem.method.length > 0) {
	            callTarget = 'method="' + $sanitize(dataItem.method) + '"';
	          } else if (!_underscore2.default.isUndefined(dataItem.dialog) && dataItem.dialog.length > 0) {
	            callTarget = 'dialog="' + $sanitize(dataItem.dialog) + '"';
	          }
	
	          var sanitizedLabel = $sanitize(dataItem.label);
	          var menuItemId = sanitizedLabel;
	          if (!_underscore2.default.isUndefined(element.attr('fis-seed'))) {
	            menuItemId = $sanitize(element.attr('fis-seed')) + '_' + menuItemId;
	          }
	
	          var menuItem = '<li><a class="quickActionMenuItem" ' + callTarget + '>' + sanitizedLabel + '</a></li>';
	
	          var menuItemElement = angular.element(menuItem);
	
	          fisUniqueIdService.generateUniqueId(scope, menuItemElement, {}, menuItemId);
	
	          menu += menuItemElement[0].outerHTML;
	        });
	
	        menu += '</ul></div>';
	
	        return menu;
	      }
	    }
	  };
	}];
	
	var _underscore = __webpack_require__(/*! underscore */ 8);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 80 */
/*!*************************************!*\
  !*** ./components/summary/index.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _summary = __webpack_require__(/*! ./summary.directive */ 81);
	
	var _summary2 = _interopRequireDefault(_summary);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.summary', []);
	
	ngModule.directive('fisSummary', _summary2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 81 */
/*!*************************************************!*\
  !*** ./components/summary/summary.directive.js ***!
  \*************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  return {
	    template: '<ul class="fis-summary" ng-transclude></ul>',
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    scope: false
	  };
	};

/***/ }),
/* 82 */
/*!******************************************!*\
  !*** ./components/summary-item/index.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _summaryItem = __webpack_require__(/*! ./summary-item.directive */ 83);
	
	var _summaryItem2 = _interopRequireDefault(_summaryItem);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.summary-item', []);
	
	ngModule.directive('fisSummaryItem', _summaryItem2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 83 */
/*!***********************************************************!*\
  !*** ./components/summary-item/summary-item.directive.js ***!
  \***********************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  return {
	    template: '<li><div class="fis-title">{{title}}</div><div class="fis-value" ng-transclude></div></li>',
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    scope: {
	      title: '@fisTitle'
	    }
	  };
	};

/***/ }),
/* 84 */
/*!***************************************!*\
  !*** ./components/user-info/index.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _userInfo = __webpack_require__(/*! ./user-info.component */ 85);
	
	var _userInfo2 = _interopRequireDefault(_userInfo);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.components.user-info', []);
	
	ngModule.component('fisUserInfo', _userInfo2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 85 */
/*!*****************************************************!*\
  !*** ./components/user-info/user-info.component.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! ./user-info.styles.less */ 86);
	
	exports.default = {
	  bindings: {
	    info: '<fisInfo'
	  },
	  template: '<li>\n      <section class="fis-user-info" >\n        <div class="fis-user-icon-ll-row clearfix">\n          <div class="fis-user-icon-div" ng-model="userinfo">\n            <span ng-if="!$ctrl.info.profileImg" class="icon-Person_Customer fis-user-icon xlrg-ic"></span>\n            <img  ng-if="$ctrl.info.profileImg" class="fis-user-img" ng-src="{{$ctrl.info.profileImg}}"/>\n          </div>\n          <div class="fis-user-last-login-div">\n            <span class="fis-uname fis-sm-user">{{$ctrl.info.firstName+ " "+$ctrl.info.lastName}}</span>\n            <div>\n              <span>{{::"fisUserInfo.lastLoginOn" | i18n : "last sign on"}}: </span>\n              <span class="fis-ll-span">{{$ctrl.info.lastLogin | date:"MM/dd/yyyy - h:mma"}}</span>\n            </div>\n          </div>\n        </div>\n      </section>\n    </li>'
	}; /**
	    * @name fisUserInfo
	    * @description
	    <p>This component can be used to dropdown with session Info.
	   </p>
	   */

/***/ }),
/* 86 */
/*!****************************************************!*\
  !*** ./components/user-info/user-info.styles.less ***!
  \****************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 87 */
/*!******************************!*\
  !*** ./controllers/index.js ***!
  \******************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _item = __webpack_require__(/*! ./item.controller */ 88);
	
	var _item2 = _interopRequireDefault(_item);
	
	var _list = __webpack_require__(/*! ./list.controller */ 89);
	
	var _list2 = _interopRequireDefault(_list);
	
	var _masterDetails = __webpack_require__(/*! ./master-details.controller */ 90);
	
	var _masterDetails2 = _interopRequireDefault(_masterDetails);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.controllers', []);
	
	ngModule.controller('fis.fisComponents.ItemController', _item2.default);
	ngModule.controller('fis.fisComponents.ListController', _list2.default);
	ngModule.controller('fis.fisComponents.RouteMasterDetailsController', ['$scope', '$resource', '$document', '$q', 'fisPubSubService', 'args', 'fisListMixin', 'fisItemMixin', 'fisCRUDTransitionsMixin', 'fisCustomActionsMixin', _masterDetails2.default]);
	
	// in case of MasterDetailsController being used through page specific ng-controller, pass the $element instead of args
	ngModule.controller('fis.fisComponents.MasterDetailsController', ['$scope', '$resource', '$document', '$q', 'fisPubSubService', '$element', 'fisListMixin', 'fisItemMixin', 'fisCRUDTransitionsMixin', 'fisCustomActionsMixin', _masterDetails2.default]);
	
	exports.default = ngModule.name;

/***/ }),
/* 88 */
/*!****************************************!*\
  !*** ./controllers/item.controller.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _jquery = __webpack_require__(/*! jquery */ 1);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ItemController = function ItemController($scope, $resource, $document, $element, fisItemMixin, fisCRUDTransitionsMixin) {
	  'ngInject';
	
	  var self = this;
	
	  fisItemMixin.call(ItemController.prototype);
	  fisCRUDTransitionsMixin.call(ItemController.prototype);
	
	  var args = {};
	  if ($element.scope().panel && $element.scope().panel.args) {
	    args = $element.scope().panel.args;
	  }
	  if (!args.url) {
	    // the argsOrElem object received here is actually $element when  MasterDetailsController is used as a page specific controller through ng-controller.
	    // Evaluate the value of fis-args attribute
	    args = $scope.$eval($element.attr('fis-args'));
	  }
	
	  if (!args.actions) {
	    args.actions = {};
	  }
	  self.args = args;
	  args.actions.update = { method: 'PUT' };
	  self.$scope = $scope;
	  self.$resource = $resource;
	  self.$document = $document;
	  try {
	    var scopedURL = $scope.$eval(args.url);
	    if (scopedURL) {
	      args.url = $scope.$eval(args.url);
	    }
	  } catch (err) {
	    // URL is not a scope variable
	  }
	  self.itemResource = $resource(args.url, args.paramDefaults, args.actions);
	
	  /**
	   * <p>Creates new Entity resource. Sets the master copy to empty object..</p>
	   */
	  var master = null;
	  $scope.findByCriteria = function (args) {
	    self.transitionTo(self.TRANSITIONS.SELECT_ITEM, args);
	  };
	
	  self.onSelectItem = function (args) {
	    var criteria = {};
	    if (args && args.criteria) {
	      self.findByCriteria(criteria, function (data) {
	        $scope.item = data[0];
	        master = angular.copy($scope.item);
	      }, angular.noop);
	    } else {
	      self.findOne(criteria, function (data) {
	        $scope.item = data;
	        master = angular.copy($scope.item);
	      }, angular.noop);
	    }
	  };
	
	  /**
	   * <p>Makes the passed in entity available on scope for saving.
	   * Updates the current state to View Pristine, if save was successful.</p>
	   */
	  $scope.save = function () {
	    self.transitionTo(self.TRANSITIONS.SAVE, $scope.item);
	  };
	
	  self.onSave = function (item) {
	    self.save(item, null, function (data) {
	      $scope.item = data;
	      self.setCurrentState(self.STATES.VIEW_PRISTINE);
	      self.setFormsToPristine();
	    }, function (opt) {
	      // TODO: throw exception with opt as payload. Let the exception handler decide what to do with it.
	      $scope.displayMessage(opt.data.messages);
	    });
	  };
	
	  $scope.edit = function (id) {
	    self.transitionTo(self.TRANSITIONS.EDIT, { id: id });
	  };
	
	  /**
	   * <p>Reverts the changes made to the entity and restores the form form to pristine state.
	   * </p>
	   * @param {id} id of entity
	   * @param {editMode} editMode flag
	   */
	  $scope.cancel = function (id, editMode) {
	    if (self.currentState === self.STATES.EDIT_DIRTY) {
	      self.transitionTo(self.TRANSITIONS.CANCEL, { id: id, editMode: editMode });
	    } else if (self.currentState === self.STATES.EDIT_PRISTINE || self.currentState === self.STATES.VIEW_PRISTINE) {
	      self.transitionTo(self.TRANSITIONS.CANCEL_EDIT, { id: id, editMode: editMode });
	    }
	  };
	
	  self.onCancel = function () {
	    _jquery2.default.extend(true, $scope.item, master);
	    master = null;
	    self.setFormsToPristine();
	  };
	
	  /**
	   * <p>Reverts the changes made to the entity and restores the form form to pristine state.
	   * </p>
	   * @param {id} id of entity
	   */
	  $scope.reset = function (id) {
	    self.transitionTo(self.TRANSITIONS.RESET, { id: id });
	  };
	
	  self.onReset = function () {
	    $scope.item = angular.copy(master);
	    _jquery2.default.extend(true, $scope.item, master);
	    self.setFormsToPristine();
	  };
	  self.addToScope($scope);
	
	  self.setInitialState(this.STATES.NO_ITEM);
	  self.setCurrentState(this.STATES.NO_ITEM);
	
	  var initialEditMode = args.initialEditMode || false;
	  $scope.findByCriteria({ editMode: initialEditMode });
	};
	ItemController.$inject = ["$scope", "$resource", "$document", "$element", "fisItemMixin", "fisCRUDTransitionsMixin"]; /* jshint maxparams:6 */
	/**
	 * @constructor
	 * @name fis.fisComponents.ItemController
	 * @param $scope
	 * @param $resource
	 * @param $document
	 * @param {Object} args Object that contains configuration such as url, params and actions to construct an Angular Resource
	 * @param fisItemMixin
	 * @param fisCRUDTransitionsMixin
	 * @description
	 <p>Controller that makes single item related operations available on the scope.</em>.
	 </p>
	 */
	exports.default = ItemController;

/***/ }),
/* 89 */
/*!****************************************!*\
  !*** ./controllers/list.controller.js ***!
  \****************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * @constructor
	 * @name fis.fisComponents.ListController
	 * @param $scope
	 * @param $resource
	 * @param $document
	 * @param {Object} args Object that contains configuration such as url, params and actions to construct an Angular Resource
	 * @description
	 <p>Controller that makes Master/Details related operations available on the scope. It inherits the basic
	 CRUD functionality from <em>fis.fisComponents.CrudController</em>.
	 </p>
	 */
	var ListController = function ListController($scope, $resource, args, fisListMixin, fisCRUDTransitionsMixin, fisCustomActionsMixin) {
	  'ngInject';
	
	  var self = this;
	
	  fisListMixin.call(ListController.prototype);
	  fisCRUDTransitionsMixin.call(ListController.prototype);
	  fisCustomActionsMixin.call(ListController.prototype);
	
	  self.args = args;
	  self.$scope = $scope;
	  self.$resource = $resource;
	  self.itemResource = $resource(args.url, args.paramDefaults, args.actions);
	
	  $scope.findAll = self.findAll;
	  $scope.selectItem = self.selectItem;
	  $scope.items = self.findAll();
	  $scope.findById = self.findById;
	
	  $scope.select = function (id) {
	    self.transitionTo(self.TRANSITIONS.SELECT_ITEM, id);
	  };
	
	  self.onSelectItem = function (id) {
	    $scope.item = self.selectItem(id);
	  };
	
	  $scope.customAction = function (action, params) {
	    self.customAction(action, params);
	  };
	
	  self.setInitialState(this.STATES.NO_ITEM);
	  self.setCurrentState(this.STATES.NO_ITEM);
	  self.addToScope($scope);
	};
	ListController.$inject = ["$scope", "$resource", "args", "fisListMixin", "fisCRUDTransitionsMixin", "fisCustomActionsMixin"];
	
	exports.default = ListController;

/***/ }),
/* 90 */
/*!**************************************************!*\
  !*** ./controllers/master-details.controller.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                                               * @constructor
	                                                                                                                                                                                                                                                                               * @name fis.fisComponents.MasterDetailController
	                                                                                                                                                                                                                                                                               * @param $scope
	                                                                                                                                                                                                                                                                               * @param $resource
	                                                                                                                                                                                                                                                                               * @param $document
	                                                                                                                                                                                                                                                                               * @param {Object} args Object that contains configuration such as url, params and actions to construct an Angular Resource
	                                                                                                                                                                                                                                                                               * @description
	                                                                                                                                                                                                                                                                               <p>Controller that makes Master/Details related operations available on the scope. It inherits the basic
	                                                                                                                                                                                                                                                                               CRUD functionality from <em>fis.fisComponents.CrudController</em>.
	                                                                                                                                                                                                                                                                               </p>
	                                                                                                                                                                                                                                                                               */
	/* jshint maxparams: 6 */
	
	
	var _jquery = __webpack_require__(/*! jquery */ 1);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var MasterDetailsController = function MasterDetailsController($scope, $resource, $document, $q, fisPubSubService, argsOrElem, fisListMixin, fisItemMixin, fisCRUDTransitionsMixin, fisCustomActionsMixin) {
	  'ngInject';
	
	  var self = this;
	
	  fisListMixin.call(MasterDetailsController.prototype);
	  fisItemMixin.call(MasterDetailsController.prototype);
	  fisCRUDTransitionsMixin.call(MasterDetailsController.prototype);
	  fisCustomActionsMixin.call(MasterDetailsController.prototype);
	
	  self.args = argsOrElem;
	  self.$scope = $scope;
	  self.$resource = $resource;
	  self.$document = $document;
	
	  if (!argsOrElem.url) {
	    // the argsOrElem object received here is actually $element when  MasterDetailsController is used as a page specific controller through ng-controller.
	    // Evaluate the value of fis-args attribute
	    argsOrElem = $scope.$eval(argsOrElem.attr('fis-args'));
	  }
	
	  try {
	    argsOrElem.url = $scope.$eval(argsOrElem.url);
	  } catch (err) {
	    // URL is not a scope variable
	  }
	  if (!argsOrElem.actions) {
	    argsOrElem.actions = {};
	  }
	
	  // For SDHTML-11361: Customization for update action (fis-arg) is overridden
	  if (!argsOrElem.actions.update) {
	    argsOrElem.actions.update = {};
	  }
	
	  // define PUT method for update method
	  argsOrElem.actions.update.method = 'PUT';
	
	  self.itemResource = $resource(argsOrElem.url, argsOrElem.paramDefaults, argsOrElem.actions);
	
	  $scope.selectItem = self.selectItem;
	
	  $scope.findAll = function () {
	    var deferred = $q.defer();
	
	    var unsubscribe = fisPubSubService.subscribe('fisOpStateSet', function (object) {
	      if (object.opState === 'SUCCESS' && object.opName === 'FindAll') {
	        deferred.resolve($scope.items);
	      } else if (object.opState === 'FAILURE' && object.opName === 'FindAll') {
	        deferred.reject(object.opMessage);
	      }
	
	      unsubscribe();
	    });
	
	    self.findAll();
	
	    return deferred.promise;
	  };
	
	  $scope.findById = function (id) {
	    var deferred = $q.defer();
	
	    var unsubscribe = fisPubSubService.subscribe('fisOpStateSet', function (object) {
	      if (object.opState === 'SUCCESS' && object.opName === 'FindById') {
	        deferred.resolve(object.opObj);
	      }
	      unsubscribe();
	    });
	
	    self.findById(id);
	
	    return deferred.promise;
	  };
	
	  // var dirtyFormNames = [];
	  $scope.args = function () {
	    return argsOrElem;
	  };
	
	  /**
	   * <p>Creates new Entity resource. Sets the master copy to empty object..</p>
	   */
	  var master = null;
	
	  self.onFetchList = function (args) {
	    if (args && !args.fetchStrategy) {
	      // urls args for pagination
	      self.findByCriteria(args, function (data) {
	        $scope.items = data;
	      }, angular.noop);
	    } else if (!args) {
	      // not delegating to fisData and therefore make a call. It's a page not using fisData
	      $scope.items = self.findAll();
	    }
	  };
	
	  /**
	   * <p>Marks the current state to Edit Pristine, and opens the form for adding an entity.</p>
	   */
	  $scope.create = function () {
	    if ($scope.clearMessages) {
	      $scope.clearMessages();
	    }
	    $scope.newItem = true;
	    self.transitionTo(self.TRANSITIONS.CREATE);
	  };
	
	  self.onCreate = function () {
	    $scope.item = self.create();
	    fisPubSubService.publish('fisItemChanged', $scope.item);
	  };
	
	  $scope.findByCriteria = function (args) {
	    self.setCurrentState(self.STATES.NO_LIST);
	    self.transitionTo(self.TRANSITIONS.FETCH_LIST, args);
	  };
	
	  /**
	   * <p>Makes the passed in entity available on scope for editing.</p>
	   * @param {param} param to be edited
	   * @param {editMode} editMode
	   */
	  $scope.select = function (param, editMode) {
	    // if it is row data (single row selected), select method should handle it like single row selection
	    if (angular.isArray(param)) {
	      if (param.length === 1) {
	        param = param[0];
	      }
	    }
	
	    if (this.clearMessages) {
	      this.clearMessages();
	    }
	
	    var args = {
	      editMode: editMode
	    };
	
	    if ((typeof param === 'undefined' ? 'undefined' : _typeof(param)) === 'object') {
	      args.item = param;
	    } else {
	      args.id = param;
	    }
	
	    self.transitionTo(self.TRANSITIONS.SELECT_ITEM, args);
	  };
	
	  self.onSelectItem = function (args) {
	    if (args.id) {
	      $scope.item = self.selectItem(args.id);
	    } else if (args.item) {
	      $scope.item = args.item;
	    } else {
	      $scope.item = args;
	    }
	
	    master = angular.copy($scope.item);
	    fisPubSubService.publish('fisItemChanged', $scope.item);
	  };
	
	  /**
	   * <p>Makes the passed in entity available on scope for saving.
	   * Updates the current state to View Pristine, if save was successful.</p>
	   *
	   */
	  $scope.save = function (displayDefaultMessage) {
	    displayDefaultMessage = displayDefaultMessage !== false;
	    $scope.sourceScope = this;
	    var deferred = $q.defer();
	
	    self.transitionTo(self.TRANSITIONS.SAVE, $scope.item, displayDefaultMessage);
	
	    var unsubscribe = fisPubSubService.subscribe('fisOpStateSet', function (object) {
	      if (object.opState === 'SUCCESS' && object.opName === 'Save') {
	        deferred.resolve($scope.item);
	      } else if (object.opState === 'FAILURE' && object.opName === 'Save') {
	        deferred.reject(object.opMessage);
	      }
	      unsubscribe();
	    });
	
	    return deferred.promise;
	  };
	
	  self.onSave = function (item, displayDefaultMessage) {
	    self.save(item, $scope.newItem, function (data) {
	      // For usecases where fisGrid is not being used with masterDetailsController.
	      if (argsOrElem.fetchStrategy && argsOrElem.fetchStrategy !== 'delegate') {
	        $scope.items = self.findAll();
	      }
	
	      var args = {};
	      args.item = data;
	
	      self.onSelectItem(args);
	
	      fisPubSubService.publish('fisOpStateSet', {
	        opState: 'SUCCESS',
	        opName: 'Save'
	      });
	
	      // TODO: remove this when we remove fisEndpoint from fisGrid. Fetching data should go through the controller.
	      $scope.$broadcast('fisRefresh', 'items');
	      self.currentState = self.STATES.VIEW_PRISTINE;
	      self.setFormsToPristine();
	      $scope.newItem = false;
	    }, function (opt) {
	      // TODO: throw exception with opt as payload. Let the exception handler decide what to do with it.
	      if (displayDefaultMessage) {
	        if ($scope.sourceScope) {
	          $scope.sourceScope.displayMessage(opt.data.messages);
	        } else {
	          $scope.displayMessage(opt.data.messages);
	        }
	      }
	
	      fisPubSubService.publish('fisOpStateSet', {
	        opState: 'FAILURE',
	        opName: 'Save',
	        opMessage: opt.data.messages
	      });
	    });
	
	    if ($scope.resetTitle) {
	      $scope.resetTitle();
	    }
	  };
	
	  $scope.edit = function (id) {
	    if ($scope.clearMessages) {
	      $scope.clearMessages();
	    }
	    $scope.newItem = false;
	    self.transitionTo(self.TRANSITIONS.EDIT, { id: id });
	  };
	
	  /**
	   * <p>Reverts the changes made to the entity and restores the form form to pristine state.
	   * </p>
	   * @param {id} id to be saved
	   * @param {editMode} editMode
	   */
	  $scope.cancel = function (id, editMode) {
	    if (self.currentState === self.STATES.VIEW_PRISTINE) {
	      self.transitionTo(self.TRANSITIONS.CANCEL, { id: id, editMode: editMode });
	    } else if (self.currentState === self.STATES.EDIT_PRISTINE || self.currentState === self.STATES.EDIT_DIRTY || self.currentState === self.STATES.EDIT_INVALID) {
	      self.transitionTo(self.TRANSITIONS.CANCEL_EDIT, { id: id, editMode: editMode });
	    }
	
	    if ($scope.resetTitle) {
	      $scope.resetTitle();
	    }
	  };
	
	  self.onCancel = function () {
	    _jquery2.default.extend(true, $scope.item, master);
	    master = null;
	    self.setFormsToPristine();
	  };
	
	  /**
	   * <p>Reverts the changes made to the entity and restores the form form to pristine state.
	   * </p>
	   *
	   * @param {id} id to be reset to pristine state
	   */
	  $scope.reset = function (id) {
	    self.transitionTo(self.TRANSITIONS.RESET, { id: id });
	  };
	
	  self.onReset = function (resetArgs) {
	    if (resetArgs.id) {
	      $scope.item = self.findById(resetArgs.id);
	      var item = $scope.item;
	      _jquery2.default.extend(true, item, master);
	    } else {
	      angular.forEach($scope.item, function (val, key) {
	        $scope.item[key] = '';
	      });
	    }
	
	    self.setFormsToPristine();
	  };
	
	  /**
	   * <p>Makes the passed in entity available on scope for deleting.
	   * Updates the current state to No Item, if delete was successful.</p>
	   * @param {id} id to be deleted
	   */
	  $scope.remove = function (id, displayDefaultMessage) {
	    displayDefaultMessage = displayDefaultMessage !== false;
	    $scope.sourceScope = this;
	    var deferred = $q.defer();
	
	    self.transitionTo(self.TRANSITIONS.REMOVE, id, displayDefaultMessage);
	
	    var unsubscribe = fisPubSubService.subscribe('fisOpStateSet', function (object) {
	      if (object.opState === 'SUCCESS' && object.opName === 'Remove') {
	        deferred.resolve(id);
	      } else if (object.opState === 'FAILURE' && object.opName === 'Remove') {
	        deferred.reject(object.opMessage);
	      }
	      unsubscribe();
	    });
	
	    return deferred.promise;
	  };
	
	  self.onRemove = function (id, displayDefaultMessage) {
	    self.remove(id, function () {
	      // For usecases where fisGrid is not being used with masterDetailsController
	      if (argsOrElem.fetchStrategy && argsOrElem.fetchStrategy !== 'delegate') {
	        $scope.items = self.findAll();
	      }
	
	      // TODO: remove this when we remove fisEndpoint from fisGrid. Fetching data should go through the controller.
	      $scope.$broadcast('fisRefresh', 'items');
	
	      self.currentState = self.STATES.NO_ITEM;
	
	      fisPubSubService.publish('fisOpStateSet', {
	        opState: 'SUCCESS',
	        opName: 'Remove'
	      });
	    }, function (opt) {
	      // TODO: throw exception with opt as payload. Let the exception handler decide what to do with it.
	      if (displayDefaultMessage) {
	        if ($scope.sourceScope) {
	          $scope.sourceScope.displayMessage(opt.data.messages);
	        } else {
	          $scope.displayMessage(opt.data.messages);
	        }
	      }
	
	      fisPubSubService.publish('fisOpStateSet', {
	        opState: 'FAILURE',
	        opName: 'Remove',
	        opMessage: opt.data.messages
	      });
	    });
	  };
	
	  $scope.customAction = function (action, params) {
	    self.customAction(action, params);
	  };
	
	  self.setInitialState(self.STATES.NO_LIST);
	  self.setCurrentState(self.STATES.NO_LIST);
	
	  /* Changes for fisData. For preFetch strategy, both the masterDetailsController and
	   * fisData make calls resulting into two calls. Therefore the pages that use fisData
	   * must omit fetchStrategy="prefetch" from their configuration
	   */
	  if (!argsOrElem.fetchStrategy) {
	    // No fetch strategy. Data will be fetched by fisData
	    // Create a args object and add fetchStrategy with value delegate
	    self.transitionTo(self.TRANSITIONS.FETCH_LIST, { fetchStrategy: 'delegate' });
	  } else if (argsOrElem.fetchStrategy !== 'search') {
	    self.transitionTo(self.TRANSITIONS.FETCH_LIST);
	  }
	
	  self.addToScope($scope);
	};
	MasterDetailsController.$inject = ["$scope", "$resource", "$document", "$q", "fisPubSubService", "argsOrElem", "fisListMixin", "fisItemMixin", "fisCRUDTransitionsMixin", "fisCustomActionsMixin"];
	
	exports.default = MasterDetailsController;

/***/ }),
/* 91 */
/*!*****************************!*\
  !*** ./directives/index.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _button = __webpack_require__(/*! ./button */ 92);
	
	var _button2 = _interopRequireDefault(_button);
	
	var _center = __webpack_require__(/*! ./center */ 95);
	
	var _center2 = _interopRequireDefault(_center);
	
	var _contentEditable = __webpack_require__(/*! ./content-editable */ 97);
	
	var _contentEditable2 = _interopRequireDefault(_contentEditable);
	
	var _cssDimension = __webpack_require__(/*! ./css-dimension */ 99);
	
	var _cssDimension2 = _interopRequireDefault(_cssDimension);
	
	var _fieldMessage = __webpack_require__(/*! ./field-message */ 101);
	
	var _fieldMessage2 = _interopRequireDefault(_fieldMessage);
	
	var _gridLayout = __webpack_require__(/*! ./grid-layout */ 103);
	
	var _gridLayout2 = _interopRequireDefault(_gridLayout);
	
	var _hierarchy = __webpack_require__(/*! ./hierarchy */ 105);
	
	var _hierarchy2 = _interopRequireDefault(_hierarchy);
	
	var _messageContainer = __webpack_require__(/*! ./message-container */ 107);
	
	var _messageContainer2 = _interopRequireDefault(_messageContainer);
	
	var _offset = __webpack_require__(/*! ./offset */ 109);
	
	var _offset2 = _interopRequireDefault(_offset);
	
	var _primary = __webpack_require__(/*! ./primary */ 111);
	
	var _primary2 = _interopRequireDefault(_primary);
	
	var _scrollable = __webpack_require__(/*! ./scrollable */ 113);
	
	var _scrollable2 = _interopRequireDefault(_scrollable);
	
	var _secondary = __webpack_require__(/*! ./secondary */ 115);
	
	var _secondary2 = _interopRequireDefault(_secondary);
	
	var _span = __webpack_require__(/*! ./span */ 117);
	
	var _span2 = _interopRequireDefault(_span);
	
	var _tabData = __webpack_require__(/*! ./tab-data */ 119);
	
	var _tabData2 = _interopRequireDefault(_tabData);
	
	var _tertiary = __webpack_require__(/*! ./tertiary */ 121);
	
	var _tertiary2 = _interopRequireDefault(_tertiary);
	
	var _visible = __webpack_require__(/*! ./visible */ 123);
	
	var _visible2 = _interopRequireDefault(_visible);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives', [_button2.default, _center2.default, _contentEditable2.default, _cssDimension2.default, _fieldMessage2.default, _gridLayout2.default, _hierarchy2.default, _messageContainer2.default, _offset2.default, _primary2.default, _scrollable2.default, _secondary2.default, _span2.default, _tabData2.default, _tertiary2.default, _visible2.default]);
	
	exports.default = ngModule.name;

/***/ }),
/* 92 */
/*!************************************!*\
  !*** ./directives/button/index.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _button = __webpack_require__(/*! ./button.directive */ 93);
	
	var _button2 = _interopRequireDefault(_button);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.button', []);
	
	// TODO should this be a 'component' vs a 'directive'?
	
	ngModule.directive('fisButton', _button2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 93 */
/*!***********************************************!*\
  !*** ./directives/button/button.directive.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisUniqueIdService", "fisMemoryUtilService", function (fisUniqueIdService, fisMemoryUtilService) {
	  'ngInject';
	
	  return {
	    restrict: 'AC',
	    link: function link(scope, element, attrs) {
	      fisUniqueIdService.generateUniqueId(scope, element, attrs);
	
	      var buttonState = attrs.fisButton;
	
	      var setState = function setState(state) {
	        // default
	        var classToAdd = 'btn btn-secondary fis-secondary';
	
	        // first clear previous state
	        if (element.hasClass('btn btn-primary')) {
	          element.removeClass('btn').removeClass('btn-primary').removeClass('fis-primary');
	        } else if (element.hasClass('btn btn-secondary')) {
	          element.removeClass('btn').removeClass('btn-secondary').removeClass('fis-secondary');
	        } else if (element.hasClass('btn btn-tertiary')) {
	          element.removeClass('btn').removeClass('btn-link').removeClass('btn-tertiary').removeClass('fis-tertiary');
	        }
	
	        if (state === 'primary') {
	          classToAdd = 'btn btn-primary fis-primary';
	        } else if (state === 'secondary') {
	          classToAdd = 'btn btn-secondary fis-secondary';
	        } else if (state === 'tertiary') {
	          classToAdd = 'btn-link btn btn-tertiary fis-tertiary';
	        }
	
	        element.addClass(classToAdd);
	      };
	
	      var buttonStateWatch = scope.$watch(buttonState, function (state) {
	        setState(state);
	      }, true);
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, buttonStateWatch);
	    }
	  };
	}];
	
	__webpack_require__(/*! ./button.styles.less */ 94);

/***/ }),
/* 94 */
/*!**********************************************!*\
  !*** ./directives/button/button.styles.less ***!
  \**********************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 95 */
/*!************************************!*\
  !*** ./directives/center/index.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _center = __webpack_require__(/*! ./center.directive */ 96);
	
	var _center2 = _interopRequireDefault(_center);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.center', []);
	
	ngModule.directive('fisCenter', _center2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 96 */
/*!***********************************************!*\
  !*** ./directives/center/center.directive.js ***!
  \***********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$timeout", "fisMemoryUtilService", function ($timeout, fisMemoryUtilService) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    require: '?fisReinit',
	    replace: false,
	    link: function link(scope, elem, attrs, fisReinit) {
	      // hide the element until current $digest is done and that the size of the element has more chance of being final.
	      elem.hide();
	
	      // fix the position and then calculate the outerWidth, otherwise left val would be wrong in first rendering
	      elem.css('position', 'fixed');
	      var parent = attrs.fisCenter ? window[attrs.fisCenter] : ':parent';
	
	      function center() {
	        elem.css({
	          top: (parseInt(angular.element(parent).height(), 10) - angular.element(elem).outerHeight(true)) / 2 + angular.element(parent).scrollTop() + 'px',
	          left: (parseInt(angular.element(parent).width(), 10) - angular.element(elem).outerWidth(true)) / 2 + angular.element(parent).scrollLeft() + 'px'
	        });
	      }
	
	      // support the fisReinit attribute. Each time its expression changes, the center function will get called again.
	      if (fisReinit) {
	        fisReinit.trigger = function () {
	          // Wait for the $digest cycle to be over to make sure the changes are made in the content of
	          // the element so that centering is done with the proper content.
	          var centerTimeout = $timeout(function () {
	            center();
	          });
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, centerTimeout, $timeout);
	        };
	      }
	
	      var resizeTimeout = $timeout(function () {
	        elem.show();
	        center();
	        angular.element(window).resize(function () {
	          center();
	        });
	      });
	      fisMemoryUtilService.cancelTimeoutOnDestroy(scope, resizeTimeout, $timeout);
	    }
	  };
	}];

/***/ }),
/* 97 */
/*!**********************************************!*\
  !*** ./directives/content-editable/index.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _contentEditable = __webpack_require__(/*! ./content-editable.directive */ 98);
	
	var _contentEditable2 = _interopRequireDefault(_contentEditable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.content-editable', []);
	
	ngModule.directive('contenteditable', _contentEditable2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 98 */
/*!*******************************************************************!*\
  !*** ./directives/content-editable/content-editable.directive.js ***!
  \*******************************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  function linker(scope, element, attrs, ngModel) {
	    var updateOn = 'blur keyup change';
	    if (!ngModel) {
	      return; // do nothing if no ng-model
	    }
	    // Specify how UI should be updated
	    ngModel.$render = function () {
	      element.html(ngModel.$viewValue || '');
	    };
	
	    function updateModel() {
	      scope.$apply(read);
	    }
	
	    attrs.$observe('fisUpdateOn', function (val) {
	      // unbind any previously bound listener
	      element.unbind(updateOn, updateModel);
	
	      updateOn = val || updateOn;
	      // Listen for change events to enable binding
	      element.bind(updateOn, updateModel);
	    });
	
	    // Write data to the model
	    function read() {
	      ngModel.$setViewValue(element.html());
	    }
	
	    if (element.text()) {
	      read();
	    }
	  }
	
	  return {
	    restrict: 'A', // only activate on element attribute
	    require: '?ngModel', // get a hold of NgModelController
	    link: linker
	  };
	};

/***/ }),
/* 99 */
/*!*******************************************!*\
  !*** ./directives/css-dimension/index.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _cssDimension = __webpack_require__(/*! ./css-dimension.directive */ 100);
	
	var _cssDimension2 = _interopRequireDefault(_cssDimension);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.css-dimension', []);
	
	[{ name: 'fisHeight', css: 'height' }, { name: 'fisMaxHeight', css: 'maxHeight' }, { name: 'fisWidth', css: 'width' }, { name: 'fisMaxWidth', css: 'maxWidth' }].forEach(function (directive) {
	  ngModule.directive(directive.name, (0, _cssDimension2.default)(directive));
	});
	
	exports.default = ngModule.name;

/***/ }),
/* 100 */
/*!*************************************************************!*\
  !*** ./directives/css-dimension/css-dimension.directive.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (directive) {
	  return ["fisPubSubService", function (fisPubSubService) {
	    'ngInject';
	
	    return {
	      priority: 500,
	      link: function link(scope, element, attrs) {
	        attrs.$observe(directive.name, function (value) {
	          if (value.match(/^\d+$/)) {
	            value += 'px';
	          }
	          /*
	          SDHTML-8826
	          This observe overrides height calculations made in the local directive (e.g. fisGrid) in IE.
	           To prevent this from happening, the local directive should publish an event. If this event is true (i.e
	          a height calculation has been made and should not be overridden) then the element's css height property
	          will not be set.
	           Note that angularjs does not currently provide a deregistration function for $observe (like it does for $watch).
	          The feature is being considered here https://github.com/angular/angular.js/pull/5609 but it will be
	          a breaking change!
	          */
	          fisPubSubService.subscribe('heightAdjusted', function (isHeightApplied) {
	            if (!isHeightApplied || _.isUndefined(isHeightApplied)) {
	              element.css(directive.css, value);
	            }
	          });
	        });
	      }
	    };
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 8)))

/***/ }),
/* 101 */
/*!*******************************************!*\
  !*** ./directives/field-message/index.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _fieldMessage = __webpack_require__(/*! ./field-message.directive */ 102);
	
	var _fieldMessage2 = _interopRequireDefault(_fieldMessage);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.field-message', []);
	
	ngModule.directive('fisFieldMessage', _fieldMessage2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 102 */
/*!*************************************************************!*\
  !*** ./directives/field-message/field-message.directive.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisI18nService", "fisScopeUtils", "$filter", "fisMessageContainerUtilService", function (fisI18nService, fisScopeUtils, $filter, fisMessageContainerUtilService) {
	  'ngInject';
	
	  var ERROR_KEY = 'error-';
	  /*
	   * returns a hash of property name to ngModel that this fisFieldMessage is linked to.
	   */
	  function getRelatedInputs(scope, attrs) {
	    if (attrs.for) {
	      // for cases where the fisFieldMessage is used outside of a field component or to override the field component's inputs (for inner field component messages)
	      // value of "for" attribute should be the same as the "name" attribute used for the ngModel
	      // each ngModel registers itself to the parent form directive and the form directive exposes a scope value using the ngModel's name
	      var ret = {};
	      var ngModel = scope[attrs.for];
	      if (ngModel.fisProperty) {
	        ret[ngModel.fisProperty] = ngModel;
	        return ret;
	      }
	      // TODO: Need to check for which use case this code executes and according to that conversion required
	      // To fix SDHTML-3674/SDHTML-4036 input element name should be in '_' format
	      // for multilevel ng-model-input and element name should be like as below to be understandable by angular
	      // ng-model-input               input element name
	      // profile.user.lastName        profile_user_lastName
	      // profile.user[0].lastName     profile_user_0__lastName
	      ret[ngModel.$name.replace('_', '.')] = ngModel;
	      return ret;
	    }
	    // check for inputs defined in Field widgets
	    // this relies on having the ngModel assigned to a previous sibling element than the current one.
	    return scope.registeredInputs;
	  }
	
	  function updateMessagesFromModel(model, scope, errorCodeToRemove) {
	    var oldMessages = scope.messages;
	    if (model.$dirty) {
	      if (!_underscore2.default.isUndefined(errorCodeToRemove) && errorCodeToRemove.length !== 0) {
	        _underscore2.default.each(errorCodeToRemove, function (code) {
	          if (scope.messages[code]) {
	            scope.messages[code] = null;
	            delete scope.messages[code];
	          }
	        });
	      }
	      angular.forEach(model.$error, function (err, key) {
	        if (err) {
	          scope.messages[key] = $filter('i18n')(ERROR_KEY + key, oldMessages[key]);
	        }
	      }, model);
	    }
	  }
	
	  return {
	    restrict: 'CA',
	    template: '<span fis-unique-id="fieldmessage" role="alert" aria-live="polite" aria-atomic="true" aria-relevant="all" class="help-block" ng-bind-html="fieldMessages()"></span>',
	    replace: true,
	    require: ['fisFieldMessage', '^?ngForm', '^?form'],
	    scope: true,
	    controller: ['$scope', '$element', '$attrs', function ($scope) {
	      $scope.messages = {};
	
	      $scope.fieldMessages = function () {
	        return _underscore2.default.values($scope.messages).join(', ');
	      };
	
	      $scope.clearMessages = function () {
	        $scope.messages = {};
	        // remove the $error map associated with the ng-model
	        angular.forEach($scope.registeredInputs, function (input) {
	          input.$setPristine();
	        });
	      };
	      // REQUIRES REFACTORING
	      // this attaches the clear messages function so the message container
	      // can access the function as well, this should be part of a service instead
	      this.clearMessages = $scope.clearMessages;
	
	      /**
	       * @name fisClearMessages event listener
	       * @description When 'fisClearMessages' event is received, the messages displayed by this widget are cleared.
	       */
	      $scope.$on('fisClearMessages', function () {
	        $scope.clearMessages();
	      });
	    }],
	    link: function link(scope, element, attrs, ctrls) {
	      var fieldElement = element.closest('.fis-field');
	      var inputs = getRelatedInputs(scope, attrs);
	      /* SDHTML-12552 - Form Validation fails when ng-repeat is used to display fields
	       * The below logic is added to make the fisName property from registered inputs
	       * accessible inside the displayMessage of fisMessageContainer.
	       */
	      ctrls[0].inputs = {};
	
	      angular.forEach(inputs, function (value) {
	        if (value.fisProperty) {
	          ctrls[0].inputs.fisProperty = value.fisProperty;
	        }
	        if (value.fisName) {
	          ctrls[0].inputs.fisName = value.fisName;
	        }
	      });
	      /**
	       * Adds a message to be displayed.
	       * @param {Object} msg The message object that comes from the fisMessageContainer
	       */
	      ctrls[0].addMessage = function (msg) {
	        if (msg.msg) {
	          scope.messages[msg.code] = fisI18nService.translate(ERROR_KEY + msg.code, msg.msg);
	        } else if (msg.message) {
	          scope.messages[msg.code] = fisI18nService.translate(ERROR_KEY + msg.code, msg.message);
	        }
	        if (msg.type === 'error' && msg.property) {
	          var isInvalid = false;
	          var modelController = inputs[msg.property];
	          modelController.$dirty = true;
	          modelController.$setValidity(msg.code, false);
	          isInvalid = true;
	          modelController.$parsers.unshift(function (value) {
	            if (isInvalid) {
	              var errorKeys = _underscore2.default.keys(modelController.$error);
	              angular.forEach(errorKeys, function (key) {
	                if (msg.code === key) {
	                  if (scope.messages[key]) {
	                    scope.messages[key] = null;
	                    delete scope.messages[key];
	                  }
	                  modelController.$setValidity(key, true);
	                  isInvalid = false;
	                  if (fieldElement) {
	                    fieldElement.removeClass('fis-invalid').addClass('fis-valid');
	                  }
	                }
	              });
	            }
	            return value;
	          });
	        }
	      };
	
	      ctrls[0].removeMessageClass = function () {
	        var form = ctrls[1] || ctrls[2];
	
	        if (!form || form && !form.$name) {
	          throw new Error('fisFieldMessage needs to be in a named form');
	        }
	
	        if (fieldElement && !form.$invalid) {
	          fieldElement.removeClass('fis-invalid');
	        }
	      };
	
	      scope.registerFieldMessage = fisMessageContainerUtilService.registerFieldMessage;
	      scope.unregisterFieldMessage = fisMessageContainerUtilService.unregisterFieldMessage;
	
	      // registers this controller to the parent fisMessageContainer
	      if (scope.registerFieldMessage) {
	        scope.registerFieldMessage(ctrls[0], _underscore2.default.keys(inputs));
	        // bind $destroy event on element.parent as fis-input directive $destroy event
	        // getting called prior to fisFieldMessage. This change introduced after angular 1.4
	        // upgrade and now angular calls $destroy event as per DOM hierarchy
	        element.parent().bind('$destroy', function () {
	          scope.unregisterFieldMessage(ctrls[0], _underscore2.default.keys(inputs));
	        });
	      }
	
	      angular.forEach(inputs, function (ngModel) {
	        var model = ngModel;
	        var form = ctrls[1] || ctrls[2];
	        if (!form || form && !form.$name) {
	          throw new Error('fisFieldMessage needs to be in a named form');
	        }
	
	        var path = form.$name + '.' + ngModel.$name + '.';
	        try {
	          fisScopeUtils.watch(scope, path + '$dirty', function (dirty) {
	            if (fieldElement) {
	              if (dirty) {
	                fieldElement.addClass('fis-dirty').removeClass('fis-pristine');
	              } else {
	                fieldElement.removeClass('fis-dirty').addClass('fis-pristine');
	              }
	            }
	            updateMessagesFromModel(model, scope);
	          });
	
	          fisScopeUtils.watch(scope, path + '$invalid', function (invalid) {
	            if (fieldElement) {
	              if (invalid) {
	                fieldElement.addClass('fis-invalid').removeClass('fis-valid');
	              } else {
	                fieldElement.removeClass('fis-invalid').addClass('fis-valid');
	              }
	            }
	            updateMessagesFromModel(model, scope);
	          });
	
	          scope.$watch(path + '$error', function (newVal, oldVal) {
	            var errorCodeToRemove = [];
	            if (!_underscore2.default.isEqual(oldVal, newVal)) {
	              if (!_underscore2.default.isEmpty(oldVal) && _underscore2.default.isEmpty(newVal)) {
	                errorCodeToRemove = _underscore2.default.keys(oldVal);
	              } else if (!_underscore2.default.isEmpty(oldVal)) {
	                errorCodeToRemove = _underscore2.default.difference(_underscore2.default.keys(oldVal), _underscore2.default.keys(newVal));
	              }
	            }
	            updateMessagesFromModel(model, scope, errorCodeToRemove);
	          }, true);
	        } catch (error) {
	          // Error handling
	        }
	      });
	    }
	  };
	}];
	
	var _underscore = __webpack_require__(/*! underscore */ 8);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 103 */
/*!*****************************************!*\
  !*** ./directives/grid-layout/index.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _gridLayout = __webpack_require__(/*! ./grid-layout.directive */ 104);
	
	var _gridLayout2 = _interopRequireDefault(_gridLayout);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.grid-layout', []);
	
	ngModule.directive('fisGridLayout', _gridLayout2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 104 */
/*!*********************************************************!*\
  !*** ./directives/grid-layout/grid-layout.directive.js ***!
  \*********************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return {
	    restrict: 'C',
	    link: function link(scope, element) {
	      element.addClass('row');
	    }
	  };
	};

/***/ }),
/* 105 */
/*!***************************************!*\
  !*** ./directives/hierarchy/index.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _hierarchy = __webpack_require__(/*! ./hierarchy.directive */ 106);
	
	var _hierarchy2 = _interopRequireDefault(_hierarchy);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.hierarchy', []);
	
	ngModule.directive('fisHierarchy', _hierarchy2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 106 */
/*!*****************************************************!*\
  !*** ./directives/hierarchy/hierarchy.directive.js ***!
  \*****************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisUniqueIdService", function (fisUniqueIdService) {
	  'ngInject';
	
	  return {
	    priority: 1000,
	    restrict: 'A',
	    transclude: 'element',
	    compile: function compile(tElement, tAttrs, transclude) {
	      var repeatExpr;
	      var childExpr;
	      var rootExpr;
	      var childrenExpr;
	
	      repeatExpr = tAttrs.fisHierarchy.match(/^(.*) in ((?:.*\.)?(.*))$/);
	      if (!repeatExpr) {
	        throw new Error('fisHierarchy should be in the form of "<item> in <rootObj>.<childrenProperty>"');
	      }
	      childExpr = repeatExpr[1];
	      rootExpr = repeatExpr[2];
	      childrenExpr = repeatExpr[3];
	
	      return function link(scope, element, attrs) {
	        var rootElement = element[0].parentNode;
	        var cache = [];
	        var branchExpr = rootElement.nodeName;
	        var uniqueIdBase;
	
	        if (fis.initParams().appStage === 'T') {
	          uniqueIdBase = attrs.fisid || attrs.fisUniqueId || 'fisHierarchy';
	          uniqueIdBase = fisUniqueIdService.generateUniqueId(scope, $(rootElement), attrs, uniqueIdBase);
	        }
	
	        // Reverse lookup object to avoid re-rendering elements
	        function lookup(child) {
	          var i = cache.length;
	          while (i--) {
	            if (cache[i].scope[childExpr] === child) {
	              return cache.splice(i, 1)[0];
	            }
	          }
	        }
	
	        scope.$watch(rootExpr, function (root) {
	          if (!root) {
	            return;
	          }
	          var cached;
	          var currentCache = [];
	          var i = 0;
	
	          // Recurse the data structure
	          (function walk(children, parentNode, parentScope, depth) {
	            var i = 0;
	            var n = children.length;
	            var last = n - 1;
	            var cursor;
	            var child;
	            var cached;
	            var childScope;
	            var grandchildren;
	            var branchCreated = false;
	
	            // Iterate the children at the current level
	            for (; i < n; ++i) {
	              // We will compare the cached element to the element in
	              // at the destination index. If it does not match, then
	              // the cached element is being moved into this position.
	              cursor = parentNode.childNodes[i];
	
	              child = children[i];
	
	              // See if this child has been previously rendered
	              // using a reverse lookup by object reference
	              cached = lookup(child);
	
	              // If the parentScope no longer matches, we've moved.
	              // We'll have to transclude again so that scopes
	              // and controllers are properly inherited
	              if (cached && cached.parentScope !== parentScope) {
	                cache.push(cached);
	                cached = null;
	              }
	
	              // If it has not, render a new element and prepare its scope
	              // We also cache a reference to its branch node which will
	              // be used as the parentNode in the next level of recursion
	              if (!cached) {
	                transclude(parentScope.$new(), function (clone, childScope) {
	                  // eslint-disable-line
	                  var parentSgIdAttr = parentNode.attributes.getNamedItem('fisid');
	
	                  childScope[childExpr] = child;
	
	                  cached = {
	                    scope: childScope,
	                    parentScope: parentScope,
	                    element: clone[0],
	                    branch: clone.find(branchExpr)[0]
	                  };
	
	                  if (fis.initParams().appStage === 'T') {
	                    // test appStage
	                    fisUniqueIdService.generateUniqueId(childScope, clone, {}, parentSgIdAttr !== null ? parentSgIdAttr.value : uniqueIdBase, true); // eslint-disable-line
	                  }
	
	                  if (!cached.branch) {
	                    var branchElem = angular.element('<' + branchExpr + ' class="fis-branch"></' + branchExpr + '>');
	                    if (fis.initParams().appStage === 'T') {
	                      // test appStage
	                      fisUniqueIdService.generateUniqueId(childScope, branchElem, {}, clone.attr('fisid') ? clone.attr('fisid') : uniqueIdBase);
	                    }
	                    cached.branch = branchElem[0];
	                    clone.append(cached.branch);
	                    branchCreated = true;
	                  }
	
	                  // This had to happen during transclusion so inherited
	                  // controllers, among other things, work properly
	                  parentNode.insertBefore(cached.element, cursor ? cursor : null);
	                });
	              } else if (cached.element !== cursor) {
	                parentNode.insertBefore(cached.element, cursor);
	              }
	
	              // Lets's set some scope values
	              childScope = cached.scope;
	
	              // Store the current depth on the scope in case you want
	              // to use it (for good or evil, no judgment).
	              childScope.$depth = depth;
	
	              // Emulate some ng-repeat values
	              childScope.$index = i;
	              childScope.$first = i === 0;
	              childScope.$last = i === last;
	              childScope.$middle = !(childScope.$first || childScope.$last);
	
	              // Push the object onto the new cache which will replace
	              // the old cache at the end of the walk.
	              currentCache.push(cached);
	
	              // If the child has children of its own, recurse 'em.
	              grandchildren = child[childrenExpr];
	              if (grandchildren && grandchildren.length) {
	                walk(grandchildren, cached.branch, childScope, depth + 1);
	              } else if (branchCreated) {
	                angular.element(cached.branch).remove();
	              }
	            }
	          })(root, rootElement, scope, 0);
	
	          // Cleanup objects which have been removed.
	          // Remove DOM elements and destroy scopes to prevent memory leaks.
	          i = cache.length;
	
	          while (i--) {
	            cached = cache[i];
	            if (cached.scope) {
	              cached.scope.$destroy();
	            }
	            if (cached.element && cached.element.parentNode) {
	              cached.element.parentNode.removeChild(cached.element);
	            }
	          }
	
	          // Replace previous cache.
	          cache = currentCache;
	        }, true);
	      };
	    }
	  };
	}];

/***/ }),
/* 107 */
/*!***********************************************!*\
  !*** ./directives/message-container/index.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _messageContainer = __webpack_require__(/*! ./message-container.directive */ 108);
	
	var _messageContainer2 = _interopRequireDefault(_messageContainer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.message-container', []);
	
	ngModule.directive('fisMessageContainer', _messageContainer2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 108 */
/*!*********************************************************************!*\
  !*** ./directives/message-container/message-container.directive.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisPubSubService", "fisConfig", "$window", "fisViewPanelService", "fisI18nService", "fisMessageContainerUtilService", function (fisPubSubService, fisConfig, $window, fisViewPanelService, fisI18nService, fisMessageContainerUtilService) {
	  'ngInject';
	
	  return {
	    restrict: 'AC',
	    scope: true,
	    link: function link(scope, element, attrs) {
	      // if user has given fisName, prepend it with unique path prepared by replacing '/' of the hash part of URL with '_'
	      if (attrs.fisName) {
	        var hash = $window.location.hash.substring(2);
	        // if hash part contains another #, then use the path only till there
	        if (hash.indexOf('#') !== -1) {
	          hash = hash.substring(0, hash.indexOf('#'));
	        }
	        var path = hash.replace(/\//g, '_');
	        if (attrs.fisName.indexOf(path) !== 0) {
	          var pathSpecificName = path + '_' + attrs.fisName;
	          element.attr('fis-name', pathSpecificName);
	        }
	      }
	      scope.$on('$destroy', function () {
	        element.removeData().removeAttr();
	      });
	    },
	    controller: ['$scope', function ($scope) {
	      fisMessageContainerUtilService.messageScope = $scope;
	      if (!fisMessageContainerUtilService.parentScope) {
	        fisMessageContainerUtilService.parentScope = $scope;
	      }
	
	      $scope.messageCache = [];
	
	      $scope.addMessageToCache = fisMessageContainerUtilService.addMessageToCache;
	
	      $scope.removeMessageFromCacheForPath = fisMessageContainerUtilService.removeMessageFromCacheForPath;
	
	      $scope.removeMessageFromCacheForActivePanelPath = fisMessageContainerUtilService.removeMessageFromCacheForActivePanelPath;
	
	      $scope.displayMessageOnPanel = fisMessageContainerUtilService.displayMessageOnPanel;
	
	      $scope.isActivePanelPathInCache = fisMessageContainerUtilService.isActivePanelPathInCache;
	
	      $scope.isMessageInCache = fisMessageContainerUtilService.isMessageInCache;
	
	      $scope.isPathInCache = fisMessageContainerUtilService.isPathInCache;
	
	      $scope.findMessagesForPath = fisMessageContainerUtilService.findMessagesForPath;
	
	      // Read config file and if fisHTTPError subscription enabled then subscribe it
	      if (fisConfig.httpErrorSubscription && fisConfig.httpErrorSubscription.enabled) {
	        fisPubSubService.subscribe('fisHTTPError', function (response) {
	          var errorLocation = fisConfig.httpErrorSubscription.errorLocation;
	          var errorObject = {};
	          if (_.isUndefined(errorLocation)) {
	            if (response.status) {
	              errorObject.msg = fisI18nService.translate(response.status.toString());
	              errorObject.type = 'error';
	            }
	          } else if (errorLocation === 'response') {
	            // response is error object as provided in config file for errorLocation
	            errorObject = response;
	          } else {
	            // error location deep nested as form.employee.errorResponse
	            var parts = errorLocation.split('.');
	            while (parts.length && (response = response[parts.shift()])) {}
	            errorObject = response;
	          }
	
	          $scope.displayMessage(errorObject);
	        });
	      }
	
	      var unsubscribePanelClosed = fisPubSubService.subscribe('fisViewPanelClosed', function (data) {
	        if ($scope.isPathInCache(data.path)) {
	          $scope.removeMessageFromCacheForPath(data.path);
	        }
	      });
	
	      var unsubscribe = fisPubSubService.subscribe('fisActiveViewPanelChanged', function (data) {
	        fisMessageContainerUtilService.activePanel = data.currentNavItem;
	        var pathOfNewActivePanel = data.after;
	        if ($scope.isPathInCache(pathOfNewActivePanel)) {
	          var messageListForPath = $scope.findMessagesForPath(pathOfNewActivePanel);
	          $scope.displayMessage(messageListForPath.messages, messageListForPath.msgScope);
	        }
	      });
	      $scope.$on('$destroy', function () {
	        unsubscribe();
	        unsubscribePanelClosed();
	      });
	
	      $scope.messages = [];
	
	      $scope.$on('fisDisplayMessage', function (event, args, target) {
	        // need to look at the event here, to get the targetScope(the scope that the emit fired from)
	        // need to fire the messages event to the correct message container
	        if (_.isUndefined(target) && !_.isUndefined(event.targetScope.fisMessageContainerId)) {
	          // this target only applies to messages meant to show on top of the dialog (not the form fields)
	          var messageTarget = event.targetScope.fisMessageContainerId;
	          for (var i = 0; i < args.length; i++) {
	            var argToCheck = args[i];
	            if (!argToCheck.property) {
	              // only add this to non property objects
	              argToCheck.target = messageTarget;
	            }
	            argToCheck = undefined;
	          }
	        }
	        $scope.displayMessage(args, target);
	        if (event.stopPropagation) {
	          event.stopPropagation();
	        }
	      });
	
	      $scope.registerFieldMessage = fisMessageContainerUtilService.registerFieldMessage;
	
	      $scope.unregisterFieldMessage = fisMessageContainerUtilService.unregisterFieldMessage;
	
	      $scope.displayMessage = fisMessageContainerUtilService.displayMessage;
	
	      $scope.dismissMessages = fisMessageContainerUtilService.dismissMessages;
	
	      $scope.clearMessages = fisMessageContainerUtilService.clearMessages;
	    }]
	
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 8)))

/***/ }),
/* 109 */
/*!************************************!*\
  !*** ./directives/offset/index.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _offset = __webpack_require__(/*! ./offset.directive */ 110);
	
	var _offset2 = _interopRequireDefault(_offset);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.offset', []);
	
	[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].forEach(function (column) {
	  ngModule.directive('fisOffset' + column, (0, _offset2.default)(column));
	});
	
	exports.default = ngModule.name;

/***/ }),
/* 110 */
/*!***********************************************!*\
  !*** ./directives/offset/offset.directive.js ***!
  \***********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (val) {
	  return function () {
	    'ngInject';
	
	    return {
	      restrict: 'C',
	      link: function link(scope, element) {
	        element.addClass('col-md-offset-' + val);
	      }
	    };
	  };
	};

/***/ }),
/* 111 */
/*!*************************************!*\
  !*** ./directives/primary/index.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _primary = __webpack_require__(/*! ./primary.directive */ 112);
	
	var _primary2 = _interopRequireDefault(_primary);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.primary', []);
	
	ngModule.directive('fisPrimary', _primary2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 112 */
/*!*************************************************!*\
  !*** ./directives/primary/primary.directive.js ***!
  \*************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisUniqueIdService", function (fisUniqueIdService) {
	  'ngInject';
	
	  return {
	    restrict: 'AC',
	    link: function link(scope, element, attrs) {
	      // TODO: could be reused for other elements than a button eventually.
	      fisUniqueIdService.generateUniqueId(scope, element, attrs);
	      element.addClass('btn btn-primary fis-primary');
	      element.attr('role', 'button');
	    }
	  };
	}];

/***/ }),
/* 113 */
/*!****************************************!*\
  !*** ./directives/scrollable/index.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _scrollable = __webpack_require__(/*! ./scrollable.directive */ 114);
	
	var _scrollable2 = _interopRequireDefault(_scrollable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.scrollable', []);
	
	ngModule.directive('fisScrollable', _scrollable2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 114 */
/*!*******************************************************!*\
  !*** ./directives/scrollable/scrollable.directive.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    link: function link(scope, element, attrs) {
	      attrs.$observe('fisScrollable', function (value) {
	        switch (value) {
	          case 'x':
	            element.css('overflow', '');
	            element.css('overflow-x', 'auto');
	            break;
	          case 'y':
	            element.css('overflow', '');
	            element.css('overflow-y', 'auto');
	            break;
	          case 'false':
	            element.css('overflow', '');
	            element.css('overflow-x', '');
	            element.css('overflow-y', '');
	            break;
	          default:
	            // sets both x & y
	            element.css('overflow', 'auto');
	        }
	      });
	    }
	  };
	};

/***/ }),
/* 115 */
/*!***************************************!*\
  !*** ./directives/secondary/index.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _secondary = __webpack_require__(/*! ./secondary.directive */ 116);
	
	var _secondary2 = _interopRequireDefault(_secondary);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.secondary', []);
	
	ngModule.directive('fisSecondary', _secondary2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 116 */
/*!*****************************************************!*\
  !*** ./directives/secondary/secondary.directive.js ***!
  \*****************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisUniqueIdService", function (fisUniqueIdService) {
	  'ngInject';
	
	  return {
	    restrict: 'AC',
	    link: function link(scope, element, attrs) {
	      fisUniqueIdService.generateUniqueId(scope, element, attrs);
	      element.addClass('btn fis-secondary');
	      element.attr('role', 'button');
	    }
	  };
	}];

/***/ }),
/* 117 */
/*!**********************************!*\
  !*** ./directives/span/index.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _span = __webpack_require__(/*! ./span.directive */ 118);
	
	var _span2 = _interopRequireDefault(_span);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.span', []);
	
	[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].forEach(function (column) {
	  ngModule.directive('fisSpan' + column, (0, _span2.default)(column));
	});
	
	exports.default = ngModule.name;

/***/ }),
/* 118 */
/*!*******************************************!*\
  !*** ./directives/span/span.directive.js ***!
  \*******************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (val) {
	  return function () {
	    // fis.angular.module('fis.widgets').directive('fisSpan' + val, [function () {
	    return {
	      restrict: 'C',
	      link: function link(scope, element) {
	        element.addClass('col-sm-' + val);
	      }
	    };
	  };
	};

/***/ }),
/* 119 */
/*!**************************************!*\
  !*** ./directives/tab-data/index.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _tabData = __webpack_require__(/*! ./tab-data.directive */ 120);
	
	var _tabData2 = _interopRequireDefault(_tabData);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.tab-data', []);
	
	ngModule.directive('fisTabData', _tabData2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 120 */
/*!***************************************************!*\
  !*** ./directives/tab-data/tab-data.directive.js ***!
  \***************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    restrict: 'C',
	    scope: true
	  };
	};

/***/ }),
/* 121 */
/*!**************************************!*\
  !*** ./directives/tertiary/index.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _tertiary = __webpack_require__(/*! ./tertiary.directive */ 122);
	
	var _tertiary2 = _interopRequireDefault(_tertiary);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.tertiary', []);
	
	ngModule.directive('fisTertiary', _tertiary2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 122 */
/*!***************************************************!*\
  !*** ./directives/tertiary/tertiary.directive.js ***!
  \***************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisUniqueIdService", function (fisUniqueIdService) {
	  'ngInject';
	
	  return {
	    restrict: 'AC',
	    link: function link(scope, element, attrs) {
	      fisUniqueIdService.generateUniqueId(scope, element, attrs);
	      element.addClass('btn btn-link fis-tertiary');
	      element.attr('role', 'button');
	    }
	  };
	}];

/***/ }),
/* 123 */
/*!*************************************!*\
  !*** ./directives/visible/index.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _visible = __webpack_require__(/*! ./visible.directive */ 124);
	
	var _visible2 = _interopRequireDefault(_visible);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.directives.visible', []);
	
	ngModule.directive('fisVisible', _visible2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 124 */
/*!*************************************************!*\
  !*** ./directives/visible/visible.directive.js ***!
  \*************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return function (scope, element, attr) {
	    scope.$watch(attr.fisVisible, function (visible) {
	      element.css('visibility', visible ? 'visible' : 'hidden');
	    });
	  };
	};

/***/ }),
/* 125 */
/*!**************************!*\
  !*** ./filters/index.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _htmlQuotes = __webpack_require__(/*! ./html-quotes.filter */ 126);
	
	var _htmlQuotes2 = _interopRequireDefault(_htmlQuotes);
	
	var _obfuscate = __webpack_require__(/*! ./obfuscate.filter */ 127);
	
	var _obfuscate2 = _interopRequireDefault(_obfuscate);
	
	var _stripHtml = __webpack_require__(/*! ./strip-html.filter */ 128);
	
	var _stripHtml2 = _interopRequireDefault(_stripHtml);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.filters', []);
	
	ngModule.filter('htmlQuotes', _htmlQuotes2.default);
	ngModule.filter('obfuscate', _obfuscate2.default);
	ngModule.filter('stripHtml', _stripHtml2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 126 */
/*!***************************************!*\
  !*** ./filters/html-quotes.filter.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return function (input) {
	    return !_.isUndefined(input) && input !== null ? input.replace(/"/g, '&quot;') : input;
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 8)))

/***/ }),
/* 127 */
/*!*************************************!*\
  !*** ./filters/obfuscate.filter.js ***!
  \*************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return function (text) {
	    if (text) {
	      return '********';
	    }
	    return '';
	  };
	};

/***/ }),
/* 128 */
/*!**************************************!*\
  !*** ./filters/strip-html.filter.js ***!
  \**************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return function (input) {
	    var tagBody = '(?:[^"\'>]|"[^"]*"|\'[^\']*\')*';
	    var tagOrComment = new RegExp('<(?:' +
	    // Comment body.
	    '!--(?:(?:-*[^->])*--+|-?)' +
	    // Special "raw text" elements whose content should be elided.
	    '|script\\b' + tagBody + '>[\\s\\S]*?</script\\s*' + '|style\\b' + tagBody + '>[\\s\\S]*?</style\\s*' +
	    // Regular name
	    '|/?[a-z]' + tagBody + ')>', 'gi');
	
	    if (input) {
	      return input.replace(tagOrComment, '').replace(/</g, '&lt;');
	    }
	    return '';
	  };
	};

/***/ }),
/* 129 */
/*!***************************!*\
  !*** ./services/index.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _fixedMenuService = __webpack_require__(/*! ./fixed-menu-service.provider */ 130);
	
	var _fixedMenuService2 = _interopRequireDefault(_fixedMenuService);
	
	var _infoPanelConfigService = __webpack_require__(/*! ./info-panel-config-service.provider */ 131);
	
	var _infoPanelConfigService2 = _interopRequireDefault(_infoPanelConfigService);
	
	var _quickActionsService = __webpack_require__(/*! ./quick-actions-service.provider */ 132);
	
	var _quickActionsService2 = _interopRequireDefault(_quickActionsService);
	
	var _sortService = __webpack_require__(/*! ./sort-service.provider */ 133);
	
	var _sortService2 = _interopRequireDefault(_sortService);
	
	var _messageContainerUtilService = __webpack_require__(/*! ./message-container-util-service.provider */ 134);
	
	var _messageContainerUtilService2 = _interopRequireDefault(_messageContainerUtilService);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.services', []);
	
	ngModule.provider('fisFixedMenuService', _fixedMenuService2.default);
	ngModule.provider('fisInfoPanelConfigService', _infoPanelConfigService2.default);
	ngModule.provider('fisQuickActionsService', _quickActionsService2.default);
	ngModule.provider('fisSortService', _sortService2.default);
	ngModule.provider('fisMessageContainerUtilService', _messageContainerUtilService2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 130 */
/*!*************************************************!*\
  !*** ./services/fixed-menu-service.provider.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var self = this;
	
	  self.fixedMenuConfig = {};
	  self.name = '';
	  self.registeredMenus = {};
	
	  self.$get = [function () {
	    var service = {};
	
	    // See: http://stackoverflow.com/questions/442404/dynamically-retrieve-the-position-x-y-of-an-html-element
	    // we allow users to adjust the offset specifically incase its slightly off
	    var getElementOffset = function getElementOffset(element, offsetX, offsetY) {
	      var _x = isNaN(offsetX) === false ? offsetX : 0;
	      var _y = isNaN(offsetY) === false ? offsetY : 0;
	      // we choose between two different options here, the new or old way
	      if (element.getBoundingClientRect) {
	        // if this native function exists, we will use this instead
	        var boundingRect = element.getBoundingClientRect();
	        // for backwards compatibility, we have to check for left and x
	        var left = boundingRect.left || boundingRect.x || 0;
	        var top = boundingRect.top || boundingRect.y || 0;
	        _x += left + boundingRect.width;
	        _y += top + boundingRect.height;
	      } else {
	        // legacy way of calculating, that works for older browsers like IE 8
	        while (!_underscore2.default.isUndefined(element) && !_underscore2.default.isNull(element)) {
	          var offsetTop = element.offsetTop;
	          var offsetLeft = element.offsetLeft;
	          if (_underscore2.default.isNaN(offsetLeft) || _underscore2.default.isUndefined(offsetLeft)) {
	            offsetLeft = 0;
	          }
	          if (_underscore2.default.isNaN(offsetTop) || _underscore2.default.isUndefined(offsetTop)) {
	            offsetTop = 0;
	          }
	          _x += offsetLeft - element.scrollLeft;
	          _y += offsetTop - element.scrollTop;
	          element = element.offsetParent;
	        }
	      }
	      return { top: _y, left: _x };
	    };
	
	    service.register = function (name, cb) {
	      self.name = name;
	      self.callBackFn = cb;
	      self.registeredMenus[name] = cb;
	    };
	
	    /**
	     * method to openMenu using a configObject
	     * @param {Object} configObj    Object to be used in configuring the fisFixedMenu
	     */
	    service.openMenu = function (configObj) {
	      configObj.position = getElementOffset(configObj.event.target, configObj.offsetX, configObj.offsetY);
	
	      if (self.registeredMenus[configObj.name]) {
	        self.registeredMenus[configObj.name](configObj); // calling the callBack function
	      }
	    };
	
	    return service;
	  }];
	};
	
	var _underscore = __webpack_require__(/*! underscore */ 8);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 131 */
/*!********************************************************!*\
  !*** ./services/info-panel-config-service.provider.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  /**
	   * @private
	   */
	
	  var self = this;
	
	  /**
	   * @name $get
	   * @methodOf fisInfoPanelService
	   * @description <p>Factory method to create instance of fisInfoPanelService.</p>
	   */
	  self.$get = ['fisConfig', function (fisConfig) {
	    var service = {}; // to be returned
	
	    // Default values
	    service.fisInfoPanel = {};
	    service.fisInfoPanel.animation = {};
	    service.fisInfoPanel.animation.timeout = {};
	    service.fisInfoPanel.animation.timeout.info = 10000;
	    service.fisInfoPanel.animation.timeout.success = 10000;
	    service.fisInfoPanel.animation.timeout.warning = 10000;
	    service.fisInfoPanel.animation.timeout.error = 10000;
	
	    // Not all may be in config file - check and set values one at a time
	    if (fisConfig && fisConfig.widgets && fisConfig.widgets.fisInfoPanel && fisConfig.widgets.fisInfoPanel.animation && fisConfig.widgets.fisInfoPanel.animation.timeout) {
	      if (fisConfig.widgets.fisInfoPanel.animation.timeout.info) {
	        service.fisInfoPanel.animation.timeout.info = fisConfig.widgets.fisInfoPanel.animation.timeout.info;
	      }
	      if (fisConfig.widgets.fisInfoPanel.animation.timeout.success) {
	        service.fisInfoPanel.animation.timeout.success = fisConfig.widgets.fisInfoPanel.animation.timeout.success;
	      }
	      if (fisConfig.widgets.fisInfoPanel.animation.timeout.warning) {
	        service.fisInfoPanel.animation.timeout.warning = fisConfig.widgets.fisInfoPanel.animation.timeout.warning;
	      }
	      if (fisConfig.widgets.fisInfoPanel.animation.timeout.error) {
	        service.fisInfoPanel.animation.timeout.error = fisConfig.widgets.fisInfoPanel.animation.timeout.error;
	      }
	    }
	
	    /**
	    * @method
	    * @methodOf fisInfoPanelService
	    * @description Returns an object that contains all the timeout values.
	    */
	    service.getAnimationTimeout = function () {
	      return service.fisInfoPanel;
	    };
	
	    /**
	     * @method
	     * @methodOf fisInfoPanelService
	     * @description Stes different timeout values.
	     */
	    service.setAnimationTimeout = function (timeout) {
	      if (timeout) {
	        if (!_.isUndefined(timeout.error)) {
	          service.fisInfoPanel.animation.timeout.error = timeout.error;
	        }
	        if (!_.isUndefined(timeout.warning)) {
	          service.fisInfoPanel.animation.timeout.warning = timeout.warning;
	        }
	        if (!_.isUndefined(timeout.success)) {
	          service.fisInfoPanel.animation.timeout.success = timeout.success;
	        }
	        if (!_.isUndefined(timeout.info)) {
	          service.fisInfoPanel.animation.timeout.info = timeout.info;
	        }
	      }
	    };
	
	    return service;
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 8)))

/***/ }),
/* 132 */
/*!****************************************************!*\
  !*** ./services/quick-actions-service.provider.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  /**
	   * @private
	   */
	
	  var self = this;
	
	  /**
	   * @name $get
	   * @methodOf fisQuickActionsServiceProvider
	   * @description
	   * <p>Factory method to create instance of fisQuickActionsService.</p>
	   */
	  self.$get = [function () {
	    /**
	     * @private
	     */
	    var service = {}; // to be returned
	
	    service.openQuickActionMenu = function (menuElement, chevronElement, nodeId) {
	      var previousOpenMenu = angular.element.find('div.qactions-show')[0];
	      var previousChevron = angular.element.find('span.icon-chevron-down.show')[0];
	      if (previousOpenMenu) {
	        angular.element(previousOpenMenu).removeClass('qactions-show');
	        angular.element(previousOpenMenu).addClass('qactions-hide');
	        angular.element(previousChevron).removeClass('show');
	      }
	
	      menuElement.attr('style', '');
	      menuElement.find('.dropdown-menu').attr('style', '');
	      menuElement.find('.dropdown-menu').attr('role', 'menu');
	      menuElement.find('.dropdown-menu > li').attr({ role: 'menuitem', tabindex: '0' });
	      menuElement.attr('qaid', nodeId);
	      menuElement.removeClass('qactions-hide');
	      menuElement.addClass('qactions-show');
	
	      // Calculate viewport dimension
	      var viewPortDim = getViewPortDimension();
	      // Calculate chevronElement position on screen
	      var absoluteOffset = getElementOffset(chevronElement[0]); // eslint-disable-line
	      var relativeOffset = chevronElement.position();
	      // Set display properties like left, right, top, z-index
	      var elemProperties = {};
	      var listProperties = {};
	
	      elemProperties['z-index'] = 5000;
	      listProperties['z-index'] = 5000;
	
	      if (viewPortDim.width - absoluteOffset.left < 160) {
	        // 160px is quick-action menu min-width
	        elemProperties.left = relativeOffset.left - 170;
	      } else {
	        elemProperties.left = relativeOffset.left - 10;
	      }
	      // check for container fluid scroll-position and adjust top position accordingly
	      var containerFluid = angular.element(document).find('.fis-content-wrapper');
	      var offsets = containerFluid.offset();
	      if (offsets && offsets.top < 0) {
	        elemProperties.top = relativeOffset.top - offsets.top + 100; // 100px is default top offset of container fluid
	      } else {
	        elemProperties.top = relativeOffset.top + 10;
	      }
	
	      var menuElementHeight = parseInt(menuElement.find('.dropdown-menu').height(), 10);
	      if (viewPortDim.height - absoluteOffset.top < menuElementHeight + 80) {
	        // 80px fis-footer height
	        listProperties.top = -(menuElementHeight + 10);
	      }
	      menuElement.css(elemProperties);
	      menuElement.find('.dropdown-menu').css(listProperties);
	    };
	
	    service.openQuickActionMenuOnBody = function (menuElement, chevronElement, nodeId) {
	      menuElement.attr('qaid', nodeId);
	      chevronElement.addClass('show');
	
	      var mOffset = chevronElement.offset();
	      var properties = {};
	      properties['z-index'] = 5000;
	      properties.left = mOffset.left;
	      properties.top = mOffset.top;
	
	      menuElement.removeClass('qactions-hide');
	      menuElement.addClass('qactions-show');
	      menuElement.appendTo('body');
	      menuElement.css(properties);
	    };
	
	    service.registerClickHandlers = function (menuElement, chevronElement) {
	      // Register a click handler that closes the quick actions menu when the user clicks somewhere outside of it
	      angular.element('html').bind('click.quickactions', function (event) {
	        var eventClass = angular.element(event.target).attr('class');
	        // The handler is already registered when the user clicks first on the chevron - hence we need to keep it open
	        // when the clicked target was the arrow or a menu item. The menu itself takes care that the menu disappears
	        // when a menu item was selected.
	        if (_underscore2.default.isUndefined(eventClass) || eventClass && eventClass.indexOf('qactions-target') < 0 && eventClass.indexOf('quickActionMenuItem') < 0 && menuElement.attr('class').indexOf('qactions-show') > 0) {
	          service.closeQuickActionMenu(menuElement, chevronElement);
	        }
	      });
	    };
	
	    service.unregisterClickHandlers = function () {
	      angular.element('html').unbind('click.quickactions');
	    };
	
	    service.closeQuickActionMenu = function (menuElement, chevronElement) {
	      menuElement.attr('qaid', '');
	      menuElement.removeClass('qactions-show');
	      menuElement.addClass('qactions-hide');
	      if (!_underscore2.default.isUndefined(chevronElement)) {
	        chevronElement.removeClass('show');
	      }
	
	      service.unregisterClickHandlers();
	    };
	
	    service.addQuickActionMenu = function (compile, scope, referencedElement, fisQuickActionDataAttribute) {
	      if (!_underscore2.default.isUndefined(fisQuickActionDataAttribute && fisQuickActionDataAttribute > 0)) {
	        var seedId = '';
	        if (!_underscore2.default.isUndefined(referencedElement.attr('fis-id'))) {
	          seedId = ' fis-seed="' + referencedElement.attr('fis-id') + '" ';
	        }
	        var quickActionMenu = '<div fis-quick-actions ' + seedId + 'fis-data="' + fisQuickActionDataAttribute + '" ' + ' class="quickActionsMenu qactions-hide" ' + ' ng-mouseleave="closeQuickActions()"></div>';
	
	        var compiledMenu = compile(quickActionMenu)(scope);
	
	        referencedElement.after(compiledMenu);
	
	        return compiledMenu;
	      }
	    };
	
	    function getViewPortDimension() {
	      var w = window;
	      var d = document;
	      var e = d.documentElement;
	      var g = d.getElementsByTagName('body')[0];
	      var x = w.innerWidth || e.clientWidth || g.clientWidth;
	      var y = w.innerHeight || e.clientHeight || g.clientHeight;
	
	      return { width: x, height: y };
	    }
	
	    // See: http://stackoverflow.com/questions/442404/dynamically-retrieve-the-position-x-y-of-an-html-element
	    var getElementOffset = function getElementOffset(element) {
	      var _x = 0;
	      var _y = 0;
	
	      while (!_underscore2.default.isUndefined(element) && !_underscore2.default.isNull(element) && !_underscore2.default.isNaN(element.offsetLeft) && !_underscore2.default.isNaN(element.offsetTop)) {
	        _x += element.offsetLeft - element.scrollLeft;
	        _y += element.offsetTop - element.scrollTop;
	        element = element.offsetParent;
	      }
	      return { top: _y, left: _x };
	    };
	
	    return service;
	  }];
	};
	
	var _underscore = __webpack_require__(/*! underscore */ 8);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 133 */
/*!*******************************************!*\
  !*** ./services/sort-service.provider.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var self = this;
	
	  self.sortCaseSensitive = true; // default value
	
	  /**
	   * The items are returned/displayed in the same order as received from the server
	   * @param list
	   * @returns {*}
	   */
	  var naturalSort = function naturalSort(list) {
	    return list;
	  };
	
	  /**
	   * Compare function as required for Array.sort
	   * @param a
	   * @param b
	   * @returns {number}
	   */
	  function compare(a, b) {
	    var x;
	    var y;
	    var t;
	    var d;
	
	    if (a.label && b.label) {
	      x = a.label;
	      y = b.label;
	    } else {
	      x = a;
	      y = b;
	    }
	    // Case insensitive
	    if (!self.sortCaseSensitive) {
	      t = x.toLowerCase();
	      d = y.toLowerCase();
	      if (!(t === d)) {
	        // if the objects are the same we want to maintain case sensitive sorting
	        x = t;
	        y = d;
	      }
	    }
	    return x > y ? 1 : x < y ? -1 : 0; // eslint-disable-line
	  }
	
	  /**
	   * Sort the items in alphabetical order, ascending
	   * if list of object, object will sorted on label if label property present
	   * else default sort
	   * @param list
	   * @returns {*}
	   */
	  var alphabeticalAsc = function alphabeticalAsc(list, fisSortCaseSensitive) {
	    if (isLableSortable(list)) {
	      // eslint-disable-line
	      self.sortCaseSensitive = fisSortCaseSensitive;
	      list.sort(compare);
	    } else {
	      list.sort();
	    }
	    return list;
	  };
	
	  /**
	   * Sort the items in alphabetical order, descending
	   * if list of object, object will sorted on label if label property present
	   * else default sort
	   * @param list
	   * @returns {*}
	   */
	  var alphabeticalDesc = function alphabeticalDesc(list, fisSortCaseSensitive) {
	    if (isLableSortable(list)) {
	      // eslint-disable-line
	      self.sortCaseSensitive = fisSortCaseSensitive;
	      list.sort(compare);
	    } else {
	      list.sort();
	    }
	    list.reverse();
	    return list;
	  };
	
	  /**
	   * Same as natural, but when moving items between left and right, the moved items are placed at the top of the target list.
	   * @param list
	   * @param listItem
	   * @returns {*}
	   */
	  var addTop = function addTop(list, fisSortCaseSensitive, listItem) {
	    list.unshift(listItem);
	    return list;
	  };
	
	  /**
	   * Same as natural, but when moving item between left and right, the moved items are placed at the bottom of the target list.
	   * @param list
	   * @param listItem
	   * @returns {*}
	   */
	  var addBottom = function addBottom(list, fisSortCaseSensitive, listItem) {
	    list.push(listItem);
	    return list;
	  };
	
	  var sortStrategies = {
	    'natural': naturalSort,
	    'alphabetical-asc': alphabeticalAsc,
	    'alphabetical-desc': alphabeticalDesc,
	    'add-top': addTop,
	    'add-bottom': addBottom
	  };
	  /**
	   * Determine if list is sortable on label
	   * @param list
	   */
	  var isLableSortable = function isLableSortable(list) {
	    if (list.length > 0 && !_underscore2.default.isUndefined($(list[0]).prop('label'))) {
	      return true;
	    }
	    return false;
	  };
	
	  self.$get = ['fisConfig', function (fisConfig) {
	    if (fisConfig && fisConfig.widgets && fisConfig.widgets.fisListBuilder && fisConfig.widgets.fisListBuilder.sortCaseSensitive) {
	      self.sortCaseSensitive = fisConfig.widgets.fisListBuilder.sortCaseSensitive;
	    }
	
	    var service = {};
	    /**
	     *  sorts list on sortStrategy
	     * @param list of objects, objects will be sorted on label
	     * @param sortStrategy
	     * @returns {*}
	     */
	    service.sort = function (list, sortStrategy, fisSortCaseSensitive) {
	      if (_underscore2.default.isUndefined(fisSortCaseSensitive)) {
	        fisSortCaseSensitive = self.sortCaseSensitive;
	      }
	
	      var sortedList;
	      if (!_underscore2.default.isUndefined(sortStrategy) && !_underscore2.default.isUndefined(sortStrategies[sortStrategy])) {
	        sortedList = sortStrategies[sortStrategy](list, fisSortCaseSensitive);
	      } else {
	        sortedList = sortStrategies.natural(list, fisSortCaseSensitive);
	      }
	      return sortedList;
	    };
	
	    service.addItemToList = function (list, listItem, sortStrategy, fisSortCaseSensitive) {
	      var sortedList;
	      if (!_underscore2.default.isUndefined(sortStrategy) && !_underscore2.default.isUndefined(sortStrategies[sortStrategy]) && !_underscore2.default.isUndefined(listItem)) {
	        sortedList = sortStrategies[sortStrategy](list, fisSortCaseSensitive, listItem);
	      } else {
	        sortedList = sortStrategies['add-bottom'](list, fisSortCaseSensitive, listItem);
	      }
	      return sortedList;
	    };
	
	    return service;
	  }];
	};
	
	var _underscore = __webpack_require__(/*! underscore */ 8);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 134 */
/*!*************************************************************!*\
  !*** ./services/message-container-util-service.provider.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                                               * @class
	                                                                                                                                                                                                                                                                               * @name fisMessageContainerUtilService
	                                                                                                                                                                                                                                                                               * @description fisMessageContainerUtilService will be used for providing utility functions which were earlier available
	                                                                                                                                                                                                                                                                               * on scope of fisMessageContainer directive, i.e. $scope.displayMessage, $scope.clearMessages etc.
	                                                                                                                                                                                                                                                                               * @memberOf fis.core
	                                                                                                                                                                                                                                                                               */
	
	
	exports.default = function () {
	  var self = this;
	
	  self.$get = ['fisI18nService', '$filter', 'fisViewPanelService', '$window', function (fisI18nService, $filter, fisViewPanelService, $window) {
	    var service = {};
	
	    var interpolate = $filter('interpolate');
	
	    function normalizeMessage(def) {
	      var ret = def;
	      if ((typeof def === 'undefined' ? 'undefined' : _typeof(def)) === 'object' && Object.keys(def).length === 0) {
	        return;
	      }
	      if (!def.messages) {
	        if (def.msg || def.message) {
	          ret = {
	            messages: [def]
	          };
	        } else if (typeof def === 'string') {
	          ret = {
	            messages: [{
	              msg: def,
	              type: 'error'
	            }]
	          };
	        } else if (angular.isArray(def)) {
	          ret = {
	            messages: def
	          };
	        } else {
	          throw new Error('Cant understand messages');
	        }
	      }
	      angular.forEach(ret.messages, function (message, key) {
	        if (angular.isString(message)) {
	          ret.messages[key] = {
	            msg: message
	          };
	          message = ret.messages[key];
	        }
	        if (!message.code && !message.msg && !message.message) {
	          throw new Error('Message cant be shown as it doesnt contain msg or code.');
	        }
	        if (!message.type) {
	          message.type = 'error';
	        }
	      });
	      return ret;
	    }
	
	    service.activePanel = {};
	    var localScope;
	
	    // Each time a message is displayed - it is added to the messageCache - only if not already there
	    service.addMessageToCache = function (msg, msgScope) {
	      if (msgScope) {
	        service.messageScope = msgScope;
	      }
	      // Add message if not in cache
	      if (!service.isMessageInCache(msg)) {
	        var activePanel = service.activePanel;
	        if (service.isActivePanelPathInCache()) {
	          if (!service.isMessageInCache(msg)) {
	            var messageListForPath = service.findMessagesForPath(activePanel.path);
	            // add new message for path
	            messageListForPath.messages.push(msg);
	          }
	        } else {
	          // add message for new path
	          service.messageScope.messageCache.push({ path: activePanel.path, messages: [msg], msgScope: msgScope });
	        }
	      }
	    };
	
	    service.removeMessageFromCacheForPath = function (path) {
	      for (var i in service.messageScope.messageCache) {
	        if (service.messageScope.messageCache[i].path === path) {
	          service.messageScope.messageCache.splice(i, 1);
	        }
	      }
	    };
	
	    service.displayMessageOnPanel = function () {
	      if (!service.isActivePanelPathInCache()) {
	        return true; // Hide
	      }
	      return false; // Show
	    };
	
	    // This method checks to see if there is anything to display
	    service.isActivePanelPathInCache = function () {
	      for (var i in service.messageScope.messageCache) {
	        if (service.messageScope.messageCache[i].path === service.activePanel.path) {
	          return true;
	        }
	      }
	      return false;
	    };
	
	    service.isMessageInCache = function (msg) {
	      for (var i in service.messageScope.messageCache) {
	        // eslint-disable-line
	        var messageListForPath = service.messageScope.messageCache[i].messages;
	        for (var j in messageListForPath) {
	          if (messageListForPath[j].msg === msg.msg) {
	            return true;
	          }
	        }
	      }
	      return false;
	    };
	
	    // path is used to unique identifier for any message (connection ) - see it as a type of key, where the msg is the element
	    service.isPathInCache = function (path) {
	      for (var i in service.messageScope.messageCache) {
	        if (service.messageScope.messageCache[i].path === path) {
	          return true;
	        }
	      }
	      return false;
	    };
	
	    service.findMessagesForPath = function (path) {
	      for (var i in service.messageScope.messageCache) {
	        if (service.messageScope.messageCache[i].path === path) {
	          return service.messageScope.messageCache[i];
	        }
	      }
	      return {};
	    };
	
	    /**
	     * @name fis.fisComponents:fisMessageContainer#message
	     * @description Property containing the messages for this container
	     */
	    service.fieldMessageMap = [];
	
	    /**
	     * @description Registers fieldMessageControllers so that it can forward to them to be displayed inline.
	     * @param {Object} fieldMessageCtrl An fisFieldMessage controller instance.
	     * @param properties
	     */
	    service.registerFieldMessage = function (fieldMessageCtrl, properties) {
	      var activePanel = fisViewPanelService.activeViewPanel();
	      if (activePanel && service.messageScope) {
	        service.messageScope.activePanel = activePanel;
	      }
	      angular.forEach(properties, function (prop) {
	        var fisFieldMessageCtrl = {};
	        fieldMessageCtrl.panelId = service.activePanel.id;
	        fisFieldMessageCtrl[prop] = fieldMessageCtrl;
	        service.fieldMessageMap.push(fisFieldMessageCtrl);
	      });
	    };
	
	    /**
	     * @description  Unregisters fisFieldMessage controller.
	     * @param {Object} fieldMessageCtrl An fisFieldMessage controller instance.
	     */
	    service.unregisterFieldMessage = function (fieldMessageCtrl, properties) {
	      angular.forEach(properties, function (prop) {
	        angular.forEach(service.fieldMessageMap, function (fisFieldMessage, index) {
	          if (fisFieldMessage[prop] === fieldMessageCtrl) {
	            service.fieldMessageMap.splice(index, 1);
	          }
	        });
	      });
	    };
	
	    function getMessageContainer(target) {
	      var msgContainer = jQuery.find('[fis-message-container][fis-name="' + target + '"]');
	      var prefix = $window.location.hash.substring(2).replace(/\//g, '_');
	      if (msgContainer.length === 0) {
	        msgContainer = jQuery.find('[fis-message-container][fis-name="' + prefix + '_' + target + '"]');
	      }
	      if (msgContainer.length === 0) {
	        msgContainer = jQuery.find('.fis-message-container [fis-name="' + target + '"]');
	      }
	      if (msgContainer.length === 0) {
	        msgContainer = jQuery.find('.fis-message-container [fis-name="' + prefix + '_' + target + '"]');
	      }
	      return msgContainer;
	    }
	
	    /**
	     * @name fis.fisComponents:fisMessageContainer#displayMessage
	     * @description  Allows setting the messages to be displayed to the user.
	     * @param def: {String|Object|Object[]} - If a string, the message is treated as an error message.
	     * @param params: {String| Object} - If a string, the name of message container on which the message is to be added/displayed.
	     *  If Object then the name of message container with css defination needs to apply on message conatiner(info panel)
	     * By using the object form, you can set multiple messages at a time and decide on the severity of the message.
	     */
	    service.displayMessage = function (def, params) {
	      var msgContainer;
	      var msg;
	      var i;
	      var messageScope = service.parentScope;
	
	      messageScope.infoPanelDef = {};
	      messageScope.infoPanelDef.isMessageShown = false;
	
	      if (params) {
	        if (angular.isString(params)) {
	          msgContainer = getMessageContainer(params);
	          if (msgContainer.length > 0) {
	            messageScope = angular.element(msgContainer[0]).scope();
	          }
	        } else if (angular.isObject(params)) {
	          if (params.$id) {
	            messageScope = params;
	          }
	          if (angular.isString(params.target)) {
	            msgContainer = getMessageContainer(params.target);
	            if (msgContainer.length > 0) {
	              messageScope = angular.element(msgContainer[0]).scope();
	            }
	          }
	          if (angular.isObject(params.infoPanelDef)) {
	            messageScope.infoPanelDef = params.infoPanelDef;
	            messageScope.infoPanelDef.response = def;
	          }
	        }
	      }
	
	      messageScope.clearMessages();
	      def = normalizeMessage(angular.copy(def));
	      if (!_.isUndefined(def) && !_.isUndefined(def.messages)) {
	        // clear any messages on internal objects here
	        for (i = 0; i < def.messages.length; i++) {
	          msg = def.messages[i];
	          if (msg && msg.target) {
	            if (angular.isString(msg.target)) {
	              msgContainer = getMessageContainer(msg.target);
	              if (msgContainer.length > 0) {
	                angular.element(msgContainer[0]).scope().clearMessages();
	              }
	            }
	          }
	        }
	        for (i = 0; i < def.messages.length; i++) {
	          msg = def.messages[i];
	          if (msg.msg) {
	            msg.msg = msg.code && fisI18nService.translate(msg.code, msg.msg) || msg.msg;
	          } else if (msg.message) {
	            msg.message = msg.code && fisI18nService.translate(msg.code, msg.message) || msg.message;
	          }
	          if (!msg.property) {
	            // eslint-disable-line
	            if (msg.target) {
	              // there is a target specified, use the targets scope instead
	              msgContainer = getMessageContainer(msg.target);
	              if (msgContainer.length > 0) {
	                localScope = angular.element(msgContainer[0]).scope();
	                // we might have a new containers scope here, we need to recreate the infoPanelDef object
	                if (_.isUndefined(localScope.infoPanelDef)) {
	                  localScope.infoPanelDef = {};
	                }
	                localScope.infoPanelDef.isMessageShown = false;
	                localScope.messages.push(msg);
	                service.addMessageToCache(msg, localScope);
	              }
	            } else {
	              if (_.isUndefined(messageScope.infoPanelDef)) {
	                messageScope.infoPanelDef = {};
	              }
	              messageScope.infoPanelDef.isMessageShown = false;
	
	              // global message
	              messageScope.messages.push(msg);
	              messageScope.addMessageToCache(msg, messageScope);
	            }
	          } else {
	            // distribute errors to form fields
	            if (msg.msg) {
	              msg.msg = interpolate(msg.msg, fisI18nService.translate(msg.property, msg.property));
	            } else if (msg.message) {
	              msg.message = interpolate(msg.message, fisI18nService.translate(msg.property, msg.property));
	            }
	            // the field message map being used is on the main scope of the page
	            if (msg.code && service.fieldMessageMap.length !== 0) {
	              // we have a error code and we know of a fieldMessageCtrl with that property
	              // send the message to the field message that handles this property
	              var messagePropertyFound = false;
	              angular.forEach(service.fieldMessageMap, function (fisFieldMessage) {
	                // eslint-disable-line
	                if (fisFieldMessage[msg.property] && fisFieldMessage[msg.property].panelId === service.activePanel.id) {
	                  // SDHTML-12552 Form Validation fails when ng-repeat is used to display fields
	                  // Here we check if msg has name property and if fisFieldMessage controller's
	                  // corresponding input element property fisName value matches msg.name, if so
	                  // we call the fisFieldMessage controller's addMessage function, so that the validation
	                  // message only gets appended to that particular input field and not to other input
	                  // fields with same property.
	                  // Basically in case of ng-repeat the property name gets repeated, so the validation
	                  // message gets appended to other input elements as well. So to fix this issue
	                  // we try and make every input element unique by giving it name attribute and using
	                  // $index of ng-repeat.
	                  if (msg.name && msg.name != '') {
	                    // eslint-disable-line
	                    if (fisFieldMessage[msg.property].inputs.fisName && fisFieldMessage[msg.property].inputs.fisName == msg.name) {
	                      // eslint-disable-line
	                      fisFieldMessage[msg.property].addMessage(msg);
	                      messagePropertyFound = true;
	                    }
	                  } else {
	                    fisFieldMessage[msg.property].addMessage(msg);
	                    messagePropertyFound = true;
	                  }
	                }
	              });
	              if (!messagePropertyFound) {
	                if (_.isUndefined(messageScope.infoPanelDef)) {
	                  messageScope.infoPanelDef = {};
	                }
	                messageScope.infoPanelDef.isMessageShown = false;
	                // we don't know the form field this belongs to or don't have a code for the error, display as a global message
	                messageScope.messages.push(msg);
	                messageScope.addMessageToCache(msg, messageScope);
	              }
	            } else {
	              if (_.isUndefined(messageScope.infoPanelDef)) {
	                messageScope.infoPanelDef = {};
	              }
	              messageScope.infoPanelDef.isMessageShown = false;
	              // we don't know the form field this belongs to or don't have a code for the error, display as a global message
	              messageScope.messages.push(msg);
	              service.addMessageToCache(msg, messageScope);
	            }
	          }
	        }
	      }
	    };
	
	    /**
	     * @name fis.fisComponents:fisMessageContainer#dismissMessages
	     * @description Invoking this will remove the non-field specific messages from the scope. The fis-info-panel directive
	     * uses this for its close button.
	     */
	    service.dismissMessages = function (target) {
	      var messageScope = service.messageScope;
	      if (target && angular.isString(target)) {
	        var msgContainer = getMessageContainer(target);
	        if (msgContainer.length > 0) {
	          messageScope = angular.element(msgContainer[0]).scope();
	        }
	      }
	      messageScope.messages = [];
	      service.parentScope.messages = [];
	      if (localScope) {
	        localScope.messages = [];
	      }
	      service.removeMessageFromCacheForPath(service.activePanel.path);
	    };
	    /**
	     * @name fis.fisComponents:fisMessageContainer#clearMessages
	     * @description Invoking this will remove all messages that were set by this directive, including the field errors.
	     */
	    service.clearMessages = function (target) {
	      var messageScope = service.messageScope;
	
	      if (target && angular.isString(target)) {
	        var msgContainer = getMessageContainer(target);
	        if (msgContainer.length > 0) {
	          messageScope = angular.element(msgContainer[0]).scope();
	        }
	      }
	      messageScope.dismissMessages();
	      angular.forEach(service.fieldMessageMap, function (fisFieldMessage) {
	        angular.forEach(fisFieldMessage, function (fieldMessageCtrl) {
	          fieldMessageCtrl.clearMessages();
	          fieldMessageCtrl.removeMessageClass();
	        });
	      });
	    };
	
	    return service;
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 8)))

/***/ }),
/* 135 */
/*!************************!*\
  !*** ./utils/index.js ***!
  \************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _crudTransitionsMixin = __webpack_require__(/*! ./crud-transitions-mixin.factory */ 136);
	
	var _crudTransitionsMixin2 = _interopRequireDefault(_crudTransitionsMixin);
	
	var _crudActionsMixin = __webpack_require__(/*! ./crud-actions-mixin.factory */ 137);
	
	var _crudActionsMixin2 = _interopRequireDefault(_crudActionsMixin);
	
	var _itemMixin = __webpack_require__(/*! ./item-mixin.factory */ 138);
	
	var _itemMixin2 = _interopRequireDefault(_itemMixin);
	
	var _listMixin = __webpack_require__(/*! ./list-mixin.factory */ 139);
	
	var _listMixin2 = _interopRequireDefault(_listMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.widgets.utils', []);
	
	ngModule.factory('fisCRUDTransitionsMixin', _crudTransitionsMixin2.default);
	ngModule.factory('fisCustomActionsMixin', _crudActionsMixin2.default);
	ngModule.factory('fisItemMixin', _itemMixin2.default);
	ngModule.factory('fisListMixin', _listMixin2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 136 */
/*!*************************************************!*\
  !*** ./utils/crud-transitions-mixin.factory.js ***!
  \*************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return function () {
	    this.STATES = {
	
	      NO_LIST: 0,
	      NO_ITEM: 1,
	      VIEW_PRISTINE: 2,
	      EDIT_PRISTINE: 3,
	      EDIT_DIRTY: 4,
	      EDIT_INVALID: 5
	
	    };
	
	    this.TRANSITIONS = {
	
	      FETCH_LIST: 0,
	      CREATE: 1,
	      SELECT_ITEM: 2,
	      SAVE: 3,
	      CANCEL_EDIT: 4,
	      CANCEL: 5,
	      EDIT: 6,
	      SOIL: 7,
	      CLEAN: 8,
	      RESET: 9,
	      REMOVE: 10,
	      INVALID: 11,
	      VALID: 12
	
	    };
	
	    this.dirtyFormNames = [];
	
	    this.setInitialState = function (initialState) {
	      this.initialState = initialState;
	    };
	
	    this.setCurrentState = function (currentState) {
	      this.currentState = currentState;
	    };
	
	    this.transitionTo = function (transitionName, args, displayDefaultMessage) {
	      switch (transitionName) {// eslint-disable-line
	
	        case this.TRANSITIONS.FETCH_LIST:
	
	          if (this.currentState === this.STATES.NO_LIST) {
	            this.onFetchList(args);
	            this.currentState = this.STATES.NO_ITEM;
	          }
	          break;
	
	        case this.TRANSITIONS.CREATE:
	
	          if (this.currentState === this.STATES.NO_ITEM || this.currentState === this.STATES.EDIT_PRISTINE || this.currentState === this.STATES.VIEW_PRISTINE || this.currentState === this.STATES.EDIT_INVALID) {
	            this.onCreate(args);
	            this.currentState = this.STATES.EDIT_PRISTINE;
	          }
	          break;
	
	        case this.TRANSITIONS.SELECT_ITEM:
	
	          if (this.currentState === this.STATES.NO_ITEM || this.currentState === this.STATES.EDIT_PRISTINE || this.currentState === this.STATES.VIEW_PRISTINE) {
	            this.onSelectItem(args);
	
	            if (args && args.editMode === true) {
	              this.currentState = this.STATES.EDIT_PRISTINE;
	            } else {
	              this.currentState = this.STATES.VIEW_PRISTINE;
	            }
	          }
	          break;
	
	        case this.TRANSITIONS.SAVE:
	
	          if (this.currentState !== this.STATES.EDIT_INVALID && (this.currentState === this.STATES.EDIT_DIRTY || this.currentState === this.STATES.EDIT_PRISTINE)) {
	            this.onSave(args, displayDefaultMessage);
	          }
	          break;
	
	        case this.TRANSITIONS.CANCEL_EDIT:
	
	          if (this.currentState === this.STATES.EDIT_PRISTINE || this.currentState === this.STATES.EDIT_DIRTY || this.currentState === this.STATES.EDIT_INVALID) {
	            this.onCancel(args);
	
	            if (args.editMode === true) {
	              this.currentState = this.STATES.NO_ITEM;
	            } else {
	              this.currentState = this.STATES.VIEW_PRISTINE;
	            }
	          }
	          break;
	
	        case this.TRANSITIONS.CANCEL:
	
	          if (this.currentState === this.STATES.VIEW_PRISTINE) {
	            this.currentState = this.STATES.NO_ITEM;
	          }
	          break;
	
	        case this.TRANSITIONS.EDIT:
	
	          if (this.currentState === this.STATES.NO_ITEM || this.currentState === this.STATES.VIEW_PRISTINE || this.currentState === this.STATES.EDIT_PRISTINE || this.currentState === this.STATES.EDIT_DIRTY) {
	            this.onSelectItem(args);
	            this.currentState = this.STATES.EDIT_PRISTINE;
	          }
	          break;
	
	        case this.TRANSITIONS.SOIL:
	
	          if (this.currentState === this.STATES.EDIT_PRISTINE) {
	            this.currentState = this.STATES.EDIT_DIRTY;
	          }
	          break;
	
	        case this.TRANSITIONS.CLEAN:
	
	          if (this.currentState === this.STATES.EDIT_DIRTY) {
	            this.currentState = this.STATES.EDIT_PRISTINE;
	          }
	          break;
	
	        case this.TRANSITIONS.RESET:
	
	          if (this.currentState === this.STATES.EDIT_DIRTY || this.currentState === this.STATES.EDIT_INVALID || this.currentState === this.STATES.EDIT_PRISTINE) {
	            this.onReset(args);
	            this.currentState = this.STATES.EDIT_PRISTINE;
	          }
	          break;
	
	        case this.TRANSITIONS.REMOVE:
	
	          if (this.currentState !== this.STATES.NO_LIST) {
	            this.onRemove(args, displayDefaultMessage);
	          }
	          break;
	
	        case this.TRANSITIONS.INVALID:
	
	          if (this.currentState === this.STATES.EDIT_DIRTY) {
	            this.currentState = this.STATES.EDIT_INVALID;
	          }
	          break;
	
	        case this.TRANSITIONS.VALID:
	
	          if (this.currentState === this.STATES.EDIT_INVALID) {
	            this.currentState = this.STATES.EDIT_DIRTY;
	          }
	          break;
	      }
	    };
	
	    this.setFormsToPristine = function () {
	      for (var i = 0; i < this.dirtyFormNames.length; i++) {
	        var form = this.$document.find('form[name="' + this.dirtyFormNames[i] + '"]');
	        form.scope()[this.dirtyFormNames[i]].$setPristine();
	      }
	    };
	
	    this.addToScope = function (scope) {
	      var self = this;
	
	      scope.isNoItem = function () {
	        return self.currentState === self.STATES.NO_ITEM;
	      };
	
	      scope.isViewPristine = function () {
	        return self.currentState === self.STATES.VIEW_PRISTINE;
	      };
	
	      scope.isEditPristine = function () {
	        return self.currentState === self.STATES.EDIT_PRISTINE;
	      };
	
	      scope.isEditDirty = function () {
	        return self.currentState === self.STATES.EDIT_DIRTY;
	      };
	
	      scope.isEdit = function () {
	        return self.currentState === self.STATES.EDIT_PRISTINE || self.currentState === self.STATES.EDIT_DIRTY || self.currentState === self.STATES.EDIT_INVALID;
	      };
	
	      scope.isInvalid = function () {
	        return self.currentState === self.STATES.EDIT_INVALID;
	      };
	
	      scope.$on('fisFormDirty', function (event, formName) {
	        self.transitionTo(self.TRANSITIONS.SOIL);
	        self.dirtyFormNames.push(formName);
	        event.stopPropagation();
	      });
	
	      scope.$on('fisFormClean', function (event, formName) {
	        self.transitionTo(self.TRANSITIONS.CLEAN);
	        self.dirtyFormNames.splice(self.dirtyFormNames.indexOf(formName));
	        event.stopPropagation();
	      });
	
	      scope.$on('fisFormInvalid', function (event) {
	        self.transitionTo(self.TRANSITIONS.INVALID);
	        event.stopPropagation();
	      });
	
	      scope.$on('fisFormValid', function (event) {
	        self.transitionTo(self.TRANSITIONS.VALID);
	        event.stopPropagation();
	      });
	    };
	
	    return this;
	  };
	};

/***/ }),
/* 137 */
/*!*********************************************!*\
  !*** ./utils/crud-actions-mixin.factory.js ***!
  \*********************************************/
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return function () {
	    this.customAction = function (action, params) {
	      // params is a object
	
	      var self = this;
	
	      this.itemResource[action](params, function () /* data*/{
	        self.$scope.items = self.findAll();
	      }, function (err) {
	        if (err.data) {
	          self.$scope.displayMessage(err.data.messages);
	        }
	      });
	    };
	    return this;
	  };
	};

/***/ }),
/* 138 */
/*!*************************************!*\
  !*** ./utils/item-mixin.factory.js ***!
  \*************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return function () {
	    this.create = function () {
	      return new this.itemResource(); // eslint-disable-line
	    };
	
	    this.save = function (item, newItem, successCB, failureCB) {
	      if (newItem) {
	        item.$save(successCB, failureCB);
	      } else {
	        item.$update(successCB, failureCB);
	      }
	    };
	
	    this.remove = function (id, successCB, failureCB) {
	      this.itemResource.remove({ id: id }, successCB, failureCB);
	    };
	
	    this.findByCriteria = function (object, successCB, failureCB) {
	      return this.itemResource.query(object, successCB, failureCB);
	    };
	
	    this.findOne = function (object, successCB, failureCB) {
	      return this.itemResource.get(object, successCB, failureCB);
	    };
	
	    return this;
	  };
	};

/***/ }),
/* 139 */
/*!*************************************!*\
  !*** ./utils/list-mixin.factory.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisPubSubService", function (fisPubSubService) {
	  'ngInject';
	
	  return function () {
	    this.selectItem = function (id) {
	      if (id) {
	        return this.findById(id);
	      }
	    };
	
	    this.findAll = function () {
	      return this.itemResource.query({}, function () /* args */{
	        fisPubSubService.publish('fisOpStateSet', {
	          opState: 'SUCCESS',
	          opName: 'FindAll'
	        });
	      }, function (args) {
	        this.$scope.displayMessage(args.data.messages);
	
	        fisPubSubService.publish('fisOpStateSet', {
	          opState: 'FAILURE',
	          opName: 'findAll',
	          opMessage: args.data.messages
	        });
	      });
	    };
	
	    this.findById = function (id) {
	      var item = null;
	      var idProp = this.args.paramDefaults && this.args.paramDefaults.id ? this.args.paramDefaults.id.substring(1) : 'id';
	
	      _underscore2.default.find(this.$scope.items, function (obj) {
	        if (obj[idProp] === id) {
	          item = obj;
	        }
	      });
	
	      // fetch the item from server if it is not found in scope.items
	      if (item === null) {
	        return this.itemResource.get({ id: id }, angular.noop, angular.noop);
	      }
	
	      fisPubSubService.publish('fisOpStateSet', {
	        opState: 'SUCCESS',
	        opName: 'FindById',
	        opObj: item
	      });
	
	      return item;
	    };
	
	    return this;
	  };
	}];
	
	var _underscore = __webpack_require__(/*! underscore */ 8);
	
	var _underscore2 = _interopRequireDefault(_underscore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ })
/******/ ]);
//# sourceMappingURL=fis-widgets.js.map;
/*!
 * 
 * @ruf/fis-shell
 * Version: 4.5.0
 * 
 * © 2018
 * Fidelity National Information Services, Inc. and/or its subsidiaries - All Rights Reserved worldwide.
 * This document is protected under the trade secret and copyright laws as the property of Fidelity National Information Services, Inc. and/or its subsidiaries.
 * Copying, reproduction or distribution should be limited and only to employees with a “need to know” to do their job. Any disclosure of this document to third parties is strictly prohibited.
 * 
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(/*! jquery */ 1);
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _angularResource = __webpack_require__(/*! angular-resource */ 3);
	
	var _angularResource2 = _interopRequireDefault(_angularResource);
	
	var _fisCoreComponents = __webpack_require__(/*! @ruf/fis-core-components */ 4);
	
	var _fisCoreComponents2 = _interopRequireDefault(_fisCoreComponents);
	
	var _services = __webpack_require__(/*! ./services */ 5);
	
	var _services2 = _interopRequireDefault(_services);
	
	var _controllers = __webpack_require__(/*! ./controllers */ 14);
	
	var _controllers2 = _interopRequireDefault(_controllers);
	
	var _components = __webpack_require__(/*! ./components */ 17);
	
	var _components2 = _interopRequireDefault(_components);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// loading jquery before angular
	var shellInit = _angular2.default.module('shell.init', []);
	shellInit.run(['$log', '$window', function ($log, $window) {
	  // execute here the code that needs to be executed before the app starts.
	  $log.log('Initializing shell.');
	
	  $window.onerror = function (message, url, line) {
	    $log.error(message, [url, line]);
	    return false;
	  };
	}]);
	
	var ngModule = _angular2.default.module('shell', [_angularResource2.default, _fisCoreComponents2.default, _controllers2.default, _components2.default, _services2.default, 'shell.init']);
	
	if (false) {
	  // eslint-disable-line
	  require('angular-mocks');
	  require('@ruf/fis-mocks');
	}
	
	exports.default = ngModule.name;

/***/ }),
/* 1 */
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ (function(module, exports) {

	module.exports = jQuery;

/***/ }),
/* 2 */
/*!**************************!*\
  !*** external "angular" ***!
  \**************************/
/***/ (function(module, exports) {

	module.exports = angular;

/***/ }),
/* 3 */
/*!*******************************!*\
  !*** external "'ngResource'" ***!
  \*******************************/
/***/ (function(module, exports) {

	module.exports = 'ngResource';

/***/ }),
/* 4 */
/*!*****************************!*\
  !*** external "'fis.core'" ***!
  \*****************************/
/***/ (function(module, exports) {

	module.exports = 'fis.core';

/***/ }),
/* 5 */
/*!***************************!*\
  !*** ./services/index.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _altMenu = __webpack_require__(/*! ./alt-menu.factory */ 6);
	
	var _altMenu2 = _interopRequireDefault(_altMenu);
	
	var _responsive = __webpack_require__(/*! ./responsive.service */ 8);
	
	var _responsive2 = _interopRequireDefault(_responsive);
	
	var _currentYear = __webpack_require__(/*! ./current-year.service */ 9);
	
	var _currentYear2 = _interopRequireDefault(_currentYear);
	
	var _sidebarState = __webpack_require__(/*! ./sidebar-state.service */ 10);
	
	var _sidebarState2 = _interopRequireDefault(_sidebarState);
	
	var _startMenu = __webpack_require__(/*! ./start-menu.service */ 11);
	
	var _startMenu2 = _interopRequireDefault(_startMenu);
	
	var _tabsbar = __webpack_require__(/*! ./tabsbar.service */ 12);
	
	var _tabsbar2 = _interopRequireDefault(_tabsbar);
	
	var _theme = __webpack_require__(/*! ./theme.service */ 13);
	
	var _theme2 = _interopRequireDefault(_theme);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.services', []);
	
	ngModule.factory('fisAltMenu', _altMenu2.default);
	ngModule.value('fisCurrentYearService', _currentYear2.default);
	ngModule.provider('fisResponsiveService', _responsive2.default);
	ngModule.provider('fisSidebarStateService', _sidebarState2.default);
	ngModule.provider('fisStartMenuService', _startMenu2.default);
	ngModule.provider('fisTabsBarService', _tabsbar2.default);
	ngModule.provider('fisThemeService', _theme2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 6 */
/*!**************************************!*\
  !*** ./services/alt-menu.factory.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisNavigationService", "$compile", "$controller", function (fisNavigationService, $compile, $controller) {
	  'ngInject';
	
	  var fisAltMenuFactory = {};
	  var altMenu;
	  var navPromise = fisNavigationService.getNavigation();
	
	  navPromise.then(function (nav) {
	    altMenu = nav.altMenu;
	  }, function (reason) {
	    console.warn('Loading Navigation for alt menu failed: ' + reason);
	  }, function (update) {
	    altMenu = update.altMenu;
	  });
	
	  function makeControllerAvailableOnScope(elem, menu, scope) {
	    _.each(menu, function (m) {
	      if (m.controller) {
	        var ctrl = m.controller;
	        setController(menu, ctrl, elem, scope);
	        menu.hasActionController = true;
	      }
	    });
	  }
	
	  function setController(item, controller, elem, scope) {
	    var locals = {
	      $scope: scope,
	      $element: elem
	    };
	
	    item._actionController = $controller(controller, locals);
	  }
	
	  fisAltMenuFactory.showAltMenu = function (elem, sourceNavigation, parentScope, event) {
	    if (_.isUndefined(altMenu)) {
	      console.warn('AltMenu is not loaded from navigation.');
	    } else {
	      makeControllerAvailableOnScope(elem, altMenu, parentScope);
	
	      parentScope.altMenu = []; // = altMenu;
	      parentScope.clsMenu = [];
	      // we have to set all this up dynamically
	
	      _.each(altMenu, function (item) {
	        if (item.controller || item.action) {
	          parentScope.altMenu.push(item);
	        }
	        if (item.cls) {
	          parentScope.clsMenu.push(item);
	        }
	      });
	
	      var menu = createCompiledMenu(parentScope, sourceNavigation);
	      var mOffset = elem.offset();
	      var presentAltMenus = $('#altmenu');
	      if (presentAltMenus.length > 0) {
	        presentAltMenus.remove();
	      }
	      var sitemap = elem.parents().find('.fis-sitemap');
	
	      $(sitemap).append(menu);
	      if (menu.outside) {
	        menu.outside('click', function () {
	          menu.hide();
	          elem.find('#altmenu').remove();
	          parentScope.$digest();
	        });
	      }
	      positionMenu(menu, elem, sitemap, mOffset, event);
	    }
	  };
	
	  function positionMenu(menu, elem, sitemap /* , mOffset, event */) {
	    var elemOffset = elem.offset();
	    var properties = {};
	
	    var siteMapOff = {};
	    if (sitemap.offset()) {
	      siteMapOff = sitemap.offset();
	    } else {
	      // failover hardcoding
	      siteMapOff.top = 135;
	      siteMapOff.left = 300;
	    }
	
	    var H_OFFSET = 30;
	    var V_OFFSET = 2;
	
	    properties.top = V_OFFSET + (elemOffset.top - siteMapOff.top);
	    properties.left = H_OFFSET + (elemOffset.left - siteMapOff.left);
	
	    properties.position = 'inherit';
	
	    var mmc = sitemap;
	
	    if (mmc.length < 1) {
	      console.warn('Unable to position the alt-menu successfully : fis-sitemap not found.');
	      return;
	    }
	
	    var height = parseFloat(mmc.height());
	    var mmcOffset = mmc.offset();
	    var relativeOffset = {};
	    relativeOffset.top = elemOffset.top - mmcOffset.top;
	    relativeOffset.left = elemOffset.left - mmcOffset.left;
	
	    if (height / 3 * 2 < relativeOffset.top) {
	      properties.top = properties.top - 30; // eslint-disable-line operator-assignment
	    }
	
	    menu.css(properties);
	  }
	
	  /**
	   * Creates a compiled alt-click dropdown menu.
	   *
	   * @param parentScope
	   * @param sourceNavigation
	   * @returns {object} - the compiled menu
	   */
	  function createCompiledMenu(parentScope, sourceNavigation) {
	    _.each(parentScope.altMenu, function (item) {
	      item.originalNavigation = sourceNavigation;
	    });
	    _.each(parentScope.clsMenu, function (item) {
	      item.originalNavigation = sourceNavigation;
	    });
	
	    // eslint-disable-next-line no-multi-str
	    var menu = '<div id="altmenu"><ul class="alt-nav-link dropdown-menu pull-right">\
	                <ul >\
	                    <li fisid="altmenu_{{item.id}}" ng-repeat="item in altMenu">\
	                          <div fis-navigation-link fis-model="item" class="alt-menu-link"></div>\
	                    </li>';
	
	    // add in the class menus if there are any
	    if (parentScope.clsMenu.length > 0) {
	      _.each(parentScope.clsMenu, function (item, index) {
	        menu = menu + '<li class="' + parentScope.clsMenu[index].cls + '" fis-model="clsMenu[' + index + ']" ></li>';
	      });
	    }
	    // close up the alt menu
	    menu = menu + '</ul></div>'; // eslint-disable-line operator-assignment
	    // compile all together
	    return $compile(menu)(parentScope);
	  }
	
	  return fisAltMenuFactory;
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 7 */
/*!********************!*\
  !*** external "_" ***!
  \********************/
/***/ (function(module, exports) {

	module.exports = _;

/***/ }),
/* 8 */
/*!****************************************!*\
  !*** ./services/responsive.service.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	  /**
	   * @private
	   */
	
	  var self = this;
	
	  /**
	   * @name $get
	   * @methodOf fisResponsiveService
	   * @description <p>Factory method to create instance of fisResponsiveService.</p>
	   */
	  self.$get = ['fisPubSubService', function (fisPubSubService) {
	    var service = {}; // to be returned
	    var width;
	    var height;
	    var maxWidthScreenSizes = {
	      small: 768,
	      medium: 1024,
	      large: 100000 // Absurdly large number
	    };
	    var _isResponsive;
	
	    $(window).resize(function () {
	      var width = service.getWidth(true); // eslint-disable-line no-unused-vars
	      var height = service.getHeight(true); // eslint-disable-line no-unused-vars
	      fisPubSubService.publish('fisResponsiveService.browserResized');
	    });
	
	    /**
	    * @method
	    * @methodOf fisResponsiveService
	    * @description Returns a string that identifies the current screen size.
	    */
	    service.getMaxWidthScreenSize = function () {
	      return Object.keys(maxWidthScreenSizes).reduce(function (result, screenSize) {
	        var screenWidth = maxWidthScreenSizes[screenSize];
	        if (_.isUndefined(result) && service.getWidth() <= screenWidth) {
	          result = screenSize;
	        }
	
	        return result;
	      }, undefined);
	    };
	
	    /**
	    * @method
	    * @methodOf fisResponsiveService
	    * @description Returns an object that describes the max-width breakpoints for screen sizes.
	    */
	    service.getMaxWidthScreenSizes = function () {
	      return maxWidthScreenSizes;
	    };
	
	    /**
	    * @method
	    * @methodOf fisResponsiveService
	    * @description Returns a cached copy of the current viewport width. This function will help limit layout events in the browsers.
	    */
	    service.getWidth = function (updateCache) {
	      if (_.isUndefined(width) || updateCache) {
	        var win = typeof window != 'undefined' && window; // eslint-disable-line eqeqeq
	        var doc = typeof document != 'undefined' && document; // eslint-disable-line eqeqeq
	        var docElem = doc && doc.documentElement;
	
	        var viewportWidth = docElem['clientWidth'] < win['innerWidth'] ? function () {
	          // eslint-disable-line dot-notation
	          return win['innerWidth']; // eslint-disable-line dot-notation
	        } : function () {
	          return docElem['clientWidth']; // eslint-disable-line dot-notation
	        };
	
	        width = viewportWidth();
	
	        var temp = service.isResponsive();
	
	        if (_isResponsive !== temp) {
	          fisPubSubService.publish('fisResponsiveService.isResponsive', temp);
	          _isResponsive = temp;
	        }
	      }
	
	      return width;
	    };
	
	    /**
	    * @method
	    * @methodOf fisResponsiveService
	    * @description Returns a cached copy of the current viewport height. This function will help limit layout events in the browsers.
	    */
	    service.getHeight = function (updateCache) {
	      if (_.isUndefined(height) || updateCache) {
	        var win = typeof window != 'undefined' && window; // eslint-disable-line eqeqeq
	        var doc = typeof document != 'undefined' && document; // eslint-disable-line eqeqeq
	        var docElem = doc && doc.documentElement;
	
	        var viewportHeight = docElem['clientHeight'] < win['innerHeight'] ? function () {
	          // eslint-disable-line dot-notation
	          return win['innerHeight']; // eslint-disable-line dot-notation
	        } : function () {
	          return docElem['clientHeight']; // eslint-disable-line dot-notation
	        };
	
	        height = viewportHeight();
	      }
	
	      return height;
	    };
	
	    /**
	    * @method
	    * @methodOf fisResponsiveService
	    * @description Returns 'true' if the application is in a responsive state.
	    */
	    service.isResponsive = function () {
	      var responsiveScreenSizes = ['small', 'medium'];
	
	      return service.isResponsiveEnabled() && _.includes(responsiveScreenSizes, service.getMaxWidthScreenSize());
	    };
	
	    /**
	    * @method
	    * @methodOf fisResponsiveService
	    * @description Returns 'true' if the application is in a responsive state.
	    */
	    service.isResponsiveEnabled = function () {
	      return $('body').hasClass('fis-responsive-shell');
	    };
	
	    return service;
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 9 */
/*!******************************************!*\
  !*** ./services/current-year.service.js ***!
  \******************************************/
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = new Date().getFullYear();

/***/ }),
/* 10 */
/*!*******************************************!*\
  !*** ./services/sidebar-state.service.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var self = this;
	  self.sidebarControllers = {};
	
	  /**
	   * @name $get
	   * @description Factory method to create instance of fisSidebarStateService
	   */
	  self.$get = [function () {
	    var service = {}; // to be returned
	
	    /**
	     * @name registerSidebar
	     * @methodOf fisSidebarStateService
	     * @param name The name of the sidebar to register
	     * @param scope The scope of the sidebar
	     * @description Method to register a sidebar with shellController
	     */
	    service.registerSidebar = function (name, scope) {
	      self.sidebarControllers[name] = scope;
	    };
	
	    /**
	     * @name openSidebar
	     * @methodOf fisSidebarStateService
	     * @param name The name of the sidebar to have its open method called
	     * @param speed How fast in milliseconds that the sidebar opens
	     * @description This method opens the sidebar
	     */
	    service.openSidebar = function (name) {
	      setOpened(name, true);
	    };
	
	    function setOpened(name, opened) {
	      var sidebarController = self.sidebarControllers[name];
	
	      if (_.isUndefined(sidebarController)) {
	        console.warn('Could not set opened state for unregistered sidebar ' + name);
	      } else {
	        sidebarController.sidebar.opened = opened;
	      }
	    }
	
	    /**
	     * @name closeSidebar
	     * @methodOf fisSidebarStateService
	     * @param name The name of the sidebar to have its close method called
	     * @param speed How fast in milliseconds that the sidebar closes
	     * @description This method closes the sidebar
	     */
	    service.closeSidebar = function (name) {
	      setOpened(name, false);
	    };
	
	    /**
	     * @name clickpin
	     * @methodOf fisSidebarStateService
	     * @param name The name of the sidebar to have its clickpin method called
	     * @description This method pinns the sidebar
	     */
	    service.clickPin = function (name) {
	      var sidebarCtrl = self.sidebarControllers[name];
	      sidebarCtrl.sidebar.pinned = !sidebarCtrl.sidebar.pinned;
	    };
	
	    /**
	     * @name updateSidebar
	     * @methodOf fisSidebarStateService
	     * @param name The name of the sidebar to have its close method called
	     * @param position The position to orient the sidebar
	     * @description This method sets the sidebar's position parameter
	     */
	    service.updateSidebarPosition = function (name, position) {
	      self.sidebarControllers[name].sidebar.position = position;
	    };
	
	    /**
	           * @name reloadSidebar
	           * @methodOf fisSidebarStateService
	           * @param name The name of the sidebar to reload
	           * @description This method reloads the sidebar contents
	           */
	    service.reloadSidebar = function (name) {
	      self.sidebarControllers[name].reload();
	    };
	
	    /**
	     * @name updateSidebarEnabled
	     * @methodOf fisSidebarStateService
	     * @param name The name of the sidebar to have its close method called
	     * @param enabled Set whether the sidebar is enabled or not
	     * @description This method sets the sidebar's enabled parameter
	     */
	    service.updateSidebarEnabled = function (name, enabled) {
	      self.sidebarControllers[name].sidebar.enabled = enabled;
	    };
	
	    /**
	     * @name updateSidebarMode
	     * @methodOf fisSidebarStateService
	     * @param name The name of the sidebar to have its close method called
	     * @param mode Set the sidebar's mode
	     * @description This method sets the sidebar's mode parameter
	     */
	    service.updateSidebarMode = function (name, mode) {
	      self.sidebarControllers[name].sidebar.mode = mode;
	    };
	
	    /**
	     * @name updateSidebarWidth
	     * @methodOf fisSidebarStateService
	     * @param name The name of the sidebar to have its width set
	     * @param width Set the sidebar's width
	     * @description This method sets the sidebar's width
	     */
	    service.updateSidebarWidth = function (name, width) {
	      self.sidebarControllers[name].sidebar.width = width;
	    };
	
	    /**
	     * @name updateSidebarMaximumWidth
	     * @methodOf fisSidebarStateService
	     * @param name The name of the sidebar to have its maximum width set
	     * @param width Set the sidebar's maximum width
	     * @description This method sets the sidebar's maximum width
	     */
	    service.updateSidebarMaximumWidth = function (name, width) {
	      self.sidebarControllers[name].sidebar.maximumWidth = width;
	    };
	
	    /**
	     * @name updateSidebarMinimumWidth
	     * @methodOf fisSidebarStateService
	     * @param name The name of the sidebar to have its minimum width set
	     * @param width Set the sidebar's minimum width
	     * @description This method sets the sidebar's minimum width
	     */
	    service.updateSidebarMinimumWidth = function (name, width) {
	      self.sidebarControllers[name].sidebar.minimumWidth = width;
	    };
	
	    /**
	     * @name unregisterSidebar
	     * @methodOf fisSidebarStateService
	     * @param name The name of the sidebar to be unregistered
	     * @description This method removes the sidebar from the service
	     */
	    service.unregisterSidebar = function (name) {
	      if (self.sidebarControllers.indexOf) {
	        var idx = self.sidebarControllers.indexOf(name);
	        if (idx > -1) {
	          self.sidebarControllers.splice(idx, 1);
	        }
	      }
	    };
	
	    /**
	     * @name isOpened
	     * @methodOf fisSidebarStateService
	     * @param name The name of the sidebar to have its opened method returned
	     * @description This method returns true if the sidebar is opened
	     * @returns {boolean}
	     */
	    service.isOpened = function (name) {
	      var sidebarController = self.sidebarControllers[name];
	
	      if (_.isUndefined(sidebarController)) {
	        console.warn('Could not get opened state for unregistered sidebar ' + name);
	      } else {
	        return sidebarController.sidebar.opened;
	      }
	    };
	
	    /**
	     * @name isPinned
	     * @methodOf fisSidebarStateService
	     * @param name The name of the sidebar to have its clickpin method called
	     * @description This method returns true if the sidebar is pinned
	     * @returns {boolean}
	     */
	    service.isPinned = function (name) {
	      var sidebarController = self.sidebarControllers[name];
	
	      if (_.isUndefined(sidebarController)) {
	        console.warn('Could not get pinned state for unregistered sidebar ' + name);
	      } else {
	        return sidebarController.sidebar.pinned;
	      }
	    };
	
	    /**
	     * @name getSidebar
	     * @param name The name of the sidebar to return
	     * @description This method returns the sidebar object
	     * @returns {object}
	     */
	    service.getSidebar = function (name) {
	      var sidebarController = self.sidebarControllers[name];
	
	      if (_.isUndefined(sidebarController)) {
	        console.warn('Could not get unregistered sidebar ' + name);
	      } else {
	        return sidebarController.sidebar;
	      }
	    };
	
	    /**
	     * @name pinSidebar
	     * @param name The name of the sidebar to set pinned to true
	     * @description pin the sidbar
	     */
	    service.pinSidebar = function (name) {
	      setPinnedState(name, true);
	    };
	
	    function setPinnedState(name, state) {
	      var sidebarController = self.sidebarControllers[name];
	
	      if (_.isUndefined(sidebarController)) {
	        console.warn('Could not set pinned state for unregistered sidebar ' + name);
	      } else {
	        sidebarController.sidebar.pinned = state;
	      }
	    }
	
	    /**
	     * @name unpinSidebar
	     * @param name The name of the sidebar to set pinned to false
	     * @description unpin the sidbar
	     */
	    service.unpinSidebar = function (name) {
	      setPinnedState(name, false);
	    };
	
	    /**
	     * @name updateSidebarTitle
	     * @param name The name to identify the sidebar
	     * @param title The new title
	     * @description update sidebar title
	     */
	    service.updateSidebarTitle = function (name, title) {
	      var sidebarController = self.sidebarControllers[name];
	      if (!_.isUndefined(sidebarController)) {
	        sidebarController.sidebar.title = title;
	      }
	    };
	    return service;
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 11 */
/*!****************************************!*\
  !*** ./services/start-menu.service.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  /**
	   * @private
	   */
	
	  var self = this;
	
	  self.menuDirectiveName = '';
	
	  /**
	   * @name $get
	   * @methodOf fisMegaMenuServiceProvider
	   * @description <p>Factory method to create instance of fisMegaMenuService.</p>
	   */
	  self.$get = ['fisPubSubService', function (fisPubSubService) {
	    var service = {}; // to be returned
	    var startMenu = {
	      closeOnMouseExit: true,
	      searchable: true,
	      quickLinksOrientation: 'left',
	      showEmptyMenu: false,
	      loadingIndicator: false
	    };
	
	    service.getMenuDirectiveName = function () {
	      return self.menuDirectiveName;
	    };
	
	    fisPubSubService.subscribe('fisStartMenu.closeOnMouseExit', function (value) {
	      startMenu.closeOnMouseExit = !!value; // eslint-disable-line no-implicit-coercion
	    });
	
	    fisPubSubService.subscribe('fisStartMenu.searchable', function (value) {
	      startMenu.searchable = !!value; // eslint-disable-line no-implicit-coercion
	    });
	
	    fisPubSubService.subscribe('fisStartMenu.quickLinksOrientation', function (value) {
	      var orientation = 'left';
	
	      if (_.isString(value) && value.trim().toLowerCase() === 'right') {
	        orientation = 'right';
	      }
	
	      startMenu.quickLinksOrientation = orientation;
	    });
	
	    fisPubSubService.subscribe('fisStartMenu.showEmptyMenu', function (value) {
	      startMenu.showEmptyMenu = !!value; // eslint-disable-line no-implicit-coercion
	    });
	
	    fisPubSubService.subscribe('fisStartMenu.loadingIndicator', function (value) {
	      startMenu.loadingIndicator = !!value; // eslint-disable-line no-implicit-coercion
	    });
	
	    /**
	    * @method
	    * @methodOf fisStartMenuService
	    * @description Returns 'true' if fisStartMenu should close when the mouse exits the menu.
	    */
	    service.GetCloseOnMouseExit = function () {
	      return startMenu.closeOnMouseExit;
	    };
	
	    /**
	    * @method
	    * @methodOf fisStartMenuService
	    * @param {boolean} enabled Indicates if fisStartMenu should close when the mouse exits the menu.
	    * @description Updates the value used to determine if fisStartMenu should close when the mouse exits the menu.
	    */
	    service.SetCloseOnMouseExit = function (enabled) {
	      startMenu.closeOnMouseExit = _.isBoolean(enabled) ? enabled : enabled.trim().toLowerCase() === 'true';
	      fisPubSubService.publish('fisStartMenu.setCloseOnMouseExit', startMenu.closeOnMouseExit);
	    };
	
	    /**
	     * @method
	     * @methodOf fisStartMenuService
	     * @description Returns 'true' if fisStartMenu can search its menu items.
	     */
	    service.GetSearchable = function () {
	      return startMenu.searchable;
	    };
	
	    /**
	     * @method
	     * @methodOf fisStartMenuService
	     * @param {boolean} enabled Indicates if fisStartMenu can search its menu items.
	     * @description Updates the value used to determine if fisStartMenu can search its menu items.
	     */
	    service.SetSearchable = function (enabled) {
	      startMenu.searchable = _.isBoolean(enabled) ? enabled : enabled.trim().toLowerCase() === 'true';
	      fisPubSubService.publish('fisStartMenu.setSearchable', startMenu.searchable);
	    };
	
	    /**
	     * @method
	     * @methodOf fisStartMenuService
	     * @description Returns 'true' if fisStartMenu displays a loading indicator on loading
	     */
	    service.GetLoadingIndicator = function () {
	      return startMenu.loadingIndicator;
	    };
	
	    /**
	     * @method
	     * @methodOf fisStartMenuService
	     * @param {boolean} enabled loading indicator on fisStartMenu button
	     * @description Updates the value used to determine if fisStartMenu displays a loading indicator on loading
	     */
	    service.SetLoadingIndicator = function (enabled) {
	      startMenu.loadingIndicator = _.isBoolean(enabled) ? enabled : enabled.trim().toLowerCase() === 'true';
	      fisPubSubService.publish('fisStartMenu.setLoadingIndicator', startMenu.loadingIndicator);
	    };
	
	    /**
	     * @method
	     * @methodOf fisStartMenuService
	     * @description Returns 'true' if fisStartMenu is visible if no browsable menu structure is present but searchable
	     */
	    service.GetShowEmptyMenu = function () {
	      return startMenu.showEmptyMenu;
	    };
	
	    /**
	     * @method
	     * @methodOf fisStartMenuService
	     * @param {boolean} enabled Indicates if fisStartMenu can search its menu items.
	     * @description Updates the value used to determine if fisStartMenu can search its menu items.
	     */
	    service.SetShowEmptyMenu = function (enabled) {
	      startMenu.showEmptyMenu = _.isBoolean(enabled) ? enabled : enabled.trim().toLowerCase() === 'true';
	      fisPubSubService.publish('fisStartMenu.setShowEmptyMenu', startMenu.showEmptyMenu);
	    };
	
	    /**
	    * @method
	    * @methodOf fisStartMenuService
	    * @description Returns 'left' or 'right' to determine orientation of the quick links area.
	    */
	    service.GetQuickLinksOrientation = function () {
	      return startMenu.quickLinksOrientation;
	    };
	
	    /**
	    * @method
	    * @methodOf fisStartMenuService
	    * @param {string} value Determines the orientation of the quick links area.
	    * @description Updates the orientation of the quick links area.
	    */
	    service.SetQuickLinksOrientation = function (value) {
	      var orientation = 'left';
	
	      if (_.isString(value) && value.trim().toLowerCase() === 'right') {
	        orientation = 'right';
	      }
	
	      startMenu.quickLinksOrientation = orientation;
	      fisPubSubService.publish('fisStartMenu.setQuickLinksOrientation', startMenu.quickLinksOrientation);
	    };
	
	    return service;
	  }];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 12 */
/*!*************************************!*\
  !*** ./services/tabsbar.service.js ***!
  \*************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  /**
	   * @private
	   */
	
	  var self = this;
	
	  /**
	  * @name $get
	  * @methodOf fisTabsBarService
	  * @description <p>Factory method to create instance of fisTabsBarService.</p>
	  */
	  self.$get = ['fisPubSubService', function (fisPubSubService) {
	    var service = {};
	
	    service.openedDropDown = undefined;
	
	    service.setUpdateTabTitle = function (updateTabTitle) {
	      fisPubSubService.publish('fisTabsBar.updateTabTitle', updateTabTitle);
	    };
	
	    service.setTooltipPrependTitle = function (tooltipPrependTitle) {
	      fisPubSubService.publish('fisTabsBar.tooltipPrependTitle', tooltipPrependTitle);
	    };
	
	    return service;
	  }];
	};

/***/ }),
/* 13 */
/*!***********************************!*\
  !*** ./services/theme.service.js ***!
  \***********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var self = this;
	
	  var defaultTheme = self.defaultTheme = {
	    id: 'default',
	    name: 'Plateau',
	    stylesheets: ['node_modules/@ruf/fis-theme-plateau/dist/kendo.min.css', 'node_modules/@ruf/fis-theme-plateau/dist/style.min.css'],
	    rel: 'stylesheet',
	    scripts: []
	  };
	
	  if (fis.initParams().appStage === 'D') {
	    defaultTheme.stylesheets = ['node_modules/@ruf/fis-theme-plateau/kendo.less', 'node_modules/@ruf/fis-theme-plateau/style.less'];
	    defaultTheme.scripts = ['node_modules/@ruf/less.js/less.js'];
	    defaultTheme.rel = 'stylesheet/less';
	  }
	
	  self.$get = ['$resource', '$q', 'fisConfig', 'fisClientStorageService', function ($resource, $q, fisConfig, fisClientStorageService) {
	    var serv = {};
	    var currentTheme = defaultTheme;
	    var removeThemeFlag = false;
	
	    serv.apply = function (theme) {
	      var deferred = $q.defer();
	      if (theme && theme.stylesheets) {
	        // a theme object, return it
	        deferred.resolve(theme);
	        currentTheme = theme;
	      } else {
	        var currentThemeFromStorage = fisClientStorageService.getItem('currentTheme');
	        if (currentThemeFromStorage && removeThemeFlag) {
	          fisClientStorageService.removeItem('currentTheme');
	          removeThemeFlag = false;
	          currentThemeFromStorage = null;
	        }
	
	        if (currentThemeFromStorage && currentThemeFromStorage.id) {
	          currentTheme = currentThemeFromStorage;
	          deferred.resolve(currentThemeFromStorage);
	        } else {
	          if (fisConfig.endpoints && fisConfig.endpoints.theme) {
	            // eslint-disable-line no-lonely-if
	            // a theme REST service is defined, use it to get the current theme
	            var params = angular.isString(theme) ? { context: theme } : theme || {};
	            params['appStage'] = fis.initParams().appStage; // eslint-disable-line dot-notation
	
	            $resource(fisConfig.endpoints.theme + '/current').get(params || {}, function (data) {
	              if (!data.id) {
	                deferred.resolve(defaultTheme);
	                currentTheme = defaultTheme;
	              }
	              deferred.resolve(data);
	            }, function () {
	              deferred.resolve(defaultTheme);
	              currentTheme = defaultTheme;
	            });
	          } else {
	            // No theme endpoint defined, use default theme.
	            currentTheme = defaultTheme;
	            deferred.resolve(currentTheme);
	          }
	        }
	      }
	      return deferred.promise;
	    };
	
	    serv.themes = function () {
	      var deferred = $q.defer();
	      if (fisConfig.endpoints && fisConfig.endpoints.theme) {
	        var params = {};
	        params['appStage'] = fis.initParams().appStage; // eslint-disable-line dot-notation
	        $resource(fisConfig.endpoints.theme).query(params || {}, function (data) {
	          deferred.resolve(data);
	        }, function () {
	          // do nothing
	        });
	      } else {
	        deferred.resolve([]);
	      }
	      return deferred.promise;
	    };
	
	    serv.removeStoredTheme = function () {
	      removeThemeFlag = true;
	    };
	
	    return serv;
	  }];
	};

/***/ }),
/* 14 */
/*!******************************!*\
  !*** ./controllers/index.js ***!
  \******************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _altClick = __webpack_require__(/*! ./alt-click.controller */ 15);
	
	var _altClick2 = _interopRequireDefault(_altClick);
	
	var _shell = __webpack_require__(/*! ./shell.controller */ 16);
	
	var _shell2 = _interopRequireDefault(_shell);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.controllers', []);
	
	ngModule.controller('altClickController', _altClick2.default);
	ngModule.controller('fis.shell.Controller', _shell2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 15 */
/*!*********************************************!*\
  !*** ./controllers/alt-click.controller.js ***!
  \*********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$scope", function ($scope) {
	  'ngInject';
	
	  /**
	   * Default controller for Alt-Click on Navigation Item
	   */
	
	  $scope.openInTab = function () {
	    $scope.open(this.fisModel.originalNavigation.path, this.$event);
	  };
	}];

/***/ }),
/* 16 */
/*!*****************************************!*\
  !*** ./controllers/shell.controller.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$scope", "$location", "fisViewService", "fisViewPanelService", "fisConfig", "fisI18nService", "fisThemeService", "fisClientStorageService", "$q", "fisPubSubService", "$window", "$document", "$log", "$timeout", "$exceptionHandler", "$controller", "$rootScope", function ($scope, $location, fisViewService, fisViewPanelService, fisConfig, fisI18nService, fisThemeService, fisClientStorageService, $q, fisPubSubService, $window, $document, $log, $timeout, $exceptionHandler, $controller, $rootScope) {
	  'ngInject';
	  /**
	   * @name config
	   * @fieldOf fis.shell.Controller
	   * @description Configuration
	   */
	
	  var deferred = $q.defer();
	  $scope.config = fisConfig;
	
	  // FIXME: this makes the fisClientStorageService dependant on the shell being present
	  // Initialize fisClientStorageService with appId received in config
	  fisClientStorageService.init(fisConfig.appId);
	
	  var currentTheme = fisThemeService.apply();
	  currentTheme.then(function () /* result*/{
	    deferred.resolve(currentTheme);
	  });
	  if (fisConfig.windowTitle) {
	    $document.title = fisConfig.windowTitle;
	  }
	
	  $exceptionHandler.intercept('userMessage', function (exception) {
	    $scope.alert(exception.userMessage, { title: fisI18nService.translate('error-dialog-title', '') });
	  });
	
	  /**
	   * Provides translation for the view displayed in the view panel.
	   * This provides automatic namespacing for shell related strings.
	   * e.g. for a key of "title", this function will prefix the key with "shell.".
	   * @param {string} key the i18n key to provide a translation for
	   * @param {string} def the default value, if the key can't be found
	   */
	  var unsubscribe = fisPubSubService.subscribe('shell.i18nReady', function () {
	    $scope.i18n = function (key, def) {
	      // keys in the shell controller can be prefixed with 'shell'
	      if (key.indexOf('.') === -1) {
	        key = ['shell', key];
	      }
	      return fisI18nService.translate(key, def);
	    };
	    // Un-subscribing shell.i18nReady event
	    unsubscribe();
	  });
	
	  /**
	   * @name reloadActivePage
	   * @methodOf fis.shell.Controller
	   * @description
	   * <p>Helper method to reload the current active View Panel. Delegates to <em>fisViewPanelService</em>.
	   * </p>
	   */
	  $scope.reloadActivePage = function () {
	    fisViewPanelService.reloadActiveViewPanel();
	  };
	
	  /**
	   * @name open
	   * @methodOf fis.shell.Controller
	   * @param {String} The Nav path for which View Panel needs to be opened
	   * @param {object} Event Object(For example, megamenu link click)
	   * @description
	   * <p>Helper method to open a View Panel corresponding to given Nav Path. Delegates to <em>fisViewPanelService</em>.
	   * </p>
	   */
	  $scope.open = fisViewPanelService.open;
	
	  /**
	   * @name close
	   * @methodOf fis.shell.Controller
	   * @param {String} The Nav path for which View Panel needs to be opened
	   * @description
	   * <p>Helper method to close a View Panel corresponding to given Nav Path. Delegates to <em>fisViewPanelService</em>.
	   * </p>
	   */
	  $scope.close = fisViewPanelService.close;
	
	  /**
	   * @name activeViewPanel
	   * @methodOf fis.shell.Controller
	   * @returns {Object} The active View Panel
	   * @description
	   * <p>Helper method to get active View Panel. Delegates to <em>fisViewPanelService</em>.
	   * </p>
	   */
	  $scope.activeViewPanel = fisViewPanelService.activeViewPanel;
	
	  $scope.activeViewPanelIndex = fisViewPanelService.activeViewPanelIndex;
	
	  $scope.viewPanels = fisViewPanelService.viewPanels;
	
	  $scope.findNavItem = fisViewService.findNavItem;
	
	  /**
	   * Logs to the console. Useful for debugging.
	   * @param {*}
	   */
	  $scope.log = function () /* args*/{
	    $log.log.apply(this, arguments);
	  };
	
	  // Wait on View Service Promise and then open top-level View Panels
	  fisViewService.load().then(function () /* nav*/{
	    fisViewPanelService.open($location.path());
	  });
	
	  $scope.currentTheme = deferred.promise;
	
	  $scope.applyTheme = function (theme) {
	    $scope.currentTheme.then(function (oldTheme) {
	      var themeId = angular.isString(theme) ? theme : theme.id;
	      if (oldTheme.id !== themeId) {
	        fisClientStorageService.setItem('currentTheme', theme);
	        $scope.currentTheme = fisThemeService.apply(theme);
	        fisPubSubService.publish('fisThemeChanged', {
	          theme: $scope.currentTheme
	        });
	      }
	    });
	  };
	
	  $scope.previewTheme = function (theme) {
	    $scope.currentTheme.then(function (oldTheme) {
	      var themeId = angular.isString(theme) ? theme : theme.id;
	      if (oldTheme.id !== themeId) {
	        $scope.currentTheme = fisThemeService.apply(theme);
	        fisPubSubService.publish('fisThemeChanged', {
	          theme: $scope.currentTheme
	        });
	      }
	    });
	  };
	
	  /**
	   * @description Provides a pass-through to the $window.open function that is accessible in bindings.
	   */
	  $scope.openWindow = function (url, name, specs, replace) {
	    // NOTE: this is to provide an alternative to the refactored capability of loading nav items in separate
	    // window. We should not start wrapping such functions in the shellController unless there's a good
	    // reason.
	    $window.open(url, name || '_blank', specs, replace);
	  };
	
	  $scope.shell = {
	    sizes: {}
	  };
	  var footerElem;
	
	  // this function is called when fis-footer-bar is ready
	  $scope.registerFooter = function (footer) {
	    footerElem = footer;
	  };
	
	  var resizeTimeout;
	  var unsubscribes = [];
	
	  function calculateShellSizes() {
	    resizeTimeout = null;
	    var tmpSize = {};
	    if (footerElem) {
	      if (footerElem.hasClass('fis-collapsible')) {
	        // In collapsible mode only the 5px height colorbar is visible
	        // the value 5 is set in fis-footer-bar.less (padding-top: @cmoAppFooterTopPadding)
	        tmpSize.footerHeight = 5;
	      } else {
	        tmpSize.footerHeight = footerElem.outerHeight();
	      }
	    } else {
	      // If footer is not present in the application, need to initialised the footerheight to 0.
	      // as this is used on stretch-to-bottom SDHTML-9642
	      tmpSize.footerHeight = 0;
	    }
	
	    var window = angular.element($window);
	    tmpSize.windowHeight = parseFloat(window.height());
	    tmpSize.windowWidth = parseFloat(window.width());
	    if (!_.isEqual(tmpSize, $scope.shell.sizes)) {
	      // Only update the scope object and publish the event if size really changed
	      $scope.shell.sizes = tmpSize;
	      fisPubSubService.publish('shell.sizeChange', $scope.shell.sizes);
	    }
	  }
	
	  var calculateAfterTimeout = function calculateAfterTimeout() {
	    // timeout is introduced because the resize event is invoked many times during the process of resizing
	    if (resizeTimeout) {
	      $timeout.cancel(resizeTimeout);
	    }
	    resizeTimeout = $timeout(calculateShellSizes, 150);
	  };
	
	  // We need to recalculate the shell sizes in some event which may influence the
	  // Footer, Header and their dimensions
	  unsubscribes.push(fisPubSubService.subscribe('shell.navReady', calculateAfterTimeout));
	  unsubscribes.push(fisPubSubService.subscribe('shell.navLoading', calculateAfterTimeout));
	  unsubscribes.push(fisPubSubService.subscribe('shell.shell.suspendWatch', calculateAfterTimeout));
	  unsubscribes.push(fisPubSubService.subscribe('fisThemeChanged', calculateAfterTimeout));
	
	  // calculate the sizes when window is resized
	  angular.element($window).on('resize', calculateAfterTimeout);
	  // Set the timeout when the controller get's instantiated, to ensure we calculate at least once
	  calculateAfterTimeout();
	
	  $scope.$on('$destroy', function () {
	    // Unsubscribe all fisPubSubService Listeners
	    _.each(unsubscribes, function (unsubscibe) {
	      unsubscibe();
	    });
	    // Cancel the resizeTimeout
	    $timeout.cancel(resizeTimeout);
	  });
	
	  // read the controller names that have been defined in controllersArr and instantiate them with shellController's scope.
	  // This is done so that the methods defined in the respective controllers get added to shell controller's scope,
	  // in case shellController is the main controller of the application
	  if ($rootScope.controllersArr && $rootScope.controllersArr.length > 0) {
	    for (var i = 0; i < $rootScope.controllersArr.length; i++) {
	      $controller($rootScope.controllersArr[i], { $scope: $scope });
	    }
	  }
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 17 */
/*!*****************************!*\
  !*** ./components/index.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _breadcrumb = __webpack_require__(/*! ./breadcrumb */ 18);
	
	var _breadcrumb2 = _interopRequireDefault(_breadcrumb);
	
	var _contentFrame = __webpack_require__(/*! ./content-frame */ 23);
	
	var _contentFrame2 = _interopRequireDefault(_contentFrame);
	
	var _dropdownSecondaryMenu = __webpack_require__(/*! ./dropdown-secondary-menu */ 27);
	
	var _dropdownSecondaryMenu2 = _interopRequireDefault(_dropdownSecondaryMenu);
	
	var _footerBar = __webpack_require__(/*! ./footer-bar */ 30);
	
	var _footerBar2 = _interopRequireDefault(_footerBar);
	
	var _footerMenu = __webpack_require__(/*! ./footer-menu */ 33);
	
	var _footerMenu2 = _interopRequireDefault(_footerMenu);
	
	var _insertView = __webpack_require__(/*! ./insert-view */ 35);
	
	var _insertView2 = _interopRequireDefault(_insertView);
	
	var _navigationLink = __webpack_require__(/*! ./navigation-link */ 37);
	
	var _navigationLink2 = _interopRequireDefault(_navigationLink);
	
	var _offCanvasMenu = __webpack_require__(/*! ./off-canvas-menu */ 39);
	
	var _offCanvasMenu2 = _interopRequireDefault(_offCanvasMenu);
	
	var _shell = __webpack_require__(/*! ./shell */ 42);
	
	var _shell2 = _interopRequireDefault(_shell);
	
	var _sideBar = __webpack_require__(/*! ./side-bar */ 45);
	
	var _sideBar2 = _interopRequireDefault(_sideBar);
	
	var _sideBarMenu = __webpack_require__(/*! ./side-bar-menu */ 48);
	
	var _sideBarMenu2 = _interopRequireDefault(_sideBarMenu);
	
	var _startMenu = __webpack_require__(/*! ./start-menu */ 50);
	
	var _startMenu2 = _interopRequireDefault(_startMenu);
	
	var _tabsBar = __webpack_require__(/*! ./tabs-bar */ 53);
	
	var _tabsBar2 = _interopRequireDefault(_tabsBar);
	
	var _tabsClosingMenu = __webpack_require__(/*! ./tabs-closing-menu */ 57);
	
	var _tabsClosingMenu2 = _interopRequireDefault(_tabsClosingMenu);
	
	var _tabsOverflowMenu = __webpack_require__(/*! ./tabs-overflow-menu */ 59);
	
	var _tabsOverflowMenu2 = _interopRequireDefault(_tabsOverflowMenu);
	
	var _tabsWidth = __webpack_require__(/*! ./tabs-width */ 61);
	
	var _tabsWidth2 = _interopRequireDefault(_tabsWidth);
	
	var _theme = __webpack_require__(/*! ./theme */ 63);
	
	var _theme2 = _interopRequireDefault(_theme);
	
	var _topBar = __webpack_require__(/*! ./top-bar */ 65);
	
	var _topBar2 = _interopRequireDefault(_topBar);
	
	var _utilityMenu = __webpack_require__(/*! ./utility-menu */ 68);
	
	var _utilityMenu2 = _interopRequireDefault(_utilityMenu);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components', [_breadcrumb2.default, _contentFrame2.default, _dropdownSecondaryMenu2.default, _footerBar2.default, _footerMenu2.default, _insertView2.default, _navigationLink2.default, _offCanvasMenu2.default, _shell2.default, _sideBar2.default, _sideBarMenu2.default, _startMenu2.default, _tabsBar2.default, _tabsClosingMenu2.default, _tabsOverflowMenu2.default, _tabsWidth2.default, _theme2.default, _topBar2.default, _utilityMenu2.default]);
	
	exports.default = ngModule.name;

/***/ }),
/* 18 */
/*!****************************************!*\
  !*** ./components/breadcrumb/index.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _breadcrumb = __webpack_require__(/*! ./breadcrumb.directive */ 19);
	
	var _breadcrumb2 = _interopRequireDefault(_breadcrumb);
	
	var _breadcrumbContainer = __webpack_require__(/*! ./breadcrumb-container.directive */ 21);
	
	var _breadcrumbContainer2 = _interopRequireDefault(_breadcrumbContainer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.breadcrumb', []);
	
	ngModule.directive('fisBreadcrumb', _breadcrumb2.default);
	ngModule.directive('fisBreadcrumbContainer', _breadcrumbContainer2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 19 */
/*!*******************************************************!*\
  !*** ./components/breadcrumb/breadcrumb.directive.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$filter", "fisPubSubService", "fisUniqueIdService", "fisMemoryUtilService", function ($filter, fisPubSubService, fisUniqueIdService, fisMemoryUtilService) {
	  'ngInject';
	
	  /**
	   * ReturnObject :
	   *  navItem   : item found in navigation
	   *  label     : label of navItem
	   *  path      : path of navItem
	   *  clickable : navItem has partial or secondaryNav
	   *  valid     : only valid if a navItem was found for this pathElement
	   */
	
	  function populateReturnObject(valid, navItem, path, value, label) {
	    var obj = {};
	    obj.valid = valid;
	    if (!_.isUndefined(navItem)) {
	      obj.navItem = navItem;
	      if (!_.isUndefined(label)) {
	        obj.label = label;
	      } else if (!_.isUndefined(navItem.label)) {
	        // eslint-disable-line no-negated-condition
	        obj.label = navItem.label;
	      } else {
	        obj.label = 'Undefined';
	      }
	      if (navItem.partial || navItem.secondaryNav) {
	        obj.clickable = true;
	      } else {
	        obj.clickable = false;
	      }
	    }
	    if (!_.isUndefined(path)) {
	      obj.path = path;
	    }
	    return obj;
	  }
	
	  return {
	    restrict: 'ACE',
	
	    scope: {
	      fisViewPanel: '&fisViewpanel',
	      fisPath: '&fisPath',
	      clickFn: '&fisMethod',
	      navItemFn: '&fisNavItemMethod'
	    },
	
	    // eslint-disable-next-line no-multi-str
	    template: '<div ng-if="crumbs.length > 0">\
	                        <ol class="breadcrumb">\
	                          <li ng-repeat="crumb in crumbs">\
	                            <span ng-if="crumb.clickable == true">\
	                              <a href="" fis-unique-id="breadcrumb {{crumb.id}}" fis-id-no-increment="true" ng-click="clickCrumb(crumb)"><span ng-bind-html="getValidLabel(crumb)"></span></a>\
	                            </span>\
	                            <span ng-if="crumb.clickable == false" >\
	                                   {{crumb.label}} <span class="breadcrumb-separator">&gt;</span> \
	                               </span>\
	                          </li>\
	                        </ol>\
	                       </div>',
	
	    controller: ['$scope', function ($scope) {
	      $scope.crumbs = [];
	    }],
	
	    link: function link(scope, elem, attrs) {
	      var crumbList;
	
	      function buildCrumbs(navItems, params, minNavLevel) {
	        crumbList = [];
	        var count = 0;
	        var checkForPartial = true;
	        var index = 1;
	        var showBreadCrumbs = false;
	
	        _.each(navItems, function (navItem) {
	          if (!_.isUndefined(navItem)) {
	            if (index >= minNavLevel) {
	              var result = validateCrumb(navItem, params);
	
	              // Ignore all navItems until the first one that has a partial or secondaryNav - idea is to start the breadcrumbs
	              // after demo and demo-pages - but not ignoring other navItems in navigation.json that do not have partials etc.
	              if (checkForPartial && result.valid) {
	                if (result.navItem.partial || result.navItem.secondaryNav) {
	                  checkForPartial = false;
	                } else {
	                  result.valid = false;
	                }
	              }
	              // Do check to see if we have secondaryNav - breadcrumbs only created when secondaryNav present
	              // Stop doing this check once secondaryNav is found in path
	              if (result.valid && result.navItem.secondaryNav && !showBreadCrumbs) {
	                showBreadCrumbs = true;
	              }
	
	              // Only build breadcrumbs if result is valid and secondaryNav already found in item in navPath
	              if (result.valid && showBreadCrumbs) {
	                index++;
	                var decodedValue = decodeURIComponent(angular.copy(result.label));
	                crumbList[count++] = { path: result.path, label: decodedValue, params: params, clickable: result.clickable, id: result.navItem.id };
	              }
	            }
	          }
	        });
	        return crumbList;
	      }
	
	      function validateCrumb(navItem, params) {
	        var returnObj = {};
	        var label;
	        if (navItem) {
	          if (navItem.label && navItem.label.indexOf('{') > -1 && navItem.label.indexOf('{') > -1) {
	            label = $filter('interpolate')(navItem.label, params);
	          }
	
	          returnObj = populateReturnObject(true, navItem, navItem.path, null, label);
	        }
	        return returnObj;
	      }
	
	      scope.getValidLabel = function (crumb) {
	        if (crumb.label.indexOf('{{') > -1) {
	          crumb.label = crumb.label.replace(/{|}/g, '');
	        }
	        return crumb.label;
	      };
	
	      /**
	       *  Invoke method when breadCrumb is clicked, specified in markup : fisMethod
	       */
	      scope.clickCrumb = function (crumb) {
	        scope.clickFn({ crumb: crumb });
	      };
	
	      var minNavLevel = 1;
	
	      if (!_.isUndefined(attrs.fisMinimumNavLevel)) {
	        minNavLevel = attrs.fisMinimumNavLevel;
	      }
	
	      var shellIntegrated = false;
	      if (attrs.fisInShell && attrs.fisInShell === 'true') {
	        shellIntegrated = true;
	      }
	
	      var breadCrumbElement = elem.find('.breadcrumbs');
	      fisUniqueIdService.generateUniqueIdForce(scope, angular.element(breadCrumbElement), {}, 'breadcrumbs');
	
	      var watchFunction = function watchFunction() {
	        if (_.isObject(scope.fisViewPanel())) {
	          return { path: scope.fisViewPanel().path, title: scope.fisViewPanel().title, navItem: scope.fisViewPanel().navItem, params: scope.fisViewPanel().params };
	        } else if (!_.isObject(scope.fisViewPanel()) && _.isString(scope.fisPath())) {
	          return { path: scope.fisPath() };
	        }
	      };
	      var watchFunct = scope.$watch(watchFunction, function (newVal) {
	        if (!_.isUndefined(newVal)) {
	          var navItem;
	          var navItems = [];
	          if (!newVal.navItem) {
	            // eslint-disable-line no-negated-condition
	            navItem = scope.navItemFn({ pathElement: newVal.path });
	            navItems = findParentHierarchy(navItem);
	          } else {
	            navItems = findParentHierarchy(newVal.navItem);
	          }
	
	          scope.crumbs = buildCrumbs(navItems, newVal.params, minNavLevel);
	
	          // event will only be fired when breadcrumbs is part of the shell
	          // reason : so that breadCrumb container in the shell can make the necessary style changes needed
	          if (shellIntegrated) {
	            if (scope.crumbs && scope.crumbs.length > 0) {
	              fisPubSubService.publish('fisBreadcrumbsPresent', {});
	            } else {
	              fisPubSubService.publish('fisBreadcrumbsRemoved', {});
	            }
	          }
	        }
	      }, true);
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, watchFunct);
	
	      function findParentHierarchy(navItem) {
	        var items = [];
	        var orderedItems = [];
	
	        if (navItem) {
	          items.push(navItem);
	          var path = navItem.unresolvedPath ? navItem.unresolvedPath : navItem.path;
	          if (path) {
	            var parentPath = path.substring(0, path.lastIndexOf('/'));
	            while (parentPath) {
	              var parentItem = scope.navItemFn({ pathElement: parentPath });
	              if (parentItem) {
	                items.push(parentItem);
	              }
	              parentPath = parentPath.substring(0, parentPath.lastIndexOf('/'));
	            }
	
	            for (var i = items.length - 1; i >= 0; i--) {
	              orderedItems.push(items[i]);
	            }
	          }
	        }
	        return orderedItems;
	      }
	
	      fisPubSubService.subscribe('fisViewPanelClosed', function () /* params */{
	        if (scope.$parent.viewPanels() && scope.$parent.viewPanels().length === 0) {
	          scope.crumbs = null;
	          fisPubSubService.publish('fisBreadcrumbsRemoved', {});
	        }
	      });
	    }
	  };
	}];
	
	__webpack_require__(/*! ./breadcrumb.styles.less */ 20);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 20 */
/*!******************************************************!*\
  !*** ./components/breadcrumb/breadcrumb.styles.less ***!
  \******************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 21 */
/*!*****************************************************************!*\
  !*** ./components/breadcrumb/breadcrumb-container.directive.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisPubSubService", "fisConfig", "fisViewPanelService", function (fisPubSubService, fisConfig, fisViewPanelService) {
	  'ngInject';
	
	  return {
	    restrict: 'ACE',
	
	    transclude: true,
	
	    scope: true,
	
	    // eslint-disable-next-line no-multi-str
	    template: '<div class="breadcrumb-container" ng-if="showCrumbs()">\
	                            <div ng-transclude></div>\
	                       </div>',
	
	    link: function link(scope) {
	      scope.showBreadcrumbs = true;
	      if (fisConfig && fisConfig.shell && fisConfig.shell.fisShell) {
	        scope.showBreadcrumbs = fisConfig.shell.fisShell.showBreadcrumbs;
	      }
	      if (scope.showBreadcrumbs) {
	        fisPubSubService.subscribe('fisBreadcrumbsPresent', function () {
	          scope.addClass('fis-breadcrumb-container-present');
	        });
	
	        fisPubSubService.subscribe('fisBreadcrumbsRemoved', function () {
	          scope.removeClass('fis-breadcrumb-container-present');
	        });
	      }
	      scope.addClass = function (classToAdd) {
	        var body = angular.element('body');
	        body.addClass(classToAdd);
	      };
	
	      scope.removeClass = function (classToRemove) {
	        var body = angular.element('body');
	        body.removeClass(classToRemove);
	      };
	
	      scope.showCrumbs = function () {
	        var activePanel = fisViewPanelService.activeViewPanel();
	        if (activePanel) {
	          // check for secondary navigation
	          var parent = fisViewPanelService._getSecondaryNavParent(activePanel.path);
	          // eslint-disable-next-line eqeqeq
	          if (parent && (parent.secondaryNav == 'menubar' || parent.secondaryNav == 'dropdown') && activePanel.parentTitle == parent.label && activePanel.id != parent.id) {
	            if ('breadcrumbs' in activePanel) {
	              if (activePanel.breadcrumbs !== false && activePanel.breadcrumbs !== true) {
	                return scope.showBreadcrumbs;
	              }
	              if (activePanel.breadcrumbs === false) {
	                scope.removeClass('fis-breadcrumb-container-present');
	              } else {
	                scope.addClass('fis-breadcrumb-container-present');
	              }
	              return activePanel.breadcrumbs;
	            }
	          }
	        }
	        return scope.showBreadcrumbs;
	      };
	    }
	  };
	}];
	
	__webpack_require__(/*! ./breadcrumb-container.styles.less */ 22);

/***/ }),
/* 22 */
/*!****************************************************************!*\
  !*** ./components/breadcrumb/breadcrumb-container.styles.less ***!
  \****************************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 23 */
/*!*******************************************!*\
  !*** ./components/content-frame/index.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _contentFrame = __webpack_require__(/*! ./content-frame.directive */ 24);
	
	var _contentFrame2 = _interopRequireDefault(_contentFrame);
	
	var _stretchToBottom = __webpack_require__(/*! ./stretch-to-bottom.directive */ 26);
	
	var _stretchToBottom2 = _interopRequireDefault(_stretchToBottom);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.content-frame', []);
	
	ngModule.directive('fisContentFrame', _contentFrame2.default);
	ngModule.directive('fisStretchToBottom', _stretchToBottom2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 24 */
/*!*************************************************************!*\
  !*** ./components/content-frame/content-frame.directive.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$sce", function ($sce) {
	  'ngInject';
	
	  return {
	    template: '<iframe fis-unique-id ng-src="{{getTrustedURL()}}" fis-stretch-to-bottom ></iframe>',
	    restrict: 'A',
	    replace: true,
	    link: function link(scope, element, attrs) {
	      element.addClass('fis-content-frame');
	      scope.getTrustedURL = function () {
	        return $sce.trustAsResourceUrl(attrs.fisSrc);
	      };
	    }
	  };
	}];
	
	__webpack_require__(/*! ./content-frame.styles.less */ 25);

/***/ }),
/* 25 */
/*!************************************************************!*\
  !*** ./components/content-frame/content-frame.styles.less ***!
  \************************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 26 */
/*!*****************************************************************!*\
  !*** ./components/content-frame/stretch-to-bottom.directive.js ***!
  \*****************************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$window", "$timeout", "fisPubSubService", function ($window, $timeout, fisPubSubService) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    require: '?fisReinit',
	    replace: false,
	    link: function link(scope, element, attrs, fisReinit) {
	      var shellSizes = scope.shell && scope.shell.sizes || scope.$parent && scope.$parent.shell && scope.$parent.shell.sizes || {};
	      function calc() {
	        var elemOffset = element.offset();
	        // Offset Object contains only zero's if object is not visible
	        var isZeroZero = elemOffset.top === 0 && elemOffset.left === 0;
	        if (!isZeroZero) {
	          if (elemOffset.top < shellSizes.windowHeight) {
	            // outerHeight setter takes padding and borders into account; we have to handle margin bottom on our own
	            // margin top is handled in the offset, as offset.top does not pay attention to margin-top
	            var bottomMargin = parseInt(element.css('margin-bottom'), 10);
	            // TODO magic value 10, needs to be investigated
	            // changed value 10 to 20 to accomodate theme differences SDHTML-8606
	            var newHeight = shellSizes.windowHeight - elemOffset.top - shellSizes.footerHeight - bottomMargin - 20;
	            element.outerHeight(newHeight);
	            // Commented out as it breaks stretchToBottom SDHTML-14243
	            // element.addClass('stretched-to-bottom'); // Add indicator class
	          } else {
	            element.removeClass('stretched-to-bottom'); // Remove indicator class
	          }
	        }
	      }
	
	      if (fisReinit) {
	        fisReinit.trigger = function () {
	          // Wait for the $digest cycle to be over
	          $timeout(function () {
	            calc();
	          });
	        };
	      }
	
	      // When the page first loads the the Kendo Splitter widget
	      // doesn't intialize - initialize it manually
	      // Please see bug SDHTML-12463
	      // setTimeout somehow actions this - ommiting it somehow doesn't
	      // make it work, needs to be investigated
	      setTimeout(function () {
	        if (element.attr('class') && element.attr('class').split(' ').indexOf('k-splitter') != -1) {
	          // eslint-disable-line eqeqeq
	          element.data('kendoSplitter').resize();
	        }
	      }, 0);
	
	      var unsub = fisPubSubService.subscribe('shell.sizeChange', function (sizes) {
	        // Catches it if the sizes is 0
	        if (Object.keys(sizes).length != 0) {
	          // eslint-disable-line eqeqeq
	          shellSizes = sizes;
	        }
	        if (Object.keys(shellSizes).length != 0) {
	          // eslint-disable-line eqeqeq
	          calc();
	        }
	      });
	
	      scope.$on('$destroy', function () {
	        unsub();
	      });
	
	      /**
	       * Recalculate the height of the directive on this specific event.
	       * It may be used by other directives managing content display
	       * E.g. TabbedComponentList to ensure proper applied height to tab content,
	       * when as new tab has been selected
	       */
	      scope.$on('stretchToBottom', calc);
	
	      // SDHTML-17169
	      scope.$on('$panelContentLoaded', function () {
	        calc();
	        fisPubSubService.publish('shell.sizeChange', {});
	      });
	
	      // Messages container messages changed. As the messages are displayed above the actual content
	      // this influences the available height for the directive
	      scope.$watch('messages', calc);
	    }
	  };
	}];

/***/ }),
/* 27 */
/*!*****************************************************!*\
  !*** ./components/dropdown-secondary-menu/index.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _dropdownSecondaryMenu = __webpack_require__(/*! ./dropdown-secondary-menu.component */ 28);
	
	var _dropdownSecondaryMenu2 = _interopRequireDefault(_dropdownSecondaryMenu);
	
	var _dropdownSecondaryMenu3 = __webpack_require__(/*! ./dropdown-secondary-menu.directive */ 29);
	
	var _dropdownSecondaryMenu4 = _interopRequireDefault(_dropdownSecondaryMenu3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.dropdown-secondary-menu', []);
	
	ngModule.component('fisDropdownSecondaryMenu', _dropdownSecondaryMenu2.default);
	ngModule.directive('fisDropdownSecondaryMenuDirective', _dropdownSecondaryMenu4.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 28 */
/*!*********************************************************************************!*\
  !*** ./components/dropdown-secondary-menu/dropdown-secondary-menu.component.js ***!
  \*********************************************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/* global $ */
	/**
	 * @name fisDropdownSecondaryMenu
	 */
	
	exports.default = {
	  // eslint-disable-next-line no-multi-str
	  template: '<div fis-dropdown-secondary-menu-directive="$ctrl.toggled">\
	        <div class="dropdown-toggle masthead-title fis-dropdown-toggle" ng-click="$ctrl.toggleDropdownMenu($event)">\
	            <i ng-if="$ctrl.item.icon" class="{{$ctrl.item.icon}}"></i>\
	            <span>{{$ctrl.item.label}}</span>\
	            <b class="caret"></b>\
	       </div>\
	       <div ng-if="$ctrl.isResponsive" style="display:none;">\
	            <ul class="accordion fis-off-canvas-top-bar">\
	                <li class="accordion-group leaf collapsed" ng-repeat="child in $ctrl.item.children">\
	                   <a href="">\
	                        <div fis-unique-id ng-if="child.partial"  ng-class="{ \'fis-dropdown-set-underline\' : child.underlineClass == true}" ng-click="$ctrl.openChild(child, false)"><span></span>{{child.label}}</div>\
	                    </a>\
	               </li>\
	            </ul>\
	        </div>\
	       <div ng-if="!$ctrl.isResponsive" fis-unique-id="{{$ctrl.item.id}}_masthead" style="position:fixed; top:inherit; left:inherit" class="dropdown-menu masthead-nowrap fis-tabs-bar-dropdown">\
	           <ul class="masthead">\
	               <li ng-repeat="child in $ctrl.item.children">\
	                   <a href="">\
	                        <div fis-unique-id ng-if="child.partial"  ng-class="{ \'fis-dropdown-set-underline\' : child.underlineClass == true}" ng-click="$ctrl.openChild(child, false)"><span></span>{{child.label}}</div>\
	                    </a>\
	               </li>\
	           </ul>\
	       </div></div>',
	  bindings: {
	    item: '<fisNavItem'
	  },
	  controller: ['fisPubSubService', 'fisViewService', 'fisViewPanelService', 'fisResponsiveService', 'fisTabsBarService', function (fisPubSubService, fisViewService, fisViewPanelService, fisResponsiveService, fisTabsBarService) {
	    var ctrl = this;
	
	    ctrl.$onInit = function () {
	      ctrl.isResponsive = fisResponsiveService.isResponsive();
	      checkUnderlineStyling();
	      fisPubSubService.subscribe('fisResponsiveService.isResponsive', function (isResponsive) {
	        ctrl.isResponsive = isResponsive;
	      });
	    };
	
	    function checkUnderlineStyling() {
	      var currentActivePanel = fisViewPanelService.activeViewPanel();
	
	      angular.forEach(ctrl.item.children, function (value) {
	        if (value.path == currentActivePanel.path) {
	          // eslint-disable-line eqeqeq
	          value.underlineClass = true;
	        } else {
	          // eslint-disable-line brace-style
	          value.underlineClass = false;
	        }
	      });
	    }
	
	    function hideDropDown(dropdown) {
	      if (dropdown) {
	        dropdown.hide();
	        fisTabsBarService.openedDropDown = undefined;
	      }
	    }
	
	    function showDropDown(dropdown) {
	      if (dropdown) {
	        dropdown.show();
	        fisTabsBarService.openedDropDown = dropdown;
	      }
	    }
	
	    $(document).on('click', function () {
	      hideDropDown(fisTabsBarService.openedDropDown);
	    });
	
	    ctrl.toggled = false;
	    ctrl.toggleDropdownMenu = function (event) {
	      if (event) {
	        event.stopPropagation();
	        var toggle = angular.element(event.currentTarget);
	        var dropdown = toggle.next();
	        var isVisible = dropdown.is(':visible');
	        if (isVisible) {
	          hideDropDown(dropdown);
	        } else {
	          hideDropDown(fisTabsBarService.openedDropDown);
	          showDropDown(dropdown);
	        }
	      }
	
	      ctrl.toggled = !ctrl.toggled;
	    };
	
	    ctrl.openChild = function (child, event) {
	      fisViewPanelService.open(child.path, event);
	
	      child.underlineClass = true;
	      angular.forEach(ctrl.item.children, function (value) {
	        if (value.path != child.path) {
	          // eslint-disable-line eqeqeq
	          value.underlineClass = false;
	        }
	      });
	    };
	  }]
	};

/***/ }),
/* 29 */
/*!*********************************************************************************!*\
  !*** ./components/dropdown-secondary-menu/dropdown-secondary-menu.directive.js ***!
  \*********************************************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return {
	    link: function link(scope, element, attr) {
	      scope.$watch(attr.fisDropdownSecondaryMenuDirective, function () {
	        // Aligning the dropdown menu with the parent Dropdown Item. SDHTML-13147
	        var leftOffset = element.offset().left;
	        var parentTabPadding = element.closest('.fis-tab-container').css('padding-left');
	        var totalLeft = leftOffset - parseInt(parentTabPadding); // eslint-disable-line radix
	        element.find('.dropdown-menu').offset({ left: totalLeft });
	      });
	    }
	  };
	};

/***/ }),
/* 30 */
/*!****************************************!*\
  !*** ./components/footer-bar/index.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _footerBar = __webpack_require__(/*! ./footer-bar.directive */ 31);
	
	var _footerBar2 = _interopRequireDefault(_footerBar);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.footer-bar', []);
	
	ngModule.directive('fisFooterBar', _footerBar2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 31 */
/*!*******************************************************!*\
  !*** ./components/footer-bar/footer-bar.directive.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisCurrentYearService", "$rootScope", "fisPubSubService", "$filter", "fisConfig", function (fisCurrentYearService, $rootScope, fisPubSubService, $filter, fisConfig) {
	  'ngInject';
	
	  return {
	    // eslint-disable-next-line no-multi-str
	    template: '\
	      <div class="row">\
	        <div class="fis-footer-bar" ng-class="{ \'fis-collapsible\': viewModel.collapsible === true }">\
	              <div class="inner-footer">\
	                  <div class="col-sm-5 col-md-6 col-lg-6"><span class="fis-copyright" href="#"  ng-bind-html="viewModel.copyright" ></span></div>\
	                  <div class="col-sm-7 col-md-6 col-lg-6"><div class="fis-controls" ng-transclude></div></div>\
	              </div>\
	            </div>\
	        </div>',
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    scope: {
	      copyright: '@',
	      fisSticky: '@',
	      fisCollapsible: '@'
	    },
	    controller: ['$scope', function ($scope) {
	      $scope.viewModel = {
	        collapsible: false,
	        copyright: '',
	        sticky: true,
	        config: {
	          sticky: undefined,
	          collapsible: undefined
	        }
	      };
	
	      var vm = $scope.viewModel;
	
	      $scope.$watch('copyright', function (newValue) {
	        vm.copyright = $filter('interpolate')(newValue, [fisCurrentYearService]);
	      });
	
	      function stringToBoolean(string) {
	        switch (string.toLowerCase()) {
	          case 'true':case 'yes':case '1':
	            return true;
	          case 'false':case 'no':case '0':case null:
	            return false;
	          default:
	            return Boolean(string);
	        }
	      }
	
	      if (!angular.isUndefined(fisConfig && fisConfig.widgets)) {
	        var widgets = fisConfig.widgets;
	
	        if (!angular.isUndefined(widgets.fisFooterBar)) {
	          var footerConfig = widgets.fisFooterBar;
	          if (!angular.isUndefined(footerConfig.isSticky)) {
	            vm.config.sticky = vm.sticky = _.isBoolean(footerConfig.isSticky) ? footerConfig.isSticky : stringToBoolean(footerConfig.isSticky);
	          }
	          if (!angular.isUndefined(footerConfig.isCollapsible)) {
	            vm.config.collapsible = vm.collapsible = _.isBoolean(footerConfig.isCollapsible) ? footerConfig.isCollapsible : stringToBoolean(footerConfig.isCollapsible);
	          }
	        }
	      }
	    }],
	    link: function link(scope, elm, attrs) {
	      var vm = scope.viewModel;
	
	      attrs.$observe('fisSticky', function (x) {
	        vm.sticky = _.isUndefined(vm.sticky) && x && x.toString().toLowerCase() === 'false' ? false : true; // eslint-disable-line no-unneeded-ternary
	      });
	
	      attrs.$observe('fisCollapsible', function (x) {
	        vm.collapsible = _.isUndefined(vm.collapsible) && x && x.toString().toLowerCase() === 'true' ? true : false; // eslint-disable-line no-unneeded-ternary
	      });
	
	      function processFooter() {
	        if (!vm.sticky) {
	          // eslint-disable-line no-negated-condition
	          var viewPanel = angular.element('div.fis-view-panel');
	
	          if (viewPanel) {
	            var currentTabs = viewPanel.children('div:not(.fis-info-panel)');
	            var currentTab = null;
	
	            if (currentTabs.length > 0) {
	              currentTab = currentTabs[scope.$parent.activeViewPanelIndex()];
	
	              if (currentTab) {
	                // /This condition may change in future once we create our own directive for iframe
	                if (angular.element(currentTab).find('iframe').length > 0) {
	                  elm.parent().css('position', 'fixed');
	                } else {
	                  // eslint-disable-line brace-style
	                  elm.parent().css('position', 'relative');
	                }
	              }
	            }
	          }
	        } else {
	          // eslint-disable-line brace-style
	          if (elm.length > 0) {
	            // eslint-disable-line no-lonely-if
	            elm.parent().css('position', 'fixed');
	          }
	        }
	      }
	
	      scope.$watch('viewModel.sticky', function (newValue) {
	        processFooter();
	
	        if (newValue) {
	          $('body').addClass('fis-footer-sticky');
	        } else {
	          $('body').removeClass('fis-footer-sticky');
	        }
	      });
	
	      scope.$watch('viewModel.collapsible', function (newValue) {
	        if (newValue) {
	          $('body').addClass('fis-footer-collapsible');
	        } else {
	          $('body').removeClass('fis-footer-collapsible');
	        }
	      });
	
	      fisPubSubService.subscribe('fisActiveViewPanelChanged', function () {
	        processFooter();
	      });
	
	      $rootScope.$on('$viewContentLoaded', function () {
	        processFooter();
	      });
	
	      if (scope.$parent.registerFooter) {
	        scope.$parent.registerFooter(elm);
	      }
	    }
	  };
	}];
	
	__webpack_require__(/*! ./footer-bar.styles.less */ 32);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 32 */
/*!******************************************************!*\
  !*** ./components/footer-bar/footer-bar.styles.less ***!
  \******************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 33 */
/*!*****************************************!*\
  !*** ./components/footer-menu/index.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _footerMenu = __webpack_require__(/*! ./footer-menu.directive */ 34);
	
	var _footerMenu2 = _interopRequireDefault(_footerMenu);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.footer-menu', []);
	
	ngModule.directive('fisFooterMenu', _footerMenu2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 34 */
/*!*********************************************************!*\
  !*** ./components/footer-menu/footer-menu.directive.js ***!
  \*********************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "fisPubSubService", function ($compile, fisPubSubService) {
	  'ngInject';
	
	  return {
	    // eslint-disable-next-line no-multi-str
	    template: '<ul class="navbar-nav nav pull-right">\
	                            <li ng-repeat="item in topLevelFooterItems" ng-class="{dropdown : item.children}">\
	                      <a ng-if="!item.children && (item.action || item.partial || item.controller)" href="" tabindex="-1">\
	                      <i ng-if="item.icon" class="{{item.icon}}"></i>\
	                                <div fis-unique-id ng-if="item.partial" ng-click="open(item.path, $event)"><span ng-bind-html="getValidLabel(item)"></span>\
	                                </div>\
	                                <div ng-if="!item.partial" fis-unique-id><span ng-bind-html="getValidLabel(item)"></span>\
	                                </div></a>\
	                      <span class="noLinkSpan" ng-if="!(item.action || item.partial || item.controller)" fis-unique-id ng-bind-html="getValidLabel(item)"></span>\
	                    </li>\
	                  </ul>',
	    restrict: 'EA',
	    replace: true,
	    controller: ['$scope', '$controller', function ($scope) {
	      var itm; // eslint-disable-line no-unused-vars
	      $scope.getValidLabel = function (item) {
	        if (item.label && item.label.indexOf('{{') > -1) {
	          item.label = item.label.replace(/{|}/g, '');
	        }
	        return item.label;
	      };
	      $scope.hasDynamicAction = function (item) {
	        itm = item;
	        return !item.partial && item.actionController && item.action;
	      };
	
	      fisPubSubService.subscribe('shell.navReady', function (nav) {
	        $scope.topLevelFooterItems = nav.footer;
	      }, true);
	
	      fisPubSubService.subscribe('shell.navChanged', function (nav) {
	        $scope.topLevelFooterItems = nav.footer;
	      }, true);
	    }],
	
	    link: function link(scope, element) {
	      scope.$watch('topLevelFooterItems', function (newVal, oldVal) {
	        if (newVal !== oldVal) {
	          var children = element.children();
	          angular.forEach(children, function (childObj) {
	            var child = angular.element(childObj);
	            var childScope = child.scope();
	            var item = childScope.item;
	            // if cls is provided to the navigation item or if it has actionController, compile the element after adding the cls as class
	            if (item.cls || item.actionController) {
	              if (item.cls) {
	                child.addClass(item.cls);
	              }
	              if (item.actionController) {
	                child.attr('ng-controller', item.actionController);
	                child.attr('ng-click', item.action);
	              }
	              // ng-repeat is removed to avoid repeating the <li> element while re-compiling
	              child.removeAttr('ng-repeat');
	              $compile(child)(childScope);
	            }
	          });
	        }
	      });
	    }
	  };
	}];

/***/ }),
/* 35 */
/*!*****************************************!*\
  !*** ./components/insert-view/index.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _insertView = __webpack_require__(/*! ./insert-view.directive */ 36);
	
	var _insertView2 = _interopRequireDefault(_insertView);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.insert-view', []);
	
	ngModule.directive('fisInsertView', _insertView2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 36 */
/*!*********************************************************!*\
  !*** ./components/insert-view/insert-view.directive.js ***!
  \*********************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisViewService", function (fisViewService) {
	  'ngInject';
	
	  return {
	    template: '<div ng-controller="ctrlr" ng-include="view.partial"></div>',
	    restrict: 'AE',
	    scope: true,
	    controller: ['$scope', '$attrs', '$element', '$parse', '$controller', function ($scope, $attrs, $element, $parse, $controller) {
	      var view = $attrs.fisInsertView;
	      // parse the object if it is not a String indicating navigation path
	      if (angular.isString($attrs.fisInsertView) && $attrs.fisInsertView.indexOf('/') === -1) {
	        view = $parse($attrs.fisInsertView)($scope);
	      }
	
	      if (angular.isObject(view)) {
	        $scope.view = view;
	      } else if (angular.isString(view)) {
	        // if navigation path is provided, get the item from path
	        $scope.view = fisViewService.getItemFromPath2Item(view);
	      }
	
	      if (!$scope.view.partial) {
	        throw new Error('Invalid View "' + $scope.view.id + '". It does not have a partial.');
	      }
	
	      if ($scope.view && $scope.view.args) {
	        $scope.args = $scope.view.args;
	        $scope.viewArgs = $scope.args;
	      }
	
	      /* The approach of attaching the ng-controller attribute and then $compile the element is not followed
	      here because the template has a single element and re-compiling the element results in execution of the
	      controller code in a continuous loop*/
	      $scope.ctrlr = function () {
	        if ($scope.view.controller && $scope.args) {
	          return $controller($scope.view.controller, { $scope: $scope, args: $scope.args }); // args must be exposed on object to make it accessible to constructor.
	        } else if ($scope.view.controller) {
	          return $controller($scope.view.controller, { $scope: $scope });
	        }
	        return angular.noop;
	      };
	    }]
	  };
	}];

/***/ }),
/* 37 */
/*!*********************************************!*\
  !*** ./components/navigation-link/index.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _navigationLink = __webpack_require__(/*! ./navigation-link.directive */ 38);
	
	var _navigationLink2 = _interopRequireDefault(_navigationLink);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.navigation-link', []);
	
	ngModule.directive('fisNavigationLink', _navigationLink2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 38 */
/*!*****************************************************************!*\
  !*** ./components/navigation-link/navigation-link.directive.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var ddo = {
	    replace: true,
	    restrict: 'A',
	    scope: true,
	    // eslint-disable-next-line no-multi-str
	    template: '\
	            <span class="fis-navigation-link">\
	                <span ng-if="viewModel.hasAction">\
	                    <span ng-if="viewModel.hasActionController" ng-controller="viewModel.getActionController" class="fis-dynamic-action">\
	                        <a href="" title="{{ fisModel.title }}" ng-click="executeAction(fisModel.action)">{{viewModel.label}}</a>\
	                    </span>\
	                    <span ng-if="!viewModel.hasActionController" ng-class="{ \'fis-dynamic-action\': fisModel.action }">\
	                        <a href="" title="{{ fisModel.title }}" ng-click="executeAction(fisModel.action)">{{viewModel.label}}</a>\
	                    </span>\
	                </span>\
	                <span ng-if="!viewModel.hasAction">\
	                    <span>\
	                        <a href="" title="{{ fisModel.title }}" ng-click="navigateToPath($event)">{{viewModel.label}}</a>\
	                    </span>\
	                </span>\
	            </span>',
	    controller: ['$scope', '$controller', '$filter', '$element', '$attrs', '$transclude', '$compile', 'fisAltMenu', '$timeout', function ($scope, $controller, $filter, $element, $attrs, $transclude, $compile, fisAltMenu) {
	      $scope.fisModel = null;
	      $scope.viewModel = {
	        _actionControlle: {},
	        getActionController: function getActionController() {
	          return $scope.viewModel._actionController;
	        },
	        hasAction: false,
	        hasActionController: false,
	        hasParams: false,
	        hasPartial: true
	      };
	
	      function setController(item, controller) {
	        var locals = {
	          $scope: $scope,
	          $element: $element,
	          $attrs: $attrs,
	          $transclude: $transclude
	        };
	
	        item._actionController = $controller(controller, locals);
	      }
	
	      $scope.$watch('fisModel.actionController', function (newValue) {
	        $scope.viewModel.hasActionController = !_.isUndefined(newValue) && newValue !== null;
	
	        if ($scope.viewModel.hasActionController) {
	          setController($scope.viewModel, newValue);
	        }
	      });
	
	      // note case SDHTML-6379 - if no action controller, this is not relevant - so no alt-click interceptor
	      $scope.executeAction = function (action) {
	        $scope.$eval(action);
	        if ($scope.fisNavigationLinkClicked) {
	          $scope.fisNavigationLinkClicked();
	        }
	      };
	
	      $scope.navigateToPath = function (e) {
	        // This function can be defined anywhere in the scope hierarchy.
	        // If it is found, it will be used.
	        if (e.altKey) {
	          fisAltMenu.showAltMenu($element, $scope.fisModel, $scope, e);
	          e.preventDefault();
	          e.stopPropagation();
	        } else {
	          // eslint-disable-line brace-style
	          if ($scope.fisNavigationLinkClicked) {
	            $scope.fisNavigationLinkClicked();
	          }
	          $scope.open($scope.fisModel.path, e);
	        }
	      };
	
	      $scope.$watch('fisModel.action', function (newValue) {
	        $scope.viewModel.hasAction = !_.isUndefined(newValue);
	      });
	
	      $scope.$watch('fisModel.label', function (newValue) {
	        $scope.viewModel.label = newValue;
	      });
	
	      $scope.$watch('fisModel.params', function (newValue) {
	        $scope.viewModel.hasParams = !_.isUndefined(newValue) && newValue !== null;
	      });
	
	      $scope.$watch('fisModel.partial', function (newValue) {
	        $scope.viewModel.hasPartial = !_.isUndefined(newValue);
	      });
	    }],
	    link: function link(scope, element, attrs) {
	      scope.$watch(attrs.fisModel, function (newValue) {
	        scope.fisModel = newValue;
	      });
	
	      if (attrs.fisClicked) {
	        scope.$watch(attrs.fisClicked, function (newValue) {
	          scope.fisClicked = newValue;
	        });
	      }
	    }
	  };
	
	  return ddo;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 39 */
/*!*********************************************!*\
  !*** ./components/off-canvas-menu/index.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _offCanvasMenu = __webpack_require__(/*! ./off-canvas-menu.directive */ 40);
	
	var _offCanvasMenu2 = _interopRequireDefault(_offCanvasMenu);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.off-canvas-menu', []);
	
	ngModule.directive('fisOffCanvasMenu', _offCanvasMenu2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 40 */
/*!*****************************************************************!*\
  !*** ./components/off-canvas-menu/off-canvas-menu.directive.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return {
	    restrict: 'EA',
	    replace: true,
	    // eslint-disable-next-line no-multi-str
	    template: '<ul class="fis-off-canvas-menu accordion">\
	                <li fis-hierarchy="item in startMenuModel.menuItems.children" ng-show="item.showOffCanvas" ng-class="getItemStateClasses(item, $index)" ng-click="toggleItem(item, $index);$event.stopPropagation();">\
	                    <span ng-if="item.children.length > 0" ng-click="toggleItem(item, $index);$event.stopPropagation();">{{item.view.label}}</span>\
	                    <div ng-if="item.children.length === 0" title="{{item.view.title}}" class="accordion-toggle"><div fis-navigation-link fis-model="item.view"></div></div>\
	                </li>\
	              </ul>',
	    scope: true,
	    controller: ['$scope', function ($scope) {
	      $scope.currentItemId = null;
	      $scope.currentItem = null;
	      $scope.expandedItems = {};
	      $scope.menuIndexer = 0;
	
	      $scope.open = $scope.$parent.open;
	
	      $scope.collapseItem = function (item) {
	        delete $scope.expandedItems[item.view.path];
	        if (item.children instanceof Array) {
	          item.children.forEach(function (i) {
	            $scope.collapseItem(i);
	          });
	        }
	      };
	
	      $scope.toggleItem = function (item) {
	        if (item.children instanceof Array && item.children.length > 0) {
	          if ($scope.expandedItems[item.view.path]) {
	            $scope.collapseItem(item);
	            delete $scope.expandedItems[item.view.path];
	          } else {
	            $scope.expandedItems[item.view.path] = true;
	            // $scope.collapseOtherItems(item);
	          }
	        }
	      };
	
	      $scope.getItemStateClasses = function (item) {
	        var classes = [];
	
	        if (item) {
	          classes.push(_.size(item.children) === 0 ? 'leaf' : 'branch');
	          classes.push($scope.expandedItems[item.view.path] ? 'expanded' : 'collapsed');
	          classes.push($scope.currentItemId === item.view.path ? 'current' : '');
	        }
	
	        return classes.join(' ').trim();
	      };
	    }]
	  };
	};
	
	__webpack_require__(/*! ./off-canvas-menu.styles.less */ 41);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 41 */
/*!****************************************************************!*\
  !*** ./components/off-canvas-menu/off-canvas-menu.styles.less ***!
  \****************************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 42 */
/*!***********************************!*\
  !*** ./components/shell/index.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _shell = __webpack_require__(/*! ./shell.directive */ 43);
	
	var _shell2 = _interopRequireDefault(_shell);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.shell', []);
	
	ngModule.directive('fisShell', _shell2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 43 */
/*!*********************************************!*\
  !*** ./components/shell/shell.directive.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisConfig", function (fisConfig) {
	  'ngInject';
	
	  function getPartsToDisplay(fisWith) {
	    if (!fisWith) {
	      // this should not change for backward compatibility
	      return {
	        header: true,
	        nav: true,
	        views: true,
	        sidebar: true,
	        footer: true
	      };
	    }
	    var ret = {};
	    _.each(fisWith.split(/[, ]/), function (val) {
	      val = angular.element.trim(val).toLowerCase();
	      if (val) {
	        ret[val] = true;
	      }
	    });
	    return ret;
	  }
	
	  return {
	    restrict: 'ACE',
	    replace: true,
	    transclude: true,
	    scope: false,
	    template: function template(tElement, tAttrs) {
	      // eslint-disable-next-line no-multi-str, no-negated-condition
	      return '<div class="app" ' + (tAttrs.fisNoController !== undefined ? '' : 'ng-controller="fis.shell.Controller"') + '>\
	                    <header role="banner">\
	                    <div id="skipMainContent">\
	                        <a href="#mainContent">Skip to main Content</a>\
	                    </div>\
	                        <div fis-hotkey="f5" fis-custom-hotkey="false" fis-global="true" ng-click="reloadActivePage()" />\
	                        <div fis-top-bar data-app-title="{{config.appTitle}}" data-cm-guid="{{config.cmGuid}}" data-cm-base-url="{{config.cmBaseUrl}}">\
	                            <div fis-utility-menu></div>\
	                        </div>\
	                    </header>\
	                    <nav role="navigation">\
	                    <div fis-tabs-bar fis-tabs-closing-menu fis-tabs-overflow-menu></div>\
	                    <div fis-breadcrumb-container>\
	                        <div fis-breadcrumb fis-viewpanel="activeViewPanel()" fis-minimum-nav-level="1" fis-method="open(crumb.path, null, crumb.params)" fis-in-shell="true" fis-nav-item-method="findNavItem(pathElement)"></div>\
	                    </div>\
	                </nav>\
	                    <div role="main"  class="container-fluid fis-content-wrapper">\
	                        <div id="mainContent" fis-views="viewPanels()" fis-selected-index="activeViewPanelIndex()" fis-stacked="{{config.preserveState}}"></div>\
	                        <div fis-sidebar fis-mode="{{config.sidebar.mode}}" fis-title="{{config.sidebar.title}}"  fis-position="{{config.sidebar.position}}" fis-width="{{config.sidebar.width}}" fis-minimum-width="{{config.sidebar.minimumWidth}}" fis-maximum-width="{{config.sidebar.maximumWidth}}" fis-enabled="{{config.sidebar.enabled}}" fis-name="{{config.sidebar.name}}" fis-opened= "{{config.sidebar.opened}}" fis-pinned= "{{config.sidebar.pinned}}">\
	                            <fis-sidebar-menu></fis-sidebar-menu>\
	                        </div>\
	                    </div>\
	                    <footer role="contentinfo">\
	                        <div fis-footer-bar data-copyright="&copy; {0} FIS">\
	                            <div fis-footer-menu></div>\
	                        </div>\
	                    </footer>\
	                </div>';
	    },
	    compile: function compile(tElement, tAttrs, transclude) {
	      var children = tElement.children();
	
	      // If a new section is added in the shell, add it below with a value of false
	      // as it will need to be disabled by default for backward compatibility
	      var display = getPartsToDisplay(tAttrs.fisWith);
	
	      // remove content that will not be used so that directives it uses don't get instantiated
	      if (!display.header) {
	        // page author doesn't want to use the default header
	        angular.element(children[0]).empty();
	      }
	      if (!display.nav) {
	        // page author doesn't want to use the default nav
	        angular.element(children[1]).empty();
	      }
	      if (!display.views) {
	        // page author doesn't want to use fisViews
	        angular.element(children[2]).children().first().remove();
	      }
	      if (!display.sidebar) {
	        // page author doesn't want to use fisSidebar
	        angular.element(children[2]).children().last().remove();
	      }
	      if (!display.footer) {
	        // page author doesn't want to use the default footer
	        angular.element(children[3]).empty();
	      }
	
	      return function (scope, element) {
	        var children = element.children();
	        // when something provided, replace appropriate element
	        element.addClass('fis-shell');
	
	        transclude(scope, function (clone) {
	          var elem;
	          if (clone.length > 0) {
	            // if the partial defines children for fis-shell and the appropriate fis-no-* attribute was used,
	            // replace the matching child elements
	            if ((elem = clone.filter('header')).length) {
	              if (display.header) {
	                throw new Error('header provided as child of fis-shell but default header already used');
	              }
	              // page author wants to replace the header
	              angular.element(children[0]).replaceWith(elem);
	            }
	            if ((elem = clone.filter('nav')).length) {
	              if (display.nav) {
	                throw new Error('nav provided as child of fis-shell but default nav already used');
	              }
	              // page author wants to replace the nav
	              angular.element(children[1]).replaceWith(elem);
	            }
	            if ((elem = clone.filter(':not(header):not(footer):not(nav)')).length) {
	              // page author wants to add content inside the shell
	              angular.element(children[2]).prepend(elem);
	            }
	            if ((elem = clone.filter('footer')).length) {
	              if (display.footer) {
	                throw new Error('footer provided as child of fis-shell but default footer already used');
	              }
	              // page author wants to replace the nav
	              angular.element(children[3]).replaceWith(elem);
	            }
	          }
	        });
	
	        var vm;
	
	        vm = {
	          isResponsive: 'always',
	          setByAttribute: false
	        };
	
	        if (!vm.setByAttribute) {
	          if (fisConfig && fisConfig.shell && fisConfig.shell.fisShell) {
	            var x = fisConfig.shell.fisShell.isResponsive;
	            if (x === 'always' || x === 'never' || x === 'by-user-agent') {
	              vm.isResponsive = x;
	              updateResponsive(vm.isResponsive);
	            }
	          }
	        }
	
	        tAttrs.$observe('fisIsResponsive', function (x) {
	          if (x === 'always' || x === 'never' || x === 'by-user-agent') {
	            vm.isResponsive = x;
	            vm.setByAttribute = true;
	            updateResponsive(vm.isResponsive);
	          }
	        });
	
	        function updateResponsive(value) {
	          var b = $('body');
	
	          if (value === 'always') {
	            if (!b.hasClass('fis-responsive-shell')) {
	              b.addClass('fis-responsive-shell');
	            }
	          } else {
	            b.removeClass('fis-responsive-shell');
	          }
	        }
	
	        updateResponsive(vm.isResponsive);
	      };
	    }
	  };
	}];
	
	__webpack_require__(/*! ./shell.styles.less */ 44);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 44 */
/*!********************************************!*\
  !*** ./components/shell/shell.styles.less ***!
  \********************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 45 */
/*!**************************************!*\
  !*** ./components/side-bar/index.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _sidebar = __webpack_require__(/*! ./sidebar.directive */ 46);
	
	var _sidebar2 = _interopRequireDefault(_sidebar);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.side-bar', []);
	
	ngModule.directive('fisSidebar', _sidebar2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 46 */
/*!**************************************************!*\
  !*** ./components/side-bar/sidebar.directive.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisSidebarStateService", "$timeout", "$compile", "fisMemoryUtilService", "fisPubSubService", function (fisSidebarStateService, $timeout, $compile, fisMemoryUtilService, fisPubSubService) {
	  'ngInject';
	
	  var sidebarDefaults = {
	    dragging: false,
	    enabled: false,
	    maximumWidth: 900,
	    minimumWidth: 100,
	    mode: 'click',
	    name: '',
	    opened: false,
	    openingTimeout: null,
	    pinned: false,
	    position: 'right',
	    resizeTimeout: null,
	    title: '',
	    width: 350
	  };
	
	  // Directive Definition Object
	  var ddo = {
	    replace: true,
	    restrict: 'EA',
	    scope: true,
	    // eslint-disable-next-line no-multi-str
	    template: '\
	        <div id="sidebar" fis-unique-id ng-class="{ \'fis-sidebar\':true, \'fis-sidebar-hover\': sidebar.mode === \'hover\', \'fis-sidebar-enabled\': sidebar.enabled, \'fis-sidebar-opened\': sidebar.opened, \'fis-sidebar-right\': sidebar.position === \'right\', \'fis-sidebar-left\': sidebar.position === \'left\', \'fis-sidebar-pinned\': sidebar.pinned }" fis-pub-sub>\
	        <div class="fis-sidebar-toggle-well">\
	            <div class="fis-sidebar-toggle" aria-expanded={{sidebar.opened===true}} ng-click="toggleSidebarClick($event)">\
	            <div class="fis-sidebar-toggle-content">\
	              <span id="caret" fis-unique-id class="fis-sidebar-caret" ng-if="sidebar.position === \'right\'" />\
	              <span class="fis-sidebar-toggle-title">{{sidebar.title}}</span>\
	              <span id="caret" fis-unique-id class="fis-sidebar-caret" ng-if="sidebar.position === \'left\'"  />\
	              </div>\
	            </div>\
	          </div>\
	          <div class="fis-sidebar-content-well" fis-unique-id>\
	          <!--ng-animate="\'fis-sidebar-content-transition\'" ng-show="sidebar.opened"-->\
	                    <div class="fis-sidebar-resize" fis-draggable="true" fis-drag-drop-type="fisSideBar"></div>\
	                        <div class="fis-sidebar-content-well-container">\
	                           <div class="fis-sidebar-content-well-outer">\
	                                 <div class="fis-sidebar-content-well-inner">\
	                                        <div class="fis-sidebar-title-well">\
	                                            <div tabindex={{sidebar.opened===true?0:-1}} aria-pressed={{sidebar.pinned}} class="fis-sidebar-title" ng-click="sidebar.pinned = !sidebar.pinned"><span>{{ sidebar.title }}</span></div>\
	                                            <div tabindex={{sidebar.opened===true?0:-1}} aria-pressed={{sidebar.pinned}} aria-label="pin sidebar" fis-unique-id class="fis-sidebar-pin glyphicon glyphicon-pushpin" ng-click="sidebar.pinned = !sidebar.pinned"></div>\
	                                        </div>\
	                                        <div class="fis-sidebar-content" ng-show="sidebar.opened" ng-transclude></div>\
	                                 </div>\
	                           </div>\
	                      </div>\
	                     </div>\
	        </div>',
	    transclude: true,
	    controller: ['$scope', function ($scope) {
	      $scope.sidebar = {
	        dragging: sidebarDefaults.dragging,
	        enabled: sidebarDefaults.enabled,
	        maximumWidth: sidebarDefaults.maximumWidth,
	        minimumWidth: sidebarDefaults.minimumWidth,
	        mode: sidebarDefaults.mode,
	        name: sidebarDefaults.name,
	        opened: sidebarDefaults.opened,
	        openingTimeout: sidebarDefaults.openingTimeout,
	        pinned: sidebarDefaults.pinned,
	        position: sidebarDefaults.position,
	        resizeTimeout: sidebarDefaults.resizeTimeout,
	        title: sidebarDefaults.title,
	        width: sidebarDefaults.width
	      };
	
	      var sidebarOpened;
	      var sidebarPinned;
	
	      // Watching Dragging
	      $scope.$watch('sidebar.dragging', function (newValue) {
	        if (typeof newValue !== 'boolean') {
	          throw new TypeError('The \'sidebar.dragging\' property was assigned an invalid value.');
	        }
	      });
	
	      // Watching Enabled
	      $scope.$watch('sidebar.enabled', function (newValue) {
	        if (typeof newValue !== 'boolean') {
	          throw new TypeError('The \'sidebar.enabled\' property was assigned an invalid value.');
	        }
	
	        if (newValue === false) {
	          sidebarOpened = $scope.sidebar.opened;
	          sidebarPinned = $scope.sidebar.pinned;
	
	          $scope.sidebar.pinned = false;
	          $scope.sidebar.opened = false;
	        } else {
	          // eslint-disable-line brace-style
	          if (sidebarOpened !== undefined) {
	            $scope.sidebar.opened = sidebarOpened;
	          }
	
	          if (sidebarPinned !== undefined) {
	            $scope.sidebar.pinned = sidebarPinned;
	          }
	        }
	      });
	
	      $scope.$watch('sidebar.maximumWidth', function (newValue) {
	        if (typeof newValue !== 'number') {
	          throw new TypeError('The \'sidebar.maximumWidth\' property was assigned an invalid value.');
	        }
	
	        if ($scope.sidebar.maximumWidth < $scope.sidebar.minimumWidth) {
	          throw new TypeError('The \'sidebar.maximumWidth\' property was assigned a value less than the minimumWidth.');
	        }
	
	        if ($scope.sidebar.width > newValue) {
	          $scope.sidebar.width = newValue;
	        }
	      });
	
	      $scope.$watch('sidebar.minimumWidth', function (newValue) {
	        if (typeof newValue !== 'number') {
	          throw new TypeError('The \'sidebar.minimumWidth\' property was assigned an invalid value.');
	        }
	
	        if ($scope.sidebar.maximumWidth < $scope.sidebar.minimumWidth) {
	          throw new TypeError('The \'sidebar.minimumWidth\' property was assigned a value greater than the maximumWidth.');
	        }
	
	        if ($scope.sidebar.width < newValue) {
	          $scope.sidebar.width = newValue;
	        }
	      });
	
	      // Watching Mode
	      $scope.$watch('sidebar.mode', function (newValue) {
	        if (typeof newValue !== 'string') {
	          // eslint-disable-line no-negated-condition
	          throw new TypeError('The \'sidebar.mode\' property was assigned an invalid value.');
	        } else {
	          newValue = newValue.trim().toLowerCase();
	        }
	
	        if (newValue !== 'click' && newValue !== 'hover') {
	          throw new TypeError('The \'sidebar.mode\' property was assigned an invalid value.');
	        }
	      });
	
	      // Watches Name
	      $scope.$watch('sidebar.name', function (newValue, oldValue) {
	        if (typeof newValue !== 'string') {
	          throw new TypeError('The \'sidebar.name\' property was assigned an invalid value.');
	        }
	
	        if (fisSidebarStateService.registerSidebar) {
	          if (typeof oldValue === 'string') {
	            fisSidebarStateService.unregisterSidebar(oldValue);
	          }
	
	          fisSidebarStateService.registerSidebar(newValue, $scope);
	        } else {
	          throw new Error('Cannot register sidebar - no registerSidebar in service');
	        }
	      });
	
	      // Watching Opened
	      $scope.$watch('sidebar.opened', function (newValue, oldValue) {
	        if (typeof newValue !== 'boolean') {
	          throw new TypeError('The \'sidebar.opened\' property was assigned an invalid value.');
	        }
	
	        $scope.publish('fisSidebarVisibilityChanged', {
	          newValue: newValue,
	          oldValue: oldValue
	        });
	      });
	
	      // Watching Pinned
	      $scope.$watch('sidebar.pinned', function (newValue, oldValue) {
	        if (typeof newValue !== 'boolean') {
	          throw new TypeError('The \'sidebar.pinned\' property was assigned an invalid value.');
	        }
	
	        if (newValue && !fisSidebarStateService.isOpened($scope.sidebar.name)) {
	          // has to be open to be pinned
	          fisSidebarStateService.openSidebar($scope.sidebar.name);
	        }
	        $scope.publish('fisSidebarPinStateChanged', {
	          newValue: newValue,
	          oldValue: oldValue
	        });
	      });
	
	      // Watching Position
	      $scope.$watch('sidebar.position', function (newValue) {
	        if (typeof newValue !== 'string') {
	          // eslint-disable-line no-negated-condition
	          throw new TypeError('The \'sidebar.position\' property was assigned an invalid value.');
	        } else {
	          newValue = newValue.trim().toLowerCase();
	        }
	
	        if (newValue !== 'right' && newValue !== 'left') {
	          throw new TypeError('The \'sidebar.position\' property was assigned an invalid value.');
	        }
	      });
	
	      // Watching Title
	      $scope.$watch('sidebar.title', function (newValue) {
	        if (typeof newValue !== 'string') {
	          throw new TypeError('The \'sidebar.title\' property was assigned an invalid value.');
	        }
	      });
	
	      // Watching Width
	      $scope.$watch('sidebar.width', function (newValue) {
	        var dirty = false;
	
	        if (_.isString(newValue)) {
	          newValue = parseInt(newValue.toString().replace('px', ''), 10);
	          dirty = true;
	        }
	
	        if (typeof newValue !== 'number') {
	          throw new TypeError('The \'sidebar.width\' property was assigned an invalid value.');
	        }
	
	        if (newValue > $scope.sidebar.maximumWidth) {
	          newValue = $scope.sidebar.maximumWidth;
	          dirty = true;
	        } else if (newValue < $scope.sidebar.minimumWidth) {
	          newValue = $scope.sidebar.minimumWidth;
	          dirty = true;
	        }
	
	        if (dirty) {
	          $scope.sidebar.width = newValue;
	        }
	      });
	
	      // When the scope is destroyed
	      $scope.$on('$destroy', function () {
	        if (fisSidebarStateService.unregisterSidebar && $scope.sidebar.name.length > 0) {
	          fisSidebarStateService.unregisterSidebar($scope.sidebar.name);
	        }
	      });
	    }],
	    link: function link(scope, element, attrs) {
	      var toggleClass = function toggleClass(action, className) {
	        var b = $('body');
	        var hasClass = b.hasClass(className);
	
	        if (action) {
	          if (!hasClass) {
	            b.addClass(className);
	          }
	        } else {
	          if (hasClass) {
	            // eslint-disable-line no-lonely-if
	            b.removeClass(className);
	          }
	        }
	      };
	
	      scope.sidebarContentMarkup = element.find('.fis-sidebar-content')[0].innerHTML;
	
	      scope.reload = function () {
	        // Remove its contents from the DOM
	        var sidebarContentElem = element.find('.fis-sidebar-content');
	        sidebarContentElem.empty();
	        // Destroy the child scopes to avoid leaking
	        var parentScope = angular.element($('.fis-sidebar-content')).scope();
	        if (typeof parentScope !== 'undefined' && parentScope !== null) {
	          var childScope = parentScope.$$childHead;
	          if (typeof childScope !== 'undefined' && childScope !== null) {
	            childScope.$destroy();
	          }
	        }
	        // Reapply the template provided in the transclusion
	        var newSidebarContentElem = $compile(scope.sidebarContentMarkup)(scope);
	        sidebarContentElem.append(newSidebarContentElem);
	        if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	          scope.$apply();
	        }
	      };
	      var toggleSidebar = function toggleSidebar(openOrClose) {
	        if (!scope.sidebar.dragging) {
	          scope.sidebar.openingTimeout = null;
	          scope.sidebar.opened = openOrClose;
	          if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	            scope.$apply();
	          }
	        }
	      };
	
	      scope.toggleSidebarClick = function (e) {
	        if (scope.sidebar.mode === 'click') {
	          toggleSidebar(!scope.sidebar.opened);
	        }
	
	        e.stopPropagation();
	        if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	          scope.$apply();
	        }
	      };
	
	      var toggleSidebarHover = function toggleSidebarHover(e) {
	        if (scope.sidebar.mode !== 'click' && !scope.sidebar.pinned) {
	          if (scope.sidebar.opened || !$(e.srcElement).hasClass('fis-sidebar-toggle-well')) {
	            if (scope.sidebar.openingTimeout) {
	              $timeout.cancel(scope.sidebar.openingTimeout);
	              scope.sidebar.openingTimeout = null;
	            }
	
	            var eType = e.type;
	
	            scope.sidebar.openingTimeout = $timeout(function () {
	              toggleSidebar(eType === 'mouseenter');
	            }, 350);
	            fisMemoryUtilService.cancelTimeoutOnDestroy(scope, scope.sidebar.openingTimeout, $timeout);
	          }
	        }
	
	        e.stopPropagation();
	        if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	          scope.$apply();
	        }
	      };
	
	      var updateBodyClasses = function updateBodyClasses(position) {
	        var b = $('body');
	        var hasRightClass = b.hasClass('fis-sidebar-right');
	        var hasLeftClass = b.hasClass('fis-sidebar-left');
	        var positionedRight = position === 'right';
	
	        if (!positionedRight && !hasLeftClass) {
	          b.addClass('fis-sidebar-left');
	        }
	
	        if (positionedRight && hasLeftClass) {
	          b.removeClass('fis-sidebar-left');
	        }
	
	        if (positionedRight && !hasRightClass) {
	          b.addClass('fis-sidebar-right');
	        }
	
	        if (!positionedRight && hasRightClass) {
	          b.removeClass('fis-sidebar-right');
	        }
	      };
	
	      var setPosition = function setPosition(position) {
	        var positionTimeout = $timeout(function () {
	          if (scope.sidebar.pinned) {
	            fisViewPanel.css('margin-left', ''); // eslint-disable-line no-use-before-define
	            fisViewPanel.css('margin-right', ''); // eslint-disable-line no-use-before-define
	          }
	
	          updateBodyClasses(position);
	          setupWidth(scope.sidebar.width); // eslint-disable-line no-use-before-define
	          fisContentWell.show(); // eslint-disable-line no-use-before-define
	
	          if (scope.sidebar.pinned) {
	            element.toggleClass('fis-sidebar-notransition');
	          }
	        }, 50);
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, positionTimeout, $timeout);
	      };
	
	      var fisSidebarToggle = element.find('.fis-sidebar-toggle');
	      var fisSidebarResize = element.find('.fis-sidebar-resize'); // eslint-disable-line no-unused-vars
	      var fisContentWell = element.find('.fis-sidebar-content-well');
	      var fisViewPanel = $('.fis-view-panel');
	
	      element.on('mouseenter mouseleave', toggleSidebarHover);
	      fisSidebarToggle.on('mouseenter', toggleSidebarHover);
	
	      var dragStartPosition;
	
	      fisPubSubService.subscribe('fisOnDragStart.fisSideBar', function (args) {
	        var event = args.event;
	        scope.sidebar.dragging = true;
	        scope.sidebar.dragStartX = scope.sidebar.width;
	
	        dragStartPosition = event.clientX;
	        if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	          scope.$apply();
	        }
	      });
	
	      fisPubSubService.subscribe('fisOnDrag.fisSideBar', function (args) {
	        scope.sidebar.dragging = true;
	
	        var direction = scope.sidebar.position === 'right' ? 1 : -1;
	        var widthAtStartOfDragOperation = scope.sidebar.dragStartX;
	        var positionAtStartOfDragOperation = dragStartPosition;
	        var currentPosition = args.event.clientX;
	
	        // Sometimes the position is 0 at the end of a drag operation.
	        // Exclude this event.
	        if (currentPosition > 0) {
	          scope.sidebar.width = widthAtStartOfDragOperation + (positionAtStartOfDragOperation - currentPosition) * direction;
	        }
	      });
	
	      fisPubSubService.subscribe('fisOnDragEnd.fisSideBar', function () {
	        scope.sidebar.dragging = false;
	        scope.sidebar.dragStartX = 0;
	        if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	          scope.$apply();
	        }
	      });
	
	      var draggableOnCancel = function draggableOnCancel() {
	        // eslint-disable-line no-unused-vars
	        scope.sidebar.dragging = false;
	        scope.sidebar.dragStartX = 0;
	        if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	          scope.$apply();
	        }
	      };
	
	      var setupWidth = function setupWidth(width) {
	        var cssWidth = width + 'px';
	        var cssNegWidth = width * -1 + 'px';
	
	        if (scope.sidebar.pinned) {
	          fisViewPanel.css('margin-' + scope.sidebar.position, cssWidth);
	        } else {
	          fisViewPanel.css('margin-left', '');
	          fisViewPanel.css('margin-right', '');
	        }
	
	        fisContentWell.css('width', cssWidth);
	        fisContentWell.css('right', '');
	        fisContentWell.css('left', '');
	        fisContentWell.css(scope.sidebar.position, cssNegWidth);
	      };
	
	      var getInt = function getInt(input) {
	        if (input !== '' && !isNaN(input)) {
	          return parseInt(input, 10);
	        }
	        return undefined;
	      };
	
	      // fis-enabled attribute
	      attrs.$observe('fisEnabled', function (newValue) {
	        if (typeof newValue === 'string' && newValue.trim().toLowerCase() === 'true') {
	          newValue = true;
	        } else {
	          newValue = sidebarDefaults.enabled;
	        }
	
	        scope.sidebar.enabled = newValue;
	      });
	
	      // fis-mode attribute
	      attrs.$observe('fisMode', function (newValue) {
	        if (typeof newValue === 'string' && newValue.trim().toLowerCase() === 'hover') {
	          newValue = 'hover';
	        } else {
	          newValue = sidebarDefaults.mode;
	        }
	
	        scope.sidebar.mode = newValue;
	      });
	
	      // fis-name attribute
	      attrs.$observe('fisName', function (newValue) {
	        if (typeof newValue === 'string') {
	          newValue = newValue.trim();
	        } else {
	          newValue = sidebarDefaults.name;
	        }
	
	        scope.sidebar.name = newValue;
	      });
	
	      // fis-position attribute
	      attrs.$observe('fisPosition', function (newValue) {
	        if (typeof newValue === 'string' && newValue.trim().toLowerCase() === 'left') {
	          newValue = 'left';
	        } else {
	          newValue = sidebarDefaults.position;
	        }
	
	        scope.sidebar.position = newValue;
	      });
	
	      // fis-title attribute
	      attrs.$observe('fisTitle', function (newValue) {
	        if (typeof newValue === 'string') {
	          newValue = newValue.trim();
	        } else {
	          newValue = sidebarDefaults.name;
	        }
	
	        scope.sidebar.title = newValue;
	      });
	
	      // fis-width attribute
	      attrs.$observe('fisWidth', function (newValue) {
	        newValue = getInt(newValue);
	
	        if (_.isUndefined(newValue)) {
	          newValue = sidebarDefaults.width;
	        }
	
	        scope.sidebar.width = newValue;
	      });
	
	      // fis-minimum-width attribute
	      attrs.$observe('fisMinimumWidth', function (newValue) {
	        newValue = getInt(newValue);
	
	        if (_.isUndefined(newValue)) {
	          newValue = sidebarDefaults.minimumWidth;
	        }
	
	        scope.sidebar.minimumWidth = newValue;
	      });
	
	      // fis-maximum-width attribute
	      attrs.$observe('fisMaximumWidth', function (newValue) {
	        newValue = getInt(newValue);
	
	        if (_.isUndefined(newValue)) {
	          newValue = sidebarDefaults.maximumWidth;
	        }
	
	        scope.sidebar.maximumWidth = newValue;
	      });
	
	      // fis-opened attribute
	      attrs.$observe('fisOpened', function (newValue) {
	        var openedTimeout = $timeout(function () {
	          if (newValue === true || typeof newValue === 'string' && newValue.trim().toLowerCase() === 'true') {
	            newValue = true;
	          } else {
	            newValue = sidebarDefaults.opened;
	          }
	
	          if (scope.sidebar.opened === false) {
	            scope.sidebar.opened = newValue;
	            if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	              scope.$apply();
	            }
	          }
	        }, 0);
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, openedTimeout, $timeout);
	      });
	
	      // fis-pinned attribute
	      attrs.$observe('fisPinned', function (newValue) {
	        var pinnedTimeout = $timeout(function () {
	          if (newValue === true || typeof newValue === 'string' && newValue.trim().toLowerCase() === 'true') {
	            newValue = true;
	          } else {
	            newValue = sidebarDefaults.pinned;
	          }
	
	          if (scope.sidebar.pinned === false) {
	            scope.sidebar.pinned = newValue;
	            if (scope.$root.$$phase !== '$apply' && scope.$root.$$phase !== '$digest') {
	              scope.$apply();
	            }
	          }
	        }, 0);
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, pinnedTimeout, $timeout);
	      });
	      var sidebarEnabledWatch = scope.$watch('sidebar.enabled', function (newValue) {
	        toggleClass(newValue, 'fis-sidebar-enabled');
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, sidebarEnabledWatch);
	
	      var sidebarDraggedWatch = scope.$watch('sidebar.dragging', function (newValue) {
	        toggleClass(newValue, 'fis-sidebar-dragging');
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, sidebarDraggedWatch);
	
	      var sidebarPinnedWatch = scope.$watch('sidebar.pinned', function (newValue) {
	        toggleClass(newValue, 'fis-sidebar-pinned');
	        setupWidth(scope.sidebar.width);
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, sidebarPinnedWatch);
	
	      var sidebarPositionWatch = scope.$watch('sidebar.position', function (newValue) {
	        fisContentWell.hide();
	
	        if (scope.sidebar.pinned) {
	          element.toggleClass('fis-sidebar-notransition');
	        }
	
	        setPosition(newValue);
	      });
	
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, sidebarPositionWatch);
	
	      var sidebarWidthWatch = scope.$watch('sidebar.width', function (newValue) {
	        setupWidth(parseInt(newValue, 10));
	      });
	      fisMemoryUtilService.cancelWatchOnDestroy(scope, sidebarWidthWatch);
	    }
	  };
	
	  return ddo;
	}];
	
	__webpack_require__(/*! ./side-bar.styles.less */ 47);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 47 */
/*!**************************************************!*\
  !*** ./components/side-bar/side-bar.styles.less ***!
  \**************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 48 */
/*!*******************************************!*\
  !*** ./components/side-bar-menu/index.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _sidebarMenu = __webpack_require__(/*! ./sidebar-menu.component */ 49);
	
	var _sidebarMenu2 = _interopRequireDefault(_sidebarMenu);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.side-bar-menu', []);
	
	ngModule.component('fisSidebarMenu', _sidebarMenu2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 49 */
/*!************************************************************!*\
  !*** ./components/side-bar-menu/sidebar-menu.component.js ***!
  \************************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * @name fisSidebarMenu
	 * @description The fisSidebarMenu component renders the sidebar content from its specified partial.
	 * @methodOf fisComponents.components
	 */
	exports.default = {
	  // eslint-disable-next-line no-multi-str
	  template: '\
	                <ul class="sidebar-list">\
	                    <li ng-repeat="item in $ctrl.sidebars">\
	                        <div fis-insert-view="$ctrl.updatePartial(item)" /></div>\
	                    </li>\
	                </ul>',
	  controller: ['fisPubSubService', 'fisUtilService', '$timeout', function (fisPubSubService, fisUtilService, $timeout) {
	    var ctrl = this;
	
	    ctrl.updatePartial = function (sidebarItem) {
	      var item = angular.copy(sidebarItem);
	      if (item.partial) {
	        item.partial = fisUtilService.appendCacheQueryParameter(item.partial);
	      }
	      return item;
	    };
	
	    fisPubSubService.subscribe('shell.navReady', function (nav) {
	      $timeout(function () {
	        ctrl.sidebars = nav.sidebar;
	      });
	    }, true);
	
	    fisPubSubService.subscribe('shell.navChanged', function (nav) {
	      $timeout(function () {
	        ctrl.sidebars = nav.sidebar;
	      });
	    }, true);
	  }]
	};

/***/ }),
/* 50 */
/*!****************************************!*\
  !*** ./components/start-menu/index.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _startMenu = __webpack_require__(/*! ./start-menu.directive */ 51);
	
	var _startMenu2 = _interopRequireDefault(_startMenu);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.start-menu', []);
	
	ngModule.directive('fisStartMenu', _startMenu2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 51 */
/*!*******************************************************!*\
  !*** ./components/start-menu/start-menu.directive.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$controller", "$compile", "fisPubSubService", "fisStartMenuService", "$timeout", "fisConfig", "fisMemoryUtilService", function ($controller, $compile, fisPubSubService, fisStartMenuService, $timeout, fisConfig, fisMemoryUtilService) {
	  'ngInject';
	
	  return {
	    restrict: 'EA',
	    replace: true,
	    // eslint-disable-next-line no-multi-str
	    template: '\
	        <div class="fis-start-menu transitions-enable" ng-class="{ \'fis-start-menu-quick-links-right\': startMenuModel.quickLinksOrientation === \'right\', \'fis-start-menu-search-disabled\': !startMenuModel.searchable, \'fis-start-menu-opened\': !startMenuModel.closed }" fis-visible="(startMenuModel.enabled && (!startMenuModel.closed))">\
	          <div fis-off-canvas-menu ng-if="isResponsive"></div>\
	        </div>',
	    scope: true,
	    controller: ('fis.shell.MenuController', ['$scope', 'fisPubSubService', 'fisStartMenuService', function ($scope, fisPubSubService, fisStartMenuService) {
	      $scope.navTimeout = -1;
	      // if config timeout value is present then menu is loaded in a timeout
	      if (fisConfig && fisConfig.menuApi && fisConfig.menuApi.navTimeout) {
	        if (_.isNumber(fisConfig.menuApi.navTimeout)) {
	          // the config value should be in ms
	          $scope.navTimeout = fisConfig.menuApi.navTimeout;
	        } else {
	          $scope.navTimeout = 100; // else default to 100ms
	        }
	      }
	
	      $scope.startMenuModel = {
	        closeOnMouseExit: true,
	        closed: true,
	        enabled: true,
	        menuItems: {},
	        primitiveViews: null,
	        quickLinksOrientation: 'left',
	        searchable: true,
	        searchableView: {
	          id: 'SearchItem',
	          label: 'Search',
	          location: '',
	          path: ''
	        },
	        selectedMenuItem: null,
	        views: null
	      };
	
	      var startMenuModel = $scope.startMenuModel;
	
	      startMenuModel.menuDirectiveName = fisStartMenuService.getMenuDirectiveName();
	
	      function filterPartialViews(views) {
	        return _.filter(views, function (view) {
	          var result = view && _.size(view.children) > 0 && _.has(view, 'label') && (_.isUndefined(view.closeable) || view.closeable);
	          return result;
	        });
	      }
	
	      function getViewAsMenuItem(view, parent) {
	        return {
	          view: view,
	          children: _.size(view.secondaryNav) !== 0 ? [] : $scope.getViewsAsMenuItems(view.children, view), // eslint-disable-line no-negated-condition
	          parent: parent ? parent : null
	        };
	      }
	
	      function include(str, needle) {
	        if (needle === '') {
	          return true;
	        }
	        if (str == null) {
	          // eslint-disable-line no-eq-null, eqeqeq
	          return false;
	        }
	        return String(str).indexOf(needle) !== -1;
	      }
	
	      function stringToBoolean(string) {
	        switch (string.toLowerCase()) {
	          case 'true':
	          case 'yes':
	          case '1':
	            return true;
	          case 'false':
	          case 'no':
	          case '0':
	          case null:
	            return false;
	          default:
	            return Boolean(string);
	        }
	      }
	
	      $scope.getViewsAsMenuItems = function (views, parent) {
	        var resultSet = [];
	
	        if (_.size(views) > 0) {
	          _.each(views, function (view) {
	            if (!include(view.id, ':')) {
	              resultSet.push(getViewAsMenuItem(view, parent));
	            }
	          });
	        }
	
	        return resultSet;
	      };
	
	      $scope.groupChildlessViews = function (views, parent) {
	        var childless = [];
	        var newView = {};
	        angular.copy(parent, newView);
	        newView.view.children = [];
	        newView.parent = parent.view;
	
	        if (_.size(views) > 0) {
	          _.each(views, function (view) {
	            if (_.size(view.children) === 0) {
	              childless.push(view);
	            }
	          });
	        }
	
	        if (_.size(childless) > 0) {
	          newView.children = childless;
	        } else {
	          newView = null;
	        }
	
	        return newView;
	      };
	
	      $scope.resetSearch = function () {
	        if ($scope.startMenuModel.searchable) {
	          _.last(startMenuModel.menuItems.children).children = [];
	        }
	      };
	
	      $scope.toggle = function () {
	        if (!$scope.isResponsive) {
	          // eslint-disable-line no-negated-condition
	          if (_.size($scope.startMenuModel.menuDirectiveName) > 0) {
	            startMenuModel.closed = !startMenuModel.closed;
	          }
	        } else {
	          startMenuModel.closed = !startMenuModel.closed;
	        }
	      };
	
	      $scope.isItemInViewToShow = function (wrapper) {
	        var isPrimaryNav = true;
	        var isSearchResult = wrapper.view.id === 'SearchItem';
	
	        if (wrapper.children && wrapper.children.length > 0 && !hasValidChildren(wrapper.children)) {
	          isPrimaryNav = false;
	        }
	
	        if (wrapper.parent && wrapper.parent.cls === 'hide') {
	          isPrimaryNav = false;
	        } else {
	          if (wrapper.children && wrapper.children.length > 0) {
	            // eslint-disable-line no-lonely-if
	            var hiddenChildren = _.filter(wrapper.children, function (childWrapper) {
	              if (childWrapper.view.cls === 'hide') {
	                return childWrapper;
	              }
	            });
	
	            if (wrapper.children.length === hiddenChildren.length) {
	              isPrimaryNav = false;
	            }
	          }
	        }
	
	        wrapper.isPrimaryNav = isPrimaryNav;
	        wrapper.isSearchResult = isSearchResult;
	        wrapper.showOffCanvas = isPrimaryNav && !isSearchResult;
	        wrapper.showMenu = isPrimaryNav || isSearchResult;
	
	        angular.forEach(wrapper.children, function (child) {
	          $scope.isItemInViewToShow(child);
	        });
	      };
	
	      function hasValidChildren(children) {
	        var isValid = false;
	        for (var i = 0; i < children.length; i++) {
	          if ((children[i].view.secondaryNav || children[i].view.partial || children[i].view.action || hasValidChildren(children[i].children)) && children[i].view.cls !== 'hide') {
	            isValid = true;
	            break;
	          }
	        }
	        return isValid;
	      }
	      function isItemInSelectedMenuToShow(itemInSelectedMenu) {
	        if (itemInSelectedMenu.children && itemInSelectedMenu.children.length > 0) {
	          var hiddenItem = _.filter(itemInSelectedMenu.children, function (item) {
	            if (item.view.cls === 'hide') {
	              return item;
	            }
	          });
	          if (itemInSelectedMenu.children.length === hiddenItem.length) {
	            return false;
	          }
	          if (!hasValidChildren(itemInSelectedMenu.children)) {
	            return false;
	          }
	        }
	        return true;
	      }
	
	      function buildNavMap(nav) {
	        // Builds the navMap - used for searching in the fisMegaMenuSearchService - may include more sections - see config.menuApi.searchSections
	        startMenuModel.navMap = {};
	        var hiddenViewsToSearch = false;
	        // add main as default
	        if (_.isUndefined(startMenuModel.searchSections) || startMenuModel.searchSections.length === 0) {
	          startMenuModel.searchSections = ['main'];
	        }
	        _.each(startMenuModel.searchSections, function (searchSection) {
	          startMenuModel.navMap[searchSection] = filterPartialViews(nav[searchSection]);
	          hiddenViewsToSearch = hiddenViewsToSearch || _.isArray(startMenuModel.navMap[searchSection]) && startMenuModel.navMap[searchSection].length > 0;
	        });
	
	        startMenuModel.primitiveViews = startMenuModel.navMap['main']; // eslint-disable-line dot-notation
	
	        // If there are views, the mega menu is enabled.
	        var showEmptyAndIsSearchable = startMenuModel.showEmptyMenu && startMenuModel.searchable;
	        startMenuModel.enabled = _.size(startMenuModel.primitiveViews) > 0 || showEmptyAndIsSearchable && hiddenViewsToSearch;
	
	        // Clone the primitiveViews, and add a search 'view' to mega menu.
	        startMenuModel.views = startMenuModel.primitiveViews.slice(0);
	
	        // If the start menu is searchable, add the view to support search.
	        if (startMenuModel.searchable) {
	          startMenuModel.views.push(startMenuModel.searchableView);
	        }
	
	        // Process the primitiveViews and prepare them to be bound to the mega menu.
	        startMenuModel.menuItems.children = $scope.getViewsAsMenuItems(startMenuModel.views);
	
	        // Fix 2nd Tier Views without children
	        _.each(startMenuModel.menuItems.children, function (child) {
	          var groupedViews = $scope.groupChildlessViews(child.children, child);
	
	          if (!_.isNull(groupedViews)) {
	            _.each(groupedViews.children, function (gChild) {
	              var foundChild = false;
	
	              _.each(child.children, function (cChild, cIndex) {
	                if (!foundChild && gChild.view.id === cChild.view.id) {
	                  child.children.splice(cIndex, 1);
	                  foundChild = true;
	                }
	              });
	            });
	
	            child.children.unshift(groupedViews);
	          }
	        });
	
	        angular.forEach(startMenuModel.menuItems.children, function (child) {
	          $scope.isItemInViewToShow(child);
	        });
	
	        // if (startMenuModel.enabled && (startMenuModel.selectedMenuItem === null) && (_.size(startMenuModel.menuItems.children) > 0)) {
	        if (startMenuModel.enabled && _.size(startMenuModel.menuItems.children) > 0) {
	          var startMenuItems = startMenuModel.menuItems.children;
	          for (var i = 0; i < startMenuItems.length; i++) {
	            if (startMenuItems[i].view.cls !== 'hide') {
	              startMenuModel.selectedMenuItem = startMenuItems[i];
	              if (isItemInSelectedMenuToShow(startMenuModel.selectedMenuItem)) {
	                break;
	              }
	            }
	          }
	        }
	
	        // Notify that the start menu is ready.
	        $scope.$broadcast('fisViews', startMenuModel.views);
	        // fisPubSubService.publish('fisMenuReset', {});
	      }
	
	      fisPubSubService.subscribe('shell.navReady', function (nav) {
	        doOnNavReadyOrChanged(nav);
	      }, true);
	
	      fisPubSubService.subscribe('shell.navChanged', function (nav) {
	        doOnNavReadyOrChanged(nav);
	      }, true);
	
	      function doOnNavReadyOrChanged(nav) {
	        /*
	         * If config 'menuApi.navTimeout' has been set then
	         * put loading of (large) menu in a timeout with
	         * the length of the timeout taken from the config value.
	         */
	        // eslint-disable-next-line no-negated-condition
	        if ($scope.navTimeout !== -1) {
	          // -1 is the scope default value
	          var mapTimeout = $timeout(function () {
	            buildNavMap(nav);
	          }, $scope.navTimeout);
	          fisMemoryUtilService.cancelTimeoutOnDestroy($scope, mapTimeout, $timeout);
	        } else {
	          buildNavMap(nav);
	        }
	      }
	
	      fisPubSubService.subscribe('fisStartMenuToggleVisibility', $scope.toggle);
	
	      if (fisConfig && fisConfig.menuApi) {
	        var menuApiConfig = fisConfig.menuApi;
	        if (!angular.isUndefined(menuApiConfig)) {
	          if (!angular.isUndefined(menuApiConfig.searchEnabled)) {
	            startMenuModel.searchable = menuApiConfig.searchEnabled || stringToBoolean(menuApiConfig.searchEnabled.toString());
	          }
	
	          if (!angular.isUndefined(menuApiConfig.closeOnMouseExit)) {
	            startMenuModel.closeOnMouseExit = menuApiConfig.closeOnMouseExit || stringToBoolean(menuApiConfig.closeOnMouseExit.toString());
	          }
	
	          if (!angular.isUndefined(menuApiConfig.quickLinksOrientation)) {
	            startMenuModel.quickLinksOrientation = menuApiConfig.quickLinksOrientation;
	          }
	
	          if (!angular.isUndefined(menuApiConfig.searchSections)) {
	            startMenuModel.searchSections = menuApiConfig.searchSections;
	          }
	
	          if (!angular.isUndefined(menuApiConfig.searchSections)) {
	            startMenuModel.showEmptyMenu = menuApiConfig.showEmptyMenu;
	          }
	        }
	      }
	
	      fisPubSubService.subscribe('fisMenuChanged', function (views) {
	        $scope.$broadcast('fisViews', views);
	      }, true);
	
	      fisPubSubService.subscribe('fisMenuReset', function () {
	        $scope.resetSearch();
	      });
	
	      fisPubSubService.subscribe('fisStartMenu.setSearchable', function (value) {
	        startMenuModel.searchable = !!value; // eslint-disable-line no-implicit-coercion
	      });
	
	      fisPubSubService.subscribe('fisStartMenu.setCloseOnMouseExit', function (value) {
	        startMenuModel.closeOnMouseExit = !!value; // eslint-disable-line no-implicit-coercion
	      });
	
	      fisPubSubService.subscribe('fisStartMenu.setQuickLinksOrientation', function (value) {
	        startMenuModel.quickLinksOrientation = value;
	      });
	
	      fisPubSubService.subscribe('fisStartMenu.setLoadingIndicator', function (value) {
	        startMenuModel.loadingIndicator = !!value; // eslint-disable-line no-implicit-coercion
	      });
	
	      fisPubSubService.subscribe('fisStartMenu.setShowEmptyMenu', function (value) {
	        startMenuModel.showEmptyMenu = !!value; // eslint-disable-line no-implicit-coercion
	      });
	
	      $scope.$watch('startMenuModel.searchable', function (newVal) {
	        fisPubSubService.publish('fisStartMenu.searchable', newVal);
	      });
	
	      $scope.$watch('startMenuModel.closeOnMouseExit', function (newVal) {
	        fisPubSubService.publish('fisStartMenu.closeOnMouseExit', newVal);
	      });
	
	      $scope.$watch('startMenuModel.quickLinksOrientation', function (newVal) {
	        fisPubSubService.publish('fisStartMenu.quickLinksOrientation', newVal);
	      });
	
	      $scope.$watch('startMenuModel.showEmptyMenu', function (newVal) {
	        fisPubSubService.publish('fisStartMenu.showEmptyMenu', newVal);
	      });
	    }]),
	    link: function link(scope, element) {
	      scope.$watch('startMenuModel.enabled', function (newValue) {
	        if (newValue) {
	          $('body').removeClass('fis-start-menu-disabled');
	        } else {
	          $('body').addClass('fis-start-menu-disabled');
	        }
	      });
	
	      scope.$watch('startMenuModel.closed', function (newValue) {
	        if (newValue) {
	          $('body').removeClass('fis-start-menu-opened');
	          if (scope.startMenu) {
	            scope.startMenu.opened = false;
	          }
	        } else {
	          $('body').addClass('fis-start-menu-opened');
	          if (scope.startMenu) {
	            scope.startMenu.opened = true;
	          }
	        }
	
	        if (newValue === false) {
	          fisPubSubService.publish('shell.resumeMMWatch');
	        } else {}
	        // fisPubSubService.publish('shell.suspendMMWatch');
	
	        // hide the loading indicator in this case once the menu is opened or closed
	        // (layout is only applied once content is finished being loaded, here, initially there is no content loaded but we still need to hide the loading indicator)
	        if (scope.startMenuModel.showEmptyMenu && scope.startMenuModel.searchable) {
	          // (no loading happens unless a search term was entered and due to menu being closed it doesnt matter so hide it)
	          fisPubSubService.publish('shell.navLoading', false);
	        }
	      });
	
	      if (_.size(scope.startMenuModel.menuDirectiveName) > 0) {
	        var menuHtml = $('<div ' + scope.startMenuModel.menuDirectiveName + ' ng-if="!isResponsive"></div>');
	
	        element.prepend(menuHtml);
	        $compile(menuHtml)(scope);
	        scope.startMenuModel.enabled = true;
	      } else {
	        scope.startMenuModel.enabled = false;
	      }
	    }
	  };
	}];
	
	__webpack_require__(/*! ./start-menu.styles.less */ 52);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 52 */
/*!******************************************************!*\
  !*** ./components/start-menu/start-menu.styles.less ***!
  \******************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 53 */
/*!**************************************!*\
  !*** ./components/tabs-bar/index.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _tabsbar = __webpack_require__(/*! ./tabsbar.directive */ 54);
	
	var _tabsbar2 = _interopRequireDefault(_tabsbar);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.tabs-bar', []);
	
	ngModule.directive('fisTabsBar', _tabsbar2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 54 */
/*!**************************************************!*\
  !*** ./components/tabs-bar/tabsbar.directive.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  // function to attach controller and action to the element
	
	  function addController(element, item) {
	    // eslint-disable-line no-unused-vars
	    element.attr('ng-controller', item.actionController);
	    element.attr('ng-click', item.action);
	    element.removeAttr('ng-repeat');
	  }
	  // function returns tab content Template to ensures we can reuse same tab with clean/pristine element
	  function getTabTemplate() {
	    // SDHTML-9729 :Custom Minified JS for HTML5 Shell breaking code
	    var tabTemplate = '<div fis-tabs-width fis-tabs-details="{{getItemTitle(item)}}" fis-tabs-closable="renderClose(item.view)" fis-tabs-front-icon="hasItemIcon(item)">\
	                        <span class="fisTabCustomClass">\
	                            <div ng-if="hasItemIcon(item)" class="fis-legacy-icon" fis-unique-id="{{item.view.title}}_icon"><i class="{{ getItemIcon(item) }}"></i></div>\
	                            <span tabindex={{isResponsive?!startMenu.opened?-1:0:0}} class="fis-tab-label" ng-dblclick="rename(item.view, $event)" ng-if="!item.view.editMode" ng-bind-html="getItemTitle(item)"></span>\
	                            <input class="input-small" ng-blur="setTitle(item.view, $event)" ng-keyup="onKeyUp(item.view, $event)" ng-show="item.view.renamable && item.view.editMode"/>\
	                        </span>\
	                        <span class="fisTabIcons">\
	                            <span class="fis-innertabicon" ng-if="renderClose(item.view)"><fis-hook id="multiWindowClickIcon" fis-hook-data="{{item}}"></fis-hook></span>\
	                            <span class="fis-cover">\
	                                <span aria-label="close" tabindex={{isResponsive?!startMenu.opened?-1:0:0}} fis-unique-id ng-if="renderClose(item.view)" class="fis-close" ng-click="close($event, item.view.path)">&times;</span>\
	                            </span>\
	                        </span>\
	                    </div>';
	    return tabTemplate;
	  }
	  return {
	    scope: true,
	    template: '\
	            <div>\
	                <div class="fis-tabs-bar">\
	                    <button class="fis-home" fis-hotkey="{{config.menuApi.hotkey || \'ctrl+m, ⌘+m\'}}" fis-custom-hotkey="false" fis-global="true" ng-mouseout="suspendWatches()" ng-if="showMenuButton()" ng-click="startMenu.toggle()">\
	                        <span ng-if="(showMenuLoader && !menuLoading) || !showMenuLoader"><!----><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></span>\
	                        <span class="k-loading" ng-if="menuLoading && showMenuLoader"><!----> </span>\
	                    </button>\
	            <div class="fis-displaypanel" ng-show="showPanels">\
	                        <ul class="nav nav-tabs" fis-hotkey="alt+left, alt+right" fis-custom-hotkey="false" fis-on-hotkey-event="keyboardNavigation($event)" fis-global="true">\
	                    <li ng-repeat="item in tabs track by $index" data-path="{{item.path}}" aria-selected="{{getClass(item.view).indexOf(\'fis-active\')>-1?true:false}}" ng-class="getClass(item.view)" class="fis-tab fis-nav-tab" fis-draggable="{{isDraggable(item.view)}}" fis-drop-target fis-drag-drop-type="fisTabsBar">\
	                                <div ng-if="item.view.secondaryNavParent.secondaryNav === \'dropdown\'" fis-unique-id tabindex={{isResponsive?!startMenu.opened?-1:0:0}} ng-class="{\'fis-cursor-pointer\':item.view.renamable && getClass(item.view.path)===\'fis-active\', \'tabIcon\':hasItemIcon(item)}" class="fis-tab-container fis-tab-container-responsive" title="{{ prependTitle(item)}}">\
	                                    <fis-dropdown-secondary-menu fis-nav-item="item.view.secondaryNavParent">\
	                                    </fis-dropdown-secondary-menu>\
	                                </div>\
	                                <div ng-if="(item.view.secondaryNav !== \'dropdown\' && item.view.secondaryNavParent.secondaryNav !== \'dropdown\')" fis-unique-id tabindex={{isResponsive?!startMenu.opened?-1:0:0}}  ng-class="{\'fis-cursor-pointer\':item.view.renamable && getClass(item.view.path)===\'fis-active\', \'tabIcon\':hasItemIcon(item)}" class="fis-tab-container" ng-click="openItem(item, $event)" title="{{ prependTitle(item) }}">\
	                                    <div ng-class="{\'fis-has-icon\': hasItemIcon(item)}" class="label-icon-wrapper ">\
	                                        ' + getTabTemplate() + '</div>\
	                                </div>\
	                                <div ng-if="(item.view.secondaryNav === \'dropdown\' && item.view.secondaryNavParent.secondaryNav !== \'dropdown\')" fis-unique-id tabindex={{isResponsive?!startMenu.opened?-1:0:0}} ng-class="{\'fis-cursor-pointer\':item.view.renamable && getClass(item.view.path)===\'fis-active\', \'tabIcon\':hasItemIcon(item)}" class="fis-tab-container fis-tab-container-responsive " title="{{ prependTitle(item)}}">\
	                                    <div ng-if="item.view.secondaryNav === \'dropdown\'">\
	                                        <fis-dropdown-secondary-menu fis-nav-item="item.view">\
	                                        </fis-dropdown-secondary-menu>\
	                                    </div>\
	                                </div>\
	                                <ul ng-if="isResponsive && activeViewPanel().path === item.path && secondaryMenuBarItems.items.length > 0" class="accordion fis-off-canvas-top-bar">\
	                                    <li class="accordion-group" fis-hierarchy="child in secondaryMenuBarItems.items" ng-show="isItemInViewToShow(child)" ng-class="getItemStateClasses(child, $index)" ng-click="toggleItem(child, $index);$event.stopPropagation();">\
	                                        <span ng-if="child.items.length > 0" ng-click="toggleItem(child, $index);$event.stopPropagation();">{{child.label}}</span>\
	                                        <div ng-if="!child.items || child.items.length === 0" title="{{child.title}}" class="accordion-toggle"><div fis-navigation-link fis-model="child"></div></div>\
	                                    </li>\
	                                </ul>\
	                            </li>\
	                            <li class="fis-tab fis-non-draggable fis-new-workspace-tab" aria-label="Add view menu item" tabindex={{isResponsive?!startMenu.opened?-1:0:0}} ng-click="openNewWorkspace()" ng-if="viewMenuPresent">\
	                                <div><i class="glyphicon glyphicon-plus"></i></div>\
	                            </li>\
	                        </ul>\
	          </div>\
	        </div>\
	        <div fis-start-menu></div>\
	                <fis-hook id="multiWindowFixedMenu"></fis-hook>\
	                <fis-hook id="multiWindowBaseController"></fis-hook>\
	                <div class="fis-subnav-bar">\
	                    <div fis-secondary-menu></div>\
	                </div>\
	      </div>',
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	
	    controller: ['$element', '$scope', '$rootScope', 'fisViewPanelService', '$timeout', 'fisPubSubService', 'fisConfig', 'fisUniqueIdService', 'fisResponsiveService', 'fisMemoryUtilService', '$compile', 'fisStartMenuService', 'fisViewService', function (element, $scope, $rootScope, fisViewPanelService, $timeout, fisPubSubService, fisConfig, fisUniqueIdService, fisResponsiveService, fisMemoryUtil, $compile, fisStartMenuService, fisViewService) {
	      var viewMenuBasePath = '';
	      var counter = 1;
	      var resumeTimeout = null;
	
	      $scope.currentItemId = null;
	      $scope.currentItem = null;
	      $scope.expandedItems = {};
	      $scope.menuIndexer = 0;
	
	      $scope.$on('$destroy', function () {
	        if (resumeTimeout) {
	          $timeout.cancel(resumeTimeout);
	        }
	      });
	
	      // by default tabs will not be updatable from secondary navigation
	      $scope.updateTabTitle = false;
	      $scope.isResponsive = fisResponsiveService.isResponsive();
	
	      // By default do not show the loading spinner while the menu is loading
	      $scope.showMenuLoader = false;
	      $scope.showMenuButton = _.size(fisStartMenuService.menuDirectiveName) > 0;
	      $scope.menuLoading = undefined;
	      fisPubSubService.subscribe('fisStartMenu.setLoadingIndicator', function (value) {
	        $scope.showMenuLoader = !!value; // eslint-disable-line no-implicit-coercion
	      });
	      $scope.$watch('showMenuLoader', function (newVal) {
	        fisPubSubService.publish('fisStartMenu.loadingIndicator', newVal);
	      });
	      $scope.navHasMain = false;
	
	      // subscribe to fisTabsBarService events
	      fisPubSubService.subscribe('fisTabsBar.updateTabTitle', function (value) {
	        $scope.updateTabTitle = value;
	      });
	
	      fisPubSubService.subscribe('fisTabsBar.tooltipPrependTitle', function (value) {
	        $scope.tooltipPrependTitle = value;
	      });
	
	      $scope.getItemStateClasses = function (item) {
	        var classes = [];
	
	        classes.push(_.size(item.children) === 0 ? 'leaf' : 'branch');
	        classes.push($scope.expandedItems[item.path] ? 'expanded' : 'collapsed');
	        classes.push($scope.currentItemId === item.path ? 'current' : '');
	
	        return classes.join(' ').trim();
	      };
	
	      $scope.collapseItem = function (item) {
	        delete $scope.expandedItems[item.path];
	        if (item.items instanceof Array) {
	          item.items.forEach(function (i) {
	            $scope.collapseItem(i);
	          });
	        }
	      };
	
	      $scope.toggleItem = function (item) {
	        if (item.children instanceof Array && item.children.length > 0) {
	          if ($scope.expandedItems[item.path]) {
	            $scope.collapseItem(item);
	            delete $scope.expandedItems[item.path];
	          } else {
	            $scope.expandedItems[item.path] = true;
	          }
	        }
	      };
	
	      $scope.showMenuButton = function () {
	        var returnValue = false;
	
	        if ($scope.isResponsive) {
	          returnValue = true;
	        } else {
	          returnValue = _.size(fisStartMenuService.getMenuDirectiveName()) > 0 && $scope.navHasMain;
	        }
	
	        return returnValue;
	      };
	
	      // add fisid for the open workspace plus button  & start menu button
	      var idTimeout = $timeout(function () {
	        var plusBtn = element.find('i.glyphicon.glyphicon-plus');
	        var startBtn = element.find('.fis-home');
	        fisUniqueIdService.generateUniqueId($scope, plusBtn, {}, 'plus_btn');
	        fisUniqueIdService.generateUniqueId($scope, startBtn, {}, 'startMenu_toggle_');
	      }, 2000);
	      fisMemoryUtil.cancelTimeoutOnDestroy($scope, idTimeout, $timeout);
	
	      fisPubSubService.subscribe('fisActiveViewPanelChanged', function (params) {
	        var navItem = params.currentNavItem;
	        if (!navItem || navItem.secondaryNav !== 'menubar' && navItem.isStatic !== true) {
	          $scope.secondaryMenuBarItems = null;
	        }
	      });
	
	      fisPubSubService.subscribe('fisSecondaryMenuClicked', function (navItem) {
	        if (navItem.secondaryNav === 'menubar') {
	          // var childrenLength = menu.element.children().length;
	
	          filterChildren(navItem.children);
	          var filteredChildren = addValidItems(navItem.children, true);
	
	          $scope.secondaryMenuBarItems = {
	            items: filteredChildren
	          };
	        } else {
	          $scope.secondaryMenuBarItems = null;
	        }
	      }, true);
	
	      fisPubSubService.subscribe('fisViewPanelClosed', function () {
	        if (_.size($scope.viewPanels()) === 0) {
	          $scope.secondaryMenuBarItems = null;
	        }
	      });
	
	      function filterPartialViews(views) {
	        // eslint-disable-line no-unused-vars
	        return _.filter(views, function (view) {
	          var result = view && _.size(view.children) > 0 && _.has(view, 'label') && (_.isUndefined(view.closeable) || view.closeable);
	          return result;
	        });
	      }
	
	      function filterChildren(children) {
	        if (children) {
	          _.each(children, function (item) {
	            if (item.items) {
	              var itemClone = _.clone(item);
	
	              itemClone.items = filterChildren(item.items);
	            } else {
	              if (item.partial && item.cls !== 'hide') {
	                // eslint-disable-line no-lonely-if
	                item.isValid = true;
	                markHierarchyValid(item);
	              }
	            }
	          });
	        }
	      }
	
	      function markHierarchyValid(item) {
	        var path = item.path;
	        var tempPath = path;
	        if (tempPath) {
	          tempPath = tempPath.substring(0, tempPath.lastIndexOf('/'));
	          if (tempPath !== '') {
	            var navItem = fisViewService.findNavItem(tempPath);
	            if (navItem) {
	              navItem.isValid = true;
	              markHierarchyValid(navItem);
	            }
	          }
	        }
	      }
	
	      function addValidItems(children) {
	        var ret = [];
	
	        if (children) {
	          _.each(children, function (item) {
	            // addItemClasses(item, firstRow);
	            if (item.items) {
	              var itemClone = _.clone(item);
	
	              itemClone.items = addValidItems(item.items, false);
	              if (item.icon) {
	                delete itemClone.icon;
	                itemClone.spriteCssClass = item.icon;
	              }
	              if (itemClone.isValid === true) {
	                ret.push(itemClone);
	              }
	            } else {
	              if (item.partial && item.cls !== 'hide' && (!item.id || item.id.indexOf(':') === -1)) {
	                // eslint-disable-line no-lonely-if
	                if (item.icon) {
	                  item.spriteCssClass = item.icon;
	                }
	                markHierarchyValid(item);
	                if (item.isValid === true) {
	                  ret.push(item);
	                }
	              }
	            }
	          });
	        }
	        return ret;
	      }
	
	      fisPubSubService.subscribe('shell.navReady', function (nav) {
	        doOnNavReadyOrChanged(nav);
	      }, true);
	
	      fisPubSubService.subscribe('shell.navChanged', function (nav) {
	        doOnNavReadyOrChanged(nav);
	      }, true);
	
	      function doOnNavReadyOrChanged(nav) {
	        $scope.viewMenuPresent = false;
	        if (nav.viewMenu && nav.viewMenu.length > 0) {
	          $scope.viewMenuPresent = true;
	          viewMenuBasePath = nav.viewMenu[0].path;
	        }
	
	        // Used to influence the menu button in tabsbar.  If there is no content in main, then don't show the menu button.
	        if (nav.main && _.size(nav.main) > 0) {
	          $scope.navHasMain = true;
	        }
	
	        navLoading(false);
	      }
	
	      function navLoading(state) {
	        if (_.isUndefined(state)) {
	          state = true;
	        } else if (!_.isBoolean(state)) {
	          state = false;
	        }
	        $scope.menuLoading = state;
	      }
	
	      fisPubSubService.subscribe('shell.navLoading', navLoading);
	
	      if (fisConfig.widgets && fisConfig.widgets.fisTabsBar) {
	        $scope.updateTabTitle = fisConfig.widgets.fisTabsBar.updateTabTitle;
	        $scope.tooltipPrependTitle = fisConfig.widgets.fisTabsBar.tooltipPrependTitle;
	      }
	      if (fisConfig.menuApi && fisConfig.menuApi.loadingIndicator) {
	        $scope.showMenuLoader = fisConfig.menuApi.loadingIndicator;
	        if (_.isUndefined($scope.menuLoading)) {
	          // In the meantime shell.navReady has not been triggered
	          navLoading(true);
	        }
	      } else {
	        console.warn('No menu loader config entry found');
	      }
	
	      function hasValidChildren(children) {
	        var isValid = false;
	
	        for (var i = 0; i < children.length; i++) {
	          if ((children[i].secondaryNav || children[i].partial || children[i].action || hasValidChildren(children[i].children)) && children[i].cls !== 'hide') {
	            isValid = true;
	            break;
	          }
	        }
	
	        return isValid;
	      }
	
	      $scope.isItemInViewToShow = function (itemInView) {
	        if (itemInView.id === 'SearchItem') {
	          return true;
	        }
	
	        if (itemInView.children && itemInView.children.length > 0 && !hasValidChildren(itemInView.children)) {
	          return false;
	        }
	
	        if (itemInView.parent && itemInView.parent.cls === 'hide') {
	          return false;
	        } else {
	          // eslint-disable-line no-else-return
	          if (itemInView.children && itemInView.children.length > 0) {
	            // eslint-disable-line no-lonely-if
	            var hiddenItem = _.filter(itemInView.children, function (item) {
	              if (item.cls === 'hide') {
	                return item;
	              }
	            });
	
	            if (itemInView.children.length === hiddenItem.length) {
	              return false;
	            }
	          }
	        }
	
	        return true;
	      };
	
	      $scope.openNewWorkspace = function () {
	        var getUri = function getUri() {
	          return viewMenuBasePath + '/' + counter;
	        };
	
	        var filter = function filter(tab) {
	          return tab.path === uri; // eslint-disable-line no-use-before-define
	        };
	
	        var uri = getUri();
	
	        if (_.any($scope.tabs, filter) || _.any($scope.overflowViewModel.overflow, filter)) {
	          counter++;
	        }
	
	        $scope.openPath(getUri(), true);
	        counter++;
	      };
	
	      $scope.rename = function (item, event) {
	        if (item.renamable) {
	          item.editMode = true;
	          var target = angular.element(event.target).next();
	          var focussingTimeout = $timeout(function () {
	            target.focus();
	          }, 0);
	          fisMemoryUtil.cancelTimeoutOnDestroy($scope, focussingTimeout, $timeout);
	          item.draggable = false;
	        }
	      };
	
	      $scope.getItemTitle = function (item) {
	        if (!_.isUndefined(item) && !_.isUndefined(item.label) && !_.isUndefined(item.view.label)) {
	          if (item.label && (item.label.indexOf('{{') > -1 || item.view.label.indexOf('{{') > -1)) {
	            item.view.title = item.view.title.replace(/{|}/g, '');
	            item.view.label = item.label = item.label.replace(/{|}/g, '');
	          }
	        }
	        if (item.view.navItem && item.view.navItem.customTitle) {
	          if (item.view.navItem.customTitle.indexOf('{{') > -1) {
	            item.view.navItem.customTitle = item.view.navItem.customTitle.replace(/{|}/g, '');
	          }
	          return item.view.navItem.customTitle;
	        } else if (!$scope.updateTabTitle && !_.isUndefined(item.parentTitle)) {
	          return item.parentTitle;
	        } else {
	          // eslint-disable-line no-else-return
	          return item.view.title;
	        }
	      };
	
	      $scope.prependTitle = function (item) {
	        var label = $scope.getItemTitle(item);
	        var title;
	        if (!_.isUndefined(item) && !_.isUndefined(item.view) && !_.isUndefined(item.view.navItem) && !_.isUndefined(item.view.navItem.title) && !_.isString(item)) {
	          title = item.view.navItem.title;
	        }
	        if ($scope.tooltipPrependTitle && !_.isUndefined(title) && label !== title) {
	          return title + ' - ' + label;
	        } else {
	          // eslint-disable-line no-else-return
	          return label;
	        }
	      };
	
	      $scope.getItemIcon = function (item) {
	        if (item.view.navItem && item.view.navItem.customIcon) {
	          return item.view.navItem.customIcon;
	        } else if (!$scope.updateTabTitle) {
	          // eslint-disable-line no-negated-condition
	          if (_.isNull(item.parentIcon)) {
	            // there is a parent and it does not have an icon
	            return '';
	          } else if (_.isUndefined(item.parentIcon)) {
	            // there is no parent, so show the item of the current view
	            return item.view.icon;
	          }
	          return item.parentIcon;
	        } else {
	          // eslint-disable-line no-else-return
	          return item.view.icon;
	        }
	      };
	
	      $scope.hasItemIcon = function (item) {
	        var icon = $scope.getItemIcon(item);
	        return !(_.isUndefined(icon) || icon === '' || icon === null);
	      };
	
	      $scope.resetTitle = function (item, event) {
	        if (!_.isUndefined(item.originalTitle)) {
	          var previousTitle = item.getTitle();
	          item.title = item.originalTitle;
	          var element = angular.element(event.target);
	          var response = {
	            oldValue: previousTitle,
	            newValue: item.getTitle()
	          };
	          element.val(item.getTitle());
	          $rootScope.$broadcast('fisViewPanelTitleChanged', response);
	        }
	      };
	
	      $scope.setTitle = function (item, event) {
	        if (_.isUndefined(item.originalTitle)) {
	          item.originalTitle = item.getTitle();
	        }
	        var previousTitle = item.getTitle();
	        var element = angular.element(event.target);
	        if (jQuery.trim(element.val()) === '') {
	          item.setTitle(previousTitle);
	          element.val(previousTitle);
	        } else {
	          item.setTitle(jQuery.trim(element.val()));
	          // send old and new value of the item's title in the event
	          var response = {
	            oldValue: previousTitle,
	            newValue: item.getTitle()
	          };
	          element.val(item.getTitle());
	          $rootScope.$broadcast('fisViewPanelTitleChanged', response);
	        }
	        item.editMode = false;
	      };
	
	      $scope.onKeyUp = function (item, event) {
	        if (event.keyCode === 13) {
	          // enter key
	          $scope.setTitle(item, event);
	        } else if (event.keyCode === 27) {
	          // escape key
	          var element = angular.element(event.target);
	          element.val(item.getTitle());
	          item.editMode = false;
	        }
	      };
	
	      $scope.$watch(function () {
	        return fisResponsiveService.isResponsive();
	      }, function (value) {
	        $scope.isResponsive = value;
	      });
	
	      var tabPathsForWatch = function tabPathsForWatch() {
	        return _.reduce($scope.viewPanels(), function (memo, view) {
	          return memo + view.path + view.title + '|';
	        }, '');
	      };
	      $scope.$watch('tabs', function (newVal, oldVal) {
	        if (newVal !== oldVal && newVal.length > 0) {
	          if (fis.initParams().appStage === 'T') {
	            // test appStage
	            // Check to see which tab changed so we can add a new fisid to reflect the updated title.
	            angular.forEach(newVal, function (newItem, index) {
	              var oldItem;
	
	              if (oldVal.length > index) {
	                oldItem = oldVal[index];
	              }
	
	              if (!angular.equals(newItem, oldItem)) {
	                // Force a new fisid for the item
	                var tabElements = $scope.getAllTabs();
	                angular.forEach(tabElements, function (tabObj) {
	                  var tab = angular.element(tabObj);
	
	                  var tabItem = tab.scope().item;
	
	                  if (tabItem === newItem) {
	                    // Force a new fisid for the label field, overriding the old one.
	                    fisUniqueIdService.generateUniqueIdForce(tab.scope(), tab.find('.fis-tab-label'), {}, tabItem.label, true);
	                    // SDHTML-12136 Force a new fisid for the close icon, overriding the old one.
	                    fisUniqueIdService.generateUniqueIdForce(tab.scope(), tab.find('.fis-cover .fis-close'), {}, tabItem.label + '_close_icon', true);
	                  }
	                });
	              }
	            });
	          }
	
	          var classTimeout = $timeout(function () {
	            var tabElements = $scope.getAllTabs();
	
	            function cleanUp(clean, tabCustomClass, tab) {
	              // Clean up for Tab reuse
	              $compile(clean)(tab.scope());
	              clean.scope().$apply();
	              clean.removeClass('compiled');
	              tabCustomClass.replaceWith(clean);
	            }
	
	            angular.forEach(tabElements, function (tabObj) {
	              var tabCustomClass = angular.element($(tabObj).find('.fisTabCustomClass'));
	              var tab = angular.element(tabObj);
	              var item;
	              var clean;
	              if (tab.scope().item) {
	                clean = angular.element(angular.element(getTabTemplate()).find('.fisTabCustomClass'));
	                item = tab.scope().item.view;
	              }
	              // if cls is provided to the navigation item or if it has an actionController, compile the element after adding the cls as class
	              if (!_.isUndefined(item) && !_.isUndefined(item.args) && !_.isUndefined(item.args.tabClass) && tabCustomClass.hasClass('compiled') || !_.isUndefined(item) && !_.isUndefined(item.args) && !_.isUndefined(item.args.tabClass) && !tabCustomClass.hasClass('compiled')) {
	                if (item.args.tabClass) {
	                  clean.addClass(item.args.tabClass);
	                  clean.addClass('compiled');
	                }
	
	                $compile(clean)(tab.scope());
	                if (clean.scope()) {
	                  clean.scope().$apply();
	                }
	
	                tabCustomClass.replaceWith(clean);
	
	                if (tabCustomClass.find('[ng-dblclick="rename(item.view, $event)"]').length === 0 || clean.find('[ng-blur="setTitle(item.view, $event)"]').length === 0) {
	                  // Renamablity of tab lost
	                  console.warn(item.args.tabClass + ' results in tab[' + item.label + '] not being renamable');
	                }
	              } else if (item && tabCustomClass.hasClass('fisTabCustomClass') && tabCustomClass.hasClass('compiled')) {
	                // has been compiled or altered
	                cleanUp(clean, tabCustomClass, tab);
	              }
	            });
	          }, 0);
	          fisMemoryUtil.cancelTimeoutOnDestroy($scope, classTimeout, $timeout);
	        }
	      });
	
	      $scope.$watch(tabPathsForWatch, function () {
	        var newViews = $scope.viewPanels();
	        var overflowViews = $scope.overflowViewModel ? _.map($scope.overflowViewModel.overflow, 'view') : [];
	
	        var newTabsViews = _.filter(newViews, function (newView) {
	          return _.every(overflowViews, function (overflowView) {
	            return newView.path !== overflowView.path;
	          });
	        });
	
	        var overflowTabViews = _.filter(newViews, function (newView) {
	          return _.some(overflowViews, function (overflowView) {
	            return newView.path === overflowView.path;
	          });
	        });
	
	        var newTabs = [];
	
	        angular.forEach(newTabsViews, function (tabView) {
	          var newTab = {
	            label: tabView.label,
	            icon: tabView.icon,
	            path: tabView.path,
	            view: tabView,
	            parentTitle: tabView.parentTitle,
	            parentIcon: tabView.parentIcon
	          };
	          newTabs.push(newTab);
	        });
	
	        var newOverflow = [];
	
	        angular.forEach(overflowTabViews, function (overflowView) {
	          newOverflow.push({
	            path: overflowView.path,
	            view: overflowView
	          });
	        });
	
	        $scope.tabs = newTabs;
	        if ($scope.overflowViewModel) {
	          $scope.overflowViewModel.overflow = newOverflow;
	        }
	      });
	
	      $scope.tabs = [];
	      $scope.showPanels = true;
	      $scope.tabsHistory = [];
	      $scope.fisPubSubService = fisPubSubService;
	
	      $scope.startMenu = {
	        toggle: function toggle() {
	          if (!fisResponsiveService.isResponsive()) {
	            var startMenuScope = element.find('.fis-start-menu').scope();
	            if (_.isObject(startMenuScope)) {
	              if (startMenuScope.startMenuModel.closed) {
	                fisPubSubService.publish('shell.navLoading', true);
	              }
	            }
	          }
	          $timeout(function () {
	            $scope.fisPubSubService.publish('fisStartMenuToggleVisibility', {});
	            $scope.resumeWatches();
	          });
	        },
	        opened: false
	      };
	
	      /**
	       * @name getAllTabs
	       * @description Returns all tabs on the navigation bar(navigation tabs, overflow tab and the close tab)
	       */
	      $scope.getAllTabs = function () {
	        return element.find('.nav > li.fis-tab');
	      };
	
	      /**
	       * @name getNavTabs
	       * @description Returns all navigation tabs on the navigation bar
	       */
	      $scope.getNavTabs = function () {
	        return element.find('.nav > li.fis-tab[data-path]');
	      };
	
	      /**
	       * @name getAllNavTabs
	       * @description Returns all navigation tabs on the navigation bar
	       */
	      $scope.getAllNavTabs = function () {
	        return $scope.getNavTabs(true);
	      };
	
	      $scope.viewPanels = function () {
	        return fisViewPanelService.viewPanels();
	      };
	
	      $scope.getClass = function (viewPanel) {
	        var classes = [];
	        if (fisViewPanelService.selectedViewPanelPath() === viewPanel.path) {
	          classes.push('fis-active');
	        } else {
	          classes.push('fis-inactive');
	        }
	        if (viewPanel.draggable === false) {
	          classes.push('fis-non-draggable');
	        }
	        if ($scope.renderClose(viewPanel)) {
	          classes.push('fis-closable');
	        }
	        return classes;
	      };
	
	      $scope.renderClose = function (navItem) {
	        return !fisViewPanelService.isNonCloseable(navItem);
	      };
	
	      $scope.openPath = function (path, $event, params) {
	        fisViewPanelService.open(path, $event, params);
	      };
	
	      $scope.openItem = function (item, $event, params) {
	        fisPubSubService.publish('fisTabsBar.tabOpened');
	        fisViewPanelService.open(item.view.path, $event, params);
	      };
	
	      function hasNextTab(dataPath) {
	        var tab = element.find('.nav > li.fis-tab[data-path ="' + dataPath + '"]').next('.fis-tab');
	        return !tab.hasClass('fis-new-workspace-tab');
	      }
	      function hasPrecedingTab(dataPath) {
	        var tab = element.find('.nav > li.fis-tab[data-path ="' + dataPath + '"]').prev('.fis-tab');
	        return tab.hasClass('fis-tab');
	      }
	      function getNextPath(dataPath) {
	        var tab = element.find('.nav > li.fis-tab[data-path ="' + dataPath + '"]').next('.fis-tab');
	        return tab.attr('data-path');
	      }
	      function getPreviousPath(dataPath) {
	        var tab = element.find('.nav > li.fis-tab[data-path ="' + dataPath + '"]').prev('.fis-tab');
	        return tab.attr('data-path');
	      }
	
	      $scope.keyboardNavigation = function (e) {
	        var evtobj = e ? e : window.event; // eslint-disable-line no-restricted-globals
	        var activeTab = element.find('li.fis-active');
	        var dataPath = activeTab.attr('data-path');
	
	        // eslint-disable-next-line eqeqeq
	        if (hasNextTab(dataPath) && evtobj.keyCode == 39 && evtobj.altKey) {
	          // open tab to the right
	          fisViewPanelService.open(getNextPath(dataPath));
	        } else if (hasPrecedingTab(dataPath) && evtobj.keyCode == 37 && evtobj.altKey) {
	          // eslint-disable-line eqeqeq
	          // open tab to the left
	          fisViewPanelService.open(getPreviousPath(dataPath));
	        }
	      };
	
	      /* $scope.drop = function (event) {
	          var sourceIndex = event.draggable.currentTarget.index();
	          var targetIndex = event.dropTarget.index();
	          if (targetIndex < 2) {
	              return false;
	          }
	           var dropTargetWidth = event.dropTarget.width();
	           var sourceOffset = event.draggable.hint.offset().left;
	          var targetOffset = event.dropTarget.offset().left;
	          var addAfter = (sourceOffset > (targetOffset + dropTargetWidth / 2)) ? 'true' : 'false';
	           var tabToMove = $scope.tabs.splice(sourceIndex, 1)[0];
	           if (sourceIndex <= targetIndex) { // Moving to left
	              if (addAfter === 'true') {
	                  $scope.tabs.splice(targetIndex, 0, tabToMove);
	              }
	              else {
	                  $scope.tabs.splice(targetIndex - 1, 0, tabToMove);
	              }
	          }
	          else {      //Moving to right
	              if (addAfter === 'true') {
	                  $scope.tabs.splice(targetIndex + 1, 0, tabToMove);
	              }
	              else {
	                  $scope.tabs.splice(targetIndex, 0, tabToMove);
	              }
	          }
	          $scope.$apply();
	           return true;
	       };*/
	
	      var draggedTab, draggedTabLabel; // eslint-disable-line no-unused-vars, one-var
	
	      $scope.isDraggable = function (viewPanel) {
	        if (viewPanel && viewPanel.draggable === false) {
	          return false;
	        }
	        return true;
	      };
	
	      fisPubSubService.subscribe('fisOnDragStart.fisTabsBar', function (args) {
	        var event = args.event;
	        draggedTab = event.target;
	        draggedTabLabel = normalizeLabel(event.target.innerText);
	      });
	
	      fisPubSubService.subscribe('fisOnDrop.fisTabsBar', function (args) {
	        var event = args.event;
	
	        // eslint-disable-next-line brace-style, max-statements-per-line
	        var sourceIndex = $scope.tabs.indexOf($.grep($scope.tabs, function (e) {
	          return e.label === draggedTabLabel;
	        })[0]);
	        // eslint-disable-next-line brace-style, max-statements-per-line
	        var targetIndex = $scope.tabs.indexOf($.grep($scope.tabs, function (e) {
	          return e.label === event.target.innerText;
	        })[0]);
	
	        if (sourceIndex >= 0 && targetIndex >= 0) {
	          var tabToMove = $scope.tabs.splice(sourceIndex, 1)[0];
	
	          /* if (sourceIndex <= targetIndex) { // Moving to left
	           $scope.tabs.splice(targetIndex - 1, 0, tabToMove);
	           }
	           else {      //Moving to right
	           $scope.tabs.splice(targetIndex, 0, tabToMove);
	           }*/
	          $scope.tabs.splice(targetIndex, 0, tabToMove);
	
	          $scope.$apply();
	        }
	      });
	
	      function normalizeLabel(label) {
	        label = label.trim();
	
	        // check if tab label has close icon present - character code for it is 215
	        // ref: http://stevehardie.com/2009/09/character-code-list-char-code/
	        if (label.charCodeAt(label.length - 1) === 215) {
	          label = label.substring(0, label.length - 2).trim();
	        }
	        return label;
	      }
	
	      $scope.close = function ($event, path) {
	        fisPubSubService.publish('fisTabsBar.tabClosed'); // SDHTML-10742
	        if ($event) {
	          $event.stopPropagation(); // to avoid triggering tab selection
	        }
	        // Try closing the viewPanel and swallow any promise rejections
	        fisViewPanelService.close(path).catch(angular.noop);
	      };
	
	      $scope.resumeWatches = function () {
	        if (_.isNull(resumeTimeout)) {
	          var menuContentScope = $('.fis-start-menu-content-area').scope();
	          if (_.isObject(menuContentScope)) {
	            fisPubSubService.publish('shell.resumeWatch', menuContentScope);
	          }
	        }
	      };
	
	      $scope.suspendWatches = function () {
	        var startMenuScope = $('.fis-start-menu').scope();
	        var menuClosed = startMenuScope.startMenuModel.closed;
	        var onMegaMenuBtn = $(':hover > button.fis-home').length > 0;
	        if (_.isNull(resumeTimeout) && menuClosed === true && onMegaMenuBtn === false) {
	          resumeTimeout = $timeout(function () {
	            var startMenuScope = $('.fis-start-menu').scope();
	            var menuContentScope = $('.fis-start-menu-content-area').scope();
	            var menuClosed = startMenuScope.startMenuModel.closed;
	
	            if (menuClosed === true && _.isObject(menuContentScope)) {
	              fisPubSubService.publish('shell.suspendWatch', menuContentScope);
	            }
	            $timeout.cancel(resumeTimeout);
	            resumeTimeout = null;
	          }, 250);
	        }
	      };
	    }],
	    compile: function compile() {
	      return function () {
	        var tabHolder = $('.fis-displaypanel ul.nav-tabs'); // eslint-disable-line no-unused-vars
	
	        /* tabHolder.kendoDraggable({
	            filter: 'li.fis-tab:not(.fis-non-draggable)', // cannot drag the 'Welcome' & 'Dashboard' tabs nor the '+' tab
	            axis: 'x',
	            hint: function (item) {
	                jQuery('span.fis-cover').hide(); // hide the x in top-right corner, don't want to drag this
	                return $(item).clone().addClass('fis-draggable').addClass('fis-draggable-no-list'); // draggable-no-list ensures that if tab is dragged beyond drop target the bullet is hidden
	            },
	            dragend: onDragEnd
	        });
	         tabHolder.kendoDropTargetArea({
	            filter: 'li.fis-tab',
	            drop: scope.drop
	        });*/
	      };
	
	      /**
	       * @name onDragEnd
	       * @param e {Event}
	       *
	       * @description Ensures that the 'x' icon is added
	       * to the tab once dragging is finished.
	       */
	      /* function onDragEnd(e) {
	          jQuery('span.fis-cover').show(); // show the x in top-right corner of the tab
	      }*/
	    }
	
	  };
	};
	
	__webpack_require__(/*! ./tabs-bar.styles.less */ 55);
	
	__webpack_require__(/*! ./sub-nav-bar.styles.less */ 56);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 55 */
/*!**************************************************!*\
  !*** ./components/tabs-bar/tabs-bar.styles.less ***!
  \**************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 56 */
/*!*****************************************************!*\
  !*** ./components/tabs-bar/sub-nav-bar.styles.less ***!
  \*****************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 57 */
/*!***********************************************!*\
  !*** ./components/tabs-closing-menu/index.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _tabsClosingMenu = __webpack_require__(/*! ./tabs-closing-menu.directive */ 58);
	
	var _tabsClosingMenu2 = _interopRequireDefault(_tabsClosingMenu);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.tabs-closing-menu', []);
	
	ngModule.directive('fisTabsClosingMenu', _tabsClosingMenu2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 58 */
/*!*********************************************************************!*\
  !*** ./components/tabs-closing-menu/tabs-closing-menu.directive.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "fisConfig", function ($compile, fisConfig) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    priority: 510,
	    controller: ['$scope', '$timeout', '$rootScope', 'fisViewPanelService', 'fisPubSubService', 'fisI18nService', function ($scope, $timeout, $rootScope, fisViewPanelService, fisPubSubService, fisI18nService) {
	      $scope.menuEnabled = 'notReady';
	      $scope.ready = false;
	      $scope.i18 = {};
	      $scope.canClose = false;
	      $scope.canCloseNotActive = false;
	      $scope.isAllCloseable; // eslint-disable-line no-unused-expressions
	
	      $scope.mousebusy = false;
	
	      fisPubSubService.subscribe('shell.navReady', function () {
	        $scope.ready = true;
	        $scope.i18.close = fisI18nService.translate('fisTabsClosingMenu.closeall', 'Close all Tabs');
	        $scope.i18.closeEA = fisI18nService.translate('fisTabsClosingMenu.closeallnotActive', 'Close all but Active tab');
	      });
	
	      // fisPubSubService.subscribe('shell.configReady', function (config) {
	      if (!_.isUndefined(fisConfig.widgets && fisConfig.widgets.fisTabsClosingMenu)) {
	        $scope.menuEnabled = fisConfig.widgets.fisTabsClosingMenu;
	      }
	      // }, true);
	
	      $scope.getCloseableTabs = function () {
	        var panels = fisViewPanelService.viewPanels();
	
	        var closableTabs = 0;
	        _.each(panels, function (value) {
	          if (!fisViewPanelService.isNonCloseable(value)) {
	            $scope.canClose = true;
	            closableTabs++;
	            if (fisViewPanelService.activeViewPanel().path === value.path) {
	              $scope.canCloseNotActive = true;
	            }
	          }
	        });
	
	        if (closableTabs > 0) {
	          $scope.isAllCloseable = true;
	        } else {
	          $scope.isAllCloseable = false;
	        }
	        return $scope.isAllCloseable;
	      };
	
	      $scope.toggleClosingMenu = function ($event) {
	        var overflow = $('.fis-close-menu-tab-container');
	
	        var windowScrollTop = $(window).scrollTop(); // see fisTabbedComponentList.scope.showOverflowMenu for original source
	        var target = $($event.currentTarget);
	        var offset = target.offset();
	        // + outerHeight() pushes the overflow list beneath the overflow tab and - windowScrollTop ensures menu stays in same place if scrolling down
	        var dd_top = offset.top + target.outerHeight() - windowScrollTop; // eslint-disable-line camelcase
	
	        // optionally as per spec subtract the fis-subnav-bar height
	        var subnavHeight = 9;
	        dd_top = dd_top - subnavHeight; // eslint-disable-line camelcase, operator-assignment
	
	        setMenuState(overflow);
	
	        $('body').append(overflow);
	        overflow.toggle();
	
	        overflow.css({
	          position: 'fixed',
	          top: dd_top + 'px ', // eslint-disable-line camelcase
	          right: $(window).outerWidth() - target.offset().left - target.outerWidth()
	        });
	        $('.fis-close-menu-tab').first().focus();
	
	        $scope.closeMenu(overflow);
	      };
	
	      /**
	       * Closes the menu, unless the mouse is busy, and reschedules check.
	       * @param overflow
	       */
	      $scope.closeMenu = function (overflow) {
	        $scope.mousebusy = !$scope.mousebusy;
	        overflow.toggle($scope.mousebusy);
	        if ($scope.mousebusy === true) {
	          $('.fis-close-menu-tab').first().focus();
	        }
	        // removed event.stopPropagation to avoid future conflict with other event.
	        // added cleaner check below. SDHTML-12780
	      };
	
	      $(document).click(function (e) {
	        if (!$(e.target).closest('.fis-close-tabs-container').length) {
	          $scope.mousebusy = false;
	          $('.fis-close-menu-tab-container').toggle($scope.mousebusy);
	        }
	      });
	
	      $scope.closeAllTabs = function () {
	        if ($scope.canClose) {
	          $('.fis-close-menu-tab-container').toggle();
	          closeAll();
	        }
	      };
	
	      $scope.closeAllOtherTabs = function () {
	        if ($scope.canCloseNotActive) {
	          $('.fis-close-menu-tab-container').toggle();
	          closeAll(true);
	        }
	      };
	
	      /**
	       * Close all tabs with optional parameter to keep open tab.
	       * @param exceptOpen boolean.
	       */
	      function closeAll(exceptOpen) {
	        var panels = fisViewPanelService.viewPanels();
	        _.each(panels, function (value) {
	          if (!fisViewPanelService.isNonCloseable(value)) {
	            if (!(exceptOpen && fisViewPanelService.activeViewPanel().path === value.path && exceptOpen === true)) {
	              fisViewPanelService.close(value.path);
	            }
	          }
	        });
	      }
	
	      /**
	       * Controls the enabled / disabled state of the submenu items.
	       * @param element listItem.
	       */
	      function setMenuState(element) {
	        var navs = element.find('.fis-close-menu-tab');
	        var panels = fisViewPanelService.viewPanels();
	
	        var closableTabs = 0;
	        _.each(panels, function (value) {
	          if (!fisViewPanelService.isNonCloseable(value)) {
	            $scope.canClose = true;
	            closableTabs++;
	            if (fisViewPanelService.activeViewPanel().path === value.path) {
	              $scope.canCloseNotActive = true;
	            }
	          }
	        });
	        if (closableTabs < 2) {
	          $scope.canCloseNotActive = false;
	        }
	        if (closableTabs < 1) {
	          $scope.canClose = false;
	        }
	        setEnabled(navs[0], $scope.canClose);
	        setEnabled(navs[1], $scope.canCloseNotActive);
	      }
	
	      /**
	       * Convenience method for setMenuState method.
	       * @param item
	       * @param enabled
	       */
	      function setEnabled(item, enabled) {
	        if (enabled) {
	          $(item).removeClass('disabled');
	          $(item).addClass('enabled');
	        } else {
	          $(item).addClass('disabled');
	          $(item).removeClass('enabled');
	        }
	      }
	    }],
	    link: function link(scope, elem) {
	      var getTemplate = function getTemplate() {
	        // eslint-disable-next-line no-multi-str
	        var overflowTemplate = '<li ng-show="getCloseableTabs()" class="pull-right fis-close-tabs-container fis-tab fis-non-draggable" ng-click="toggleClosingMenu($event)">\
	                         <div ng-show="true" class="fis-close-tabs-icon-holder">\
	                             <i class="dropdown-toggle glyphicon glyphicon-remove" aria-label="Close" fis-unique-id "></i> \
	                             <ul class="dropdown-menu pull-right fis-close-menu-tab-container" role="menu">\
	                                 <li  class="fis-close-menu-tab" fis-unique-id aria-label="close all tabs" ng-click="closeAllTabs($event)" id="fis-close-menu-tab_1">\
	                                    <span class="glyphicon glyphicon-remove"/><span class="fis-close-menu-tab-spacer"/><span>{{i18.close}}</span></li>\
	                                 <li  class="fis-close-menu-tab" fis-unique-id ng-click="closeAllOtherTabs($event)" id="fis-close-menu-tab_2">\
	                                    <span class="glyphicon glyphicon-remove"/><span class="fis-close-menu-tab-spacer"/><span>{{i18.closeEA}}</span></li>\
	                             </ul>\
	                         </div>\
	                     </li>';
	
	        var menu = $compile(angular.element(overflowTemplate))(scope);
	        var subMenu = menu.find('.fis-close-menu-tab-container'); // eslint-disable-line no-unused-vars
	        return menu;
	      };
	
	      scope.$watch('menuEnabled', function (newValue) {
	        // Needed to signal to the dropdowns that are based off the body tag.
	        $('body').toggleClass('fis-tab-closing-menu-enabled', newValue.enabled);
	
	        if (newValue.enabled === true) {
	          elem.parent().addClass('fis-tab-closing-menu-enabed');
	          var menu = getTemplate();
	          var navContainer = elem.find('.nav');
	          navContainer.append(menu);
	          // currently no requirement to disable the menu, but should be added here when needed.
	        }
	        if (newValue.enabled === false) {
	          $('.fis-overflow-container').addClass('fis-overflow-no-close-menu');
	        }
	      });
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 59 */
/*!************************************************!*\
  !*** ./components/tabs-overflow-menu/index.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _tabsOverflowMenu = __webpack_require__(/*! ./tabs-overflow-menu.directive */ 60);
	
	var _tabsOverflowMenu2 = _interopRequireDefault(_tabsOverflowMenu);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.tabs-overflow-menu', []);
	
	ngModule.directive('fisTabsOverflowMenu', _tabsOverflowMenu2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 60 */
/*!***********************************************************************!*\
  !*** ./components/tabs-overflow-menu/tabs-overflow-menu.directive.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "$window", "$timeout", "fisUniqueIdService", "fisResponsiveService", "fisViewPanelService", "fisPubSubService", "fisMemoryUtilService", "$interval", function ($compile, $window, $timeout, fisUniqueIdService, fisResponsiveService, fisViewPanelService, fisPubSubService, fisMemoryUtilService, $interval) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    priority: 500,
	    controller: ['$element', '$scope', '$timeout', '$window', '$rootScope', 'fisViewPanelService', function ($element, $scope, $timeout, $window, $rootScope, fisViewPanelService) {
	      var viewModel = undefined; // eslint-disable-line no-undef-init
	
	      $scope.overflowViewModel = viewModel = {
	        activeTab: undefined,
	        addToOverflow: undefined,
	        addToTabs: undefined,
	        clicked: undefined,
	        hasViewPanels: false,
	        newWorkspaceTab: undefined,
	        overflow: [],
	        removeFromOverflow: undefined,
	        removeFromTabs: undefined,
	        showDropdown: false,
	        ready: false
	      };
	
	      var isTabValid = function isTabValid(tab) {
	        if (_.isObject(tab)) {
	          if (!(_.has(tab, 'path') && _.isString(tab.path) && !isBlank(tab.path))) {
	            // eslint-disable-line no-use-before-define
	            console.warn('Cannot move an empty path.');
	            return false;
	          }
	
	          if (!(_.has(tab, 'view') && _.isObject(tab.view))) {
	            console.warn('Cannot move an empty view panel.');
	            return false;
	          }
	        } else {
	          console.warn('Cannot move an empty tab.');
	          return false;
	        }
	
	        return true;
	      };
	
	      /**
	       * Tests a string to see if it is empty or has only whitespace characters.
	       * @param {string} str - A string to test.
	       * @return {Boolean} Returns true if the string is empty or has only whitespace characters.
	       */
	      var isBlank = function isBlank(str) {
	        if (str == null) {
	          // eslint-disable-line eqeqeq, no-eq-null
	          str = '';
	        }
	
	        return (/^\s*$/.test(str)
	        );
	      };
	
	      /**
	       * Removes an item from the overflow collection.
	       * @param {(Tab|string)} param - A path used to identify an item in the overflow collection. The parameter can either be an object with a 'path' property, or a string.
	       * @return {(Tab|null)} Returns a reference to the object that has been removed, or null if there was no object that matches the path.
	       */
	      viewModel.removeFromOverflow = function (pathOrTab) {
	        var path = '';
	        var tabFound = false;
	        var foundTabIndex = -1;
	
	        if (_.isString(pathOrTab)) {
	          if (!isBlank(pathOrTab)) {
	            // eslint-disable-line no-negated-condition
	            path = pathOrTab;
	          } else {
	            console.warn('Cannot move an empty path.');
	            return null;
	          }
	        } else if (isTabValid(pathOrTab)) {
	          path = pathOrTab.path;
	        } else {
	          return null;
	        }
	
	        // Find the tab in the overflow based on path property.
	        var tab = _.find(viewModel.overflow, function (item, index) {
	          if (item.path === path) {
	            tabFound = true;
	            foundTabIndex = index;
	            return true;
	          }
	
	          return false;
	        });
	        if (tabFound && foundTabIndex !== -1) {
	          viewModel.overflow.splice(foundTabIndex, 1);
	        }
	        // The tab might be undefined becuase of _.find() so let's test it,
	        return !_.isEmpty(tab) ? tab : null; // eslint-disable-line no-negated-condition
	      };
	
	      /**
	       * Removes an item from the tabs collection.
	       * @param {(Tab|string)} param - A path used to identify an item in the tabs collection. The parameter can either be an object with a 'path' property, or a string.
	       * @return {(Tab|null)} Returns a reference to the object that has been removed, or null if there was no object that matches the path.
	       */
	      viewModel.removeFromTabs = function (pathOrTab) {
	        var path = '';
	        var tabFound = false;
	        var foundTabIndex = -1;
	
	        if (_.isString(pathOrTab)) {
	          if (!isBlank(pathOrTab)) {
	            // eslint-disable-line no-negated-condition
	            path = pathOrTab;
	          } else {
	            console.warn('Cannot move an empty path.');
	            return null;
	          }
	        } else if (isTabValid(pathOrTab)) {
	          path = pathOrTab.path;
	        } else {
	          return null;
	        }
	
	        if (fisViewPanelService.selectedViewPanelPath() === path) {
	          console.warn('Cannot move the active view panel.');
	          return null;
	        }
	
	        // Find the tab in the tabs based on path property.
	        var tab = _.find($scope.tabs, function (item, index) {
	          if (item.path === path) {
	            // if (!fisViewPanelService.isNonCloseable(item.view)) {
	            tabFound = true;
	            foundTabIndex = index;
	            return true;
	            // }
	          }
	
	          return false;
	        });
	        if (tabFound && foundTabIndex !== -1) {
	          $scope.tabs.splice(foundTabIndex, 1);
	        }
	        // The tab might be undefined becuase of _.find() so let's test it,
	        return !_.isEmpty(tab) ? tab : null; // eslint-disable-line no-negated-condition
	      };
	
	      /**
	       * Adds an item from the overflow collection.
	       * @param {Tab} tab - An object that has a path and view property.
	       */
	      viewModel.addToOverflow = function (tab) {
	        if (!isTabValid(tab)) {
	          return null;
	        }
	
	        // Is there an item in the collection that has the same path as the tab?
	        var inCollection = _.any(viewModel.overflow, function (item) {
	          return tab.path === item.path;
	        });
	
	        // If not, then add the tab to the start of the collection.
	        if (!inCollection) {
	          viewModel.overflow.unshift(tab);
	        }
	      };
	
	      /**
	       * Adds a tab from the tabs collection.
	       * @param {Tab} tab - An object that has a path and view property.
	       */
	      viewModel.addToTabs = function (tab) {
	        if (!isTabValid(tab)) {
	          return null;
	        }
	
	        // Is there an item in the collection that has the same path as the tab?
	        var inCollection = _.any($scope.tabs, function (item) {
	          return tab.path === item.path;
	        });
	
	        // If not, then add the tab to the end of the collection.
	        if (!inCollection) {
	          $scope.tabs.push(tab);
	        }
	      };
	
	      /**
	       * Show and hide the overflow menu items.
	       */
	      viewModel.toggleMenu = function () {
	        viewModel.showDropdown = !viewModel.showDropdown;
	      };
	
	      /**
	       * Moves the tab to the tabs collection and activates its ViewPanel.
	       * @param {Tab} item - An object that has a path and view property.
	       */
	      viewModel.clicked = function (tab) {
	        if (!isTabValid(tab)) {
	          return false;
	        }
	
	        viewModel.removeFromOverflow(tab);
	        viewModel.addToTabs(tab);
	        fisViewPanelService.open(tab.path, 'true');
	      };
	
	      /**
	       * Moves all the tabs in the overflow collection to the tabs collection.
	       */
	      viewModel.moveOverflowToTabs = function () {
	        $scope.tabs = $scope.tabs.concat(viewModel.overflow);
	        viewModel.overflow.length = 0;
	      };
	
	      /**
	       * Updates the hasViewPanels property when the number of tabs in the overflow collection changes.
	       */
	      $scope.$watch(function () {
	        return _.size(viewModel.overflow) > 0;
	      }, function (hasViewPanels) {
	        viewModel.hasViewPanels = hasViewPanels;
	      });
	    }],
	    link: function link(scope, element) {
	      var viewModel = scope.overflowViewModel;
	      var body = $('body');
	      var resizeTimeout;
	      var intervalFlag = true;
	      // eslint-disable-next-line no-multi-str
	      var overflowTabsTemplate = '\
	                <li ng-repeat="item in overflowViewModel.overflow" data-path="{{item.path}}" ng-class="getClass(item.view)" class="fis-tab fis-overflow-tab" style="visibility: hidden !important;">\
	                    <div fis-unique-id ng-class="{\'fis-cursor-pointer\':item.view.renamable && getClass(item.view.path)===\'fis-active\', \'tabIcon\':hasItemIcon(item)}" class="fis-tab-container" title="{{ prependTitle(item) }}">\
	                        <div ng-class="{\'fis-has-icon\': hasItemIcon(item)}" class="label-icon-wrapper">\
	                            <div ng-if="hasItemIcon(item)" class="fis-legacy-icon" fis-unique-id="{{item.view.title}}_icon"><i class="{{ getItemIcon(item) }}"></i></div>\
	                            <span class="fis-tab-label" ng-if="!item.view.editMode" ng-bind-html="getItemTitle(item)"></span>\
	                            <input class="input-small" ng-blur="setTitle(item.view, $event)" ng-show="item.view.renamable && item.view.editMode"/>\
	                            <span class="fis-cover"><span fis-unique-id ng-if="renderClose(item.view)" class="fis-close">&times;</span></span>\
	                        </div>\
	                    </div>\
	                </li>';
	      // eslint-disable-next-line no-multi-str
	      var overflowMenuTemplate = '\
	                <li class="pull-right fis-overflow-container">\
	                    <div ng-show="overflowViewModel.hasViewPanels">\
	                        <div class="dropdown fis-overflow-menu">\
	                            <a class="dropdown-toggle fis-overflow-menu-caret" fis-unique-id ng-click="overflowViewModel.toggleMenu()"><b class="caret"></b></a>\
	                            <ul class="dropdown-menu pull-right fis-overflow-menu-tab-container" fis-unique-id="overFlowMenuList" role="menu" ng-show="overflowViewModel.showDropdown">\
	                                <li ng-repeat="item in overflowViewModel.overflow" ng-class="getClass(item.view.path)" class="fis-overflow-menu-tab">\
	                                    <div fis-unique-id ng-click="overflowViewModel.clicked(item)" title="{{ getItemTitle(item) }}">\
	                                        <span class="fis-overflow-icon-container"><span ng-if="!hasItemIcon(item)" class="fis-overflow-icon-filler"></span><i ng-if="hasItemIcon(item)" class="{{ getItemIcon(item) }}" ></i></span>\
	                                        <span class="fis-label" ng-bind-html="getItemTitle(item)"></span>\
	                                    </div>\
	                                </li>\
	                            </ul>\
	                        </div>\
	                    </div>\
	                </li>';
	      var lookup = {
	        nav: element.find('.nav'),
	        container: undefined,
	        tabs: undefined,
	        toggle: undefined,
	        dropdown: undefined
	      };
	
	      var init = function init() {
	        lookup.container = $compile(angular.element(overflowMenuTemplate))(scope);
	        lookup.tabs = $compile(angular.element(overflowTabsTemplate))(scope);
	        lookup.toggle = lookup.container.find('.fis-overflow-menu-caret');
	        lookup.dropdown = lookup.container.find('.fis-overflow-menu-tab-container');
	
	        lookup.nav.append(lookup.tabs);
	        lookup.nav.append(lookup.container);
	
	        // Checks to see if jQuery has an 'outside' function, and adds one if not.
	        if (!element.outside) {
	          (function ($) {
	            $.fn.outside = function (ename, cb) {
	              return this.each(function () {
	                var $this = $(this); // eslint-disable-line no-unused-vars
	                var self = this;
	
	                $(document).bind(ename, function tempo(e) {
	                  if (e.target !== self && !$.contains(self, e.target)) {
	                    cb.apply(self, [e]);
	                    if (!self.parentNode) $(document.body).unbind(ename, tempo);
	                  }
	                });
	              });
	            };
	          })(jQuery);
	        }
	
	        // Setup the dropdown so that it's a child of the body, and positioned below the toggle.
	        body.append(lookup.dropdown);
	
	        // check, if click is anywhere else but not on container. SDHTML-12780
	        $(document).on('click', function (e) {
	          if (!$(e.target).closest('.fis-overflow-container').length) {
	            scope.overflowViewModel.showDropdown = false;
	            if (scope.$$phase !== '$apply' && scope.$$phase !== '$digest') {
	              scope.$apply();
	            }
	          }
	        });
	      };
	
	      var resizeThrottler = function resizeThrottler() {
	        // ignore resize events as long as an actualResizeHandler execution is in the queue
	        if (!resizeTimeout) {
	          resizeTimeout = $timeout(function () {
	            if (intervalFlag) {
	              // runs only for the first time to check if view is visible
	              var isViewLoadedCheck = $interval(function () {
	                if (!body.hasClass('hidden')) {
	                  $interval.cancel(isViewLoadedCheck);
	                  balanceTabs(); // eslint-disable-line no-use-before-define
	                  resizeTimeout = null;
	                  intervalFlag = false;
	                }
	              }, 100); // keeping interval as much high for performance.
	            } else {
	              balanceTabs(); // eslint-disable-line no-use-before-define
	              resizeTimeout = null;
	            }
	            // The actualResizeHandler will execute at a rate of 15fps
	          }, 32);
	        }
	      };
	
	      var balanceTabs = function balanceTabs() {
	        // Don't balance the tabs if the page isn't ready, or if the app is in the Responsive state.
	        if (scope.isResponsive || body.hasClass('hidden')) {
	          return;
	        }
	
	        var tabs = lookup.nav.find('.fis-nav-tab');
	
	        if (_.size(tabs) == 0) {
	          // eslint-disable-line eqeqeq
	          return;
	        }
	
	        var workspaceTab = lookup.nav.find('.fis-new-workspace-tab');
	        var activeTab = tabs.filter('.fis-active');
	        var threshold = tabs.filter(':first').offset().top;
	        var dirtyCheck = false;
	
	        _.find(lookup.nav.find('.fis-overflow-tab').get(), function (tab) {
	          var tab = $(tab); // eslint-disable-line no-redeclare
	
	          if (threshold === tab.offset().top) {
	            viewModel.addToTabs(viewModel.removeFromOverflow(tab.attr('data-path')));
	            dirtyCheck = true;
	            return false;
	          } else {
	            // eslint-disable-line no-else-return
	            return true;
	          }
	        });
	
	        _.find(tabs.filter(':not(.fis-active)').get().reverse(), function (tab) {
	          var tab = $(tab); // eslint-disable-line no-redeclare
	
	          if (threshold !== tab.offset().top) {
	            // eslint-disable-line no-negated-condition
	            viewModel.addToOverflow(viewModel.removeFromTabs(tab.attr('data-path')));
	            dirtyCheck = true;
	            return false;
	          } else {
	            // eslint-disable-line no-else-return
	            return true;
	          }
	        });
	
	        if (dirtyCheck) {
	          var balanceTimeout = $timeout(function () {
	            balanceTabs();
	          }, 0);
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, balanceTimeout, $timeout);
	          return;
	        }
	
	        if (_.size(activeTab) > 0) {
	          if (threshold !== activeTab.offset().top) {
	            viewModel.addToOverflow(viewModel.removeFromTabs(tabs.filter(':not(.fis-active)').last().attr('data-path')));
	            dirtyCheck = true;
	          }
	        }
	
	        if (dirtyCheck) {
	          var balanceTimeout2 = $timeout(function () {
	            balanceTabs();
	          }, 0);
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, balanceTimeout2, $timeout);
	          return;
	        }
	
	        var workspaceTabWidth = workspaceTab.outerWidth(true) || 0;
	        var closeIconWidth = lookup.nav.find('.fis-close-tabs-container').outerWidth(true);
	        var workspaceTabOffset = workspaceTab.offset();
	
	        var calculateSize = lookup.nav.outerWidth(true) - (workspaceTabOffset && workspaceTabOffset.left || 0);
	        var availableSpace = calculateSize - workspaceTabWidth - closeIconWidth;
	
	        if (_.size(workspaceTab) > 0) {
	          if (threshold !== workspaceTab.offset().top || availableSpace < lookup.container.outerWidth(true) + 22) {
	            // 22 is width of overflow caret, which is not visible yet.
	            viewModel.addToOverflow(viewModel.removeFromTabs(tabs.filter(':not(.fis-active)').last().attr('data-path')));
	            dirtyCheck = true;
	          }
	        }
	
	        if (dirtyCheck) {
	          var balanceTimeout3 = $timeout(function () {
	            balanceTabs();
	          }, 0);
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, balanceTimeout3, $timeout);
	        }
	      };
	
	      init();
	
	      scope.$watch('overflowViewModel.hasViewPanels', function (hasViewPanels) {
	        // Needed to signal to the dropdowns that are based off the body tag.
	        $('.app > nav').toggleClass('fis-tab-overflow-menu-enabled', hasViewPanels);
	        body.toggleClass('fis-tab-overflow-menu-enabled', hasViewPanels);
	      });
	
	      scope.$watch('overflowViewModel.showDropdown', function () {
	        lookup.dropdown.css({
	          right: parseFloat($($window).width()) - lookup.toggle.offset().left - lookup.toggle.outerWidth()
	        });
	      });
	
	      scope.$watch('isResponsive', function (isResponsive) {
	        if (isResponsive) {
	          viewModel.moveOverflowToTabs();
	        } else {
	          resizeThrottler();
	        }
	      });
	
	      fisPubSubService.subscribe('fisActiveViewPanelChanged', function () {
	        resizeThrottler();
	      });
	
	      fisPubSubService.subscribe('fisViewPanelClosed', function () {
	        resizeThrottler();
	      });
	
	      fisPubSubService.subscribe('shell.navReady', function () {
	        viewModel.ready = true;
	        resizeThrottler();
	      });
	
	      $($window).bind('resize', function () {
	        resizeThrottler();
	        scope.$digest();
	      });
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 61 */
/*!****************************************!*\
  !*** ./components/tabs-width/index.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _tabsWidth = __webpack_require__(/*! ./tabs-width.directive */ 62);
	
	var _tabsWidth2 = _interopRequireDefault(_tabsWidth);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.tabs-width', []);
	
	ngModule.directive('fisTabsWidth', _tabsWidth2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 62 */
/*!*******************************************************!*\
  !*** ./components/tabs-width/tabs-width.directive.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$timeout", "$interval", function ($timeout, $interval) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    scope: {
	      fisTabsDetails: '@',
	      fisTabsClosable: '=',
	      fisTabsFrontIcon: '='
	    },
	    link: function link(scope, element, attrs) {
	      scope.initial = true;
	
	      // Set label width, taking into account all icons.
	      var setWidth = function setWidth() {
	        $timeout(function () {
	          var label = element.find('.fis-tab-label');
	          var icons = element.find('.fisTabIcons');
	
	          var icons_width; // eslint-disable-line camelcase
	
	          icons.css('width', 'auto');
	          label.css('width', 'auto');
	
	          $timeout(function () {
	            icons_width = parseFloat(icons.width()); // eslint-disable-line camelcase
	
	            // The 4 accounts for trailing space in the title
	            var wrapper_width = 200 - icons_width - 4; // eslint-disable-line camelcase
	
	            if (parseFloat(element.width()) > 200) {
	              if (scope.fisTabsFrontIcon) {
	                // Take front icon width and padding into account
	                wrapper_width -= 21; // eslint-disable-line camelcase
	              }
	              label.css('width', wrapper_width);
	            }
	          }, 1); // Need to set timeout to 1ms to get in stack behind all other timeouts at 0.
	
	          // On application reload, the setWidth function runs too early (while application loads).
	          // Set an interval to check that the width is ready, then rerun setWidth.
	          if ((parseFloat(icons.width()) == 0 || parseFloat(label.width()) == 0 || parseFloat(element.width()) > 200) && scope.initial) {
	            // eslint-disable-line eqeqeq
	            scope._widthInterval = $interval(function () {
	              if (parseFloat(label.width()) == 0 || parseFloat(element.width()) > 200) {
	                // eslint-disable-line eqeqeq
	                setWidth();
	                $interval.cancel(scope._widthInterval);
	              }
	            }, 500, 120);
	
	            scope.$on('$destroy', function () {
	              $interval.cancel(scope._widthInterval);
	            });
	          }
	
	          scope.initial = false;
	        }, 0);
	      };
	
	      if (scope.fisTabsClosable) {
	        // Set initial width when new tab is opened
	        setWidth();
	
	        // Observe tab label, when it changes, set width
	        attrs.$observe('fisTabsDetails', function () {
	          setWidth();
	        });
	      }
	    }
	  };
	}];

/***/ }),
/* 63 */
/*!***********************************!*\
  !*** ./components/theme/index.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _theme = __webpack_require__(/*! ./theme.directive */ 64);
	
	var _theme2 = _interopRequireDefault(_theme);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.theme', []);
	
	ngModule.directive('fisTheme', _theme2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 64 */
/*!*********************************************!*\
  !*** ./components/theme/theme.directive.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$document", "$timeout", "fisConfig", "fisPubSubService", "fisUtilService", function ($document, $timeout, fisConfig, fisPubSubService, fisUtilService) {
	  'ngInject';
	
	  return {
	    template: '',
	    restrict: 'AEC',
	    replace: true,
	    link: function link(scope, element, attrs) {
	      $document.find('body').addClass('hidden');
	      $document.find('body').addClass('fis-theme');
	      scope.customstyle = '';
	
	      if (fisConfig.endpoints && fisConfig.endpoints.styles) {
	        scope.customstyle = fisConfig.endpoints.styles;
	      }
	
	      // Used $timeout function as setInterval to check body element visibility
	      // so that when theme applied we can remove loading indicator from body
	      function hideLoadingIndicator() {
	        var timerId = $timeout(function checkVisibility() {
	          if ($document.find('body').css('visibility') !== 'hidden') {
	            // eslint-disable-line no-negated-condition
	            $timeout.cancel(timerId);
	            $document.find('body').removeClass('loading-indicator hidden');
	          } else {
	            timerId = $timeout(checkVisibility, 100);
	          }
	        }, 100);
	      }
	
	      scope.currentTheme.then(function (theme) {
	        applyTheme(theme);
	        hideLoadingIndicator();
	      });
	
	      fisPubSubService.subscribe('fisThemeChanged', function (newTheme) {
	        newTheme.theme.then(function (theme) {
	          $document.find('body').addClass('loading-indicator hidden');
	          removeAppliedTheme();
	          applyTheme(theme);
	          hideLoadingIndicator();
	        });
	      });
	
	      function applyTheme(theme) {
	        var i = 0;
	        if (scope.customstyle) {
	          if (_.isString(scope.customstyle)) {
	            // eslint-disable-line no-undef
	            theme.stylesheets.push(scope.customstyle);
	          } else {
	            theme.stylesheets = theme.stylesheets.concat(scope.customstyle);
	          }
	        }
	        $document.find('body').append('<style> .fis-theme { visibility: hidden;} </style>');
	        if (theme.stylesheets) {
	          for (i = 0; i < theme.stylesheets.length; i++) {
	            var rel = theme.rel ? theme.rel : 'stylesheet';
	            var href = theme.stylesheets[i];
	            href = fisUtilService.appendCacheQueryParameter(href);
	
	            if (attrs.fisThemeParams) {
	              href = fisUtilService.appendQueryParameters(href, attrs.fisThemeParams);
	            }
	            $document.find('body').append('<link class="theme" rel=' + rel + ' type="text/css" href=' + href + '></link>');
	            // added this piece of code to make dynamic link loading work in IE8.
	            // http://stackoverflow.com/a/5541628/529174
	            /* angular.element('<link>')
	              .appendTo($document.find('head'))
	              .attr({'class' : 'theme' , type : 'text/css', rel : rel})
	              .attr('href', href);*/
	          }
	        }
	
	        if (theme.scripts) {
	          for (i = 0; i < theme.scripts.length; i++) {
	            var src = theme.scripts[i];
	            src = fisUtilService.appendCacheQueryParameter(src);
	
	            if (attrs.fisThemeParams) {
	              src = fisUtilService.appendQueryParameters(src, attrs.fisThemeParams);
	            }
	
	            var script = $document[0].createElement('script');
	            script.setAttribute('class', 'theme');
	            script.src = src;
	            $document.find('head')[0].appendChild(script);
	          }
	        }
	      }
	
	      function removeAppliedTheme() {
	        $document.find('link.theme, script.theme').remove();
	      }
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ }),
/* 65 */
/*!*************************************!*\
  !*** ./components/top-bar/index.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _topbar = __webpack_require__(/*! ./topbar.directive */ 66);
	
	var _topbar2 = _interopRequireDefault(_topbar);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.top-bar', []);
	
	ngModule.directive('fisTopBar', _topbar2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 66 */
/*!************************************************!*\
  !*** ./components/top-bar/topbar.directive.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  return {
	    // eslint-disable-next-line no-multi-str
	    template: '<div class="fis-top-bar navbar-static-top">\
	      <div class="top-bar-container">\
	                  <div class="row">\
	                    <div class="brand-logo">\
	                      <div class="pull-left"><div class="logo-container"><div id="SGCommonMenu" class="fis-common-menu" fis-common-menu cm-base-url="{{cmBaseUrl}}" cm-guid="{{cmGuid}}"></div></div></div>\
	                      <div class="brand-title"><h1>{{appTitle}}</h1></div>\
	                    </div>\
	                    <div class="utility-menu"><div class="fis-controls" ng-transclude></div></div>\
	              </div>\
	          </div>\
	      </div>',
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    scope: {
	      appTitle: '@',
	      cmGuid: '@',
	      cmBaseUrl: '@'
	    }
	  };
	};
	
	__webpack_require__(/*! ./top-bar.styles.less */ 67);

/***/ }),
/* 67 */
/*!************************************************!*\
  !*** ./components/top-bar/top-bar.styles.less ***!
  \************************************************/
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 68 */
/*!******************************************!*\
  !*** ./components/utility-menu/index.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _utilityMenu = __webpack_require__(/*! ./utility-menu.directive */ 69);
	
	var _utilityMenu2 = _interopRequireDefault(_utilityMenu);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('shell.components.utility-menu', []);
	
	ngModule.directive('fisUtilityMenu', _utilityMenu2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 69 */
/*!***********************************************************!*\
  !*** ./components/utility-menu/utility-menu.directive.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "fisPubSubService", "$timeout", "fisMemoryUtilService", function ($compile, fisPubSubService, $timeout, fisMemoryUtilService) {
	  'ngInject';
	
	  // function to attach controller and action to the element
	
	  function addController(element, item) {
	    element.attr('ng-controller', item.actionController);
	    element.attr('ng-click', item.action);
	    element.removeAttr('ng-repeat');
	  }
	
	  return {
	    // eslint-disable-next-line no-multi-str
	    template: '<ul class="nav navbar-nav pull-right">\
	                <li fis-unique-id="top_level_utility_{{item.id}}" ng-repeat="item in topLevelUtilityItems" ng-class="{dropdown : item.children}">\
	                    <a fis-unique-id ng-if="!(item.children && item.children.length > 0) && item.partial" href="#" ng-click="open(item.path, $event)">\
	                        <i ng-if="item.icon" class="{{item.icon}}"></i>\
	                        <span ng-bind-html="getValidLabel(item)"></span>\
	                    </a>\
	                    <a tabindex="-1" fis-unique-id ng-if="!(item.children && item.children.length > 0) && !item.partial && !item.menuPartial && item.action" href="" ng-click="item.action;">\
	                        <i ng-if="item.icon" class="{{item.icon}}"></i>\
	                        <span ng-bind-html="getValidLabel(item)"></span>\
	                    </a>\
	                    <span class="noLinkSpan" ng-if="(!item.children.length && !(item.action || item.partial || item.controller || item.menuPartial))" fis-unique-id> <i ng-if="item.icon" class="{{item.icon}}"></i>\
	                    {{item.label}}</span>\
	                    <a fis-unique-id="{{item.label}}_masthead_title" ng-if="(item.children && item.children.length > 0) || item.menuPartial " href="" class="dropdown-toggle masthead-title" data-toggle="dropdown" ng-click="toggleDropdownMenu($event)">\
	                        <i ng-if="item.icon" class="{{item.icon}}"></i>\
	                        <span ng-bind-html="getValidLabel(item)"></span>\
	                        <b class="caret"></b>\
	                    </a>\
	                    <div fis-unique-id="{{item.id}}_masthead" ng-if="(item.children && item.children.length > 0) || item.menuPartial" class="dropdown-menu masthead-nowrap" >\
	                        <div class="masthead" ng-include="item.menuPartial"></div>\
	                        <ul class="masthead">\
	                            <li ng-repeat="child in item.children">\
	                                <a href="">\
	                                    <div fis-unique-id ng-if="child.partial" ng-click="open(child.path)"><span ng-bind-html="getValidLabel(child)"></span>    </div>\
	                                    <div fis-unique-id ng-if="!child.partial"><i ng-if="child.icon" class="{{child.icon}}"></i><span ng-bind-html="getValidLabel(child)"></span></div>\
	                                </a>\
	                            </li>\
	                        </ul>\
	                    </div>\
	                </li>\
	            </ul>',
	    restrict: 'EA',
	    replace: true,
	    controller: ['$scope', '$controller', function ($scope) {
	      var itm; // eslint-disable-line no-unused-vars
	
	      $scope.getValidLabel = function (item) {
	        if (!_.isUndefined(item)) {
	          if (item.label && item.label.indexOf('{{') > -1) {
	            item.label = item.label.replace(/{|}/g, '');
	          }
	          return item.label;
	        }
	      };
	
	      $scope.hasDynamicAction = function (item) {
	        itm = item;
	        return !item.partial && item.actionController && item.action;
	      };
	
	      fisPubSubService.subscribe('shell.navReady', function (nav) {
	        $scope.topLevelUtilityItems = nav.utility;
	      }, true);
	
	      fisPubSubService.subscribe('shell.navChanged', function (nav) {
	        $scope.topLevelUtilityItems = nav.utility;
	      }, true);
	    }],
	    link: function link(scope, element) {
	      var openedDropDown;
	
	      if (!element.outside) {
	        (function ($) {
	          $.fn.outside = function (ename, cb) {
	            return this.each(function () {
	              var $this = $(this); // eslint-disable-line no-unused-vars
	              var self = this;
	
	              $(document).bind(ename, function tempo(e) {
	                if (e.target !== self && !$.contains(self, e.target)) {
	                  cb.apply(self, [e]);
	                  if (!self.parentNode) $(document.body).unbind(ename, tempo);
	                }
	              });
	            });
	          };
	        })(jQuery);
	      }
	
	      function hashCode(value) {
	        // eslint-disable-line no-unused-vars
	        var hash = 0,
	            i,
	            char,
	            l; // eslint-disable-line one-var, one-var-declaration-per-line
	        if (value.length == 0) return hash; // eslint-disable-line eqeqeq
	        for (i = 0, l = value.length; i < l; i++) {
	          char = value.charCodeAt(i);
	          hash = (hash << 5) - hash + char;
	          hash |= 0; // Convert to 32bit integer
	        }
	        return hash;
	      }
	
	      var openedParent = null; // eslint-disable-line no-unused-vars
	      var openedTarget = null; // eslint-disable-line no-unused-vars
	
	      function positionDropDown(srcElement, menuElement) {
	        // eslint-disable-line no-unused-vars
	        var menuOffset = menuElement.offset(); // eslint-disable-line no-unused-vars
	        var sourceOffset = srcElement.offset();
	        var top = sourceOffset.top + srcElement.outerHeight();
	        var width = parseFloat(srcElement.width());
	
	        menuElement.css('position', 'fixed');
	        menuElement.css({
	          top: top + 'px',
	          left: sourceOffset.left + width - parseFloat(menuElement.width()) + 20
	        });
	      }
	
	      function GetChildOfAHostSpot(element, hashedIDLabel, hashedID) {
	        // eslint-disable-line no-unused-vars
	        var child = null;
	
	        if (element !== null) {
	          if (element.attr(hashedIDLabel) === hashedID) {
	            child = element;
	          } else {
	            child = GetChildOfAHostSpot(element.parent(), hashedIDLabel, hashedID); // eslint-disable-line new-cap
	          }
	        }
	
	        return child;
	      }
	
	      function hideDropDown(dropdown) {
	        if (dropdown) {
	          dropdown.hide();
	          openedDropDown = undefined;
	        }
	      }
	
	      function showDropDown(dropdown) {
	        if (dropdown) {
	          dropdown.show();
	          openedDropDown = dropdown;
	        }
	      }
	
	      $(document).on('click', function () {
	        hideDropDown(openedDropDown);
	      });
	
	      var loadedEventHandlers = false; // eslint-disable-line no-unused-vars
	      scope.toggleDropdownMenu = function ($ev) {
	        if ($ev) {
	          $ev.stopPropagation();
	
	          var toggle = $($ev.currentTarget);
	          var dropdown = toggle.next();
	          var hasToggle = toggle.hasClass('dropdown-toggle');
	          var isVisible = dropdown.is(':visible');
	
	          if (hasToggle) {
	            if (isVisible) {
	              hideDropDown(dropdown);
	            } else {
	              hideDropDown(openedDropDown);
	              showDropDown(dropdown);
	            }
	          }
	        }
	      };
	
	      scope.$watch('topLevelUtilityItems', function (newVal, oldVal) {
	        if (newVal !== oldVal) {
	          var classTimeout = $timeout(function () {
	            var children = element.children();
	
	            // add class and controller to item if they are present
	            angular.forEach(children, function (childObj) {
	              var child = angular.element(childObj);
	              var childScope = child.scope();
	              var item = childScope.item;
	              if (item.cls || item.actionController) {
	                if (item.cls) {
	                  child.addClass(childScope.item.cls);
	                }
	                if (item.actionController) {
	                  addController(child, item);
	                }
	              }
	              if (item.icon) {
	                var mastheadAnchorElem = child.find('.dropdown-toggle')[0];
	                if (mastheadAnchorElem) {
	                  var iTag = angular.element(mastheadAnchorElem).find('i')[0];
	                  if (iTag) {
	                    var iTagElem = angular.element(iTag);
	                    iTagElem.addClass(item.icon);
	                    $compile(iTagElem)(childScope);
	                  }
	                }
	              }
	              if (item.children && item.children.length > 0) {
	                var sibling = child.find('div.dropdown-menu')[0];
	                var children = angular.element(sibling).find('li');
	
	                angular.forEach(children, function (elemObj) {
	                  var elem = angular.element(elemObj);
	                  var childObj = elem.scope().child;
	                  if (!_.isUndefined(childObj) && (childObj.cls || childObj.actionController)) {
	                    if (childObj.cls) {
	                      elem.addClass(childObj.cls);
	                    }
	                    if (childObj.actionController) {
	                      addController(elem, childObj);
	                    }
	                  }
	                });
	              }
	            });
	
	            // now compile the children
	            angular.forEach(children, function (childObj) {
	              var child = angular.element(childObj);
	              var childScope = child.scope();
	              var item = childScope.item;
	
	              if (item.cls || item.actionController) {
	                // ng-repeat is removed to avoid repeating the <li> element while re-compiling
	                child.removeAttr('ng-repeat');
	                var innerChildWithNgRepeat = child.find('[ng-repeat]');
	                innerChildWithNgRepeat.removeAttr('ng-repeat');
	                $compile(child)(childScope);
	              }
	
	              // need to compile children against their own scope
	              if (item.children && item.children.length > 0) {
	                var sibling = child.find('div.dropdown-menu')[0];
	                var children = angular.element(sibling).find('li');
	
	                angular.forEach(children, function (elemObj) {
	                  var elem = angular.element(elemObj);
	                  var childObj = elem.scope().child;
	                  if (!_.isUndefined(childObj) && (childObj.cls || childObj.actionController)) {
	                    // ng-repeat is removed to avoid repeating the <li> element while re-compiling
	                    elem.removeAttr('ng-repeat');
	                    $compile(elem)(elem.scope());
	                    var innerChildWithNgRepeat = elem.find('[ng-repeat]');
	                    innerChildWithNgRepeat.removeAttr('ng-repeat');
	                    // $compile(child)(childScope);
	                  }
	                });
	              }
	            });
	          }, 0);
	          fisMemoryUtilService.cancelTimeoutOnDestroy(scope, classTimeout, $timeout);
	        }
	      });
	    }
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 7)))

/***/ })
/******/ ]);
//# sourceMappingURL=fis-shell.js.map;
/*!
 * 
 * @ruf/fis-bootstrap
 * Version: 4.5.0
 * 
 * © 2016
 * Fidelity National Information Services, Inc. and/or its subsidiaries - All Rights Reserved worldwide.
 * This document is protected under the trade secret and copyright laws as the property of Fidelity National Information Services, Inc. and/or its subsidiaries.
 * Copying, reproduction or distribution should be limited and only to employees with a “need to know” to do their job. Any disclosure of this document to third parties is strictly prohibited.
 * 
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(/*! @ruf/fis-bootstrap-components */ 1);
	__webpack_require__(/*! @ruf/fis-bootstrap-table */ 2);
	
	__webpack_require__(/*! ./scripts/lib.module.js */ 3);
	
	module.exports = 'fis.bootstrap';

/***/ }),
/* 1 */
/*!*********************************************!*\
  !*** external "'fis.bootstrap.components'" ***!
  \*********************************************/
/***/ (function(module, exports) {

	module.exports = 'fis.bootstrap.components';

/***/ }),
/* 2 */
/*!****************************************!*\
  !*** external "'fis.bootstrap.table'" ***!
  \****************************************/
/***/ (function(module, exports) {

	module.exports = 'fis.bootstrap.table';

/***/ }),
/* 3 */
/*!*******************************!*\
  !*** ./scripts/lib.module.js ***!
  \*******************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var libModDeps = ['fis.bootstrap.components', 'fis.bootstrap.table'];
	angular.module('fis.bootstrap', libModDeps);
	// backward compatibility
	var ngModule = angular.module('fisBsStarterKit', ['fis.bootstrap']);
	
	exports.default = ngModule.name;

/***/ })
/******/ ]);
//# sourceMappingURL=fis-bootstrap.js.map