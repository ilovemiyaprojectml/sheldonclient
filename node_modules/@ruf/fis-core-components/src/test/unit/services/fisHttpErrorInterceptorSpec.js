'use strict';

describe('fisHttpErrorInterceptor', function () {
  var $httpBackend;

  var throwError = function () {
    throw new Error('Should not have been called');
  };

  beforeEach(angular.mock.module('fis.core'));
  beforeEach(angular.mock.module(function () {
    return function (_$httpBackend_) {
      $httpBackend = _$httpBackend_;
      $httpBackend.when('GET', 'partials/401').respond(401);
      $httpBackend.when('GET', 'partials/403').respond(403);
      $httpBackend.when('GET', 'partials/404').respond(404);
      $httpBackend.when('GET', 'partials/500').respond(500);
      $httpBackend.when('GET', 'partials/302').respond(302);
      $httpBackend.when('GET', 'partials/200').respond(200);
      $httpBackend.when('GET', 'partials/0').respond(0);
    };
  }));

  function setup(fn, status) {
    if (status) {
      angular.mock.module(function (fisHttpErrorInterceptorProvider) {
        fisHttpErrorInterceptorProvider.setLoginRequiredStatus(status);
      });
    }
    angular.mock.inject(function ($http, $rootScope, fisPubSubService) {
      fn($http, $rootScope, fisPubSubService);
    });
  }

  it('by default, should fire fisLoginRequired when 403 is received', function () {
    setup(function ($http, $rootScope) {
      var err = false;
      var loginRequired = false;
      $rootScope.$on('fisLoginRequired', function () {
        loginRequired = true;
      });
      $http.get('partials/403').then(throwError, function () {
        err = true;
      });
      // make sure request is made to backend
      $httpBackend.flush();

      // the error callback should have been invoked
      expect(err).toBe(true);

      // fisLoginRequired should have been fired
      expect(loginRequired).toBe(true);
    });
  });

  it('should accept a different login http status', function () {
    setup(function ($http, $rootScope) {
      var err = false;
      var loginRequired = false;

      $rootScope.$on('fisLoginRequired', function () {
        loginRequired = true;
      });
      $http.get('partials/401').then(throwError, function () {
        err = true;
      });
      // make sure request is made to backend
      $httpBackend.flush();

      // the error callback should have been invoked
      expect(err).toBe(true);

      // fisLoginRequired should have been fired
      expect(loginRequired).toBe(true);

      // the default (403) should not fire fisLoginRequired in this case
      loginRequired = false;
      $http.get('partials/403').then(throwError, function () {
        err = true;
      });
      // make sure request is made to backend
      $httpBackend.flush();

      // the error callback should have been invoked
      expect(err).toBe(true);

      // fisLoginRequired should NOT have been fired
      expect(loginRequired).toBe(false);
    }, 401);
  });

  it('should accept many different login http status', function () {
    setup(function ($http, $rootScope) {
      var err = false;
      var loginRequired = false;

      $rootScope.$on('fisLoginRequired', function () {
        loginRequired = true;
      });

      $http.get('partials/401').then(throwError, function () {
        err = true;
      });
      // make sure request is made to backend
      $httpBackend.flush();

      // the error callback should have been invoked
      expect(err).toBe(true);

      // fisLoginRequired should have been fired
      expect(loginRequired).toBe(true);

      // the 403 should also fire fisLoginRequired in this case
      loginRequired = false;
      $http.get('partials/403').then(throwError, function () {
        err = true;
      });
      // make sure request is made to backend
      $httpBackend.flush();

      // the error callback should have been invoked
      expect(err).toBe(true);

      // fisLoginRequired should also have been fired
      expect(loginRequired).toBe(true);
    }, [401, 403]);
  });

  it('any HTTP error status code should publish the response to the fisHTTPError topic', function () {
    setup(function ($http, $rootScope, fisPubSubService) {
      var err;
      var published;
      var unsub = fisPubSubService.subscribe('fisHTTPError', function (response) {
        published = Boolean(response.config);
      });

      published = false;
      err = false;
      $http.get('partials/403').then(throwError, function () {
        err = true;
      });
      // make sure request is made to backend
      $httpBackend.flush();

      // the error callback should have been invoked
      expect(err).toBe(true);

      // fisLoginRequired should have been fired
      expect(published).toBe(true);

      published = false;
      err = false;
      $http.get('partials/500').then(throwError, function () {
        err = true;
      });
      // make sure request is made to backend
      $httpBackend.flush();

      // the error callback should have been invoked
      expect(err).toBe(true);

      // fisLoginRequired should have been fired
      expect(published).toBe(true);
      unsub();
    });
  });

  it('non-error HTTP status codes should NOT publish the response to the fisHTTPError topic', function () {
    setup(function ($http, $rootScope, fisPubSubService) {
      var err;
      var published;
      var unsub = fisPubSubService.subscribe('fisHTTPError', function (response) {
        published = Boolean(response.config);
      });

      published = false;
      err = false;
      $http.get('partials/302').then(throwError, function () {
        err = true;
      });
      // make sure request is made to backend
      $httpBackend.flush();

      // the error callback should have been invoked for 302
      expect(err).toBe(true);

      // ...but fisHTTPError should not be published
      expect(published).toBe(false);

      published = false;
      err = true;
      $http.get('partials/200').then(function () {
        err = false;
      }, throwError);
      // make sure request is made to backend
      $httpBackend.flush();

      // the error callback should have been invoked
      expect(err).toBe(false);

      // fisLoginRequired should have been fired
      expect(published).toBe(false);
      unsub();
    });
  });
});
