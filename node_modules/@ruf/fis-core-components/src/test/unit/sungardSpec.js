'use strict';

/* jasmine specs for services go here */

describe('fis', function () {
  beforeEach(function () {
    fis.initParams().appStage = 'P';
  });
  afterEach(function () {
    fis.initParams().appStage = 'P';
  });
  it('should define fis and sg namespaces', function () {
    expect(window.fis).toBeDefined();
    expect(window.sg).toBeDefined();
  });

  describe('initParams', function () {
    it('should set defaults when passed no arguments', function () {
      fis.initParams();
      expect(fis.initParams().appStage).toEqual('P');
      expect(fis.initParams().baseElement).toBe(document);
    });

    it('should only extend defaults', function () {
      fis.initParams({ appStage: 'D' });
      expect(fis.initParams().appStage).toEqual('D');
      expect(fis.initParams().baseElement).toBe(document);
    });
  });

  describe('utils.getRequestParam', function () {
    it('should return a single value when only one param exists', function () {
      expect(fis.utils.getRequestParam.call('?some=params&test=success', 'test')).toEqual('success');
    });
    it('should return an array of values when more than one param exists', function () {
      expect(fis.utils.getRequestParam.call('?some=params&test=success&test=success', 'test')).toEqual(['success', 'success']);
    });
    it('should return null if the parameter is not found', function () {
      expect(fis.utils.getRequestParam.call('?some=params&test=success', 'other')).toBe(null);
    });
  });

  describe('fis.prefixContext', function () {
    var pathsObj = {
      jQuery: '/libs/jquery/jquery',
      angular: '/libs/angular/angular'
    };

    it('should return paths unchanged if location path empty', function () {
      spyOn(window.sg, 'getLocationPath').and.returnValue('/');

      var modifiedPaths = fis.prefixContext(pathsObj);
      expect(modifiedPaths.jQuery).toBe('/libs/jquery/jquery');
      expect(modifiedPaths.angular).toBe('/libs/angular/angular');
    });

    it('should return paths unchanged if location path empty space', function () {
      spyOn(window.sg, 'getLocationPath').and.returnValue('');

      var modifiedPaths = fis.prefixContext(pathsObj);
      expect(modifiedPaths.jQuery).toBe('/libs/jquery/jquery');
      expect(modifiedPaths.angular).toBe('/libs/angular/angular');
    });

    it('should prefix location path if for simple location path like /test', function () {
      spyOn(window.sg, 'getLocationPath').and.returnValue('/test');

      var modifiedPaths = fis.prefixContext(pathsObj);
      expect(modifiedPaths.jQuery).toBe('/test/libs/jquery/jquery');
      expect(modifiedPaths.angular).toBe('/test/libs/angular/angular');
    });

    it('should prefix location path if for simple location path like /test', function () {
      spyOn(window.sg, 'getLocationPath').and.returnValue('/test');

      var modifiedPaths = fis.prefixContext(pathsObj);
      expect(modifiedPaths.jQuery).toBe('/test/libs/jquery/jquery');
      expect(modifiedPaths.angular).toBe('/test/libs/angular/angular');
    });

    it('should trim the last / from location path like /test/', function () {
      spyOn(window.sg, 'getLocationPath').and.returnValue('/test/');

      var modifiedPaths = fis.prefixContext(pathsObj);
      expect(modifiedPaths.jQuery).toBe('/test/libs/jquery/jquery');
      expect(modifiedPaths.angular).toBe('/test/libs/angular/angular');
    });

    it('should prefix the location path for multipart location path like /test1/test2', function () {
      spyOn(window.sg, 'getLocationPath').and.returnValue('/test1/test2');

      var modifiedPaths = fis.prefixContext(pathsObj);
      expect(modifiedPaths.jQuery).toBe('/test1/test2/libs/jquery/jquery');
      expect(modifiedPaths.angular).toBe('/test1/test2/libs/angular/angular');
    });

    it('should drop the resource part for location path like /test1/test.html', function () {
      spyOn(window.sg, 'getLocationPath').and.returnValue('/test1/test.html');

      var modifiedPaths = fis.prefixContext(pathsObj);
      expect(modifiedPaths.jQuery).toBe('/test1/libs/jquery/jquery');
      expect(modifiedPaths.angular).toBe('/test1/libs/angular/angular');
    });

    it('should drop the resource part for location path like /test1/test2/test.htm', function () {
      spyOn(window.sg, 'getLocationPath').and.returnValue('/test1/test2/test.htm');

      var modifiedPaths = fis.prefixContext(pathsObj);
      expect(modifiedPaths.jQuery).toBe('/test1/test2/libs/jquery/jquery');
      expect(modifiedPaths.angular).toBe('/test1/test2/libs/angular/angular');
    });
  });

  describe('fis.utils.getInjector', function () {
    it('should return null when fis.start was not yet invoked.', function () {
      expect(fis.utils.getInjector()).toBe(null);
    });
  });

  describe('fis.start', function () {
    it('should set the injector.', function (done) {
      var injector = {};
      spyOn(angular, 'bootstrap').and.returnValue(injector);

      expect(fis.utils.getInjector()).toBe(null);
      expect(fis.initParams().configEndpoint).not.toBeDefined();

      fis.start();

            // Need the setTimeout to skip a javascript frame to let the internal $.ready() function in the fis.start method to complete.
      setTimeout(function () {
        console.log('injector ' + injector + ' ' + fis.utils.getInjector());

        expect(fis.initParams().configEndpoint).toEqual('api/config');
        expect(fis.utils.getInjector()).toBe(injector);

        done(); // call this to finish off the it block
      }, 500);
    });

    it('should throw a meaningful error when missing init parameters', function () {
      spyOn(angular, 'bootstrap').and.returnValue({});
      var initParams = fis.initParams;

      spyOn(fis, 'initParams');

      var success = false;

      try {
        fis.start();
      } catch (err) {
        success = true;
        expect(err.message).toBe('Init params need to be provided to fis.start.');
      }

      expect(success).toBe(true);
            // put it back as it was
      fis.initParams = initParams;
    });

    it('should throw a meaningful error when missing modules in init parameters', function () {
      spyOn(angular, 'bootstrap').and.returnValue({});
      spyOn(fis, 'initParams').and.returnValue({});

      var success = false;

      try {
        fis.start();
      } catch (err) {
        success = true;
        expect(err.message).toBe('Modules needs to be defined in init parameters.');
      }

      expect(success).toBe(true);
    });

    it('should allow passing valid init parameters', function () {
      var ngSpy = spyOn(angular, 'bootstrap').and.returnValue({});
      spyOn(fis.utils, 'getInjector').and.returnValue(null);

      var modules = ['my-module'];

      fis.bootstrapAngular(modules);
      expect(ngSpy).toHaveBeenCalledWith(document, modules);
    });
  });
});
