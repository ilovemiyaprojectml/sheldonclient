'use strict';

describe('fisUniqueIdService', function () {
  beforeEach(angular.mock.module('fis.core'));

  beforeEach(function () {
    fis.initParams().appStage = 'P';
  });
  afterEach(function () {
    fis.initParams().appStage = 'P';
  });

  describe('generating correct unique id values (testing generateUniqueIdForce)', function () {
    function checkRootScopeListener(rootScope) {
            // generateUniqueIdForce registers a listener on the scope.$root scope
            // Check that this listener exists
      expect(rootScope.$$listenerCount).toBeDefined();
      expect(rootScope.$$listenerCount.$routeChangeStart).toBe(1);
      expect(angular.isArray(rootScope.$$listeners.$routeChangeStart)).toBe(true);
      expect(rootScope.$$listeners.$routeChangeStart.length).toBe(1);
    }

    it('should generate a unique id for a character only string', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'foo')).toBe('foo_1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id for a numeric string', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, '12')).toBe('12_1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should throw an error for boolean value', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
        expect(function () {
          fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, true);
        }).toThrow();
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id for similar to existing fisId', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'abc1')).toBe('abc1_1');
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'abc1_1')).toBe('abc1_1_1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id for empty string', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, '')).toBe('_1');
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, '')).toBe('_2');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id when no string passed', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes)).toBe('_1');
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes)).toBe('_2');
        checkRootScopeListener($rootScope);
      });
    });

    it('should NOT generate a unique id for space only string', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, ' ')).toBe('__1');
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, ' ')).toBe('__2');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id replacing all special characters expect underscore and dash', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, '_a.b,c-d#e+f*g`h?i)j%k$l§m!n@o;p:q>r<s{t[u]v}w|xüy\\z')).toBe('_a_b_c-d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z_1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id using ngModel value if present and no idBase available', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = { ngModel: 'modelValue' };
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes)).toBe('modelValue_1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id NOT using ngModel value if present and idBase available', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = { ngModel: 'modelValue' };
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'abc')).toBe('abc_1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id using item path if present, ngClick is used and no idBase available', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var scope = $rootScope.$new();
        scope.item = { path: 'dummyPath' };
        var attributes = { ngClick: function () {} };
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes)).toBe('dummyPath_1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id NOT using item path if present, ngClick is used but idBase available', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var scope = $rootScope.$new();
        scope.item = { path: 'dummyPath' };
        var attributes = { ngClick: function () {} };
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'id2Base')).toBe('id2Base_1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id using ngClick property value if present, no item path and idBase available', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = { ngClick: 'actionYeah()' };
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes)).toBe('actionYeah__1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id NOT using ngClick property value if present, no item path but idBase available', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = { ngClick: 'actionYeah()' };
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'id2Base')).toBe('id2Base_1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id using fisI18n property value if present and no idBase available', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = { fisI18n: 'international' };
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes)).toBe('international_1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id NOT using fisI18n property value if present and idBase available', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = { fisI18n: 'international' };
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'myId')).toBe('myId_1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id using ngModel property value, even if item path and is available', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = { ngModel: 'modelValue' };
        var scope = $rootScope.$new();
        scope.item = { path: 'theWay' };
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes)).toBe('modelValue_1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should generate a unique id using item path value, altough if fisI18n is available', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = { fisI18n: 'international' };
        var scope = $rootScope.$new();
        scope.item = { path: 'theWay' };
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes)).toBe('international_1');
        checkRootScopeListener($rootScope);
      });
    });

    it('should increment suffix number to create unique ids', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'foo')).toBe('foo_1');
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'foo')).toBe('foo_2');
        checkRootScopeListener($rootScope);
      });
    });

    it('should increment suffix number to create unique ids', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'foo')).toBe('foo_1');
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'foo')).toBe('foo_2');
        checkRootScopeListener($rootScope);
      });
    });

    it('should reset idCounter when angular route changes', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'foo')).toBe('foo_1');
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'foo')).toBe('foo_2');
        checkRootScopeListener($rootScope);
                // Emit a routeChangeStart event, so the service reset the idCounter
        $rootScope.$emit('$routeChangeStart');
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'foo')).toBe('foo_1');
        expect(fisUniqueIdService.generateUniqueIdForce(scope, undefined, attributes, 'foo')).toBe('foo_2');
      });
    });
  });

  describe('handling the element the right way (testing generateUniqueIdForce\'s element handling)', function () {
    it('should add fisId property to passed element and return the fisId', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var scope = $rootScope.$new();
        var element = angular.element('<p></p>');
        var attributes = {};
        expect(fisUniqueIdService.generateUniqueIdForce(scope, element, attributes, 'theIdBase')).toBe('theIdBase_1');
        expect(element.attr('fisId')).toEqual('theIdBase_1');
      });
    });

    it('should not override existing fisId property on passed element and return the existing one', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var scope = $rootScope.$new();
        var element = angular.element('<p fisid="ImHere"></p>');
        var attributes = {};
        expect(fisUniqueIdService.generateUniqueIdForce(scope, element, attributes, 'theIdBase')).toBe('ImHere');
        expect(element.attr('fisId')).toEqual('ImHere');
      });
    });

    it('should override existing fisId property on passed element if said so', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var scope = $rootScope.$new();
        var element = angular.element('<p fisid="ImHere"></p>');
        var attributes = {};
        expect(fisUniqueIdService.generateUniqueIdForce(scope, element, attributes, 'theIdBase', true)).toBe('theIdBase_1');
        expect(element.attr('fisId')).toEqual('theIdBase_1');
      });
    });
  });

  describe('generating correct unique id values with static seed (testing generateIdWithStaticSeed)', function () {
    it('should generate id using idBase', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, 'foo')).toBe('foo');
      });
    });

    it('should generate id using staticId and idBase', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, 'foo', undefined, 'staticId')).toBe('foo_staticId');
      });
    });

    it('should generate id using staticId, childIdBase and idBase', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, 'foo', 'childIdBase', 'staticId')).toBe('foochildIdBase_staticId');
      });
    });

    it('should generate id using staticId and childIdBase', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, undefined, 'childIdBase', 'staticId')).toBe('childIdBase_staticId');
      });
    });

    it('should generate id using staticId only', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, undefined, undefined, 'staticId')).toBe('staticId');
      });
    });

    it('should generate id using staticId with spaces only', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, undefined, undefined, 'static Id')).toBe('static_Id');
      });
    });

    it('should generate id using childIdBase only', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, undefined, 'childIdBase')).toBe('childIdBase');
      });
    });

    it('should generate id using childIdBase with spaces only', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, undefined, 'child Id Base')).toBe('child_Id_Base');
      });
    });

    it('should generate id using fisUniqueIdSeed attribute', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = { fisUniqueIdSeed: 'theSeed' };
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, 'theBase')).toBe('theSeed');
      });
    });

    it('should generate id using fisUniqueIdSeed attribute and childIdBase', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = { fisUniqueIdSeed: 'theSeed' };
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, 'theBase', 'theChildId')).toBe('theSeedtheChildId');
      });
    });

    it('should generate id using an array as staticId value with childIdBase, idBase and fisUniqueIdSeed attribute present', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = { fisUniqueIdSeed: 'theSeed' };
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        var array = ['my', 'special', 'idBase', 'array'];
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, 'theBase', 'theChildId', array)).toBe('theSeedtheChildId_my_special_idBase_array');
      });
    });

    it('should generate id using an array as staticId value with idBase and fisUniqueIdSeed attribute present', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = { fisUniqueIdSeed: 'theSeed' };
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        var array = ['my', 'special', 'idBase', 'array'];
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, 'theBase', undefined, array)).toBe('theSeed_my_special_idBase_array');
      });
    });

    it('should generate id using an array as staticId value with childIdBase and idBase present', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        var array = ['my', 'special', 'idBase', 'array'];
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, 'theBase', 'theChildId', array)).toBe('theBasetheChildId_my_special_idBase_array');
      });
    });

    it('should generate id using an array as staticId value with idBase present', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        var array = ['my', 'special', 'idBase', 'array'];
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, 'theBase', undefined, array)).toBe('theBase_my_special_idBase_array');
      });
    });

    it('should generate id using an array as staticId value with special values', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var attributes = {};
        var scope = $rootScope.$new();
                // scope, element, attributes, idBase, childIdBase, staticId
        var array = [['my'], true, 'idBase', { bar: 'array' }];
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, undefined, attributes, 'theBase', undefined, array)).toBe('theBase_my_true_idBase__object_Object_');
      });
    });
  });

  describe('handling the element the right way (testing generateIdWithStaticSeed\'s element handling)', function () {
    it('should add fisId property to passed element and return the fisId', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var scope = $rootScope.$new();
        var element = angular.element('<p></p>');
        var attributes = {};
        expect(fisUniqueIdService.generateIdWithStaticSeed(scope, element, attributes, undefined, 'childIdBase', 'staticId')).toBe('childIdBase_staticId');
        expect(element.attr('fisId')).toEqual('childIdBase_staticId');
      });
    });

    it('should not override existing fisId property to passed element', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var scope = $rootScope.$new();
        var element = angular.element('<p fisid="existingFisId"></p>');
        var attributes = {};
        fisUniqueIdService.generateIdWithStaticSeed(scope, element, attributes, undefined, 'childIdBase', 'staticId');
        expect(element.attr('fisId')).toEqual('existingFisId');
      });
    });
  });

  describe('should invoke the right fisid generation method (testing generateUniqueId)', function () {
    it('should generate id with static seed if given an idBase with spaces', function () {
            // Notice that this generation works even without appStage T!
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var scope = $rootScope.$new();
        var element = angular.element('<p></p>');
        var attributes = {};
                // scope, element, attributes, idBase, allowOverride
        expect(fisUniqueIdService.generateUniqueId(scope, element, attributes, 'id Base')).toBe('id_Base');
        expect(element.attr('fisId')).toEqual('id_Base');
      });
    });

    it('should generate unique id if given an String idBase', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        fis.initParams().appStage = 'T';
        var scope = $rootScope.$new();
        var element = angular.element('<p></p>');
        var attributes = {};
        // scope, element, attributes, idBase, allowOverride
        expect(fisUniqueIdService.generateUniqueId(scope, element, attributes, 'theBase')).toBe('theBase_1');
        expect(element.attr('fisId')).toEqual('theBase_1');
      });
    });

    it('should generate unique id if given an String idBase and override is true', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        fis.initParams().appStage = 'T'; // Change to appStage T and afterwards back to P
        var scope = $rootScope.$new();
        var element = angular.element('<p fisid="existingFisId"></p>');
        var attributes = {};
                // scope, element, attributes, idBase, allowOverride
        expect(fisUniqueIdService.generateUniqueId(scope, element, attributes, 'theBase', true)).toBe('theBase_1');
        expect(element.attr('fisId')).toEqual('theBase_1');
      });
    });

    it('should not generate unique id if appStage != T', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var scope = $rootScope.$new();
        var element = angular.element('<p></p>');
        var attributes = {};
                // scope, element, attributes, idBase, allowOverride
        expect(fisUniqueIdService.generateUniqueId(scope, element, attributes, 'theBase')).not.toBeDefined();
        expect(element.attr('fisId')).toEqual(undefined);
      });
    });

    it('should not generate unique id and not manipulate existing fisid if appStage != T', function () {
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var scope = $rootScope.$new();
        var element = angular.element('<p fisid="existingfisid"></p>');
        var attributes = {};
                // scope, element, attributes, idBase, allowOverride
        expect(fisUniqueIdService.generateUniqueId(scope, element, attributes, 'theBase')).not.toBeDefined();
        expect(element.attr('fisId')).toEqual('existingfisid');
      });
    });

    it('should fail when passing array as idBase', function () {
      fis.initParams().appStage = 'T';
      angular.mock.inject(function ($rootScope, fisUniqueIdService) {
        var scope = $rootScope.$new();
        var attributes = {};
                // scope, element, attributes, idBase, allowOverride
        expect(function () {
          fisUniqueIdService.generateUniqueId(scope, undefined, attributes, ['theBase', 'array']);
        }).toThrow();
      });
    });
  });
});
