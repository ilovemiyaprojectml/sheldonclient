/* jshint maxcomplexity:9*/
export default function () {
  'use strict';
  function toInt(str) {
    return parseInt(str, 10);
  }

  function parseISODate(value) {
    var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    var match;
    if ((match = value.match(R_ISO8601_STR))) {
      var date = new Date(0);
      var tzHour = 0;
      var tzMin = 0;
      var dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear;
      var timeSetter = match[8] ? date.setUTCHours : date.setHours;

      if (match[9]) {
        tzHour = toInt(match[9] + match[10]);
        tzMin = toInt(match[9] + match[11]);
      }
      dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
      var h = toInt(match[4] || 0) - tzHour;
      var m = toInt(match[5] || 0) - tzMin;
      var s = toInt(match[6] || 0);
      var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
      timeSetter.call(date, h, m, s, ms);
      return date;
    }
    return value;
  }

  var self = this;

  self.$get = [function () {
    var service = {};

    service.operators = ['and', 'or'];
    service.operators.AND = service.operators[0];
    service.operators.OR = service.operators[1];

    service.constraints = ['eq', 'contains', 'ne', 'gt', 'ge', 'lt', 'le', 'startswith',
                'endswith', 'is_null', 'not_contains', 'not_endswith', 'not_null', 'in_rel_range',
                'not_in_rel_range', 'in_future', 'in_past', 'is_between', 'not_is_between', 'in', 'not_in',
                'is_empty', 'not_empty', 'not_startswith'];
    service.constraints.EQ = service.constraints[0];
    service.constraints.CONTAINS = service.constraints[1];
    service.constraints.NE = service.constraints[2];
    service.constraints.GT = service.constraints[3];
    service.constraints.GE = service.constraints[4];
    service.constraints.LT = service.constraints[5];
    service.constraints.LE = service.constraints[6];
    service.constraints.STARTS_WITH = service.constraints[7];
    service.constraints.ENDS_WITH = service.constraints[8];
    service.constraints.IS_NULL = service.constraints[9];
    service.constraints.NOT_CONTAINS = service.constraints[10];
    service.constraints.NOT_ENDS_WITH = service.constraints[11];
    service.constraints.NOT_NULL = service.constraints[12];
    service.constraints.IN_REL_RANGE = service.constraints[13];
    service.constraints.NOT_IN_REL_RANGE = service.constraints[14];
    service.constraints.IN_FUTURE = service.constraints[15];
    service.constraints.IN_PAST = service.constraints[16];
    service.constraints.BETWEEN = service.constraints[17];
    service.constraints.NOT_BETWEEN = service.constraints[18];
    service.constraints.IN = service.constraints[19];
    service.constraints.NOT_IN = service.constraints[20];
    service.constraints.IS_EMPTY = service.constraints[21];
    service.constraints.NOT_EMPTY = service.constraints[22];
    service.constraints.NOT_STARTS_WITH = service.constraints[23];

    var constraintsWithoutValue = [service.constraints.IS_EMPTY, service.constraints.NOT_EMPTY,
                service.constraints.IS_NULL, service.constraints.NOT_NULL];

    function Criteria(operator) {
      if (angular.isString(operator)) {
        this.operator = operator || service.operators.AND;
        this.operands = [];
      } else if (angular.isObject(operator)) {
        var jsonObj = operator;
        var currentOperator = service.operators.AND;
        if (jsonObj.operator) {
          currentOperator = jsonObj.operator;
        }
        if (service.operators.indexOf(currentOperator) === -1) {
          throw new Error('Invalid operator : ' + currentOperator);
        }

        var newCrit = service.newCriteria(currentOperator);

        if (angular.isArray(jsonObj.operands)) {
          completeCriteriaFromOperands(jsonObj.operands, newCrit);
        }

        return newCrit;
      }
    }

    function completeCriteriaFromOperands(inputoperands, origCrit) {
      for (var i = 0; i < inputoperands.length; i++) {
        var operand = inputoperands[i];
        if (operand.operator) {
          var newCrit = service.newCriteria(operand.operator);
          if (operand.operands) {
            completeCriteriaFromOperands(operand.operands, newCrit);
            origCrit.add(newCrit);
          }
        } else {
          origCrit.add(new service.Criterion(operand.property, operand.value, operand.constraint, operand.type, operand.skipValidation));
        }
      }
    }

    Criteria.prototype.setOperator = function (operator) {
      if (service.operators.indexOf(operator) === -1) {
        throw new Error('Invalid operator : ' + operator);
      }
      this.operator = operator;
      return this;
    };

    Criteria.prototype.add = function (operand) {
      operand.validate();
      this.operands.push(operand);
      return this;
    };

    Criteria.prototype.setOperands = function (operands) {
      this.operands = operands;
      return this;
    };

    Criteria.prototype.isValid = function (isChild) {
      if (service.operators.indexOf(this.operator) === -1) {
        return false;
      }
      if (isChild && this.operands.length === 0) {
        return false;
      }
      for (var i = 0; i < this.operands.length; i++) {
        var operand = this.operands[i];
        if (!angular.isUndefined(operand.skipValidation) && !operand.skipValidation && !operand.isValid(true)) {
          return false;
        }
        var j = i + 1;
        var nextOperand = this.operands[j];
        if (nextOperand) {
          if (!angular.isUndefined(nextOperand.skipValidation) && !nextOperand.skipValidation && !nextOperand.isValid(true)) {
            return false;
          }
          if (service.operators.indexOf(this.operator) === -1) {
            return false;
          }
        }
      }
      return true;
    };

    Criteria.prototype.validate = function () {
      if (!this.isValid()) {
        throw new Error('Invalid Criteria: ' + this);
      }
    };

    Criteria.prototype.validateWithoutError = function () {
      console.warn('DEPRECATED: Criteria.validateWithoutError. Use Criteria.isValid.');
      return this.isValid();
    };

    Criteria.prototype.toString = function () {
      var crit = this.getAsString();
      var finalCrit = '';
      if (crit) {
        finalCrit = crit.substring(1);
        finalCrit = finalCrit.substring(0, finalCrit.length - 1);
      }
      return finalCrit;
    };

    Criteria.prototype.getAsString = function () {
      var crit = '(';
      for (var i = 0; i < this.operands.length; i++) {
        var operand = this.operands[i];
        crit += operand.getAsString();
        var j = i + 1;
        var next = this.operands[j];
        if (next) {
          crit += ' ';
          crit += this.operator;
          crit += ' ';
        }
      }
      crit += ')';

      return crit;
    };

    function isNumber(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }

    function isValidValue(value, constraint, type) {
      if ((angular.isUndefined(value) || value === '') && value !== 0) {
        if (constraintsWithoutValue.indexOf(constraint) === -1) {
          return false;
        }
        return true;
      } else if (constraintsWithoutValue.indexOf(constraint) > -1) {
        return false;
      }

      if ((type === 'integer' || type === 'number' || type === 'double') && !isNumber(value)) {
        return false;
      }
      if (type === 'date' || type === 'datetime' || type === 'time') {
        if (!value.toISOString) {
          try {
            new Date(value).toISOString();
          } catch (e) {
            // SDHTML-13812 - IE javascript engine cannot parse date in '2016-06-06T00:16:07+0000' format
            value = parseISODate(value);
            if (!angular.isUndefined(value)) {
              try {
                return Boolean(angular.isDate(value) ? value.toISOString() : new Date(value).toISOString());
              } catch (e) {
                return false;
              }
            }
            return false;
          }
        }
      }
      if (type === 'boolean') {
        if (typeof (value) !== 'boolean' && (value !== 'true' && value !== 'false')) {
          return false;
        }
      }
      return true;
    }

    // criterion object
    function Criterion(property, value, constraint, type, skipValidation) {
      this.property = property || null;
      this.value = angular.isUndefined(value) ? '' : value;
      this.constraint = constraint || service.constraints.EQ;
      this.type = type;
      this.skipValidation = skipValidation;
    }

    function marshallValue(value, type) {
      if (type === 'integer' || type === 'boolean' || (type && type.substring(0, 6) === 'double') || type === 'number') {
        return value;
      }
      if (type === 'date' || type === 'datetime' || type === 'time') {
        if (!value.toISOString) {
          /* eslint-disable no-negated-condition */
          if (!isNaN(Date.parse(value))) {
            value = new Date(value);
          } else {
            // SDHTML-13812 - IE javascript engine cannot parse date in '2016-06-06T00:16:07+0000' format
            value = parseISODate(value);
          }
          /* eslint-enable no-negated-condition */
        }
        return 'datetime\'' + value.toISOString() + '\'';
      }
      return '\'' + value.toString().replace(/'/g, '\'\'') + '\'';
    }

    Criterion.prototype.getAsString = function () {
      // var spaceWithStarIfCaseInsensitive = this.ignoreCase ? '' : '*';
      var result = '';
      switch (this.constraint) {
        case 'startswith':
        case 'endswith':
          result = this.constraint + '(' + this.property + ',' + marshallValue(this.value, this.type) + ')';
          break;
        case 'not_startswith':
        case 'not_endswith':
          result = 'not ' + this.constraint.substring(this.constraint.indexOf('_') + 1) + '(' + this.property + ',' + marshallValue(this.value, this.type) + ')';
          break;
        case 'contains':
          result = 'substringof(' + marshallValue(this.value, this.type) + ',' + this.property + ') eq true';
          break;
        case 'not_contains':
          result = 'substringof(' + marshallValue(this.value, this.type) + ',' + this.property + ') eq false';
          break;
        case 'is_null':
          result = this.property + ' eq null';
          break;
        case 'not_null':
          result = this.property + ' ne null';
          break;
        case 'is_empty':
          result = this.property + ' eq \'\'';
          break;
        case 'not_empty':
          result = this.property + ' ne \'\'';
          break;
        default:
          if (this.skipValidation || service.constraints.indexOf(this.constraint) < 0) {
            result = this.property + ' ' + this.constraint + ' ' + this.value;
          } else {
            result = this.property + ' ' + this.constraint + ' ' + marshallValue(this.value, this.type);
          }
      }
      return result;
    };

    Criterion.prototype.isValid = function () {
      if (!this.property || service.constraints.indexOf(this.constraint) === -1 || !isValidValue(this.value, this.constraint, this.type)) {
        return false;
      }
      return true;
    };

    Criterion.prototype.validate = function () {
      if (!angular.isUndefined(this.skipValidation) && !this.skipValidation && !this.isValid()) {
        throw new Error('Invalid Criterion: ' + this);
      }
    };

    Criterion.prototype.validateWithoutError = function () {
      console.warn('DEPRECATED: Criterion.validateWithoutError. Use Criterion.isValid.');
      return this.isValid();
    };

    Criterion.prototype.setProperty = function (property) {
      if (!property) {
        throw new Error('Invalid property');
      }
      this.property = property;
      return this;
    };

    Criterion.prototype.setValue = function (value) {
      this.value = value;
      return this;
    };

    Criterion.prototype.setConstraint = function (constraint) {
      if (service.constraints.indexOf(constraint) === -1) {
        throw new Error('Invalid constraint : ' + constraint);
      }
      this.constraint = constraint;
      return this;
    };

    service.newCriteria = function (operator) {
      if (!operator) {
        operator = service.operators.AND;
      }
      if (angular.isString(operator)) {
        if (service.operators.indexOf(operator) === -1) {
          throw new Error('Invalid operator : ' + operator);
        }
      }
      return new Criteria(operator);
    };

    service.Criteria = Criteria;
    service.Criterion = Criterion;

    return service;
  }];
}
