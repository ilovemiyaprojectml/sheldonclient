/**
 * @name fisData
 * @description Directive that provides a list based widget with a $resource it can query to GET a collection of data items.
 *      This is useful only for GET of a collection of
 * @methodOf fis.core.directives
 */
export default function (fisResourceService, $q, $parse, fisCriteriaService, fisElementUtils, $interpolate, $timeout, fisUtilService, fisConfig, fisScopeUtils) {
  'ngInject';

  var queryParameterPrefix = 'fisParam';

  return {
    restrict: 'A',
    priority: 600,
    compile: function (elem, attrs) {
                // Save the original parameter expressions for later if required.
                // We will need them for interpolating the variable values if we're running in an isolated scope.
      attrs._paramVariables = fisElementUtils.copyProperties(attrs, queryParameterPrefix, {});

      return function () {};
    },
    controller: ['$attrs', '$scope', '$element',
                function ($attrs, $scope, $element) {
                  var self = this;

                  var odataV3Adaptor = $attrs.fisAdaptor === 'odatav3' || (fisConfig.dataSourceAdaptor === 'odatav3');
                  function isAlwaysFetch() {
                    return angular.isUndefined($attrs.fisFetchVisibleOnly) || !$attrs.fisFetchVisibleOnly;
                  }

                  // Only add the visibility watch when the fetching should depend on the visibility of the component
                  if (!isAlwaysFetch()) {
                    /*
                    Adds a watch to the visibility state of the element.
                    If the element is made visible and there was a call to fetchData while it was invisible,
                    the fetch is executed now.

                    scope.allowFetch is used again in fetchData below
                      */
                    var watchFn = function () {
                      $scope.allowFetch = $element.is(':visible');

                      if ($scope.allowFetch) {
                        if ($scope.deferred) {
                          $scope.deferred.resolve(self.fetchData($scope.lastParams));
                          $scope.deferred = undefined;
                          $scope.lastParams = undefined;
                        }
                      }
                    };
                    fisScopeUtils.postDigest($scope, function () {
                      return $element.is(':visible');
                    }, watchFn, $timeout, true);
                  }

                  if (!$attrs.fisData) {
                    throw new Error('You must provide a value to the fis-data attribute');
                  }

                  var functionExpression = $attrs.fisData.indexOf('(') !== -1;
                  var arrayExpression = $attrs.fisData.indexOf('[') !== -1;
                  var objectExpression = $attrs.fisData.indexOf('{') !== -1;
                  var fixedResourceUrl = !functionExpression && !arrayExpression && !objectExpression && $attrs.fisData.indexOf('/') !== -1;
                  var beforeFetchListeners = [];
                  var afterFetchListeners = [];
                  var dataChangedListeners = [];

                  var schema = {
                    // the JSON element that contains the array of data items
                    data: ($parse($attrs.fisSchemaData)($scope) !== undefined) ? $parse($attrs.fisSchemaData)($scope) : $attrs.fisSchemaData, // eslint-disable-line
                    // the JSON element that contains the total number of records in the entire dataset (useful for widgets that support some kind of pagination)
                    total: $attrs.fisSchemaTotal
                  };

                  var Resource;

                  // TODO: add fisSharedCriteria to allow providing a criteria that multiple widgets can share.
                  //       It will be merged with the Criteria created by the grid (translated from kendo filters)
                  //       before being sent to fetchData in the params: {crit: mergedCriteria}
                  //       This is needed to be able to provide complex search outside of the grid.

                  if (!fixedResourceUrl && !functionExpression) {
                    // watch to see if the provided fisData value changes (checking references, not equality).
                    // this is to determine if the fisData will be handling RESTful fetching
                    var fisDataChangeWatch = $scope.$watch($attrs.fisData, function (newVal, oldVal) {
                      if (!newVal) {
                        // $attrs.fisData doesn't resolve to a value. We keep resource as-is.
                        return;
                      }
                      // when the watch is initialized, this function is called with identical newVal and oldVal
                      if (newVal !== oldVal) {
                        // if a String value, the user may have changed the endpoint of the resource
                        Resource = determineResource($attrs, newVal);

                        self.fireDataChanged(newVal);
                      }
                    });
                    $scope.$on('$destroy', function () {
                      if (fisDataChangeWatch) {
                        fisDataChangeWatch();
                      }
                    });
                  }

                    /**
                     * @return Returns the schema object to be used
                     */
                  self.getSchema = function () {
                    return schema;
                  };

                  /**
                   * Can be used by a widget directive to tell that the data has changed and that the underlying dom widget (kendo or other)
                   * can be notified of that change and be refreshed accordingly (by invoking fetchData again).
                   * Note that fisData will already invoke this if it detects that the reference to the model has changed.
                   */
                  self.fireDataChanged = function (data) {
                    invokeListeners(dataChangedListeners, data);
                  };

                  /**
                   * @returns a promise that will resolve into an object with two properties:
                   * The data property will contain an array of objects and the total property will contain the total number
                   * of records available in the dataset, if this information is available. This total is used for pagination, so that
                   * widgets can calculate the total number of pages.
                   */
                  self.fetchData = function (params) {
                    if ($attrs.fisSort) {
                      // check if the attribute specified in fis-sort is assignable (scope object)
                      var fisSort = $parse($attrs.fisSort);
                      if (fisSort.assign && params) {   // add params to check to prevent widgets with fis-sort breaking if no params defined for assignable expression
                        // if fis-sort expression is assignable, update the expression whenever user interacts with the grid
                        // (manual sorting by clicking on column headers)
                        var sortExpressionArray = [];
                        if (odataV3Adaptor) {
                          var sortExpr = params.sort;
                          if (sortExpr) {
                            var sortDefs = sortExpr.split(',');
                            angular.forEach(sortDefs, function (sortDef) {
                              var parts = sortDef.split(' ');
                              if (parts.length === 2) {
                                sortExpressionArray.push({ field: parts[0], dir: parts[1] });
                              }
                            });
                          }
                        } else {
                          angular.forEach(params.sort, function (sortedParam) {
                                        // here the param.sort received is in the format ["fieldName,sortOrder","fieldName,sortOrder",..]
                                        // Convert it to [{field:fieldName, dir:sortOrder},{field:fieldName, dir:sortOrder}..] format
                            var parts = sortedParam.split(',');
                            sortExpressionArray.push({ field: parts[0], dir: parts[1] });
                          });
                        }
                        // Update the fis-sort assignable expression to the changed value
                        fisSort.assign($scope, sortExpressionArray.length === 1 ? sortExpressionArray[0] : sortExpressionArray);
                      }
                    }

                    // If not explicitely set to just fetch when visible the fetch function is always called
                    if (!isAlwaysFetch()) {
                      /*
                      Only fetch the data when the fetching is allowed (since the element is visible) - otherwise
                      enter this if and return just a promise that will be resolved once.
                        */
                      if (!$scope.allowFetch) {
                        // Store any provided parameters for later execution
                        $scope.lastParams = params;
                        if ($scope.deferred) {
                          // There is already a deferred execution of fetchData - return a new promise here as the resolution
                          var newDeferred = $q.defer();
                          $scope.deferred.resolve(newDeferred.promise);
                          $scope.deferred = newDeferred;
                        } else {
                          // This is the first call to fetchData since the element is invisible
                          $scope.deferred = $q.defer();
                        }

                        // Return just a promise for now - the watch on the visibility will resolve it later
                        return $scope.deferred.promise;
                      }
                    }

                    if ($attrs.fisCriteria) {
                      var mergedCriteria;
                      var mergedOperands;
                      var fisCriteria = fisCriteriaService.newCriteria($parse($attrs.fisCriteria)($scope));

                      if (params.crit) {
                        mergedOperands = [];
                        fisCriteria.operands.concat(params.crit.operands).forEach(function (operand) {
                          if (mergedOperands.indexOf(operand) === -1) {
                            mergedOperands.push(operand);
                          }
                        });
                        mergedCriteria = angular.extend(fisCriteria, params.crit);
                        mergedCriteria.operands = mergedOperands;
                      } else {
                        mergedCriteria = fisCriteria;
                      }
                      params.crit = mergedCriteria.toString();
                    }

                    Resource = determineResource($attrs);
                    invokeListeners(beforeFetchListeners, params);

                    params = fisElementUtils.copyProperties($attrs, queryParameterPrefix, params);

                    // When running in isolated scope, e.g. in fisGrid, we don't have access to the outer scope.
                    // Someone using a parameter like fis-param-foo="{{foo}}" would need to use {{$parent.foo}}
                    // to escape the isolated scope of fisGrid. To avoid that, we reevaluate the fis-param-*
                    // expressions against the parent scope. This way, the use doesn't need to care whether
                    // the directive uses isolated scope or not.
                    if ($scope.hasOwnProperty('$$isolateBindings') && $scope) {
                      // Loop over the parameter expressions that we saved in the compile function.
                      // The variables are not interpolated at this stage.
                      angular.forEach($attrs._paramVariables, function (val, key) {
                        // Interpolate the variable ourselves using the $interpolate service
                        // We use the parent scope to resolve the variables.
                        var interpolatedValue = $interpolate(val)($scope);

                        // Assign the variable to the respective entry in the params object,
                        // overwriting any value that was previously there.
                        params[key] = interpolatedValue;
                      });
                    }

                    if (Resource) {
                      return getDataFromResource(params);
                    }
                    // data retrieval is managed externally (could still come from a server)
                    var getter = $parse($attrs.fisData);
                    var promise;

                    if (functionExpression) {
                      // function expression
                      // wrap in a promise, chain promises if function also returns a promise
                      promise = $q.when(getter($scope, { params: params })).then(function (data) {
                        var resultData = invokeListeners(afterFetchListeners, normalizeData(data));
                        if (angular.isFunction(schema.data)) {
                          resultData.data = retrieveDataFromSchemaData(data);
                        }
                        return resultData;
                      }, function () {
                        // TODO: define exceptions
                        throw new Error('fisData could not get data from ' + $attrs.fisData);
                      });
                    } else {
                      var scoped = getter($scope);
                      if (angular.isFunction(scoped)) {
                        var result = scoped(params);
                        promise = $q.when(result).then(function (data) {
                          var resultData = invokeListeners(afterFetchListeners, normalizeData(data));
                          if (angular.isFunction(schema.data)) {
                            resultData.data = retrieveDataFromSchemaData(data);
                          }
                          return resultData;
                        }, function () {
                          throw new Error('fisData could not get data from ' + $attrs.fisData);
                        });
                      } else {
                        var deferred = $q.defer();
                        var resultData = invokeListeners(afterFetchListeners, normalizeData(scoped));
                        if (angular.isFunction(schema.data)) {
                          resultData.data = retrieveDataFromSchemaData(scoped);
                        }
                        deferred.resolve(resultData);
                        promise = deferred.promise;
                      }
                    }

                    return promise;
                  };

                  function retrieveDataFromSchemaData(data) {
                    var resultData = [];
                    var results = schema.data(data);
                    angular.forEach(results, function (item) {
                      resultData.push(item);
                    });
                    return resultData;
                  }

                  self.addDataChangedListener = function (listener) {
                    if (dataChangedListeners.indexOf(listener) === -1) {
                      dataChangedListeners.push(listener);
                    }
                    return function () {
                      var idx = dataChangedListeners.indexOf(listener);
                      if (idx !== -1) {
                        dataChangedListeners.splice(idx, 1);
                      }
                    };
                  };

                  self.addBeforeFetchListener = function (listener) {
                    if (beforeFetchListeners.indexOf(listener) === -1) {
                      beforeFetchListeners.push(listener);
                    }
                    return function () {
                      var idx = beforeFetchListeners.indexOf(listener);
                      if (idx !== -1) {
                        beforeFetchListeners.splice(idx, 1);
                      }
                    };
                  };

                  self.addAfterFetchListener = function (listener) {
                    if (afterFetchListeners.indexOf(listener) === -1) {
                      afterFetchListeners.push(listener);
                    }
                    return function () {
                      var idx = afterFetchListeners.indexOf(listener);
                      if (idx !== -1) {
                        afterFetchListeners.splice(idx, 1);
                      }
                    };
                  };

                  function normalizeData(data) {
                    if (data.data) {
                      return data;
                    }

                    if (angular.isArray(data)) {
                      if (data.length > 1) {
                        return {
                          data: data
                        };
                      } else if (data.length === 1) {
                        return {
                          data: data,
                          obj: data[0]
                        };
                      }
                    }
                    if (angular.isArray(data)) {
                      return {
                        data: data
                      };
                    }
                    if (schema && schema.data) {
                      var resultData = {
                        data: []
                      };
                      angular.extend(resultData, data);
                      if (schema.data !== 'data') {
                        var results;
                        if (angular.isString(schema.data)) {
                          results = fisUtilService.extractData(schema.data, data);
                        }
                        angular.forEach(results, function (item) {
                          resultData.data.push(item);
                        });
                      }

                      if (schema.total) {
                        resultData.total = data[schema.total];
                      }
                      if (schema.data !== 'data') {
                        delete resultData[schema.data];
                      }
                      if (schema.total !== 'total') {
                        delete resultData[schema.total];
                      }
                      return resultData;
                    }
                    return {
                      data: [data]
                    };
                  }

                  function invokeListeners(listeners, data) {
                    angular.forEach(listeners, function (listener) {
                            // invoke the listener and make sure it's returned data is normalized so that all listeners can expect the same format.
                      data = normalizeData(listener(data) || data);
                    });
                    return data;
                  }

                  function getDataFromResource(params) {
                    var instance;
                    var deferred = $q.defer();
                    var promise;

                    // here you can receive params that are objects but that you may not want to transform to JSON
                    // to pass as query parameters. Make sure they are marshalled to a string that is appropriate
                    // to the backend.
                    // TODO: provide a hook to marshall special objects (decorate params). For now, only translating Criteria to its string form
                    if (params.crit) {
                      params.crit = params.crit.toString();
                    }
                    if (odataV3Adaptor) {
                      if (params.crit) {
                        params.$filter = params.crit.toString();
                        delete params.crit;
                      }

                      if (angular.isNumber(params.offset)) {
                        params.$skip = params.offset;
                        delete params.offset;
                      }

                      if (angular.isNumber(params.limit)) {
                        params.$top = params.limit;
                        delete params.limit;
                      }

                      if (params.sort) {
                        params.$orderby = params.sort;
                        delete params.sort;
                      }
                      // TODO add $inlinecount only when schema.total is defined
                      // params.$inlinecount = 'allpages'; // ask for the total in the response
                      params.$format = 'json';
                    }
                    instance = Resource.getData(params, function () {
                      // don't return just instance.data, send back everything
                      deferred.resolve(invokeListeners(afterFetchListeners, instance));
                    }, function (d) {
                      // TODO: define exceptions (fisException service?)
                      deferred.reject(invokeListeners(afterFetchListeners, d));
                    });
                    promise = deferred.promise;
                    promise.data = instance.data;
                    return promise;
                  }

                  function determineResource(attrs, val) {
                    if (functionExpression) {
                      // fisData will not handle invoking the rest resource and will delegate to the function expression
                      return null;
                    }
                    val = val || (fixedResourceUrl && attrs.fisData) || $parse(attrs.fisData)($scope);

                    if (angular.isString(val)) {
                      // the value refers to a $resource URL
                      // fisData will handle RESTful fetching
                      return fisResourceService(val, null, null, schema);
                    } else if (!val) {
                      // $attrs.fisData is not empty but doesn't resolve to a scoped value, consider the string in $attrs.fisData as a $resource URL
                      // fisData will handle RESTful fetching
                      return fisResourceService(attrs.fisData, null, null, schema);
                    }
                    // fisData will not handle RESTful fetching
                    return null;
                  }
                }]

  };
}
