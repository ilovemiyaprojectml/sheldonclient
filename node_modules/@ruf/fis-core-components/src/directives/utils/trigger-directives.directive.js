/**
 * @name fisReinit
 * @description This directive watches for changes in the provided expression and broadcasts a fisReinit event.
 * Other directives can also provide a <code>trigger</code> function that will get executed instead of broadcasting an event.
 * Use this attribute directive when you want directives that support it to reinitializing themselves.
 * This is useful for directives that do not put watches on all the attributes it supports but you still want to
 * change attribute values.
 * @methodOf fis.core.directives
 */
/**
 * @name fisRefresh
 * @description This directive watches for changes in the provided expression and broadcasts a fisRefresh event.
 * Other directives can also provide a <code>trigger</code> function that will get executed instead of broadcasting an event.
 * Use this attribute directive when you want directives that support it to refresh their data without reinitializing themselves.
 * @methodOf fis.core.directives
 */
 export default function (directive) {
   return function () {
     return {
       restrict: 'A',
       controller: ['$scope', '$attrs', function ($scope, $attrs) {
         var self = this;

          // put a watch on the attribute's expression and invoke the controller's trigger function
         $scope.$watch($attrs[directive], function (newVal, oldVal) {
           if (newVal !== oldVal) {
             self.trigger($scope, newVal, oldVal);
           }
         }, true); // uses angular.equals

          // default trigger function $broadcasts an event with the same name as the directive.
          // Directives that require this directive can override this function and provide their own.
          // Like this: triggerCtrl.trigger = function(scope, newVal, oldVal) {...}
         self.trigger = function (scope, newVal, oldVal) {
           scope.$broadcast(directive, { value: newVal, oldValue: oldVal });
         };
       }]
     };
   };
 }
