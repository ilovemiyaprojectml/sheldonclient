export default function (fisUniqueIdService, fisScopeUtils) {
  'ngInject';
  var fieldTemplate = `<div class="fis-field control-group">
                <%var isExpVal=false;if (field.attrs.fisLabel  || field.attrs.required !== undefined) {if(field.attrs.fisLabel && field.attrs.fisLabel.indexOf("\'") > -1){field.attrs.fisLabel = field.attrs.fisLabel.replace(/\'/g,\'"\');}if(field.attrs.fisLabel && field.attrs.fisLabel.indexOf("{{") > -1){field.attrs.fisLabel = field.attrs.fisLabel.replace(/{|}/g,"");isExpVal=true;}%><label class="control-label"><span><span class="fis-req">*</span><%if(isExpVal){%><span ng-bind-html="<%- field.attrs.fisLabel %>"></span><%} else{%><span ng-bind-html="\'<%- field.attrs.fisLabel %>\'"></span><%}%></span></label><%}%>
                <div class="controls">
                    <div ng-show="fisEditMode" class="wrap fis-inputs" fis-unique-id="edit_mode">
                    <%= field.editTemplate %>
                    </div>
                    <div ng-show="!fisEditMode" class="wrap fis-view-value control-label-view" fis-unique-id="not_edit_mode">
                    <%= field.viewTemplate %>
                    </div>
                    <% if (field.attrs.fisInstruct){ %><span ng-show="fisEditMode" class="fis-instruct-message"><%- field.attrs.fisInstruct %></span> <% } %>
                    <span ng-show="fisEditMode" fis-field-message></span>
                </div>
            </div>`;

  var FieldController = function ($scope, $element, $attrs, $transclude, $parse) {
    if ($scope.$parent.fisEditMode !== true && $scope.$parent.fisEditMode !== false) {
                // set fisEditMode on the parent if it is not already set.
                // this takes care of fields that are outside of an fisFields directive.
      $scope.$parent.fisEditMode = true;
    }

    fisScopeUtils.watch($scope.$parent, $attrs.fisDisabled, function (disabled) {
      $scope.fisDisabled = disabled;

      var required = $parse($attrs.fisRequired)($scope);

      if (required === true) {
        if (disabled === true) {
                        // Was required, is now disabled, so remove the required flag
          $scope.fisRequired = false;
          $element.removeClass('fis-required');
        } else {
                        // Was required, the flag might have been removed earlier, so re-add it
          $scope.fisRequired = true;
          $element.addClass('fis-required');
        }
      }
    });

    fisScopeUtils.watch($scope.$parent, $attrs.fisRequired, function (required) {
      $scope.fisRequired = required;

      if (required) {
        $element.addClass('fis-required');
      } else if ($attrs.required == null) { // eslint-disable-line
        $element.removeClass('fis-required');
      }
    });

    fisScopeUtils.watch($scope.$parent, $attrs.fisEditMode, function (editMode) {
      $scope.fisEditMode = editMode;
    });

    /**
     * @name registeredInputs
     * @description Hash of model property to ngModel.
     * Used by fisFieldMessage to dispatch valid state to ngModel
     * @methodOf FieldController
     */
    $scope.registeredInputs = {};

    var models = [];

    /**
     * @name registerInput
     * @description Registers a ngModel controller. Invoked by fisInput controller
     * @methodOf FieldController
     */
    $scope.registerInput = function (ngModel) {
      if (ngModel.fisProperty) {
        $scope.registeredInputs[ngModel.fisProperty] = ngModel;
        models.push(ngModel);
      }
    };

    $scope.unregisterInput = function (ngModel) {
      if (ngModel.fisProperty && $scope.registeredInputs[ngModel.fisProperty] === ngModel) {
        delete $scope.registeredInputs[ngModel.fisProperty];

        var idx = models.indexOf(ngModel);
        if (idx > -1) {
          delete models[idx];
        }
      }
    };

    $scope.fieldValue = function () {
      // TODO: provide access to fis-input element(s) inside transclusion
      // scope.fisFieldValueFn is the callback that is provided by the linkWrapper
      return $scope.fisFieldValueFn($scope, $element, $attrs, models);
    };
  };

  // default function used by scope.fieldValue which only takes care of single input fields (single ngModel per field)
  // the models passed to it will be decorated with fisLabel, fisProperty and fisInput properties (this is done in fisInput directive)
  function fieldValueFn(scope, element, attrs, models) {
    return models[0] && models[0].$modelValue || '';
  }

  /**
   * @name FieldDirective
   * @methodOf fis.fis.core.forms
   */
  var FieldDirective = function (options) {
    var self = this;
    options = options || {};

    // Using default priority of 0, just like any other directive does
    self.priority = 0;

    // Overwrite it with whatever the user has specified.
    // Don't use the || approach since it doesn't handle 0 gracefully.
    if (options.priority !== undefined) {
      self.priority = options.priority;
    }

    self.restrict = options.restrict || 'ACE';
    self.require = options.require; // should merge with this and only return array of required to outside link fn
    self.transclude = options.transclude || false;
    self.scope = true;
    self.editTemplate = options.editTemplate || '';
    self.viewTemplate = options.viewTemplate || '{{fieldValue()}}';
    self.fieldValue = options.fieldValue || fieldValueFn;

    self.compiledTemplate = _.template(fieldTemplate);

    self.controller = options.controller || ['$scope', '$element', '$attrs', '$transclude', '$parse', FieldController];

    self.compile = function (element, attrs, transclude) {
      var context = {
        editTemplate: self.editTemplate,
        viewTemplate: self.viewTemplate,
        attrs: attrs
      };

      attrs.fisSize = attrs.fisSize || 'large';

      // attaching the editTemplate and viewTemplate to the main fieldTemplate
      var markup = self.compiledTemplate({ field: context });

      if (markup.indexOf('<%') !== -1) {
        markup = _.template(markup)({ field: context });
      }

      var tplElement = angular.element(markup);

      /* Call moveAssignAttributesToInputs to move and assign attributes to inputs element
        * - If elements have compile function with transclusion then input element added after compilation,
        *  so in this case move and assign attributes after compilation done.
        * - If input elements have link function then input element already added,
        *  so in this case first move and assign attributes to input element and then call link function.
        */
      var result;

      if (options.compile) {
        // if the FieldDirective was provided with a compile function, invoke it.
        // We pass it the tplElement we just created but also the original element to allow
        // inspecting it in a provided compile function before it gets replaced below.
        result = linkWrapper(options.compile(tplElement, attrs, transclude, element), self.fieldValue);
        moveAssignAttributesToInputs(attrs, tplElement);
      } else {
        moveAssignAttributesToInputs(attrs, tplElement);
        // return the link function
        result = linkWrapper(options.link || angular.noop, self.fieldValue);
      }

      // replace the provided element with the newly constructed one.
      element.replaceWith(tplElement);

      return result;
    };
    return self;
  };

  // Function mo ves and assign attributes to input element
  function moveAssignAttributesToInputs(attrs, tplElement) {
    // find the input elements in the assembled template element
    var inputs = findInputs(tplElement);

    // find the label element in the assembled template element
    var labels = findLabel(tplElement);

    // move attributes from the template's root element to each input element found, following naming convention
    moveAttributesToInputs(attrs, tplElement, inputs);

    // assign additional attributes to inputs (e.g. ng-disabled)
    assignAttributesToInputs(attrs, tplElement, inputs);

    // move attributes from the template's root element to each label element found, following naming convention
    moveAttributesToLabel(attrs, tplElement, labels);
  }

  function linkWrapper(linkFn, valueFn) {
    return function (scope, element, attrs, ctrls) {
      if (attrs.fisLabel === undefined) {
        if (attrs.required != null) { // eslint-disable-line
          element.find('.control-label').addClass('without-fis-label');
        }
        element.find('.controls').addClass('without-fis-label');
      }

      attrs.$observe('ngRequiredInput', function (value) {
        if (value === 'true') {
          element.addClass('fis-required');
        }
      });

      var editModelName = element.find('input').attr('ng-model');

      if (!editModelName) {
        editModelName = element.find('select').attr('ng-model');
      }

      fisUniqueIdService.generateUniqueId(scope, element.find('.fis-view-value'), attrs, 'view_' + editModelName);

      scope.fisFieldValueFn = valueFn;
      if (linkFn) {
        linkFn(scope, element, attrs, ctrls);
      }
    };
  }

  /*
    * @name moveAttributes
    * @param attrs The angular Attributes object for the directive
    * @param rootElement The angular decorated root element of the directive
    * @param inputs A hash of input element name to decorate element.
    * @private
    */
  function moveAttributesToInputs(attrs, rootElement, inputs) {
    var rootAttrs = attrs;

    // move attributes for each input found
    angular.forEach(inputs, function (elem, name) {
      var inputAttrs = getAttributesForInput(attrs, name);
      // remove the attributes found from the rootAttrs
      rootAttrs = _.omit(rootAttrs, _.keys(inputAttrs));
      // Object.keys(inputAttrs).forEach(function (inputAttr){
      //    rootAttrs[inputAttr] = undefined;
      // });
      // copy the attributes minus the ending part (i.e. ng-model-input becomes ng-model for the element marked as 'input')
      angular.forEach(inputAttrs, function (attr) {
        elem.attr(attr.name, attr.val);
      });
    });

    // rootAttrs now contains only the attributes that were not assigned to inputs
    // add them to the root element of the directive
    angular.forEach(rootAttrs, function (val, key) {
      if (key === 'class') {
        rootElement.addClass(val);
      } else {
        var denormalized = attrs.$attr[key];
        if (denormalized) {
          rootElement.attr(denormalized, val);
        }
      }
    });
  }

  /*
    * @name moveAttributesToLabel
    * @param attrs The angular Attributes object for the directive
    * @param rootElement The angular decorated root element of the directive
    * @param label A hash of label element name to decorate element.
    * @private
    */
  function moveAttributesToLabel(attrs, rootElement, label) {
    var rootAttrs = attrs;

    // move attributes for each label found
    angular.forEach(label, function (elem, name) {
      var labelAttrs = getAttributesForLabel(attrs, name);

      // remove the attributes found from the rootAttrs
      rootAttrs = _.omit(rootAttrs, _.keys(labelAttrs));
      // Object.keys(labelAttrs).forEach(function (labelAttr){
      //    rootAttrs[labelAttr] = undefined;
      // });

      // copy the attributes minus the ending part (i.e. class-label becomes class for the element marked as 'label')
      angular.forEach(labelAttrs, function (attr) {
        if (attr.name === 'class') {
          elem.addClass(attr.val);
        } else {
          elem.attr(attr.name, attr.val);
        }
      });
    });

    // rootAttrs now contains only the attributes that were not assigned to inputs
    // add them to the root element of the directive
    angular.forEach(rootAttrs, function (val, key) {
      if (key === 'class') {
        rootElement.addClass(val);
      } else {
        var denormalized = attrs.$attr[key];

        if (denormalized) {
          rootElement.attr(denormalized, val);
        }
      }
    });
  }

  /*
    * @description This function will make sure the template elements to be compiled follow our form field conventions
    * so that widget developers and page developers don't have to know about them.
    * @param {Object} attrs Angular Attributes object for the root element
    * @param {Object} root The template's root element
    * @param {Object} inputs The array of input elements
    * @private
    */
  function assignAttributesToInputs(attrs, root, inputs) {
    // TODO: if any of the input is marked required by a ng-required-value for example, put fis-required class on root element
    angular.forEach(inputs, function (elem) {
      elem.attr('ng-disabled', 'fisDisabled');
      elem.attr('fis-unique-id', '');

      if (attrs.required != null) { // eslint-disable-line
        // let's empty string ("") through, DON'T CHANGE TO !== ELSE THINGS BREAK
        elem.attr('required', true);
      } else {
        elem.attr('ng-required', 'fisRequired');
      }
    });

    if (attrs.required != null) { // eslint-disable-line
      // DON'T CHANGE TO !== ELSE THINGS BREAK
      root.addClass('fis-required');
    }
  }

  function getAttributesForInput(attrs, name) {
    var ret = {};
    var endsWith = '-' + name;
    var re = new RegExp(endsWith + '$');

    angular.forEach(attrs, function (val, key) {
      var denormalized = attrs.$attr[key];

      if (denormalized && denormalized.match(re)) {
        // remove the last part of the attribute name
        var attrName = denormalized.substring(0, denormalized.length - endsWith.length);
        ret[key] = { name: attrName, val: val };
      }
    });

    return ret;
  }

  function getAttributesForLabel(attrs, name) {
    var ret = {};
    var endsWith = '-' + name;
    var re = new RegExp(endsWith + '$');

    angular.forEach(attrs, function (val, key) {
      var denormalized = attrs.$attr[key];

      if (denormalized && denormalized.match(re)) {
        // remove the last part of the attribute name
        if (denormalized !== 'fis-label') {
          var attrName = denormalized.substring(0, denormalized.length - endsWith.length);
          ret[key] = { name: attrName, val: val };
        }
      }
    });

    return ret;
  }

  function findInputs(parent) {
    var ret = {};

    var nodeList = parent[0].querySelectorAll('[fis-input]');
    for (var i = 0; i < nodeList.length; ++i) {
      var elem = angular.element(nodeList[i]);
      ret[elem.attr('fis-input') || 'input'] = elem;
    }

    return ret;
  }

  function findLabel(parent) {
    var ret = {};

    parent.find('label').each(function (index, n) {
      var elem = angular.element(n);
      ret[elem.attr('fis-label') || 'label'] = elem;
    });

    return ret;
  }

  return {

    create: function (options) {
      return new FieldDirective(options);
    },

    // TODO: remove this when we have removed requireJS, only needed for tests to be able to access
    _FieldController: FieldController

  };
}
