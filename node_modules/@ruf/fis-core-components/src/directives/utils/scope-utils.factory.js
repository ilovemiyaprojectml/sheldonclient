export default function () {
  var service = {};

  /**
   * @description Allows setting a watch on a specified scope and invoke a callback with the watched value as an argument
   * It also treats 'true'/'false' as hardcoded values and will not put a watch in these cases. This is useful when you are watching a directive attribute.
   * @param {Object} scope The scope on witch to put a watch.
   * @param {String} watched The scoped model to watch. If 'true' or 'false', the value is converted to a boolean and passed directly to the callback.
   * @param {function} cb Callback to be invoked when the value changes. Can be invoked many times in the same $digest. Should be idempotent.
   * @param {Object|String} def If provided, def will be passed to the callback if watched is falsy.
   */
  service.watch = function (scope, watched, cb, def) {
    if (!cb) {
      throw new Error('No callback provided!');
    }

    if (!watched) {
      // check for null and undefined. DON'T CHANGE TO !== ELSE THINGS BREAK.
      if (def != null) { // eslint-disable-line
        cb(def);
      }
      return;
    }

    if (watched === 'true') {
      cb(true);
    } else if (watched === 'false') {
      cb(false);
    } else {
      scope.$watch(watched, function (value) {
        cb(value);
      });
    }
  };

  /**
   * Trigger a watch function once after a digest cycle competed
   * @param scope scope to create the $watch at
   * @param listener function returning the property to watch for (similarly to the first parameter you pass to regular scope.$watch)
   * @param callback function ti be executed after the digest cycle completed
   * @param $timeout reference to angular $timeout service
   * @param apply boolean, true if the callback should be wrapped in scope.$apply, false to execute without wrapping
   */
  service.postDigest = function (scope, listener, callback, $timeout, apply) {
    return (function () {
      var unregister;
      var previous;
      var timeout;

      // Register some cleanup methods at the scope
      scope.$on('$destroy', function () {
        if (timeout) {
          $timeout.cancel(timeout);
        }
        if (unregister) {
          unregister();
        }
      });

      function postDigest(callback) {
        // Register a $watch with custom function as watchExpression.
        // A watchExpression will be executed in every digest cycle
        unregister = scope.$watch(function () {
          // In the first digest cycle unregister this watch again
          // to avoid creating multiple timeouts (infinity loop)
          unregister();
          // Create a timeout, this timeout will be executed after the digest cycle finished
          timeout = $timeout(function () {
            var current = listener();
            // Check whether our listener changed
            if (current !== previous) {
              if (apply) {
                // Execute callback in $scope.$apply phase
                (function (current, previous) {
                  scope.$apply(function () {
                    callback(current, previous);
                  });
                })(current, previous);
              } else {
                callback(current, previous);
              }
              previous = current;
            }
            // Recursive call to register for the next digest cycle
            postDigest(callback);
          }, 0, false);
        });
      }

      // Start postDigest Cycle
      postDigest(callback);
    })();
  };

  return service;
}
