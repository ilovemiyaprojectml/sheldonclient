/**
 * @class
 * @name fisViewService
 * @description View service, retrieves navigation structure.
 * @namespace navigation
 */
export default function () {
  'use strict';
  var self = this;
  // filters allow modifying the incoming nav structure before it gets
  // processed. It could be used to define the nav structure on the client
  // instead of on the server.
  // filter signature: function( items, params )
  // item: array of root nav items
  // params: params sent to navigation.refresh method.
  var filters = [];
  self.addFilter = function (filter) {
    return filters.push(filter);
  };

  self.removeFilter = function (idx) {
    delete filters[idx];
  };

  // set to false to prevent service from invoking the navigation rest endpoint
  self.remote = true;

  var staticViews = null;
  self.setViews = function (views) {
    staticViews = views;
  };

  // the default RESTful resource endpoint
  var defaultEndpoint = 'api/navigation.json';
  var endpoint = null;
  self.endpoint = function (ep) {
    if (ep) {
      endpoint = ep;
    }
    return endpoint;
  };

  // reference to angular's $routeProvider
  self.$routeProvider = null;

  self.$get = ['$templateCache', '$resource', '$route', '$rootScope', '$log', 'fisConfig', '$q', 'fisPubSubService', 'fisUtilService', '$injector', 'fisNavigationService', 'fisI18nService',
    function ($templateCache, $resource, $route, $rootScope, $log, fisConfig, $q, fisPubSubService, fisUtilService, $injector, fisNavigationService, fisI18nService) {
      var nav = null;
      var path2Item = {};
      var id2Item = {};
      var serv = {};

      /**
       * @name applyFilter
       * @description Utility function to filter navigation model.
       * @param model model to apply filters to
       * @param params filter parameters
       * @return
       * @methodOf fisViewService
       * @private
       */
      function applyFilters(model, params) {
        for (var i = 0; i < filters.length; i++) {
          filters[i](model, params);
        }
      }

      /**
       * @name traverse
       * @description Utility function to traverse and process navigation
       * structure
       * @param items structure to traverse
       * @param cb calback to apply during traversal
       * @param navPath tracks position in structure.
       * @return
       * @methodOf fisViewService
       * @private
       */
      function traverse(items, cb, navPath) {
        var path = navPath || [];
        angular.forEach(items, function (itm/* , key*/) {
          var ret = cb.apply(this, [itm, path]);
          if (ret === false) {
            return false;
          }
          if (itm.children) {
            path.push(itm);
            traverse(itm.children, cb, path);
            path.pop();
          }
          if (itm.quickLinks) {
            angular.forEach(itm.quickLinks, function (quickLinks) {
              path.push(itm);
              path.push(quickLinks);// include quicklinks in path
              traverse(quickLinks.children, cb, path);
              path.pop();
              path.pop();
            });
          }
        }, items);
      }

      /**
       * @name normalizeLabel
       * @description Normalises text to acceptable characters
       * @param label text to normalise
       * @return normalized text
       * @methodOf fisViewService
       * @private
       */
      function normalizeLabel(label) {
        return label.toLowerCase().replace(' ', '-');
      }

      function updatePath2Item(itm, path) {
        if (!itm.id) {
          itm.id = normalizeLabel(itm.label);
        }
        if (!itm.path) {
          var a = [];
          for (var i = 0; i < path.length; i++) {
            a.push(path[i].id);
          }
          a.push(itm.id);
          itm.path = '/' + a.join('/');
          path2Item[itm.path] = itm;
        }
        // In case, translation data is loading asynchronously, updating the label and title in path2Item[] array
        if (path2Item[itm.path] !== undefined) {
          path2Item[itm.path].label = itm.label;
          path2Item[itm.path].title = itm.title;
        }
      }

      function updateId2Item(itm) {
        if (itm.id.indexOf('/') > -1) {
          var isAlreadyIncluded = Object.keys(id2Item).some(function (key) {
            return id2Item[key] === itm;
          });
          if (!isAlreadyIncluded) {
            id2Item[itm.id] = itm;
          }
        }
      }

      /**
       * @name normalizeModel
       * @description Normalizes text to acceptable characters for model
       * @param model structure with labels to normalize
       * @methodOf fisViewService
       * @private
       */
      function normalizeModel(model) {
        angular.forEach(model, function (navItems/* , key*/) {
          traverse(navItems, function (itm, path) {
            updatePath2Item(itm, path);
            updateId2Item(itm);

            // i18n support of navigation item's label and title
            if (itm.label && itm.label.indexOf('i18n(') === 0) {
              itm.label = itm.label.substring(itm.label.indexOf('(') + 2, itm.label.indexOf(')') - 1);
              // In case, translations are available for the selected language then we can directly translate label and titles
              if (fisI18nService.isTranslationReady()) {
                itm.label = fisI18nService.translate(itm.label);
                updatePath2Item(itm, path);
                updateId2Item(itm);
              } else {
                // In case, translations are loading asynchronously, we need to use promise api to update
                // labels and titles on receiving data for translation
                fisI18nService.translateAsync(itm.label).then(function (resolvedLabel) {
                  itm.label = resolvedLabel;
                  updatePath2Item(itm, path);
                  updateId2Item(itm);
                });
              }
            }
            if (itm.title && itm.title.indexOf('i18n(') === 0) {
              itm.title = itm.title.substring(itm.title.indexOf('(') + 2, itm.title.indexOf(')') - 1);
              // In case, translations are available for the selected language then we can directly translate label and titles
              if (fisI18nService.isTranslationReady()) {
                itm.title = fisI18nService.translate(itm.title);
                updatePath2Item(itm, path);
                updateId2Item(itm);
              } else {
                // In case, translations are loading asynchronously, we need to use promise api to update
                // labels and titles on receiving data for translation
                fisI18nService.translateAsync(itm.title).then(function (resolvedTitle) {
                  itm.title = resolvedTitle;
                  updatePath2Item(itm, path);
                  updateId2Item(itm);
                });
              }
            }
            // support definitions that only contain a template
            if (itm.template && !itm.partial) {
              itm.partial = itm.path + '.tpl.html';
            }
          });
        });
      }

      /**
       * @name createRoutes
       * @description Creates angular routes from navigation structure
       * @param model navigation structure
       * @methodOf fisViewService
       * @private
       */
      function createRoutes(model) {
        angular.forEach(model, function (navItems /* , key*/) {
          traverse(navItems, function (itm/* , path*/) {
            if (itm.partial) {
              var opts = {
                templateUrl: fisUtilService.appendCacheQueryParameter(itm.partial)
              };

              if (itm.template) {
                // prefill $templateCache with provided template
                $templateCache.put(itm.partial, itm.template);
              }

              if (itm.controller) {
                // TODO: Controllers need to be loaded on demand
                opts.controller = itm.controller;
              }
              opts.resolve = createResolveProperty(itm);
              self.$routeProvider.when(itm.path, opts);
            } else if (!itm.children && !itm.action) {
              $log.warn('Leaf nav item without a partial: ' + itm.label);
            }
          });
        });
      }

      function createResolveProperty(itm) {
        var ret = {};

        // find the constructor in the registry
        var ctrl = itm.controller && fis.__controllers[itm.controller];

        angular.forEach(ctrl, function (val, key) {
          if (key.indexOf('$') !== 0) {
            ret[key] = createResolveValue(val, itm.args);
          }
        });

        if (itm.args) {
          ret.args = function () {
            return itm.args;
          };
        }

        return ret;
      }

      function createResolveValue(toResolve, args) {
        if (angular.isFunction(toResolve) || (angular.isArray(toResolve) && angular.isFunction(toResolve[toResolve.length - 1]))) {
          return function resolveFunction() {
            return $injector.invoke(toResolve, this, { args: args });
          };
        }
        return toResolve; // a simple object/array/native we want to pass
      }

      /**
       * @name processMenu
       * @description Process navigation structure for use in shell
       * @param model navigation structure
       * @param params filter parameters
       * @methodOf fisViewService
       * @private
       */
      function processMenu(model, params) {
        // TODO: execute all into a single traversal for speed.
        // add the default workspace
        applyFilters(model, params);
        normalizeModel(model);
        createRoutes(model);

        return model;
      }

      /**
       * @name fetchNavigation
       * @description Fetches navigation structure from backend and processes it
       * @param endpoint Serverside RESTful endpoint that serves navigation structure
       * @param params filter parameters
       * @methodOf fisViewService
       * @private
       */
      function fetchNavigation(endpoint, params) {
        var deferred = $q.defer();
        $resource(endpoint).get(params,
          function (results) {
            var finalResult = {};
            for (var key in results) {
              if (results.hasOwnProperty(key)) {
                var value = results[key];
                if (key.indexOf('$') !== 0) {
                  finalResult[key] = value;
                }
              }
            }
            resolveViews(deferred, finalResult, params);
          },
          function () {
            deferred.reject('Could not load navigation from ' + endpoint);
          }
        );
        return deferred.promise;
      }

      function resolveViews(deferred, views, params) {
        // assign the processed views to the internal nav var
        nav = processMenu(views, params);

        // resolve the deferred object to the processed views
        deferred.resolve(nav);

        // publish it on the 'shell.navReady' topic so that nav widgets can render the views
        fisPubSubService.publish('shell.navReady', nav);
        fisNavigationService.setNavigation(nav);
        return deferred.promise;
      }

      /**
       * @name load
       * @description Loads and initializes navigation
       * @param params filter parameters
       * @param model existing navigation structure(optional)
       * @methodOf fisViewService
       */
      serv.load = function (params, model) {
        // TODO: use fisConfig to get default params and extend with received params
        params = params || {};
        path2Item = params.path2Item || {};

        fisPubSubService.publish('shell.navLoading', true);
        if (model || staticViews) {
          // views provided as an argument or at config time; make it the new nav structure
          return resolveViews($q.defer(), angular.copy(model || staticViews), params);
        } else if (self.endpoint()) {
          // an endpoint was provided at config time, it takes precedence over config service
          return fetchNavigation(self.endpoint(), params);
        }
        return fetchNavigation(fisConfig.endpoints && fisConfig.endpoints.navigation || defaultEndpoint, params);
      };

      serv.loadOnNavChange = function (params, model) {
            // TODO: use fisConfig to get default params and extend with received params
        params = params || {};
        path2Item = params.path2Item || {};

        var deferred = $q.defer();

            // assign the processed views to the internal nav var
        nav = processMenu(angular.copy(model), params);

            // resolve the deferred object to the processed views
        deferred.resolve(nav);

        fisPubSubService.publish('shell.navChanged', nav);

        fisNavigationService.setNavigation(nav);
        return deferred.promise;
      };

        /**
         * @name findNavItem
         * @description Retrieves item at specified path.
         * @param navPath Navigation Path for required item
         * @param fromPath Path to search from if navPath is relative (doesn't start with '/').
         *          If not provided and navPath is relative, the function will return undefined.
         * @methodOf fisViewService
         */
        /* serv.findNavItem = function (navPath, fromPath) {
         console.log('Processing for navPath...', navPath);
         console.log('fromPath...', fromPath);
         fromPath = fromPath || '';
         if( navPath && navPath.indexOf('/') !== 0 ) {
         // navPath is relative, search from fromPath
         var item, idx = fromPath.lastIndexOf('/') + 1;
         console.log('index...', idx);
         console.log('path2Item...', path2Item);
         while(idx > 1) {
         console.log('path...', fromPath.substring(0, idx) + navPath);
         item = path2Item[fromPath.substring(0, idx) + navPath];
         console.log('item...', item);
         if( item ) {
         return item;
         }
         idx = fromPath.lastIndexOf('/', idx - 2) + 1;
         console.log('index after...', idx);
         }
         }
         return path2Item[navPath];
         };*/

      serv.findNavItem = function (navPath, fromPath) {
        var item = null;
        fromPath = fromPath || '';

        if (navPath && navPath.indexOf('/') !== 0) {
          // navPath is relative, search from fromPath
          // var idx = fromPath.lastIndexOf('/') + 1;
          // console.log('index...', idx);
          // console.log('path2Item...', path2Item);
          // console.log('path...', fromPath.substring(0, idx) + navPath);
          item = path2Item[fromPath + '/' + navPath];
          // console.log('item...', item);
          if (item) {
            return item;
          }
          // item not found relative to fromPath.
          item = serv.getItemFromPath2Item(navPath);
          // item still not found. Try to find if the path is just id. check with ids that contain '/' character
          if (!item) {
            item = getItemFromId2Item(navPath);
          }
          return item;
        }

        item = path2Item[navPath];

        return item;
      };

      function getItemFromId2Item(navPath) {
        var item = null;

        for (var id in id2Item) { // eslint-disable-line
          var idArr = id.split('/');
          var navPathArr = navPath.split('/');
          if (idArr.length === navPathArr.length) {
            var paramArr = matchTokens(idArr, navPathArr);
            if (paramArr) {
              item = id2Item[id];
              item.params = paramArr;
              break;
            }
          }
        }
        return item;
      }

      function matchTokens(idArr, navPathArr) {
        var paramArr = {};

        for (var i = 0; i < idArr.length; i++) {
          if (idArr[i] !== navPathArr[i] && idArr[i].indexOf(':') !== 0) {
            paramArr = null;
            return false;
          } else if (idArr[i] !== navPathArr[i] && idArr[i].indexOf(':') === 0) {
            var paramName = idArr[i].substring(1);
            var paramValue = navPathArr[i];
            paramArr[paramName] = paramValue;
          }
        }

        return paramArr;
      }

      // returns the last part of the navItem, excluding those those which include a ':', in which case the second last part will be returned
      function getNavPathEnd(navItem) {
        var parts = navItem.split('/');
        var size = parts.length;

        if (size < 2) {
          return navItem;
        }

        if (parts[size - 1].indexOf(':') === -1) {
          return parts[size - 1];
        } else if (parts[size - 2].indexOf(':') === -1) {
          return parts[size - 2];
        }

        // more than one parameters in id
        for (var i = size - 1; i > 0; i--) {
          if (parts[i].indexOf(':') === -1) {
            return parts[i];
          }
        }
      }

      serv.getItemFromPath2Item = function (navPath) {
        var navItem = null;

        for (var path in path2Item) {
          if (path2Item.hasOwnProperty(path)) {
            var item = path2Item[path];

            var pathTokenLength = path.split('/').length;
            var navPathTokenLength = navPath.split('/').length;

            if (((pathTokenLength > 2 && navPathTokenLength > 2 && pathTokenLength === navPathTokenLength) ||
                    (pathTokenLength <= 2 || navPathTokenLength <= 2)) &&
                    getNavPathEnd(path) === getNavPathEnd(navPath)) {
              navItem = item;
              return navItem;
            }
          }
        }
        return navItem;
      };

      serv.addDynamicItem = function (item, opts) {
        path2Item[item.path] = item;
        self.$routeProvider.when(item.path, opts);
      };

      /**
       * @name addItemToMenu
       * @description Add a node to existing navigation structure dynamically
       * @param parentItemId id or path of the node to which the new node needs to be appended
       * @param itemToAdd new node to be added
       * @methodOf fisViewService
       */
      serv.addNavItem = function (parentItemId, itemToAdd, openItemAfterAdd, openParams, addAfterItemId) {
        if (itemToAdd && itemToAdd.id) {
          var deferred = $q.defer();
          openItemAfterAdd = (openItemAfterAdd === 'true' || openItemAfterAdd === true);
          openParams = jQuery.isEmptyObject(openParams) ? undefined : openParams;
          fisPubSubService.publish('fisBeforeNavItemAdd', true);
          var parentItem = serv.findNavItem(parentItemId);
          if (parentItem) {
            itemToAdd.path = parentItem.path + '/' + itemToAdd.id;
            path2Item[itemToAdd.path] = itemToAdd;
            if (!parentItem.children) {
              parentItem.children = [];
            }

            if (isItemAlreadyPresentInParent(parentItem.children, itemToAdd)) {
              deferred.reject();
            } else {
              // add item after the specified sibling - if this item is not found, the new item will be added at the end
              if (addAfterItemId) {
                var siblingItem = serv.findNavItem(addAfterItemId);
                if (siblingItem) {
                  var siblingIndex = -1;
                  for (var i = 0; i < parentItem.children.length; i++) {
                    if (parentItem.children[i].path === siblingItem.path) {
                      siblingIndex = i;
                      break;
                    }
                  }
                  if (siblingIndex > -1) {
                    parentItem.children.splice(siblingIndex + 1, 0, itemToAdd);
                  }
                }
              } else {
                parentItem.children.push(itemToAdd);
              }
              updateModel(parentItem, function (navItems, matchedItem) {
                matchedItem.children = parentItem.children;
              });

              serv.loadOnNavChange({ path2Item: path2Item }, nav).then(function () {
                fisPubSubService.publish('fisAfterNavItemAdd', { nav: nav, itemToAdd: itemToAdd, parentItem: parentItem, openItemAfterAdd: openItemAfterAdd, openParams: openParams });
                deferred.resolve(nav);
              });
            }
          } else if (!parentItem && nav[parentItemId]) {
            // if item needs to be added directly at root level (for ex. directly under main, footer etc.)
            itemToAdd.path = '/' + itemToAdd.id;
            path2Item[itemToAdd.path] = itemToAdd;
            if (isItemAlreadyPresentInParent(nav[parentItemId], itemToAdd)) {
              deferred.reject();
            } else {
              nav[parentItemId].push(itemToAdd);
              serv.loadOnNavChange({ path2Item: path2Item }, nav).then(function () {
                var rootNav = parentItemId;
                fisPubSubService.publish('fisAfterNavItemAdd', { nav: nav, itemToAdd: itemToAdd, parentItem: parentItem, openItemAfterAdd: openItemAfterAdd, openParams: openParams, rootNav: rootNav });
                deferred.resolve(nav);
              });
            }
          }
          return deferred.promise;
        }
      };

      function isItemAlreadyPresentInParent(children, itemToAdd) {
        return children.some(function (child) {
          return child.id === itemToAdd.id;
        });
      }

      // TODO: There should not be a need for traversing the nav and updating it separately
      // However in case when we add an item first and then remove it, the changes are not
      // getting reflected in the model.
      // Need to look into the cause of this.
      function updateModel(itemToLookup, cb) {
        angular.forEach(nav, function (navItems/* , key*/) {
          traverse(navItems, function (itm) {
            if (itm.path === itemToLookup.path) {
              cb.apply(this, [navItems, itm]);
            }
          });
        });
      }

      function getIndexOfChild(childItem, parentItem) {
        var index = -1;
        if (parentItem && parentItem.children) {
          for (var i = 0; i < parentItem.children.length; i++) {
            var child = parentItem.children[i];
            if (child.id === childItem.id) {
              index = i;
              break;
            }
          }
        }
        return index;
      }

      serv.removeNavItem = function (itemToRemoveId, openParentNode, openParams) {
        var deferred = $q.defer();
        var parentItem;

        openParentNode = (openParentNode === 'true' || openParentNode === true);
        fisPubSubService.publish('fisBeforeNavItemRemove', true);
        var itemToRemove = serv.findNavItem(itemToRemoveId);
        if (itemToRemove) {
          var parentPath = itemToRemove.path.substring(0, itemToRemove.path.lastIndexOf('/'));
          if (parentPath) {
            parentItem = serv.findNavItem(parentPath);

            // if parent item not found, tokenize the path and try to find the parent
            if (!parentItem) {
              var hasMoreTokens = true;
              var tempPath = parentPath;

              while (hasMoreTokens) {
                tempPath = tempPath.substring(0, tempPath.lastIndexOf('/'));
                if (tempPath && tempPath.length === 0) {
                  hasMoreTokens = false;
                } else {
                  parentItem = serv.findNavItem(tempPath);
                  if (parentItem) {
                    hasMoreTokens = false;
                  }
                }
              }
            }

            if (parentItem) {
              var itmToRemIndex = getIndexOfChild(itemToRemove, parentItem);
              if (itmToRemIndex > -1) {
                parentItem.children.splice(itmToRemIndex, 1);
                path2Item[parentItem.path] = parentItem;

                delete path2Item[itemToRemove.path];
                delete id2Item[itemToRemove.id];

                updateModel(parentItem, function (navItems, matchedItem) {
                  matchedItem.children = parentItem.children;
                });
              }
            }
          } else {
            // no parent path means the node is at root level
            updateModel(itemToRemove, function (navItems, matchedItem) {
              navItems.splice(navItems.indexOf(matchedItem), 1);
            });
          }

          serv.loadOnNavChange({ path2Item: path2Item }, nav).then(function () {
            fisPubSubService.publish('fisAfterNavItemRemove', { nav: nav, itemToRemove: itemToRemove, parentItem: parentItem, openParentNode: openParentNode, openParams: openParams });
            deferred.resolve(nav);
          });
        } else {
          deferred.reject();
        }

        return deferred.promise;
      };

      return serv;
    }];
}
