export default function ($route, $anchorScroll, $compile, $controller, $animate, fisI18nService, $timeout) {
  'ngInject';
  // Makes a scope "freezable". This means it can be detached and re-attached
  // to the scope hierarchy. This code is specific to the fisView and can't be reused
  // for any scope. A frozen scope will not participate in the $apply cycle so
  // watches inside it will not be checked.
  // The scope keeps the same prototype so it could still modify models in the parent.
  // It will not be able to $emit events to the parent and the parent will not be able to $broadcast to it.
  // The reason we are freezing the scope is to prevent performance degradation when
  // multiple tabs are opened.
  function makeFreezable(s) {
    // make sure that when the parent scope is destroyed,
    // we re-attach the scope so that it can also be destroyed
    s.$parent.$on('$destroy', function () {
      if (s.$$frozen) {
        s.$freeze(false);
      }
      // tell fisViews that if the lastSelectedPanel was destroyed, ignore it and lose the reference on it so it can be GC'd
      s.$$fisGC = true;
    });

    s.$freeze = function (freeze) {
      if (freeze && !this.$$frozen) {
        // let the scope know it is about to be frozen
        this.$broadcast('fisFreezing');

        // marker to indicate the scope is frozen
        this.$$frozen = {};
        // preserve the parent (ngRepeat scope)
        this.$$frozen.$parent = this.$parent;

        // detach from the parent
        this.$parent.$$childHead = null;
        this.$parent.$$childTail = null;

        this.$parent = null;
        // let the scope know it has been frozen
        this.$broadcast('fisFrozen');
      } else if (!freeze && this.$$frozen) {
        // let the scope know it is about to be unfrozen
        this.$broadcast('fisUnfreezing');

        // re-attach the scope to its parent
        this.$parent = this.$$frozen.$parent;
        this.$parent.$$childHead = this;
        this.$parent.$$childTail = this;
        this.$$frozen = null;

        // let the scope know it has been unfrozen
        this.$broadcast('fisUnfrozen');
      }
    };

    return s;
  }

  return {
    restrict: 'EA',
    scope: true, // needed because we now put stuff in the scope
    replace: true,
    controller: ['$scope', '$attrs', 'fisPubSubService', function ($scope, $attrs, fisPubSubService) {
      /**
       * Provides translation for the view displayed in the view panel.
       * This overrides the shell controller's i18n function and provides
       * automatic namespacing based on the current view panel's module and id.
       * e.g. for a view panel in the "desktop-ui" module and an id of "dashboard", the key,
       * if it doesn't already contain dots ".", will be prefixed by "desktop-ui.dashboard.".
       * @param {string} key the i18n key to provide a translation for
       * @param {string} def t{{item.label}}he default value, if the key can't be found
       */
      var unsubscribe = fisPubSubService.subscribe('shell.i18nReady', function () {
        $scope.i18n = function (key, def) {
          if (angular.isDefined(key)) {
            if (key.indexOf('.') === -1) {
              // TODO: when we allow reuse of viewPanels, the view panel should not be the active view panel
              //      because this fisViewPanel directive will occur multiple times in the dom (once for each tab).
              //      If we leave it like that, all strings of all views will get changed each time the active view is changed.
              var view = $scope.activeViewPanel();
              if (view) {
                key = [view.module, view.id, key];
              }
            }
            return fisI18nService.translate(key, def);
          }
        };
        // Un-subscribing shell.i18nReady event
        unsubscribe();
      });

      $scope.setTitle = function (value) {
        $scope.activeViewPanel().setTitle(value);
      };

      $scope.resetTitle = function () {
        $scope.activeViewPanel().resetTitle();
      };

      $scope.setIcon = function (value) {
        $scope.activeViewPanel().setIcon(value);
      };

      if ($attrs.fisStacked && $attrs.fisStacked === 'false') {
        $scope.fisStacked = false;
      } else {
        $scope.fisStacked = true;
      }
    }],
    template: `<div fis-message-container>
                  <div class="fis-info-panel"></div>
                  <div ng-repeat="panel in panels" class="fis-panel-container ng-hide" fis-element="panel" fis-pub-sub></div>
                  <div class="default-panel"></div>
                </div>`,
    link: function (scope, element, attrs) {
      // the default panel is used if none of the provided panels are selected or if no panels are provided
      var defaultPanel;
        // the previously selected panel
      var lastSelectedPanel;
        // expression to evaluate when contents is loaded
      var onloadExp = attrs.fisOnLoad || '';
      var updateTimeout;
      // start with no panels
      scope.panels = undefined;

      function matchingPathParams(currentParams, panelParams) {
        if (Object.keys(currentParams).length > 0) {
          for (var prop in currentParams) {
            if (currentParams[prop] != panelParams[prop]) { // eslint-disable-line
              return false;
            }
          }
        }
        return true;
      }

      function updatePanel(panel) {
        lastSelectedPanel = panel;
        // we need the current route...
        var current = $route.current;
        // and the current route's local variables
        var locals = current && current.locals;
        // and the template for that route
        var template = locals && locals.$template;

        var activePanel = scope.activeViewPanel();

        if (current && current.templateUrl && activePanel && current.templateUrl.indexOf(activePanel.partial) !== -1 && matchingPathParams(current.pathParams, activePanel.params)) {
          // if the selected panel is for the current route, simply unfreeze its scope
          if (current && panel.$route && panel.$route.originalPath === current.$$route.originalPath) {
            // detach the scope from the scope hierarchy
            panel.$scope.$freeze(false);
            // panel already loaded, just broadcast it
            panel.$scope.$broadcast('$panelContentLoaded');
          } else if (template) {
            // The panel is not for the current route, replace its contents with the route's template
            // Clear the contents of the selected panel
            clearContent(panel, false);
            // associate with the current route
            panel.$route = current.$$route;
            // make the route template the panel's content in an animatable way
            $animate.enter(angular.element('<div></div>').html(template).contents(), panel.$element);

            // compile the panel's content
            var link = $compile(panel.$element.contents());
            var controller;
            // grab a hold of the scope that the ng-repeat created for the panel div
            var repeatScope = panel.$element.scope();
            // create a child scope and make it freezable
            panel.$scope = current.scope = makeFreezable(repeatScope.$new());
            // if args are present in the item, make it available on the scope as viewArgs
            if (panel.args) {
              panel.$scope.viewArgs = panel.args;
            }

            // if the current route declares a controller
            if (current.controller) {
              // add the current panel's scope to the route's local variables
              locals.$scope = panel.$scope;
              // add the panel's element to the route's local variables
              locals.$element = panel.$element;
              // create the controller with the injectable locals
              controller = $controller(current.controller, locals);
              // attach to the panel
              panel.$element.children().data('$ngControllerController', controller);
            }

            // link the compiled contents with the panel's scope
            link(panel.$scope);
            // emit the $viewContentLoaded event like ng-view does
            panel.$scope.$emit('$viewContentLoaded');

            // execute the onload handler
            panel.$scope.$eval(onloadExp);

            // $anchorScroll might listen on event...
            $anchorScroll();
          } else if (panel.$scope && panel.args.targetScope.location.$$url) {
            // check for presence of scope.alert and scope.open: these are defined in the shell
            // and this could be used outside the shell since it is in fis-components.
            // no template for this route, display relevant message alert box (if a message is available)
            var msg;
            if (scope.alert && (msg = fisI18nService.translate('error-path-not-found', ''))) {
              scope.alert(msg, { title: fisI18nService.translate('error-dialog-title') });
            }
            // open the last open panel
            if (scope.open) {
              scope.open(lastSelectedPanel.path);
            }
          }
        }
      }

      function update() {
        // find the selected panel
        var panel = getSelectedPanel();
        // ensure we are not dealing with a lastSelectedPanel that was destroyed
        // this can happen when switching menus
        if (lastSelectedPanel && lastSelectedPanel.$scope && lastSelectedPanel.$scope.$$fisGC) {
          // the scope (and therefore the panel) was destroyed. Lose the references
          clearContent(lastSelectedPanel, true);
          lastSelectedPanel = null;
        }

        if (lastSelectedPanel !== panel) { // eslint-disable-line
          // we are changing panel, or the last panel was destroyed...
          if (lastSelectedPanel) {
            // hide the previous one if it still exists
            $animate.addClass(lastSelectedPanel.$element, 'ng-hide');
            lastSelectedPanel.$element.removeClass('fis-selected');

            if (lastSelectedPanel.saveState === false) {
              // View doesn't want state saving. Destroy the scope.
              clearContent(lastSelectedPanel, false);
            } else if (lastSelectedPanel.$scope) {
              // freeze the scope on the previous panel
              // scope may not be there for nav item without partial and secondary menu
              lastSelectedPanel.$scope.$freeze(true);
            }
          }
          // show the selected one
          if (panel.$element) {
            $animate.removeClass(panel.$element, 'ng-hide').then(function () {
              panel.$element.addClass('fis-selected');
              if (updateTimeout) {
                $timeout.cancel(updateTimeout);
              }
              updateTimeout = $timeout(function () {
                updatePanel(panel);
              }, 0);
            });
          }
        } else {
          updatePanel(panel);
        }
      }

      // This function is invoked when a panel is already opened but
      // the route it is currently associated to needs to change
      function clearContent(panel, removeElementRef) {
        // remove the contents, if any, in an animatable way
        var contents = panel.$element.contents();

        if (contents.length > 0) {
          $animate.leave(contents);
        }

        if (panel.$scope) {
          // destroy the scope associated to the panel's content
          panel.$scope.$destroy();
          // make sure we don't keep a reference on it for GC
          panel.$scope = null;
          // make sure no route is associated to this panel
          panel.$route = null;
          // make sure no element is associated to this panel
          if (removeElementRef) {
            panel.$element = null;
          }
        }
      }

      function getSelectedPanel() {
        if (angular.isNumber(scope.selectedIndex) && scope.selectedIndex !== -1) {
          return scope.panels[scope.selectedIndex];
        }

        return getDefaultPanel();
      }

      function getDefaultPanel() {
        if (!defaultPanel) {
          // initialize default panel since we need it.
          defaultPanel = {};
          defaultPanel.$element = angular.element(element[0].getElementsByClassName('default-panel')[0]);
        }
        return defaultPanel;
      }

      if (scope.fisStacked && attrs.fisViews && attrs.fisSelectedIndex) {
        // if a fisViews attribute is provided, operate in state preservation mode
        scope.$watchCollection(attrs.fisViews, function (value) {
          // don't need to find out what was added; scopes will be added if selected and a route is followed
          scope.panels = value;
        });
        scope.$watch(attrs.fisSelectedIndex, function (idx) {
          scope.selectedIndex = idx;
        });
      }

      element.addClass('fis-view-panel');

      scope.$on('$routeChangeSuccess', update);
    }
  };
}
