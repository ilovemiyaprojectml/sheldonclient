/* jshint maxparams:12 */
/**
 * @class
 * @name fisViewPanelService
 * @requires $locatio* @requires $timeout
 * @requires fisViewService
 * @description
 <p>Provides ViewPanel management functionality to the application.<p>
 <p>This service subscribes to <em>shell.navReady</em> event to get a list of
 top-level Navigation Items with partials configured and opens up non-closeable ViewPanels for these
 as the landing view for a user.</p>
 <p>The provider for this service, <em>fisViewPanelServiceProvider</em>, can be configured with View opening
 strategy during the module configuration phase. This can be a function or string. Possible value for string argument
 is <em>mdi</em> at the moment, while <em>sdi</em> and <em>hybrid</em> options would be made available in future.</p>
 */
export default function () {
  'use strict';

  var DEFAULT_OPEN_STRAT = 'mdi';
  var CUSTOM_OPEN_STRAT = 'custom function';

  var provider = this;
  var openStratStr = null;
  var customStrategyFn = null;
  var preventBrowserNavigation = true;

  /**
   * @name setViewOpeningStrategy
   * @methodOf fisViewPanelServiceProvider
   * @param {String | Function} Function reference of custom view opening strategy or string from enum (only 'mdi' and 'browser' at this point in time)
   * @description
   * <p>Configures the provider with a View Panel Opening strategy that is then used by the <em>fisViewPanelService</em> to open
   * View Panels.</p>
   */
  this.setViewOpeningStrategy = function (fn) {
    if (angular.isFunction(fn)) {
      openStratStr = CUSTOM_OPEN_STRAT;
      customStrategyFn = fn;
    } else if (angular.isString(fn)) {
      openStratStr = fn;
    } else {
      openStratStr = DEFAULT_OPEN_STRAT;
    }
  };

  /**
   * @name getViewOpeningStrategy
   * @methodOf fisViewPanelServiceProvider
   * @description
   * <p>Get the view opening strategy string reference or custom function if one was set.</p>
   */
  this.getViewOpeningStrategy = function () {
    if (openStratStr === null) {
      return DEFAULT_OPEN_STRAT;
    } else if (openStratStr === CUSTOM_OPEN_STRAT) {
      return customStrategyFn;
    }
    return openStratStr;
  };

  /**
   * @name setPreventBrowserNavigation
   * @methodOf fisViewPanelServiceProvider
   * @param {Boolean} True for preventing browser reloading while navigating
   * @description
   * <p>Set a flag to prevent browser default navigation while using <em>fisViewPanelService</em>.</p>
   */
  this.setPreventBrowserNavigation = function (val) {
    preventBrowserNavigation = Boolean(val);
  };

  /**
   * @name getPreventBrowserNavigation
   * @methodOf fisViewPanelServiceProvider
   * @description
   * <p>Get if the view panel should prevent the default browser navigation.</p>
   */
  this.getPreventBrowserNavigation = function () {
    return preventBrowserNavigation;
  };

  /**
   * @name ViewPanel
   * @methodOf fisViewPanelService
   * @param {viewDef} navigation Item
   * @description extends and decorates the nav item with a label and ability to change this via method call.
   */
  var ViewPanel = function (viewDef, $filter) {
    angular.extend(this, viewDef);

    this.$filter = $filter;
    this.navItem = angular.copy(viewDef);
    this.title = viewDef.label;
  };

  ViewPanel.prototype.setTitle = function (stringOrObject) {
    if (typeof stringOrObject !== 'object') { // eslint-disable-line
      this.navItem.customTitle = stringOrObject;
    } else {
      var tl = '';
      var sep = '|';

      if (stringOrObject.sep) {
        sep = stringOrObject.sep;
      }

      if (stringOrObject.prefix) {
        tl = stringOrObject.prefix;
        tl += sep;
      }

      tl += this.$filter('interpolate')(this.navItem.label, stringOrObject);

      if (stringOrObject.suffix) {
        tl += sep;
        tl += stringOrObject.suffix;
      }

      this.navItem.customTitle = tl;
    }
  };

  ViewPanel.prototype.setIcon = function (cssClass) {
    this.navItem.customIcon = cssClass;
  };

  ViewPanel.prototype.resetIcon = function () {
    this.navItem.customIcon = undefined;
  };

        // Returns the title the view want's to be shown in the tab.
        // (fisTabsBar may display parentTitle due to config if no customTitle supplied)
  ViewPanel.prototype.getTitle = function () {
    if (this.navItem && this.navItem.customTitle) {
      return this.navItem.customTitle;
    }

    return this.title;
  };

        // Returns the icon the view want's to be shown in the tab.
        // (fisTabsBar may display parentIcon due to config if no customIcon supplied)
  ViewPanel.prototype.getIcon = function () {
    if (this.navItem && this.navItem.customIcon) {
      return this.navItem.customIcon;
    }

    return this.icon;
  };

        // we merge properties from the routeParams with the already manually set params.
        // jQuery.extend(this.params, $routeParams);
  ViewPanel.prototype.resetTitle = function () {
    this.navItem.customTitle = undefined;
  };

  this.ViewPanel = ViewPanel;

        /**
         * @name $get
         * @methodOf fisViewPanelServiceProvider
         * @description
         * <p>Factory method to create instance of fisViewPanelService.</p>
         */
  this.$get = [

    '$location',
    '$timeout',
    'fisViewService',
    'fisConfig',
    '$filter',
    '$route',
    'fisPubSubService',
    'fisI18nService',
    '$routeParams',
    '$rootScope',
    '$q',
    '$controller',

    function ($location, $timeout, fisViewService, fisConfig, $filter, $route, fisPubSubService, fisI18nService, $routeParams, $rootScope, $q, $controller) {
      var service = {};
      var selectedPanelPath;
      var selectedPanelUnresolvedPath;
      var selectedPanelParams;
      var tabs = [];
      var navigationUnderWay = false;
      var changeLocationNavigationUnderway = false;
      var strategies = {};
      var keepSameTabsOpenOnReload;
      var keepTabsOpenVariableLoaded;
      var tabsAfterNavReadySet;
      var preventBrowserNavigationSet;
      var refreshInterval;

      function init() {
        startAvailableStrategies();

        loadKeepTabsOpenVariable();  // sets keepSameTabsOpenOnReload variable

        setupTabsAfterNavReady();

        setupPreventBrowserNavigation();

        setupLocaleChangeHandle();

        refreshInterval = setInterval(publishNavComplete, 100);
      }

      function publishNavComplete() {
        if (keepTabsOpenVariableLoaded && tabsAfterNavReadySet && preventBrowserNavigationSet) {
          // publish event navigation done...
          clearInterval(refreshInterval);
          fisPubSubService.publish('shell.viewPanelReady');
        }
      }

      /**
       * Setup the initially available opening strategies
       * by placing them in the private strategies object
       */
      function startAvailableStrategies() {
        strategies = {
          mdi: mdiFunction,
          browser: browserFunction
        };
      }

      function isDuplicatePath(path, items) {
        return items.some(function (item) {
          return path === item.path;
        });
      }

      function loadKeepTabsOpenVariable() {
        if (angular.isUndefined(keepSameTabsOpenOnReload)) {
          if (fisConfig.widgets && fisConfig.widgets.fisTabsBar && angular.isDefined(fisConfig.widgets.fisTabsBar.keepSameTabsOpenOnReload)) {
            keepSameTabsOpenOnReload = fisConfig.widgets.fisTabsBar.keepSameTabsOpenOnReload;
          } else {
            keepSameTabsOpenOnReload = false;
          }
          keepTabsOpenVariableLoaded = true;
          return keepSameTabsOpenOnReload;
        }

        keepTabsOpenVariableLoaded = true;
        return keepSameTabsOpenOnReload;
      }

      function setupTabsAfterNavReady() {
        fisPubSubService.subscribe('shell.navReady', function (nav) {
          if (keepSameTabsOpenOnReload) {
            // Clearing all tabs not in new nav structure
            if (tabs.length > 0) {
              for (var i = tabs.length; i-- > 0;) {
                var tabItem = tabs[i];
                var item = fisViewService.findNavItem(tabItem.path);

                // remove tab not in new nav structure but do not remove untitled tab (':vmcount')
                if (!item && tabItem.id !== ':vmCount') {
                  tabs.splice(i, 1);
                }
              }
            }
          } else {
            tabs = [];
          }

          // Get static tabs from nav structure
          var newTabs = getNewTabs(nav.main);

          // Checks to see which static pages need to be added or which static pages already in tabs
          newTabs.forEach(function (newTab, index) {
            // Checks to see if newTab exists in current or new nav structure
            var item = fisViewService.findNavItem(newTab.path);

            // it exists in nav structure
            if (item) {
              // Checking if newTab already in tabs
              if (!isDuplicatePath(item.path, tabs)) {
                // Adds static page to tabs
                var newStaticPage = new provider.ViewPanel(item, $filter);
                tabs.splice(index, 0, newStaticPage);
              }
            }
          });

          resetSelectedPanelPath();
          tabsAfterNavReadySet = true;
        }, true);
      }

      function getNewTabs(items) {
        var tabs = [];
        var count = 0;

        items.forEach(function (item) {
          item.location = 'main';
          if (isValidTab(item)) {
            tabs[count++] = new provider.ViewPanel(item, $filter);
          }
        });

        return tabs;
      }

      function isValidTab(item) {
        return hasNonCloseableFlag(item) || hasDropdownSecondaryMenu(item);
      }

      function hasNonCloseableFlag(item) {
        return angular.isDefined(item.closeable) && !item.closeable;
      }

      function hasDropdownSecondaryMenu(item) {
        return item.secondaryNav === 'dropdown';
      }

      function resetSelectedPanelPath() {
        // This is important when reloading navigation at runtime.
        selectedPanelPath = undefined;
        selectedPanelUnresolvedPath = undefined;
        selectedPanelParams = undefined;
      }

      function setupPreventBrowserNavigation() {
        if (provider.getPreventBrowserNavigation()) {
          $rootScope.$on('$locationChangeStart', onLocationChangeStart);
        } else {
          $rootScope.$on('$locationChangeStart', onLocationChangeStartNavigate);
        }
      }

      var shellReady = false;

      function onLocationChangeStartNavigate() {
        fisPubSubService.subscribe('shell.navReady', function () {
          shellReady = true;
        });

        if (!navigationUnderWay && shellReady) {
          changeLocationNavigationUnderway = true;
          service.open($location.path());
        }

        navigationUnderWay = false;

        preventBrowserNavigationSet = true;
      }

      function onLocationChangeStart(event, newPath, oldPath) {
        if (!navigationUnderWay) { // eslint-disable-line
          var newUrl = getUrlWithoutHash(newPath);
          var oldUrl = getUrlWithoutHash(oldPath);

          if (newUrl !== oldUrl) {
            // Old and new path are not the same, which means that someone is trying to navigate away from the current page.
            // prevent the location change (this will revert the url in the address bar to what it was
            event.preventDefault();
          }
        } else {
          navigationUnderWay = false;
        }

        preventBrowserNavigationSet = true;
      }

      function setupLocaleChangeHandle() {
        fisPubSubService.subscribe('fisLocaleChanged', function () {
          // Reload the navigation if the locale setting changed
          var activePanel = service.activeViewPanel();
          fisViewService.load().then(function () {
            $timeout(function () {
              if (activePanel) {
                // get the path the to take care of unicode path
                var item = fisViewService.getItemFromPath2Item(activePanel.path);
                if (item) {
                  service.open(item.path, null, activePanel.params);// Open active one last.
                } else { // untitled tab
                  service.open(activePanel.path, null, activePanel.params);// Open active one last.
                }
              }
            }, 0);
          });
        });
      }

      function checkAndSetForSecondaryNavItem(navItem, event, params) {
        var navParent = getSecondaryNavThroughPaths(navItem);

        if (navParent) {
          // set the parent title for display
          var paramsToUse = params ? params : navParent.params;

          // check if tab is already present - if it is, do not update parentTitle, as it can mess up with tab title
          var tabAlreadyPresent = false;

          tabs.forEach(function (tab) {
            if (tab.path === navItem.path) {
              tabAlreadyPresent = true;
            }
          });

          // change parent title only if tab is not already present and there are parameters
          if (!tabAlreadyPresent && paramsToUse) {
            navItem.parentTitle = $filter('interpolate')(navParent.label, paramsToUse);
          } else if (!tabAlreadyPresent && !paramsToUse && navParent.label && navParent.label.indexOf('{') < 0 && navParent.label.indexOf('}') < 0) {
            navItem.parentTitle = navParent.label;
          }

          navItem.parentIcon = navParent.icon ? navParent.icon : null;
          var newNavItem = openSecNavItem(navItem, event, params);
          if (newNavItem) {
            navItem = newNavItem;
          }
        }
      }

      function getSecondaryNavThroughPaths(navItem) {
        var navParent = null;

        if (navItem !== undefined && navItem !== null) {
          if (navItem.unresolvedPath) {
            navParent = getSecondaryNavParent(navItem.unresolvedPath);
          }

          if (navParent === null) {
            navParent = getSecondaryNavParent(navItem.path);
          }
        }
        return navParent;
      }

      function publishViewPanelChange(navItem, previousViewPanel, event) {
        if (navItem && navItem.params) {
          navItem.decodedParams = addDecodedParams(navItem.params);
        }

        fisPubSubService.publish('fisActiveViewPanelChanged', {
          before: previousViewPanel,
          after: selectedPanelPath,
          currentNavItem: navItem,
          event: event
        });
      }

      function addDecodedParams(params) {
        var decodedParams = {};
        if (params) {
          for (var key in params) {
            if (params.hasOwnProperty(key)) {
              var paramValue = params[key];
              // decode only if url contains : or / characters
              if (paramValue && typeof paramValue === 'string' && (paramValue.indexOf('%2F') > -1 || paramValue.indexOf('%3A') > -1)) {
                decodedParams[key] = decodeURIComponent(paramValue);
              }
            }
          }
        }
        return decodedParams;
      }

      /**
       * Call the appropriate opening strategy which decides whether to open
       * a new tab or reuse the current one
       * @param navItem object containing information about the view to be opened
       * @param localEvent
       */
      function callRelevantStrategy(navItem, localEvent, parameters) {
        // Check for boolean values as localEvent to override strategy
        if (typeof (localEvent) === 'boolean') {
          if (localEvent) {
            openInNewTab(navItem, null, parameters);
          } else {
            openInSameTab(navItem, null, parameters);
          }
        } else {
          // No overriding, continue as usual
          var openingStrategy = provider.getViewOpeningStrategy();

          if (angular.isFunction(customStrategyFn) && openStratStr === CUSTOM_OPEN_STRAT) {
            // We've got a custom strategy and should use it
            customStrategyFn.call(service, navItem, localEvent, parameters);
          } else {
            // Use one of the framework pre-implemented strategies
            var stratFn = strategies[openingStrategy];

            if (angular.isFunction(stratFn)) {
              stratFn.call(service, navItem, localEvent, parameters);
            } else {
              // Framework default/Fallback if we do not have a strategy function
              // matching this name or one at all
              strategies[DEFAULT_OPEN_STRAT].call(service, navItem, localEvent, parameters);
              console.warn('Unable to find opening strategy ' + openingStrategy + ', will use default ' + DEFAULT_OPEN_STRAT);
            }
          }
        }
      }

      function validateNavItem(navItem, navPath) {
        setPathNotFoundError(navItem, navPath);

        setPartialNotFoundError(navItem);
      }

      function setPathNotFoundError(navItem, navPath) {
        // if (hasNoItemButTabs(navItem)) {
        // we need to display path-not-found error even if there are no tabs open
        if (!navItem && navPath !== '' && navPath !== '/') {
          throwNoItemDefinedError(fisI18nService.translate('error-path-not-found', ''));
        }
      }

      function hasNoItemButTabs(navItem) {
        return !navItem && tabs.length > 0;
      }

      function throwNoItemDefinedError(userMessage) {
        // TODO: replace with a fisMessageCenterService
        var err = new Error('No nav item defined for this path');
        err.userMessage = userMessage;
        throw err;
      }

      function setPartialNotFoundError(navItem) {
        if (hasTabsButNoPartial(navItem)) {
          throwNoPartialFoundError(navItem, fisI18nService.translate('error-partial-not-found', ''));
        }
      }

      function hasTabsButNoPartial(navItem) {
        return navItem && // item exists
          !navItem.partial && // but no partial
          !navItem.secondaryNav && // neither secondary nav
          !navItem.action &&// or action
          tabs.length > 0; // and the service has tabs
      }

      function throwNoPartialFoundError(navItem, userMessage) {
        // TODO: replace with a fisMessageCenterService
        var err = new Error('Nav item "' + navItem.label + '" does not have a partial to load');
        err.userMessage = userMessage;
        throw err;
      }

      function substituteParams(path, localParams) {
        while (path.indexOf(':') > -1) {
          path = getReplacedPath(path, localParams);
        }

        return path;
      }

      function removeExtraParamsFromLocalParams(path, localParams) {
        var localParamsToKeep = {};
        while (path.indexOf(':') > -1) {
          var paramStr = path.substring(path.indexOf(':') + 1);
          var param = paramStr.indexOf('/') > -1 ? paramStr.substring(0, paramStr.indexOf('/')) : paramStr;
          localParamsToKeep[param] = localParams[param];
          path = path.substring(path.indexOf(':' + paramStr) + 1);
        }
        return localParamsToKeep;
      }

      function hasSpecialCharacter(paramVal) {
        return !/^[a-zA-Z0-9-% ]*$/.test(paramVal);
      }

      function getReplacedPath(path, localParams) {
        var paramStr = path.substring(path.indexOf(':') + 1);
        var param = paramStr.indexOf('/') > -1 ? paramStr.substring(0, paramStr.indexOf('/')) : paramStr;
        var remainingStr = paramStr.substring(param.length);

        var paramValue;
        var paramValueOrig = localParams[param];
        if (paramValueOrig && (paramValueOrig.toString().indexOf('/') > -1 || paramValueOrig.toString().indexOf(':') > -1)) {
          paramValue = encodeURIComponent(paramValueOrig);
        } else if (hasSpecialCharacter(paramValueOrig)) {
          paramValue = encodeURIComponent(paramValueOrig);
          paramValue = decodeURIComponent(paramValue);
        } else {
          paramValue = decodeURIComponent(paramValueOrig);
        }

        if (localParams[param] !== paramValue) { // This Is a reload
          localParams[param] = paramValue;// Set Local param to decoded value so it can found
        }
        return path.substring(0, path.indexOf(':')) + paramValue + remainingStr;
      }

      // Updating tabs[] array with the data received from the translation object
      // This is required to update the tab title correctly in case translation data is loading asynchronously
      function updateTabsArray(path, navItem) {
        if (tabs) {
          for (var count = 0; count < tabs.length; count++) {
            if (tabs[count].path === path) {
              if (navItem && navItem.label) {
                tabs[count].label = navItem.label;
                tabs[count].title = navItem.label;
              }
              break;
            }
          }
        }
      }

      function getSecondaryNavParent(navPath) {
        var tempPath = navPath;
        var navItemParent = null;
        var itemWithSecNav = null;

        while (!itemWithSecNav) {
          if (tempPath) {
            navItemParent = fisViewService.findNavItem(tempPath);
            updateTabsArray(tempPath, navItemParent);
            itemWithSecNav = getItemParentRefIfValid(navItemParent);
            tempPath = tempPath.substring(0, tempPath.lastIndexOf('/'));
          } else {
            break;
          }
        }

        // clear params from the item, since it may contain stale value
        if (itemWithSecNav) {
          itemWithSecNav.params = null;
        }
        return itemWithSecNav;
      }

      // Expose getSecondaryNavParent functionality required by breadcrumbs container to check for a tab
      // whether its a secondary navigation tab or not
      service._getSecondaryNavParent = getSecondaryNavParent;

      function getItemParentRefIfValid(navItemParent) {
        var value = null;
        if (navItemParent && (navItemParent.secondaryNav === 'menubar' || navItemParent.secondaryNav === 'dropdown')) {
          value = navItemParent;
        }
        return value;
      }

      function openSecNavItem(item, event, params) {
        var navItem = getNavItemFromViewPanel(item);
        var parameters = getParamsOrNavItemParams(params, navItem);
        var substitutedNavItem = getSubstitutedUrlIfContainsParams(parameters, navItem);

        openTestingByGroupOpened(substitutedNavItem, event, parameters);

        if (isValidSecondaryMenuItem(navItem)) {
          var itemWithSecNav = getSecondaryNavThroughPaths(navItem);
          var children = getChildrenFromNavItem(navItem, itemWithSecNav);
          var newNavItem = null;

          updateAllChildren(itemWithSecNav);

          setParamsAcessedBySecondaryMenu(itemWithSecNav, substitutedNavItem);

          newNavItem = getNewNavItem(navItem, itemWithSecNav, children);

          fisPubSubService.publish('fisSecondaryMenuClicked', itemWithSecNav);

          return newNavItem;
        }
      }

      function getNavItemFromViewPanel(item) {
        var navItem = item;

        if (navItem instanceof provider.ViewPanel) {
          navItem = navItem.navItem;
          if (navItem.params && navItem.unresolvedPath) {
            navItem.path = navItem.unresolvedPath;
          }
        }

        return navItem;
      }

      function getParamsOrNavItemParams(params, navItem) {
        var parameters = params;

        if (!parameters && navItem.params !== null) {
          parameters = navItem.params;
        }

        return parameters;
      }

      function getSubstitutedUrlIfContainsParams(parameters, navItem) {
        var substitutedNavItem = angular.copy(navItem);

        if (parameters && navItem) {
          // set the original parameterized path
          if (!substitutedNavItem.unresolvedPath) {
            substitutedNavItem.unresolvedPath = navItem.path;
          }
          substitutedNavItem.path = substituteParams(navItem.path, parameters);
          substitutedNavItem.label = $filter('interpolate')(navItem.label, parameters);
          substitutedNavItem.params = parameters;
        }

        return substitutedNavItem;
      }

      function openTestingByGroupOpened(substitutedNavItem, event, parameters) {
        if ((isTrue(event) || angular.isUndefined(event) || angular.isObject(event)) && !isSecNavItemGroupOpen(substitutedNavItem) && !isPartOfSecondaryNav(getSecondaryNavParent(substitutedNavItem.path), service.activeViewPanel())) {
          openInNewTab(substitutedNavItem, event);
        } else {
          openInSameTab(substitutedNavItem, event, parameters);
        }
      }

      function isPartOfSecondaryNav(navItem, currentNavItem) {
        var containsNavItem = false;
        if (navItem !== null && currentNavItem !== null) {
          if ((navItem.id === currentNavItem.id)) {
            return true;
          } else if (angular.isDefined(navItem.children) && angular.isArray(navItem.children)) {
            navItem.children.forEach(function (childNavItem) {
              if (containsNavItem !== true) {
                containsNavItem = isPartOfSecondaryNav(childNavItem, currentNavItem);
              }
            });
          } else {
            return false;
          }
        }
        return containsNavItem;
      }

      function isValidSecondaryMenuItem(navItem) {
        return navItem &&
          (navItem.secondaryNav ||
            getSecondaryNavParent(navItem.path) ||
            getSecondaryNavParent(navItem.unresolvedPath));
      }

      function getChildrenFromNavItem(navItem, itemWithSecNav) {
        var children = null;

        if (navItem.secondaryNav) {
          children = navItem.children;
        } else if (itemWithSecNav) {
          children = itemWithSecNav.children;
        }

        return children;
      }

      function setParamsAcessedBySecondaryMenu(itemWithSecNav, substitutedNavItem) {
        if (itemWithSecNav) {
          itemWithSecNav.params = substitutedNavItem.params;
        }
      }

      function getNewNavItem(navItem, itemWithSecNav, children) {
        var newNavItem = angular.extend({}, navItem);
        newNavItem.children = children;
        newNavItem.secondaryNav = itemWithSecNav.secondaryNav;

        return newNavItem;
      }

      function updateAllChildren(navItem) {
        if (navItem && navItem.children) {
          navItem.children.forEach(function (child) {
            updateChildData(child);

            updateAllChildren(child);
          });
        }
      }

      function updateChildData(child) {
        if (child.partial) {
          child.isStatic = true;
        }

        child.text = child.label;
        child.items = child.children;

        if (child.partial) {
          child.url = child.path;
        }
      }

      function isSecNavItemGroupOpen(navItem) {
        var itemWithSecNav = getSecondaryNavThroughPaths(navItem);
        var secNavItemGroupPresent = false;

        if (itemWithSecNav !== null) {
          // attach a property secondaryNavParent to the navItem in case the parent secondary navigation item has secondaryNav as dropdown
          if (hasDropdownSecondaryMenu(itemWithSecNav)) {
            navItem.secondaryNavParent = itemWithSecNav;
          }

          for (var i = 0; i < tabs.length; i++) {
            if (isTabPathValid(tabs[i], navItem, itemWithSecNav)) {
              secNavItemGroupPresent = true;
              selectedPanelPath = tabs[i].path;
              selectedPanelUnresolvedPath = tabs[i].unresolvedPath;
              selectedPanelParams = tabs[i].params;

              return secNavItemGroupPresent;
            }
          }
        }
      }

      function isTabPathValid(tab, navItem, itemWithSecNav) {
        if (navItem.unresolvedPath) {
          return tabPathHasNavItemParams(tab, navItem, itemWithSecNav);
        }
        return tab.path.indexOf(itemWithSecNav.path) > -1;
      }

      function tabPathHasNavItemParams(tab, navItem/* , itemWithSecNav*/) {
        var continueLooping = true;
        var unresolvedPath = navItem.unresolvedPath;
        var navPathUptoResolvedParam;
        var paramValue;

        while (continueLooping) {
          var paramStr = unresolvedPath.substring(unresolvedPath.indexOf(':') + 1);
          var param = paramStr.indexOf('/') > -1 ? paramStr.substring(0, paramStr.indexOf('/')) : paramStr;
          var remainingStr = paramStr.substring(param.length);
          paramValue = navItem.params[param];
          navPathUptoResolvedParam = unresolvedPath.substring(0, unresolvedPath.indexOf(':')) + paramValue;
          if (remainingStr.indexOf(':') > -1) {
            unresolvedPath = unresolvedPath.substring(0, unresolvedPath.indexOf(':')) + paramValue + remainingStr;
          } else {
            continueLooping = false;
          }
        }

        // check for the token length of navPathUptoResolvedParam and tab.path
        // if the length of tokens of navPathUptoResolvedParam is greater than tab.path length and navPathUptoResolvedParam begins with tab.path,
        // it means the current nav item to open is a child of the existing tab),
        // If the length of tokens is same, it means the current nav item to open is not a child of the existing tab
        // This check is needed for cases where the name of the new tab to open contains the name of the already open tab, for example Bank_of_Pune and Bank_of_Pune1
        var navPathUptoResolvedParamTokens = getTokensFromNavPath(navPathUptoResolvedParam);
        var tabPathTokens = getTokensFromNavPath(tab.path);
        var navPathContainsTabPath = false;
        if (navPathUptoResolvedParamTokens.length > tabPathTokens.length && navPathUptoResolvedParam.indexOf(tab.path) > -1) {
          navPathContainsTabPath = true;
        }

        return ((tab.path.indexOf(navPathUptoResolvedParam) > -1) && paramValue === tab.label) || navPathContainsTabPath;
      }

      function openInNewTab(navItem, event, parameters) {
        if (isFalse(event)) {
          openInSameTab(navItem, event, parameters);
        }

        if (navItem) {
          if (!isAlreadyInTabs(navItem)) {
            addNewTab(navItem);
          }

          setPathAndNavigateTo(navItem);
        }
      }
      // Expose opening in a new tab functionality so custom opening strategies may use it
      /**
       * @name _openInNewTab
       * @methodOf fisViewPanelService
       * @param {Object} Navigation Item to be opened
       * @param
       * @description
       * <p>Configures the provider with a View Panel Opening strategy that is then used by the <em>fisViewPanelService</em> to open
       * View Panels.</p>
       */
      service._openInNewTab = openInNewTab;

      function isAlreadyInTabs(navItem) {
        return tabs.some(function (tab) {
          return tab.path === navItem.path;
        });
      }

      function addNewTab(navItem) {
        tabs.push(new provider.ViewPanel(navItem, $filter));
        publishViewPanelOpened(navItem, getLastTab());
      }

      function publishViewPanelOpened(navItem, tab) {
        fisPubSubService.publish('fisViewPanelOpened', {
          path: navItem.path,
          viewPanel: tab
        });
      }

      function getFirstTab() {
        return tabs[0];
      }

      function getLastTab() {
        return tabs[tabs.length - 1];
      }

      function openInSameTab(navItem, event, parameters) {
        if (!isSecNavItemGroupOpen(navItem) && hasItemButNoTabsOrEvent(navItem, event)) {
          openInNewTab(navItem, event, parameters);
        } else if (hasItemAndTabs(navItem)) {
          if (!shouldOpenInSameTab(navItem)) {
            setPathAndNavigateTo(navItem, parameters);
          }
        }
      }
                // Expose opening in same tab functionality so custom opening strategies may use it
      service._openInSameTab = openInSameTab;

      function hasItemButNoTabsOrEvent(navItem, event) {
        return hasItemButNoTabs(navItem) || isTrue(event);
      }

      function hasItemButNoTabs(navItem) {
        return navItem && tabs.length === 0;
      }

      function hasItemAndTabs(navItem) {
        return navItem && tabs.length > 0;
      }

      function shouldOpenInSameTab(navItem, parameters) {
        var activeViewPanel = service.activeViewPanel();
        var isOpeningAction = false;

        if (isActiveAndNonCloseable(activeViewPanel, navItem)) {
          openInNewTab(navItem, parameters);
          isOpeningAction = true;
        } else if (shouldReplaceViewPanel(activeViewPanel, navItem, parameters)) {
          isOpeningAction = true;
        }

        return isOpeningAction;
      }

      function isActiveAndNonCloseable(activeViewPanel, navItem) {
        return activeViewPanel &&
                        service.isNonCloseable(activeViewPanel) &&
                        !getSecondaryNavParent(navItem.path);
      }

      function findCurrentlyOpenedTab(activeViewPanel) {
        if (!activeViewPanel) {
          return null;
        }

        var activeViewPanelIndex = null;

        tabs.forEach(function (tab, index) {
          if (activeViewPanel.path === tab.path) {
            activeViewPanelIndex = index;
          }
        });

        return activeViewPanelIndex;
      }

      function shouldReplaceViewPanel(activeViewPanel, navItem, parameters) {
        var navItemInTabs = isNavItemInTabs(navItem);
        var activeViewPanelIndex = findCurrentlyOpenedTab(activeViewPanel);

        if (activeViewPanel && !navItemInTabs) {
          replaceViewPanel(activeViewPanel, navItem, parameters, activeViewPanelIndex);

          return true;
        }
        return false;
      }

      function isNavItemInTabs(navItem) {
        return tabs.some(function (tab) {
          return tab.path === navItem.path;
        });
      }

      function replaceViewPanel(activeViewPanel, navItem, parameters, index) {
        var promise = publishViewPanelReplaceIntent(navItem, activeViewPanel);
        promise.then(function () {
          onViewPanelReplaceIntentSuccess(navItem, parameters, index);
        }, function () {
                        // publish an event if view panel replacement has been vetoed.
          fisPubSubService.publish('fisViewPanelReplaceVetoed', {
            navItem: navItem,
            viewPanel: activeViewPanel
          });
        });
      }

      function publishViewPanelReplaceIntent(navItem, activeViewPanel) {
        return fisPubSubService.publish('fisViewPanelReplaceIntent', {
          path: navItem.path,
          viewPanel: activeViewPanel
        });
      }

      function onViewPanelReplaceIntentSuccess(navItem, parameters, index) {
        var tab = tabs[index] = new provider.ViewPanel(navItem, $filter);

        publishViewPanelOpened(navItem.path, tab);
        publishViewReplaced(navItem);

        setPathAndNavigateTo(navItem);
      }

      function setPathAndNavigateTo(navItem) {
        selectedPanelPath = navItem.path;
        selectedPanelUnresolvedPath = navItem.unresolvedPath;
        selectedPanelParams = navItem.params;
        navigateTo(navItem);
      }

      function publishViewReplaced(navItem) {
        fisPubSubService.publish('fisViewPanelReplaced', { path: navItem.path });
      }

      function getUrlWithoutHash(url) {
        // Use the provided URL as the default value,
        // this will ensure a correct return value even
        // if it doesn't contain a trailing hash (anchor)
        var iPound = url.lastIndexOf('#');
        var iSlash = url.lastIndexOf('/');
        var noHash = url;

        // Only cut off the hash if the hash sign was
        // found after the last slash in the path.
        if (iPound > iSlash) {
          // Take everything before the hash sign
          noHash = url.substring(0, iPound);
        }

        return noHash;
      }

      function navigateTo(navItem) {
        // Give time to angular to complete it's $apply cycle and then update path
        // Reference - https://groups.google.com/d/msg/angular/FJwxJ-XbJaE/584zbwBjbU8J
        $timeout(function () {
          // Route change only occurs when $location.path changes
          // In some cases, we want the route to be refreshed even if the path doesn't change:
          // 1. The user clicks on a bookmark containing #/welcome for example. In this case,
          //    open is called with #/welcome but $location.path() is already #/welcome
          // 2. The navigation structure is changed with fisViewService.load and the current path is
          //    #/welcome and the new path to open is also #/welcome. In this case, the paths may be the
          //    same but they are referring to different views so we need to reload.
          // Note that fisViews will not drop the current view panel and reload the route's template:
          // it will notice the view panel is for the same route and will not do anything
          // since it only means the user is navigating to the same page again, in which case we don't
          // want the view to be reloaded.
          if ($location.path() === navItem.path) {
            $route.reload();
          } else {
            $location.path(navItem.path);
          }

          if (!changeLocationNavigationUnderway) { // eslint-disable-line
            /*
                This variable is explicitly set to true because it is checked while updating the view
                The '$locationChangeStart' event handler checks for this flag to be set to true, else it will
                prevent the location change.
                Since this function is called by the open method of framework, we want the $location to change
            */
            navigationUnderWay = true;
          } else {
            changeLocationNavigationUnderway = false;
          }
        }, 0);
      }

      function mdiFunction(navItem, event, parameters) {
        if (isFalse(event)) {
          openInSameTab(navItem, event, parameters);
        } else {
          openInNewTab(navItem, event, parameters);
        }
      }

      function browserFunction(navItem, event, parameters) {
        if (!event || (event && !event.ctrlKey && !event.metaKey)) {
          // to open child page in the current tab.
          openInSameTab(navItem, null, parameters);
        } else {
          // to open child page in new tab.
          openInNewTab(navItem, null, parameters);
        }
      }

      function isTrue(e) {
        return e === true || e === 'true';
      }

      function isFalse(e) {
        return e === false || e === 'false';
      }

      function resetLocationHash() {
        // This is done to avoid carrying over the anchor
        // location (hash, e.g. "#toc_3") to the new tab.

        // We might have to revisit this if we want to
        // support opening tabs and jumping to a
        // specific location at the same time.
        $location.hash('');
      }

      function getDefaultIfNoPath(navPath) {
        if (navPath === undefined) {
          return '';
        }
        return navPath;
      }

      function normalizeOpenArguments(args, event, params) {
        var localEvent = null;
        var localParams = {};

        if (args.length === 2) {
          localEvent = getValidatedEvent(args[1]);

          if (isStrategyOverride(event)) {
            localEvent = event;
          } else { // it's a params object, set it to localParams
            localParams = args[1];
          }
        } else if (args.length === 3) {
          localEvent = event;
          localParams = params;
        }

        return {
          localEvent: localEvent,
          localParams: localParams
        };
      }

      function getValidatedEvent(value) {
        if (isEvent(value)) {
          return value;
        }
        return null;
      }

      function isEvent(value) {
        return value && value.target;
      }

      function isStrategyOverride(value) {
        return value === 'true' || value === 'false' || value === true || value === false;
      }

      function checkIfTabIsAlreadyPresent(navPath, event, params) {
        var navItem = null;
        var tabFound = false;

        tabs.forEach(function (tab) {
          if (tab.path === navPath) {
            tabFound = true;
            navItem = tab;
            checkAndSetForSecondaryNavItem(tab, event, params);
          }
        });

        return {
          navItem: navItem,
          tabFound: tabFound
        };
      }

      function tryOpenViewBasedOnDefaultParams(navItem, navPath, tabFound, event, params, localParams) {
        if (isNavPathNotDefined(navPath, tabFound)) {
          navItem = openDefaultView(event, params);
        } else if (isRelativePath(navPath, tabFound)) {
          navItem = openRelativeView(navPath, event, params, localParams);
          if (navItem) {
            navPath = navItem.path;
          }
        } else if (isSecondaryNavigation(navPath, tabFound)) {
          navItem = openSecondaryView(navPath, event, params);
        }

        // When navItem has parameterized url, a copy of the navItem is created and processed. Hence, the
        // isStatic property is not set even if secondary navigation is present.
        // Hence, setting this property after all the processing is done
        if (navItem && getSecondaryNavParent(navItem.path) && navItem.partial) {
          navItem.isStatic = true;
        }

        return navItem;
      }

      function openDefaultView(event, params) {
        // TODO: default if no root tab.
        // Provide a way to configure default and open tabs if necessary?

        var navItem = getFirstTab();

        if (isNavItemDefined(navItem)) {
          checkAndSetForSecondaryNavItem(navItem, event, params);
          return navItem;
        }
        return null;
      }

      function isNavPathNotDefined(navPath, tabFound) {
        return !navPath && tabFound === false;
      }

      function isNavItemDefined(navItem) {
        return navItem && navItem.path;
      }

      function isRelativePath(navPath, tabFound) {
        return navPath &&
          navPath.indexOf('/') !== 0 &&
          tabFound === false;
      }

      function openRelativeView(navPath, event, params, localParams) {
        var navItemTemp = fisViewService.findNavItem(navPath, selectedPanelPath);
        var key;

        // if navItemTemp not found, look it up using selectedPanelUnresolvedPath
        if (!navItemTemp) {
          navItemTemp = fisViewService.findNavItem(navPath, selectedPanelUnresolvedPath);

          // add the selectedPanelParams to localParams for substitution.
          for (key in selectedPanelParams) {
            if (selectedPanelParams.hasOwnProperty(key)) {
              localParams[key] = selectedPanelParams[key];
            }
          }
        }

        // Add the selectedPanelParams to localParams for substitution in case navItemTemp is found.
        // In this case add the param only if localParams does not have the key
        if (navItemTemp) {
          for (key in selectedPanelParams) {
            if (selectedPanelParams.hasOwnProperty(key) && !localParams.hasOwnProperty(key)) {
              localParams[key] = selectedPanelParams[key];
            }
          }
        }

        if (navItemTemp && navItemTemp.params && Object.keys(localParams).length === 0) {
          localParams = navItemTemp.params;
        }

        // if no local params are defined, try to use params from the active view panel in this case; since the view to be opened is a relative view.
        if (angular.isUndefined(localParams) || localParams === null || Object.keys(localParams).length === 0) {
          if (service.activeViewPanel()) {
            localParams = service.activeViewPanel().params;
          }
        }

        // when a parent page is called from child page without giving any parameters, child page params are also added in localParams
        // we need to remove such extra params from localParams
        var navItem = null;
        if (navItemTemp) {
          localParams = removeExtraParamsFromLocalParams(navItemTemp.path, localParams);

          var path = substituteParams(navItemTemp.path, localParams);

          navItem = getNavItemForRelativePath(navItemTemp, path, localParams);
          navItem.unresolvedPath = navItemTemp.path;

          checkAndSetForSecondaryNavItem(navItem, event, params);
        }

        return navItem;
      }

      function getNavItemForRelativePath(navItem, path, localParams) {
        var newItem = {};

        angular.copy(navItem, newItem);

        newItem.path = path;
        newItem.label = $filter('interpolate')(newItem.label, localParams);
        newItem.params = localParams;

        return newItem;
      }

      function isSecondaryNavigation(navPath, tabFound) {
        return getSecondaryNavParent(navPath) && tabFound === false;
      }

      function openSecondaryView(navPath, event, params) {
        var navItem = fisViewService.findNavItem(navPath);

        // case of handling parameterized navigation item with secondary menu
        if (!navItem) {
          var relativeData = extractRelativeUrlData(navItem, navPath);
          params = relativeData.params;
          navItem = relativeData.navItem;
        }
        checkAndSetForSecondaryNavItem(navItem, event, params);
        if (navItem) {
          navItem.params = params;
        }
        return navItem;
      }

      function findNavItemIfNotDefined(navItem, navPath) {
        // TODO: should it instead just call navigation.navigate(navPath) and have tabs handled in view service?

        if (!isNavItemDefined(navItem)) {
          navItem = fisViewService.findNavItem(navPath, selectedPanelPath);
        }

        return navItem;
      }

      function extractRelativeUrlData(navItem, navPath) {
        var tempPath = navPath;
        var tokens = getTokensFromNavPath(navPath);
        var parameters = {};
        var tempNavPath = navPath;
        var parsedData = null;
        var hasMoreTokens = true;

        while (hasMoreTokens) {
          if (!hasPathToParse(tempNavPath)) {
            break;
          }

          tempPath = tempPath.substring(0, tempPath.lastIndexOf('/'));
          if (tempPath.length === 0) {
            break;
          }
          var tempNavItem = fisViewService.findNavItem(tempPath);

          if (tempNavItem) {
            var parsedDataCopy = angular.copy(parsedData);

            parsedData = findMatchedChildThroughNavPath({
              navItem: navItem,
              tokens: tokens,
              tempPath: tempPath,
              tempNavPath: tempNavPath,
              tempNavItem: tempNavItem,
              hasMoreTokens: true,
              parameters: parameters
            });

            if (parsedData && parsedDataCopy && parsedData.navItem && parsedDataCopy.navItem && parsedData.navItem.id === parsedDataCopy.navItem.id) {
              hasMoreTokens = false;
              return {
                params: null,
                navItem: null
              };
            }

            navItem = parsedData.navItem;
            tokens = parsedData.tokens;
            tempPath = parsedData.tempPath;
            tempNavPath = parsedData.tempNavPath;
            tempNavItem = parsedData.tempNavItem;
            parameters = parsedData.parameters;

            if (!parsedData.hasMoreTokens) {
              break;
            }
          } else if (noMoreItems(tempNavItem, tempPath)) {
            parsedData = findMatchedNoChild(navItem, parameters, tempPath, tempNavPath);

            navItem = parsedData.navItem;
            parameters = parsedData.parameters;

            break;
          }
        }

        var resolvedPath;
        // compute resolvedPath only for cases when navPath contains tempPath -- this is needed in case there is a parameterized url,
        // in which case, this navPath will have unresolved path (with ':' character), and tempPath will have resolved path with substituted parameters.
        if (navItem) {
          var navItemIdTokens = getTokensFromNavPath(navItem.id) || [];
          if (navPath.indexOf(tempPath) > -1 && navItemIdTokens.length > 2) {
            resolvedPath = navPath.substring(tempPath.length + 1);
          }
        }

        return {
          params: parameters,
          navItem: navItem,
          resolvedPath: resolvedPath
        };
      }

                // exposing this method since it is used internally by breadcrumb widget to extract relative data
      service._extractRelativeUrlData = extractRelativeUrlData;

      function noMoreItems(tempNavItem, tempPath) {
        return !tempNavItem && tempPath.lastIndexOf('/') === 0;
      }

      function hasSomeEquivalentParam(child, childPath) {
        var childPathWithoutParam = child.id;
        var withoutParamWord = childPathWithoutParam.substring(0, childPathWithoutParam.indexOf('/'));
        var originalWord = childPath.substring(0, childPath.indexOf('/'));
        return withoutParamWord === originalWord;
      }

      function getTokensFromNavPath(navPath) {
        var tokens = [];

        if (navPath && navPath.indexOf('/') > -1) {
          tokens = navPath.split('/');
        }

        return tokens;
      }

      function hasPathToParse(path) {
        return path && path.substring(0, path.lastIndexOf('/'));
      }

      function getChildTokens(childPath) {
        return childPath.split('/');
      }

      function getChildDataFromPath(child, childPath, tokensLength, tempPath, tempNavPath, hasMoreTokens) {
        var childData = {};
        var childTokens = getChildTokens(childPath);
        var itemTokens = child.path.split('/');

        childData.paramName = child.id.substring(child.id.indexOf(':') + 1);
        childData.paramVal = getParameterValue(child, childPath, childTokens);
        childData.navItem = angular.copy(child);

        if (tokensLength === itemTokens.length) {
          childData.hasMoreTokens = false;
          childData.tempPath = tempPath;
          childData.tempNavPath = tempNavPath;
        } else {
          childData.hasMoreTokens = hasMoreTokens;
                        // remove tokens already resolved
          spliceChildTokens(child, childTokens);
                        // Add to tempPath the resolved tokens and the unresolved tokens and start again :-)
          childData.tempPath = tempPath + '/' + child.id + '/' + childTokens.join('/');
          childData.tempNavPath = childData.tempPath; // start again - but with one token resolved
        }

        return childData;
      }

      function spliceChildTokens(child, childTokens) {
        if (child.id.indexOf(':') === 0) {
          childTokens.splice(0, 1);
        } else {
          childTokens.splice(0, 2);
        }
      }

      function findMatchedChildThroughNavPath(defaultData) {
        var childPath = defaultData.tempNavPath.substring(defaultData.tempPath.length + 1);
        var cont = true;

        while (cont) {
          if (!defaultData.tempNavItem.children) {
            break;
          }

          var parsedDataCopy = angular.copy(parsedData); // eslint-disable-line

          var parsedData = parseChildDataFrom({
            cont: cont,
            navItem: defaultData.navItem,
            childPath: childPath,
            tokens: defaultData.tokens,
            tempPath: defaultData.tempPath,
            tempNavPath: defaultData.tempNavPath,
            tempNavItem: defaultData.tempNavItem,
            hasMoreTokens: defaultData.hasMoreTokens,
            parameters: defaultData.parameters
          });

          if (parsedData && parsedDataCopy && parsedData.navItem && parsedDataCopy.navItem && parsedData.navItem.id === parsedDataCopy.navItem.id) {
            cont = false;
            return defaultData;
          }

          cont = parsedData.cont;
          childPath = parsedData.childPath;
          defaultData.navItem = parsedData.navItem;
          defaultData.tokens = parsedData.tokens;
          defaultData.tempPath = parsedData.tempPath;
          defaultData.tempNavPath = parsedData.tempNavPath;
          defaultData.tempNavItem = parsedData.tempNavItem;
          defaultData.hasMoreTokens = parsedData.hasMoreTokens;
          defaultData.parameters = parsedData.parameters;
        }

        return defaultData;
      }

      function findMatchedNoChild(_navItem, parameters, tempPath, tempNavPath) {
        var navItem = fisViewService.getItemFromPath2Item(tempPath);
        var navigationPanelParamValue = createUrlFillingParams(tempPath, tempNavPath);
        var paramNameString;
        if (navItem !== null) {
          paramNameString = findParamName(navItem);
        }

        parameters[paramNameString] = navigationPanelParamValue;

        return {
          navItem: navItem,
          parameters: parameters
        };
      }

      function createUrlFillingParams(tempPath, tempNavPath) {
        return tempNavPath.substring(tempPath.length + 1);
      }

      function findParamName(navItem) {
        return navItem.id.substring(navItem.id.indexOf(':') + 1);
      }

      function parseChildDataFrom(defaultData) {
        var i = 0;
        var child = null;
        var childData = null;

        for (i = 0; i < defaultData.tempNavItem.children.length; i++) {
          child = defaultData.tempNavItem.children[i];

          if (child && child.id.indexOf(':') !== -1) {
            var proceed = child.id.indexOf(':') === 0 ? true : hasSomeEquivalentParam(child, defaultData.childPath);
            if (proceed) {
              childData = getChildDataFromPath(
                              child,
                              defaultData.childPath,
                              defaultData.tokens.length,
                              defaultData.tempPath,
                              defaultData.tempNavPath,
                              defaultData.hasMoreTokens
                          );

              defaultData.cont = false;
              defaultData.navItem = childData.navItem;
              defaultData.hasMoreTokens = childData.hasMoreTokens;
              defaultData.tempPath = childData.tempPath;
              defaultData.tempNavPath = childData.tempNavPath;
              defaultData.parameters[childData.paramName] = childData.paramVal;

              break;
            }
          } else {
            for (var j = 0; j < defaultData.tokens.length; j++) {
              if (child.id === defaultData.tokens[j]) {
                var itemTokens = child.path.split('/');
                // commented below line otherwise it continously loops for the case mentioned in SDHTML-5237
                // defaultData.tempPath = defaultData.tempPath + '/' + child.path + '/';
                defaultData.tempNavPath = defaultData.tempPath;
                if (defaultData.tokens.length === itemTokens.length) {
                  defaultData.hasMoreTokens = false;
                  defaultData.cont = false;
                  defaultData.navItem = angular.copy(child);
                }
                break;
              }
            }
            defaultData.cont = false;
          }
        }
        return defaultData;
      }

      function getParameterValue(child, childPath, childTokens) {
        var paramVal;

        if (child.id.indexOf(':') === 0) {
          paramVal = childTokens[0];
        } else {
          paramVal = childTokens[1];
        }

        return paramVal;
      }

      function getParametersIfUndefined(parameters, params) {
        if (parameters === null && angular.isDefined(params)) {
          parameters = params;
        }

        return parameters;
      }

      function mergeParametersIfRequired(parameters, params) {
        if (parameters === null && angular.isDefined(params)) {
          parameters = params;
        } else if (angular.isDefined(params)) {
          $.extend(true, parameters, params);
        }

        return parameters;
      }

      function getNavItemCopyIfParams(navItem, parameters, resolvedPath) {
        if (parameters && navItem) {
          if (navItem instanceof provider.ViewPanel) {
            navItem = navItem.navItem;
          }
          // if it is a parameterized URL, substitue the params in the navItem's path
          navItem = angular.copy(navItem);
          if (!navItem.unresolvedPath) {
            navItem.unresolvedPath = navItem.path;
          }
          navItem.path = substituteParams(navItem.path, parameters);
          if (navItem.path && navItem.path.indexOf('/undefined/') > -1 && resolvedPath) {
            navItem = fisViewService.findNavItem(resolvedPath);
            navItem.path = substituteParams(navItem.path, navItem.params);
          }
          navItem.label = $filter('interpolate')(navItem.label, parameters);
          if (!resolvedPath) {
            navItem.params = parameters;
          }
        }

        return navItem;
      }

      function getPanelPath(navPath) {
        var panelPath = null;

        if (angular.isDefined(navPath)) {
          panelPath = navPath;
        } else {
          panelPath = service.activeViewPanel().path;
        }

        return panelPath;
      }

      function forceSelectionOfLastPanel(force) {
        if (hasNoSelectedPanelPathButTabs()) {
          if (force === undefined || force) {
            // TODO: is this needed? is it only used when closing a tab? could it be moved there?
            selectedPanelPath = getLastTab().path;
          } else {
            // no opened view panel (tab) available to select and we don't force selection.
            return null;
          }
        }
      }

      function hasNoSelectedPanelPathButTabs() {
        return !selectedPanelPath && tabs && tabs.length > 0;
      }

      function createParamsIfNotDefined(activeViewPanel) {
        if (activeViewPanel !== null) {
          if (angular.isUndefined(activeViewPanel.params) || activeViewPanel.params === null) {
            activeViewPanel.params = {}; // we create a new object
          } else if (angular.isUndefined(activeViewPanel.decodedParams) || activeViewPanel.decodedParams === null) {
            activeViewPanel.decodedParams = addDecodedParams(activeViewPanel.params);
          }
        }
      }

      function isSecondaryNavItemReplacingPrimary(item, isNonCloseable) {
        var primaryItem = getSecondaryNavParent(item.path);

        if (primaryItem === item) {
          return false;
        }
        if (primaryItem) {
          var stillOpenPrimaryItem = service.viewPanels().filter(function (panel) {
            return panel.path === primaryItem.path;
          });
          if (stillOpenPrimaryItem.length === 0) {
            // The parent is not open in another tab, the closability depends on the parents closability
            return service.isNonCloseable(primaryItem);
          }
          // The parent is open in another tab, thus we now may close this children tab
          return false;
        }

        return isNonCloseable;
      }

      function getDefaultViewPanelIfNotDefined(viewPanel, navPath) {
        if (!navPath) {
          viewPanel = service.activeViewPanel();
        }

        return viewPanel;
      }

      function getDefaultNavPathIfNotDefined(navPath) {
        if (!navPath) {
          navPath = service.activeViewPanel().path;
        }

        return navPath;
      }

      function getDataFromNavPath(viewPanel, navPath) {
        var tabIndexToRemove = null;

        if (navPath) {
          for (var i = 0; i < tabs.length; i++) {
            if (tabs[i].path === navPath) {
              tabIndexToRemove = i;
              break;
            }
          }

          if (tabIndexToRemove !== undefined) {
            viewPanel = tabs[tabIndexToRemove];
          }
        }

        return {
          viewPanel: viewPanel,
          tabIndexToRemove: tabIndexToRemove
        };
      }

      function closeViewPanel(viewPanel, navPath, tabIndexToRemove) {
        var tabToFocus = null;
        var deferred = $q.defer();

        if (viewPanel) {
          viewPanel.$isClosing = true;

          var promise = publishViewPanelCloseIntent(viewPanel, navPath);

          promise
            .then(function () {
              // handle the case where another close call has been made before the current one ends
              viewPanel = getDefaultViewPanelIfNotDefined(viewPanel, navPath);
              navPath = getDefaultNavPathIfNotDefined(navPath);

              tabToFocus = getTabFocusFromNavPath(navPath);
              tabIndexToRemove = getTabIndexToRemove(tabIndexToRemove, navPath);

              removeTabByIndex(viewPanel, navPath, tabIndexToRemove, tabToFocus);

              deferred.resolve();
            },
            function () {
              deferred.reject('Pos 3');
            })
            .finally(function () {
              // Had to use $timeout to wrap the publish call. Promises seems to behave in synchronous manner when
              // resolved with non-promise values (returned by $q.when in fisPubSubService.publish code). Therefore
              // when fisViewPanelCloseIntent is published, promise.then and promise.always is called immediately called
              // and the fis-views directive doesn't get a chance to react to viewPanel.$isClosing change and add
              // a loading indicator.
              $timeout(function () {
                viewPanel.$isClosing = false;
              }, 0);
            });
        } else {
          // The navPath was not open or invalid, so resolve it right away - there's nothing to close.
          deferred.resolve();
        }

        return deferred.promise;
      }

      function getTabFocusFromNavPath(navPath) {
        var tabToFocus = null;

        if (navPath !== selectedPanelPath) {
          tabToFocus = selectedPanelPath;
        }

        return tabToFocus;
      }

      function getTabIndexToRemove(tabIndexToRemove, navPath) {
        for (var i = 0; i < tabs.length; i++) {
          if (tabs[i].path === navPath) {
            tabIndexToRemove = i;
            break;
          }
        }

        return tabIndexToRemove;
      }

      function openDefaultEmptyView() {
        $location.path('');
        navigationUnderWay = true;
      }

      function openLastTab() {
                    // TODO: open last activated from a stack
        var params = getLastTab() ? getLastTab().params : null;
        service.open(getLastTab().path, null, params);
      }

      function removeViewPanel(tabIndexToRemove) {
        tabs.splice(tabIndexToRemove, 1);
      }

      function openViewAfterClose(tabToFocus) {
        if (tabs.length === 0) {
          openDefaultEmptyView();
        } else if (tabs.length > 0 && tabToFocus === null) {
          openLastTab();
        }
      }

      function copyClosingPanel(viewPanel) {
                    // create a copy of the closed view panel but without any functions
                    // or properties starting with '$' as we do not want the subscriber to modify the
                    // closed view panel
        var viewPanelCopy = {};
        Object.keys(viewPanel).forEach(function (key) {
          if (!key.match(/^\$/)) {
            var value = viewPanel[key];
            if (!angular.isFunction(value)) {
              viewPanelCopy[key] = value;
            }
          }
        });
        return viewPanelCopy;
      }

      function removeTabByIndex(viewPanel, navPath, tabIndexToRemove, tabToFocus) {
        if (tabIndexToRemove !== null) {
          removeViewPanel(tabIndexToRemove);

          openViewAfterClose(tabToFocus);

          viewPanel = copyClosingPanel(viewPanel);

          publishViewPanelClosed(viewPanel, navPath);
        }
      }

      function publishViewPanelCloseIntent(viewPanel, navPath) {
        return fisPubSubService.publish('fisViewPanelCloseIntent', {
          path: navPath,
          viewPanel: viewPanel
        });
      }

      function publishViewPanelClosed(viewPanel, navPath) {
        return fisPubSubService.publish('fisViewPanelClosed', {
          path: navPath,
          viewPanel: viewPanel
        });
      }

      /**
       * @name open
       * @methodOf fisViewPanelService
       * @param {string} navPath Navigation Path to open. Undefined or empty string will load the default view.
       * @param {Object} [event] Optional triggering event (For example, click), can be 'true' or 'false' :
       *         True means we want to force opening in a new tab (and bypass the strategy) and false means we force opening in the same tab.
       * @param {Object} [params] Optional Additional parameters
       * @description Opens a ViewPanel using the configured strategy (or framework defaults 'mdi' strategy if none is configured.)
       */
      service.open = function (_navPath, event, params) {
        // Hash must be removed when moving between pages (no event is fired when pages are loaded from a bookmark,
        // an event is defined when navigating the menu or moving between tabs.
        if (angular.isDefined(event)) {
          resetLocationHash();
        }
        var relativeData = null;
        var parameters = null;
        var navPath = getDefaultIfNoPath(_navPath);
        var normalized = normalizeOpenArguments(arguments, event, params);
        var localEvent = normalized.localEvent;
        var localParams = normalized.localParams;
        var previousViewPanel = service.activeViewPanel(false);
        var presentData = checkIfTabIsAlreadyPresent(navPath, event, params);
        var navItem = presentData.navItem;
        var tabFound = presentData.tabFound;
        var navItemExist = false;
        navigationUnderWay = true;
        var resolvedPath;

        navItem = tryOpenViewBasedOnDefaultParams(navItem, navPath, tabFound, event, params, localParams);

        navItem = findNavItemIfNotDefined(navItem, navPath);

        if ((DEFAULT_OPEN_STRAT === provider.getViewOpeningStrategy()) && angular.isDefined(event)) {
          if (event && event.shiftKey && event.shiftKey === true) {
            if (angular.isDefined(navItem)) {
                                /* The original code, which only checks whether the "last" item in the array matches in the path property:
                                _.each(tabs,function(tab){
                                    navItemExist = tab.path === navItem.path;
                                });
                                 During the removal of underscore, the code has been adjusted
                                 */
              navItemExist = tabs.some(function (tab) {
                return tab.path === navItem.path;
              });
              if (navItemExist === false) {
                tabs.push(new provider.ViewPanel(navItem, $filter));
                return;
              }
            }
          }
        }

                    // if navItem not found, check for possibility of the navPath having relative url.
        if (hasNoItemButTabs(navItem)) {
          relativeData = extractRelativeUrlData(navItem, navPath);

          parameters = relativeData.params;
          navItem = relativeData.navItem;
          resolvedPath = relativeData.resolvedPath;
        }

        parameters = getParametersIfUndefined(parameters, params);

        navItem = getNavItemCopyIfParams(navItem, parameters, resolvedPath);

        if (navItem !== undefined && navItem !== null && navItem.parentTitle !== undefined) {
          navItem.isStatic = true;
        }

        validateNavItem(navItem, navPath);

        if (angular.isDefined(navItem) && angular.isUndefined(navItem.partial)) {
          if (fisConfig.widgets && fisConfig.widgets.fisTabsBar) {
            var openFirstChildIfEmpty = fisConfig.widgets.fisTabsBar.openFirstChildIfEmpty;

            if (angular.isUndefined(openFirstChildIfEmpty) || openFirstChildIfEmpty) {
              var firstChildWithPartial = findFirstChildWithPartial(navItem);

              if (firstChildWithPartial !== null) {
                $timeout(function () {
                  service.open(firstChildWithPartial.path, event, params);
                  fisPubSubService.publish('fisFirstSecondaryItemOpened');
                });
              }
            }
          }
        }

        if (!getSecondaryNavParent(navPath)) {
          callRelevantStrategy(navItem, localEvent, localParams);
        }

        // Passing the event object through here allows listeners of this to determine the origin of the open
        // e.g. was it a mega menu link or a tabbar link?
        publishViewPanelChange(navItem, previousViewPanel, event);

        if (navItem !== undefined && (navItem.closeable === true || navItem.closeable === 'true' || navItem.closeable === undefined)) {
                        // broadcast on the rootscope, so other external modules can listen for this
          $rootScope.$broadcast('fisTabOpened', { path: _navPath });
        }

        $timeout(function () {
          navigationUnderWay = false;
        });
      };

      function findFirstChildWithPartial(navItem) {
        if (angular.isDefined(navItem.children) && navItem.children.length > 0) {
          if (angular.isUndefined(navItem.children[0].partial)) {
            return findFirstChildWithPartial(navItem.children[0]);
          }
          return navItem.children[0];
        }
        return null;
      }

      /**
       * @name viewPanels
       * @methodOf fisViewPanelService
       * @returns {Array} Open ViewPanels
       * @description Returns array of open view panels
       */
      service.viewPanels = function () {
        return tabs;
      };

      /**
       * @name viewPanelByPath
       * @methodOf fisViewPanelService
       * @param {String} Navigation Path of the open View Panel
       * @returns {Object} View Panel for the navigation path passed in
       * @description Returns the view panel corresponding to the given nav path
       */
      service.viewPanelByPath = function (navPath) {
        var viewPanel;

        for (var i = 0; i < tabs.length; i++) {
          if (tabs[i].path === navPath) {
            viewPanel = tabs[i];

            break;
          }
        }

        return viewPanel;
      };

      /**
       * @name reloadActiveViewPanel
       * @methodOf fisViewPanelService
       * @param {String} Navigation Path of the panel that needs to be reloaded - optional, if not provided, then the current active panel is used
       * @description Reloads the current active panel
       */
      service.reloadActiveViewPanel = function (navPath, params) {
        var panelPath = getPanelPath(navPath);
        var parameters = null;

        for (var j = 0; j < tabs.length; j++) {
          if (tabs[j].path === panelPath) {
            var navItem = fisViewService.findNavItem(panelPath);
            // handling parameterized navigation item with resolved path
            if (!navItem) {
              var relativeData = extractRelativeUrlData(navItem, panelPath);
              navItem = relativeData.navItem;
              parameters = relativeData.params;
            } else if (angular.isUndefined(params) || params.length === 0) {
                // if params are undefined, try to use params from the active view panel in this case; since the view to be opened is a relative view.
              parameters = service.activeViewPanel().params;
            }

            parameters = mergeParametersIfRequired(parameters, params);
            navItem = getNavItemCopyIfParams(navItem, parameters);
            // Replace ViewPanel - ng-repeat will detect change and destroy DOM (div and scope)
            tabs[j] = new provider.ViewPanel(navItem, $filter);

            service.open(panelPath, null, parameters);

            break;
          }
        }
      };

                /**
                 * @name activeViewPanel
                 * @methodOf fisViewPanelService
                 * @returns {Object} Active View Panel
                 * @description Returns the active View Panel. This will always return an activeViewPanel
                 *      if there are opened view panels because it will select one.
                 * @param force undefined or a truthy value will force selection of the last tab.
                 */
      service.activeViewPanel = function (force) {
        var activeViewPanel = null;

        forceSelectionOfLastPanel(force);

        for (var i = 0; i < tabs.length; i++) {
          if (tabs[i].path === selectedPanelPath) {
            activeViewPanel = tabs[i];

            break;
          }
        }

        createParamsIfNotDefined(activeViewPanel);

        return activeViewPanel;
      };

      /**
       * @name activeViewPanelIndex
       * @methodOf fisViewPanelService
       * @returns {int} Active View Panel index
       * @description Returns the active View Panel index
       */
      service.activeViewPanelIndex = function () {
        for (var i = 0; i < tabs.length; i++) {
          if (tabs[i].path === selectedPanelPath) {
            return i;
          }
        }

        return -1;
      };

      /**
       * @name viewPanelParams
       * @methodOf fisViewPanelService
       * @returns {Object} params for active view panel
       * @description Returns the params for active View Panel
       */
      service.viewPanelParams = function () {
        var params = {};

        if (service.activeViewPanel()) {
          params = service.activeViewPanel().params;
        }

        return params;
      };

      /**
       * @name selectedViewPanelPath
       * @methodOf fisViewPanelService
       * @returns {String} Active View Panel path
       * @description Returns the active View Panel path
       */
      service.selectedViewPanelPath = function (path) {
        if (arguments.length === 0) {
          return selectedPanelPath;
        }
        service.selectedPanelPath = path;
        service.open(path);
      };

      /**
       * @name resetSelectedViewPanelPath
       * @methodOf fisViewPanelService
       * @description Removes the selected panel path reference
       */
      service.resetSelectedViewPanelPath = function () {
        selectedPanelPath = undefined;
      };

      /**
       * @name isNonCloseable
       * @methodOf fisViewPanelService
       * @param {Object} item View Panel
       * @returns {boolean} true if the View Panel is non-closeable else false
       * @description Returns if a View Panel is closeable or not. View Panels corresponding to top level
       * Navigation Items that have partials attached to them are considered non-closeable.
       */
      service.isNonCloseable = function (item) {
        var isNonCloseable = false;

        if (isNavItemDefined(item)) {
          if (angular.isDefined(item.closeable)) {
            isNonCloseable = !item.closeable;
          }

          var parent = getItemParentRefIfValid(item);

          if (parent !== item) {
            isNonCloseable = isSecondaryNavItemReplacingPrimary(item, isNonCloseable);
          }

          if (isNavItemDefined(item) && hasDropdownSecondaryMenu(item)) {
            isNonCloseable = true;
          }
        }

        return isNonCloseable;
      };

      /**
       * @name close
       * @methodOf fisViewPanelService
       * @param {String} _navPath Path corresponding to a View Panel
       * @description Closes a View Panel associated to the nav Path
       */
      service.close = function (_navPath) {
        var viewPanel = getDefaultViewPanelIfNotDefined(null, _navPath);
        var navPath = getDefaultNavPathIfNotDefined(_navPath);
        var navPathData = getDataFromNavPath(viewPanel, navPath);
        var tabIndexToRemove = navPathData.tabIndexToRemove;

        viewPanel = navPathData.viewPanel;

        // broadcast on the rootscope, so other external modules can listen for this
        $rootScope.$broadcast('fisTabClosed', { path: _navPath });

        return closeViewPanel(viewPanel, navPath, tabIndexToRemove);
      };

      function findScopeForEvaluation(context, element) {
        // check if the context is a scope (that's the case when the service function is invoked from an angular expression)
        if (context.$eval) {
          // it quacks like one
          return context;
        }

        // no luck try with the element, if present
        if (element && element.scope) {
          return element.scope();
        }

        throw new Error('Cannot find a scope to evaluate expression in.');
      }

      function findElementFromEvent(event) {
        return angular.isObject(event) &&
                        angular.isDefined(event.target) &&
                        angular.element(event.target);
      }

      function processActionView(context, viewDef, event, params) {
        var locals;
        var ret;
        var destroyScope = false;
        var element = findElementFromEvent(event);
        var evalScope = findScopeForEvaluation(context, element);

        if (angular.isObject(params)) {
          locals = angular.copy(params);
        } else {
          locals = {};
        }

        locals.view = viewDef;
        locals.$scope = evalScope;

        if (angular.isString(viewDef.actionController)) {
          // create a new child scope on which to attach the controller
          locals.$scope = evalScope = evalScope.$new();
          locals.$element = element;
          $controller(viewDef.actionController, locals);
          destroyScope = true;
        }

        // elements can't be referenced in angualr expressions
        delete locals.$element;
        // event put in locals only for the expression evaluation
        locals.$event = event;

        ret = evalScope.$eval(viewDef.action, locals);

        if (destroyScope) {
          evalScope.$destroy();
        }

        return ret;
      }

      service.openView = function (viewDef, event, params) {
        var context = this;

        if (viewDef.action) {
          return processActionView(context, viewDef, event, params);
        } else if (viewDef.path) {
          return service.open.call(context, viewDef.path, event, params);
        } else if (angular.isString(viewDef)) {
          return service.open.call(context, viewDef, event, params);
        }

        throw new Error('Cannot open provided view definition object');
      };

      /* service.setNavigationComplete = function() {
          $timeout (function () {
              navigationUnderWay = false;
          });
      };*/

      var activePanel;

      fisPubSubService.subscribe('fisBeforeNavItemAdd', function () {
        activePanel = service.activeViewPanel();
      });

      fisPubSubService.subscribe('fisAfterNavItemAdd', function (params) {
        if (params.rootNav === 'main' && params.itemToAdd.partial) {
          tabs.push(new provider.ViewPanel(params.itemToAdd, $filter));
        }
        if (params.openItemAfterAdd) {
          service.open(params.itemToAdd.path, null, params.openParams);
        } else {
          service.open(activePanel.path, null, params.openParams);
        }
        fisPubSubService.publish('fisAfterNavItemAdded');
      });

      fisPubSubService.subscribe('fisBeforeNavItemRemove', function () {
        activePanel = service.activeViewPanel();
      });

      fisPubSubService.subscribe('fisAfterNavItemRemove', function (params) {
        var tabToClose = null;
        var secondaryNavParent;

        for (var i = 0; i < tabs.length; i++) {
          if (tabs[i].id === params.itemToRemove.id) {
            tabToClose = tabs[i];
            break;
          }
        }
        if (!params.openParentNode && tabToClose) {
          service.close(tabToClose.path);
        }

        // see if the item to be removed is part of the currently open secondary menu bar
        // if it is, the secondary menu bar should refresh irrespective of the openParentNode param value
        if (params.itemToRemove.id !== service.activeViewPanel().id &&
                        service.activeViewPanel() && (service.activeViewPanel().unresolvedPath || service.activeViewPanel().path)) {
          var activePanelPath = service.activeViewPanel().unresolvedPath ? service.activeViewPanel().unresolvedPath : service.activeViewPanel().path;
          secondaryNavParent = getSecondaryNavParent(params.itemToRemove.path);
          var secondaryNavParentForActiveTab = getSecondaryNavParent(activePanelPath);
          if (secondaryNavParent && secondaryNavParentForActiveTab && secondaryNavParent.path === secondaryNavParentForActiveTab.path) {
            if (tabToClose) {
              service.close(tabToClose.path);
            }
            service.open(service.activeViewPanel().path, null, params.openParams);
          }
        }

        if (params.openParentNode && params.parentItem && params.parentItem.partial) {
          service.open(params.parentItem.path, null, params.openParams);
        } else if (params.openParentNode && params.parentItem && !params.parentItem.partial) {
          secondaryNavParent = getSecondaryNavParent(params.itemToRemove.path);
          if (secondaryNavParent) {
            service.open(secondaryNavParent.path, null, params.openParams);
          } else if (tabToClose) {
            service.close(tabToClose.path);
          }
        }

        fisPubSubService.publish('fisAfterNavItemRemoved');
      });

      init();

      return service;
    }
  ];
}
