export default function () {
  'use strict';
  var self = this;
  var NOT_FOUND = '__NOT_FOUND__';

  var defaultLocale = 'en';
  self.setDefaultLocale = function (locale) {
    defaultLocale = locale;
  };

  self.$get = ['$rootScope', '$http', '$q', '$location', 'fisPubSubService', 'fisConfig', '$translate',
    function ($rootScope, $http, $q, $location, fisPubSubService, conf, $translate) {
      var serv = {};

      var supportedLanguagesDeferred = $q.defer();
      serv.supportedLanguages = supportedLanguagesDeferred.promise;

      /**
       * @name defaultLocale
       * @description Getter function to access the framework default locale
       * @return the default framework locale
       * @methodOf angular.module('fis.core').fisI18nService
       */
      serv.defaultLocale = function () {
        return defaultLocale;
      };

      var cancelTranslateLoadingSuccess = $rootScope.$on('$translateLoadingSuccess', function () {
        fisPubSubService.publish('shell.i18nReady');
        cancelTranslateLoadingSuccess();
      });

      /**
       * @name locale
       * @description Getter/setter function to access the current locale
       *  @param [locale] The locale string to be set (optional).
       *  @return the current locale
       *  @methodOf angular.module('fis.core').fisI18nService
       */
      serv.locale = function (locale) {
        if (locale) {
          // only way to only request a single language is to
          $translate.use(locale);
          $http.defaults.headers.common['Accept-Language'] = locale;
          fisPubSubService.publish('fisLocaleChanged', locale);
        }

        return locale || $translate.proposedLanguage();
      };

      serv.isTranslationReady = function () {
        if ($translate.isReady() && $translate.getTranslationTable($translate.proposedLanguage()) !== null) {
          return true;
        }
        return false;
      };

      function processLocaleConfiguration(defaultLang) {
        var initLang = $location.search().lang || serv.defaultLocale();
        if (initLang !== defaultLang && conf.supportedLanguages) {
          // First check for actual language code like "de-CH" from supported language list
          var foundLang;
          conf.supportedLanguages.some(function (language) {
            if (angular.equals(language.value, defaultLang)) {
              foundLang = language;
              return true;
            }
            return false;
          });
          // if not found then check for a fallback standard language code
          // like "de" from supported language list
          if (angular.isUndefined(foundLang)) {
            var standardLangCode = defaultLang.split('-');
            conf.supportedLanguages.some(function (language) {
              if (angular.equals(language.value, standardLangCode[0])) {
                foundLang = language;
                return true;
              }
              return false;
            });
          }
          if (angular.isDefined(foundLang)) {
            initLang = (foundLang.value) ? foundLang.value : initLang;
          }
        }

        $http.defaults.headers.common['Accept-Language'] = initLang;

        $translate.use(initLang);

        // only invoked once on load of the page (once config is loaded)
        fisPubSubService.publish('fisLocaleSet', initLang);

        supportedLanguagesDeferred.resolve(conf.supportedLanguages);
        // Put the $location in the rootScope so that we can watch it
        $rootScope.location = $location;

        // put a watch on the lang request parameter and change the locale according to that parameter
        $rootScope.$watch('location.search().lang', function (lang) {
          if (lang && lang !== serv.locale()) {
            serv.locale(lang);
            // FIXME: removing the lang param because it screws up routes.
            $rootScope.location.search('lang', null);
          }
        });
      }
      processLocaleConfiguration(fetchLocaleFromConfig());
      // return config locale or fetch locale from browser
      function fetchLocale() {
        if (angular.isDefined(conf.locale)) {
          return conf.locale;
        }
        return findBestDefaultLanguage();
      }

      // Retrieve locale as per configuration provided by user
      function fetchLocaleFromConfig() {
        var defaultLang = serv.defaultLocale();
        if (angular.isDefined(conf.preferredLocale)) {
          if (conf.preferredLocale === 'browser') {
            defaultLang = findBestDefaultLanguage();
          } else {
            defaultLang = fetchLocale();
          }
        } else {
          defaultLang = fetchLocale();
        }
        return defaultLang;
      }

      // find the closest language we can from what is sent through the "Accept-Language" header.
      // After invocation of processLocaleConfiguration, we set the Accept-Language headers.
      // Therefore, the config service's request is made using the browser's Accept-Language so the
      // server can also return the language it receives.
      function findBestDefaultLanguage() {
        // Chrome and Firefox return the Accept-Language languages with navigator.languages.
        // Not supported in other browsers
        if (window.navigator.languages) {
          return window.navigator.languages[0];
        }

        // Most supported. Returns Accept-Language on older firefox and OS language on IE 11
        if (window.navigator.language) {
          return window.navigator.language;
        }

        // IE specific property. Returns the operating system's natural language setting.
        // http://msdn.microsoft.com/en-us/library/ie/ms535867(v=vs.85).aspx
        if (window.navigator.userLanguage) {
          return window.navigator.userLanguage;
        }

        // all supported browsers should have returned already
        return 'en';
      }

      // This function is used to get the translated values for the specified keys
      function getTranslatedValues(keysToTranslate, def, key, translations, translation) {
        for (var i = 0; i < keysToTranslate.length; i++) {
          // $translate.instant removes white spaces from string so compare trimmed value here as well
          if (translations[keysToTranslate[i]] !== keysToTranslate[i].trim()) {
            translation = translations[keysToTranslate[i]];
            break;
          }
        }
        return translation === NOT_FOUND ? (def === null || def === undefined) && key.join('.') || def : translation;
      }

      // This function returns the keysToTranslate array
      function getKeysToTranslate(key) {
        if (angular.isArray(key)) {
          var ns = angular.copy(key);
          var keysToTranslate = [];
          while (ns.length > 0) {
            if (ns[0]) {
              keysToTranslate.push(ns.join('.'));
            }
            ns.shift();
          }
          return keysToTranslate;
        }
      }

      /**
       * @name translate
       * @description provides a translation for the provided key
       * @param {string|string[]} key The key to be translated. If an array, the service will try from the most significant (all elements joined to form a key) to the least significant (only the last element is used as the key)
       * @param {string} [def] The default string to use if no translations are available
       * @return The translated text if found, the default string provided or the key itself if nothing else can be returned
       * @methodOf angular.module('fis.core').fisI18nService
       */

      // using $translate.instant
      serv.translate = function (key, def) {
        var translation = NOT_FOUND;
        if (angular.isString(key)) {
          key = key.split('.');
        }
        if (angular.isArray(key)) {
          var keysToTranslate = getKeysToTranslate(key);
          var translations = $translate.instant(keysToTranslate);
          return getTranslatedValues(keysToTranslate, def, key, translations, translation);
        }
        return (def || key);
      };

      /**
       * @name translateAsync
       * @description provides a translation for the provided key when translation data is not yet loaded
       * @param {string|string[]} key The key to be translated. If an array, the service will try from the most significant (all elements joined to form a key) to the least significant (only the last element is used as the key)
       * @param {string} [def] The default string to use if no translations are available
       * @return Promise which will get resolved to the translated text if found, the default string provided or the key itself if nothing else can be returned
       * @methodOf angular.module('fis.core').fisI18nService
       */
      serv.translateAsync = function (key, def) {
        var translation = NOT_FOUND;
        var translations;
        var asyncTranslation = $q.defer();
        if (angular.isString(key)) {
          key = key.split('.');
        }
        var keysToTranslate = getKeysToTranslate(key);
        // We have subscribed to '$translateChangeSuccess' event published by angular.translate module.
        // Once the translation object is available, we will resolve the promise for UI translation of data.
        var cancelTranslateChangeSuccess = $rootScope.$on('$translateChangeSuccess', function () {
          translations = $translate.instant(keysToTranslate);
          var result = getTranslatedValues(keysToTranslate, def, key, translations, translation);
          asyncTranslation.resolve(result);
          // un-registering '$translateChangeSuccess' event handler
          cancelTranslateChangeSuccess();
        });
        return asyncTranslation.promise;
      };
      return serv;
    }];
}
