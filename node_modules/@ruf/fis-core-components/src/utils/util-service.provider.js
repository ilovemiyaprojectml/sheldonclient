/**
 * @class
 * @name fisUtilService
 * @description fisUtilService will be used for abstracting functionality that will break unit tests, i.e. phantomJS - see calculateContainerWidth
 * @memberOf fis.core
 */
export default function () {
  var self = this;

  self.$get = [function () {
    var service = {};

            /**
             *@name calculateContainerWidth
             *@param {Object} currentTabstrip.
             *
             *@description Returns the width of the Div containing the tabstrip.
             * The extra width ensures there is always some space on the tabstrip.
             * This method is in fisUtilService because it breaks the unit tests - uses jQuery to calculate the width of component on screen
             * which is a problem for phantomJS which is headless
             *
             */
    service.calculateContainerWidth = function (component) {
      return parseFloat(component.width());
    };

    function queryStringToObject(queryString) {
      var ret = {};
      var queryPairs;

      if (angular.isString(queryString)) {
        queryPairs = queryString.split('&');
      } else if (angular.isObject(queryPairs)) {
        queryPairs = queryString;
      }

      queryPairs.forEach(function (queryElem) {
        var elemParts = queryElem.split('=');
        ret[elemParts[0]] = elemParts[1];
      });
      return ret;
    }

    function objectToQueryString(object) {
      var str = '';
      Object.keys(object).forEach(function (key) {
        var val = object[key];
        if (val !== null) {
          str += (key + '=');
          if (angular.isDefined(val)) {
            str += val;
          }
          str += '&';
        }
      });
      return str.slice(0, -1);
    }

    /**
     * Append custom parameters to a given URL. Already existing parameters will be overridden.
     * Set the value of key to null to remove it from the url. Keeps existing anchors in the URL.
     * @param url {String} The URL the parameters should be appended to.
     * @param params {string|object} Object holding key-value pairs of parameters or query string in format "key=value" separated by &
     * @returns {String} url enhanced by the parameters
     */
    service.appendQueryParameters = function (url, params) {
      var pathString = url.match(/^([^?#]*)/i);
      var queryString = url.match(/\?([^#]*)/i);
      var anchorString = url.match(/(#.*)$/i);

                // Set to empty String of no matches found, otherwise use the first (and hopefully only) match
      pathString = pathString === null ? '' : pathString[1];
      anchorString = anchorString === null ? '' : anchorString[1];

      var queryObject = {};

      if (queryString !== null) {
        queryObject = queryStringToObject(queryString[1]);
      }
      if (angular.isString(params)) {
        params = queryStringToObject(params);
      }
      var mergedQueryString = objectToQueryString(angular.extend(queryObject, params));
      if (mergedQueryString !== '') {
        pathString += '?';
      }
      return pathString + mergedQueryString + anchorString;
    };

    /**
     * Append version and appStage parameters to a given URL
     * @param url The URL the parameters should be appended to
     * @param customVersion {String} optional Override the version value
     * @returns {String} url with the cache query parameters added
     */
    service.appendCacheQueryParameter = function (url, customVersion) {
      var cacheQueryObject = fis.getCacheQuery();
      if (angular.isDefined(customVersion)) {
                    // Clone the object to not change the version setting
        cacheQueryObject = angular.extend({}, cacheQueryObject);
        cacheQueryObject.version = customVersion;
      }
      return service.appendQueryParameters(url, cacheQueryObject);
    };

    /**
     * Extract data from complex JSON for nested path (multi level)
     * @param schema JSON path
     * @param data JSON response
     * @returns extracted data from JSON response
     */
    service.extractData = function (schema, data) {
      var results;
      var temp = angular.copy(data);
      var tokens = schema.split(/\.|(\(\))|(\[\d+?])/).filter(function (t) {
        return t;
      });
      if (tokens.length === 1) {
        results = temp[schema];
      } else {
        var isTokenArrayAccess = /^\[\d+\]$/;
        for (var i = 0; i < tokens.length; i++) {
          var extractValue;
          if (isTokenArrayAccess.test(tokens[i])) {
            extractValue = temp[parseInt(tokens[i].substr(1), 10)];
          } else {
            extractValue = temp[tokens[i]];
          }
          if (angular.isDefined(extractValue)) {
            temp = extractValue;
            results = temp;
          }
        }
      }
      return results;
    };

    /*
    * This function does a proper boolean check and is necessary anywhere
    * that an angular directive is pulling in an attribute that is meant
    * to be a boolean. Sometimes the value coming in will be a string,
    * so the shortcut ways of checking boolean state don't work.
    */
    service.booleanCheck = function (actualValue, defaultValue) {
      if (actualValue === undefined || actualValue === null) {
        // no value specified, so resort to default value
        return defaultValue;
      } else if (typeof actualValue === 'boolean') {
        // specific check to make sure its boolean
        return actualValue;
      }
      var lowercase = actualValue.toLowerCase();
        // we have to be specific here, otherwise use the default
      if (lowercase === 'true') {
        return true;
      } else if (lowercase === 'false') {
        return false;
      }
      return defaultValue;
    };

    /**
     * Checks whether a given value is NaN.
     * This is not the same as the native isNaN function, which will
     * also return true for many other not-number values, such as undefined.
     *
     * @param value
     * @returns {boolean}
     */
    service.isNaN = function (value) {
      return toString.call(value) === '[object Number]' && value !== Number(value);
    };

    return service;
  }];
}
