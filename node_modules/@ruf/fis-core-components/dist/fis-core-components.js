/*!
 * 
 * @ruf/fis-core-components
 * Version: 4.5.1
 * 
 * © 2018
 * Fidelity National Information Services, Inc. and/or its subsidiaries - All Rights Reserved worldwide.
 * This document is protected under the trade secret and copyright laws as the property of Fidelity National Information Services, Inc. and/or its subsidiaries.
 * Copying, reproduction or distribution should be limited and only to employees with a “need to know” to do their job. Any disclosure of this document to third parties is strictly prohibited.
 * 
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(/*! jquery */ 1);
	
	__webpack_require__(/*! angular */ 2);
	
	var _angularSanitize = __webpack_require__(/*! angular-sanitize */ 3);
	
	var _angularSanitize2 = _interopRequireDefault(_angularSanitize);
	
	var _angularResource = __webpack_require__(/*! angular-resource */ 4);
	
	var _angularResource2 = _interopRequireDefault(_angularResource);
	
	var _angularAnimate = __webpack_require__(/*! angular-animate */ 5);
	
	var _angularAnimate2 = _interopRequireDefault(_angularAnimate);
	
	__webpack_require__(/*! ./fis */ 6);
	
	__webpack_require__(/*! ./fis-angular-decorators */ 7);
	
	var _hook = __webpack_require__(/*! ./hook */ 8);
	
	var _hook2 = _interopRequireDefault(_hook);
	
	var _data = __webpack_require__(/*! ./data */ 11);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _directives = __webpack_require__(/*! ./directives */ 18);
	
	var _directives2 = _interopRequireDefault(_directives);
	
	var _filters = __webpack_require__(/*! ./filters */ 32);
	
	var _filters2 = _interopRequireDefault(_filters);
	
	var _i18n = __webpack_require__(/*! ./i18n */ 36);
	
	var _i18n2 = _interopRequireDefault(_i18n);
	
	var _pubsub = __webpack_require__(/*! ./pubsub */ 43);
	
	var _pubsub2 = _interopRequireDefault(_pubsub);
	
	var _services = __webpack_require__(/*! ./services */ 46);
	
	var _services2 = _interopRequireDefault(_services);
	
	var _utils = __webpack_require__(/*! ./utils */ 55);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _views = __webpack_require__(/*! ./views */ 58);
	
	var _views2 = _interopRequireDefault(_views);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = angular.module('fis.core', [_angularAnimate2.default, _angularSanitize2.default, _angularResource2.default, _hook2.default, _data2.default, _directives2.default, _filters2.default, _i18n2.default, _pubsub2.default, _services2.default, _utils2.default, _views2.default]);
	
	// for backward compatibility
	// making sure jquery gets loaded before angular
	angular.module('fisComponents', [ngModule.name]);
	
	if (false) {
	  // eslint-disable-line
	  require('jasmine-jquery');
	  require('jasmine-ajax');
	  require('angular-mocks');
	  require('@ruf/fis-mocks');
	}
	
	// SDHTML-14222: provide ability to disable angular's debug info while preserving the element.scope function.
	// Code taken from angular's source
	ngModule.decorator('$compile', ['$delegate', function ($delegate) {
	  $delegate.$$addScopeInfo = function $$addScopeInfo($element, scope, isolated, noTemplate) {
	    var dataName = isolated ? noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope' : '$scope';
	    $element.data(dataName, scope);
	  };
	
	  return $delegate;
	}]);
	
	// create an empty controllerArr here, so that any module that has to register a controller can push it to this array
	// TODO: find where this is needed and move this code there.
	ngModule.run(['$rootScope', function ($rootScope) {
	  $rootScope.controllersArr = [];
	}]);
	
	/**
	 * This fix moved from fisInput to prevent multiple invocations of this fix - shown cause memory leak otherwise.
	 *
	 * IE specific fix, IE triggering validation on Focus of inputs
	 * If a placeholder is defined on an input element IE10 fires this event when
	 * the placeholder is set during DOM loading and when it is removed when the user clicks into the input field so that error messages
	 * which depend on the pristine condition are displayed although the user has not yet modified the input's value.
	 */
	ngModule.run(['$sniffer', function ($sniffer) {
	  var msie = parseInt((/msie (\d+)/.exec(navigator.userAgent.toLowerCase()) || [])[1], 10);
	  var _hasEvent = $sniffer.hasEvent;
	  $sniffer.hasEvent = function (event) {
	    if (event === 'input' && msie === 10) {
	      return false;
	    }
	    return _hasEvent.call(this, event);
	  };
	}]);
	
	module.exports = ngModule.name;

/***/ }),
/* 1 */
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ (function(module, exports) {

	module.exports = jQuery;

/***/ }),
/* 2 */
/*!**************************!*\
  !*** external "angular" ***!
  \**************************/
/***/ (function(module, exports) {

	module.exports = angular;

/***/ }),
/* 3 */
/*!*******************************!*\
  !*** external "'ngSanitize'" ***!
  \*******************************/
/***/ (function(module, exports) {

	module.exports = 'ngSanitize';

/***/ }),
/* 4 */
/*!*******************************!*\
  !*** external "'ngResource'" ***!
  \*******************************/
/***/ (function(module, exports) {

	module.exports = 'ngResource';

/***/ }),
/* 5 */
/*!******************************!*\
  !*** external "'ngAnimate'" ***!
  \******************************/
/***/ (function(module, exports) {

	module.exports = 'ngAnimate';

/***/ }),
/* 6 */
/*!****************!*\
  !*** ./fis.js ***!
  \****************/
/***/ (function(module, exports) {

	'use strict';
	
	(function (fis, document) {
	  'use strict';
	
	  var params = null;
	  var cacheQuery = {};
	  var injector = null;
	
	  angular.extend(fis, {
	    // adding version this way so that grunt-bump can automatically update the version
	    version: '4.5.1'
	  });
	
	  // this can be replaced by using applications to change the cache string sent in requests
	  fis.cacheVersion = fis.version;
	
	  /**
	   * @name extend
	   * @description Copies properties of the second object into the first
	   * @param o1 Object to 'extend'. (Target)
	   * @param o2 Object to copy properties from. (Source)
	   * @returns The extended object.
	   */
	  function extend(o1, o2) {
	    for (var itm in o2) {
	      if (itm) {
	        o1[itm] = o2[itm];
	      }
	    }
	    return o1;
	  }
	
	  fis.paths = function () {
	    return {};
	  };
	  fis.shim = function () {
	    return {};
	  };
	
	  /**
	   * @class
	   * @name fis.initParams
	   * @description Get/Set accessor function for initParameters. Would normally be invoked by app-setup.js
	   * @param [opts] String
	   * @returns initParams object populated with appStage, configEndpoint, baseElement, modules etc.
	   * @namespace fis.initParams
	   */
	  fis.initParams = function (opts) {
	    if (opts || params === null) {
	      if (opts) {
	        // Use this syntax over the object notation, otherwise grunt-bump will try to update the object and
	        // destroy the file.
	        cacheQuery = {};
	        cacheQuery.version = fis.cacheVersion;
	        cacheQuery.appStage = opts.appStage;
	      }
	
	      params = extend(params || {
	        appStage: fis.utils.getRequestParam('appStage') || 'P',
	        baseElement: document,
	        modules: []
	      }, opts || {});
	
	      if (params.appStage === 'D') {
	        console.log('- Development mode.');
	      }
	    }
	
	    return params;
	  };
	
	  fis.getCacheQuery = function () {
	    return cacheQuery;
	  };
	
	  // Keep the String Parameter function for backward compatibility
	  fis.cacheQueryParameter = function (args) {
	    console.warn('Please use fisUtilService appendCacheQueryParameter() function for adding cache query parameters to url');
	    var version = cacheQuery.version;
	    if (args) {
	      version = args;
	    }
	    return 'version=' + version + '&appStage=' + cacheQuery.appStage;
	    // 'version=' + version + '&appStage=' + cacheQuery.appStage + '';
	  };
	
	  fis.prefixContext = function (pathObj) {
	    var modifiedPaths = extend({}, pathObj);
	    var context = fis.getLocationPath();
	    // context === / means no context root else context root like /myapp/
	    if (context !== '/') {
	      // check if it ends in resource extension like test.html, test.htm etc. Drop it if that's the case
	      var arrContext = context.split('/');
	      var arrContextLength = arrContext.length;
	      if (arrContext[arrContextLength - 1].indexOf('.') !== -1) {
	        // resource extension present
	        arrContext.splice(arrContextLength - 1, 1); // drop the last part
	      }
	      context = arrContext.join('/');
	
	      // remove the trailing / if it ends with one
	      if (context.match(/\/$/)) {
	        context = context.substr(0, context.length - 1);
	      }
	      for (var prop in modifiedPaths) {
	        if (modifiedPaths[prop].indexOf('/') === 0) {
	          modifiedPaths[prop] = context + modifiedPaths[prop];
	        }
	      }
	    }
	    return modifiedPaths;
	  };
	
	  // Extracting location path logic into separate method for testability
	  fis.getLocationPath = function () {
	    return window.location.pathname;
	  };
	
	  fis.packages = function (arr) {
	    var i;
	    var n = arr.length;
	    var packages = [];
	
	    if (params.appStage !== 'D') {
	      return arr;
	    }
	
	    for (i = 0; i < n; i++) {
	      packages.push({ name: arr[i], main: 'dev' });
	    }
	
	    return packages;
	  };
	
	  fis.bootstrapAngular = function (depModules) {
	    // only bootstrap if it wasn't already done by ng-app
	    if (!fis.utils.getInjector()) {
	      injector = angular.bootstrap(document, depModules);
	    }
	  };
	  /**
	   * @class
	   * @name fis.start
	   * @description Boot starting the framework. Loading the required or necessary script files through this.
	   * @param [init]
	   * @namespace fis.start
	   */
	  fis.start = function (initParams) {
	    if (angular.isObject(initParams)) {
	      initParams = fis.initParams(initParams);
	    } else {
	      initParams = fis.initParams();
	    }
	
	    if (!angular.isObject(initParams)) {
	      throw new Error('Init params need to be provided to fis.start.');
	    }
	
	    if (!angular.isArray(initParams.modules)) {
	      throw new Error('Modules needs to be defined in init parameters.');
	    }
	
	    // apps that are using ng-app will not have a configEndpoint and would use the newer
	    // fisConfig constant approach. For apps using fis.start, keep the old behavior of
	    // providing a default configEndpoint
	    if (!initParams.configEndpoint) {
	      initParams.configEndpoint = 'api/config';
	    }
	
	    angular.element(document).ready(function () {
	      // only bootstrap if it wasn't already done by ng-app
	      fis.bootstrapAngular(initParams.modules);
	    });
	  };
	
	  /**
	   * @namespace fis.utils
	   */
	  fis.utils = {};
	
	  /**
	   * @name getRequestParam
	   * @description Returns a single request parameter for the provided name
	   * @param name The name of the request parameter you are looking for
	   * @returns The value of the parameter if it is present only once or an array of values if it is present multiple times. Null is not found.
	   * @memberOf fis.utils
	   */
	  fis.utils.getRequestParam = function (name) {
	    var isString = function isString(value) {
	      return typeof value === 'string' || value instanceof String;
	    };
	    var re = new RegExp('[?&]' + encodeURIComponent(name) + '=([^&]*)', 'g');
	    var res = [];
	    var search = isString(this) ? this : window.location.search;
	    var match = re.exec(search);
	
	    while (match) {
	      res.push(decodeURIComponent(match[1]));
	      match = re.exec(search);
	    }
	
	    if (res.length === 0) {
	      return null;
	    } else if (res.length === 1) {
	      return res[0];
	    }
	
	    return res;
	  };
	
	  fis.utils.getInjector = function () {
	    return injector;
	  };
	
	  function findRootElement() {
	    var rootElement = document.querySelector && document.querySelector('[ng-app]');
	    if (rootElement) {
	      return angular.element(rootElement);
	    }
	    return null;
	  }
	
	  function findInjector() {
	    var root = findRootElement();
	    if (root) {
	      return root.injector();
	    }
	    return null;
	  }
	
	  angular.element(document).ready(function () {
	    angular.element(document).find('body').removeClass('fis-loading-indicator');
	    injector = findInjector();
	  });
	
	  console.log('  ____  _   _ _____\n' + ' |  _ \\| | | |  ___|\n' + ' | |_) | | | | |_\n' + ' |  _ <| |_| |  _|\n' + ' |_| \\_\\\\___/|_|\n' + ' FIS Responsive UI Framework\n' + ' Version: ' + fis.version + '\n © 2012-' + (new Date().getYear() + 1900) + ', all rights reserved.\n');
	})(window.fis = window.sg = window.fis || window.sg || {}, document);

/***/ }),
/* 7 */
/*!***********************************!*\
  !*** ./fis-angular-decorators.js ***!
  \***********************************/
/***/ (function(module, exports) {

	'use strict';
	
	var fis = window.fis = window.sg = window.fis || window.sg || {};
	
	fis.__angularModule = angular.module;
	
	fis.__controllers = {};
	
	angular.module = function (name, deps) {
	  'use strict';
	
	  var module = fis.__angularModule(name, deps);
	  var origCtrlFn = module.controller;
	
	  module.controller = function (name, constructor) {
	    var entry = constructor;
	
	    if (angular.isArray(constructor)) {
	      entry = constructor[constructor.length - 1];
	    }
	    fis.__controllers[name] = entry;
	
	    return origCtrlFn.apply(this, arguments);
	  };
	  return module;
	};

/***/ }),
/* 8 */
/*!***********************!*\
  !*** ./hook/index.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _hook = __webpack_require__(/*! ./hook.directive */ 9);
	
	var _hook2 = _interopRequireDefault(_hook);
	
	var _hookList = __webpack_require__(/*! ./hook-list.directive */ 10);
	
	var _hookList2 = _interopRequireDefault(_hookList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.hook', []);
	
	ngModule.directive('fisHook', _hook2.default);
	ngModule.directive('fisHookList', _hookList2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 9 */
/*!********************************!*\
  !*** ./hook/hook.directive.js ***!
  \********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "fisConfig", "$templateCache", "$parse", "fisTemplateCacheService", function ($compile, fisConfig, $templateCache, $parse, fisTemplateCacheService) {
	  'ngInject';
	
	  return {
	    restrict: 'E',
	    replace: 'true',
	    scope: true,
	    template: '<div class="hook"></div>',
	    link: function link(scope, elem, attrs) {
	      var setHookData = function setHookData() {
	        var fisHookData = $parse(attrs.fisHookData);
	        scope.fisHookData = fisHookData(scope);
	      };
	
	      if (attrs.fisHookData) {
	        setHookData();
	        attrs.$observe('fisHookData', function () {
	          setHookData();
	        });
	      }
	
	      if (attrs.id) {
	        var templateName = attrs.id;
	        var template = fisTemplateCacheService.getTemplate(templateName);
	
	        if (angular.isDefined(template)) {
	          if (attrs.ngController) {
	            template = addController(template, attrs);
	          }
	          var hook = angular.element(template);
	          elem.append(hook);
	          $compile(hook)(scope);
	        }
	      }
	    }
	  };
	
	  function addController(template, attrs) {
	    var startDiv = '<div ng-controller="' + attrs.ngController + '">';
	    var endDiv = '</div>';
	    return startDiv + template + endDiv;
	  }
	}];

/***/ }),
/* 10 */
/*!*************************************!*\
  !*** ./hook/hook-list.directive.js ***!
  \*************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", "fisConfig", function ($compile, fisConfig) {
	  'ngInject';
	
	  return {
	    restrict: 'E',
	    replace: 'true',
	    template: '<div class="hookList" />',
	    link: function link(scope, elem, attrs) {
	      var newTemplate = buildHookListElement(attrs);
	      var hookList = angular.element(newTemplate);
	      elem.append(hookList);
	      $compile(hookList)(scope);
	    }
	  };
	
	  function buildHookListElement(attrs) {
	    var buffer = [];
	    if (fisConfig && fisConfig.hookListConfig) {
	      buffer.push('<div>');
	
	      fisConfig.hookListConfig.forEach(function (configItem) {
	        if (configItem.enabled === 'true') {
	          if (configItem.id === attrs.id) {
	            buffer.push(buildHookElement(configItem));
	          }
	        }
	      });
	      buffer.push('</div>');
	    }
	    return buffer.join('');
	  }
	
	  function buildHookElement(item) {
	    var hooks = item.hooks;
	    var buffer = ['<div'];
	    hooks.forEach(function (hookId) {
	      buffer.push('<div>');
	      buffer.push('<fis-hook id="');
	      buffer.push(hookId);
	      buffer.push('"');
	      buffer.push(' />');
	      buffer.push('</div>');
	    });
	    buffer.push('</div>');
	    return buffer.join('');
	  }
	}];

/***/ }),
/* 11 */
/*!***********************!*\
  !*** ./data/index.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _data = __webpack_require__(/*! ./data.directive */ 12);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _dataVar = __webpack_require__(/*! ./data-var.directive */ 13);
	
	var _dataVar2 = _interopRequireDefault(_dataVar);
	
	var _resourceService = __webpack_require__(/*! ./resource-service.provider */ 14);
	
	var _resourceService2 = _interopRequireDefault(_resourceService);
	
	var _criteriaService = __webpack_require__(/*! ./criteria-service.provider */ 15);
	
	var _criteriaService2 = _interopRequireDefault(_criteriaService);
	
	var _constraintsFactory = __webpack_require__(/*! ./constraints-factory.provider */ 16);
	
	var _constraintsFactory2 = _interopRequireDefault(_constraintsFactory);
	
	var _typeBasedConstraints = __webpack_require__(/*! ./type-based-constraints.value */ 17);
	
	var _typeBasedConstraints2 = _interopRequireDefault(_typeBasedConstraints);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.data', []);
	
	ngModule.directive('fisData', _data2.default);
	ngModule.directive('fisDataVar', _dataVar2.default);
	
	ngModule.provider('fisResourceService', _resourceService2.default);
	ngModule.provider('fisCriteriaService', _criteriaService2.default);
	ngModule.provider('fisConstraintsFactory', _constraintsFactory2.default);
	
	ngModule.value('typeBasedConstraints', _typeBasedConstraints2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 12 */
/*!********************************!*\
  !*** ./data/data.directive.js ***!
  \********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisResourceService", "$q", "$parse", "fisCriteriaService", "fisElementUtils", "$interpolate", "$timeout", "fisUtilService", "fisConfig", "fisScopeUtils", function (fisResourceService, $q, $parse, fisCriteriaService, fisElementUtils, $interpolate, $timeout, fisUtilService, fisConfig, fisScopeUtils) {
	  'ngInject';
	
	  var queryParameterPrefix = 'fisParam';
	
	  return {
	    restrict: 'A',
	    priority: 600,
	    compile: function compile(elem, attrs) {
	      // Save the original parameter expressions for later if required.
	      // We will need them for interpolating the variable values if we're running in an isolated scope.
	      attrs._paramVariables = fisElementUtils.copyProperties(attrs, queryParameterPrefix, {});
	
	      return function () {};
	    },
	    controller: ['$attrs', '$scope', '$element', function ($attrs, $scope, $element) {
	      var self = this;
	
	      var odataV3Adaptor = $attrs.fisAdaptor === 'odatav3' || fisConfig.dataSourceAdaptor === 'odatav3';
	      function isAlwaysFetch() {
	        return angular.isUndefined($attrs.fisFetchVisibleOnly) || !$attrs.fisFetchVisibleOnly;
	      }
	
	      // Only add the visibility watch when the fetching should depend on the visibility of the component
	      if (!isAlwaysFetch()) {
	        /*
	        Adds a watch to the visibility state of the element.
	        If the element is made visible and there was a call to fetchData while it was invisible,
	        the fetch is executed now.
	          scope.allowFetch is used again in fetchData below
	          */
	        var watchFn = function watchFn() {
	          $scope.allowFetch = $element.is(':visible');
	
	          if ($scope.allowFetch) {
	            if ($scope.deferred) {
	              $scope.deferred.resolve(self.fetchData($scope.lastParams));
	              $scope.deferred = undefined;
	              $scope.lastParams = undefined;
	            }
	          }
	        };
	        fisScopeUtils.postDigest($scope, function () {
	          return $element.is(':visible');
	        }, watchFn, $timeout, true);
	      }
	
	      if (!$attrs.fisData) {
	        throw new Error('You must provide a value to the fis-data attribute');
	      }
	
	      var functionExpression = $attrs.fisData.indexOf('(') !== -1;
	      var arrayExpression = $attrs.fisData.indexOf('[') !== -1;
	      var objectExpression = $attrs.fisData.indexOf('{') !== -1;
	      var fixedResourceUrl = !functionExpression && !arrayExpression && !objectExpression && $attrs.fisData.indexOf('/') !== -1;
	      var beforeFetchListeners = [];
	      var afterFetchListeners = [];
	      var dataChangedListeners = [];
	
	      var schema = {
	        // the JSON element that contains the array of data items
	        data: $parse($attrs.fisSchemaData)($scope) !== undefined ? $parse($attrs.fisSchemaData)($scope) : $attrs.fisSchemaData, // eslint-disable-line
	        // the JSON element that contains the total number of records in the entire dataset (useful for widgets that support some kind of pagination)
	        total: $attrs.fisSchemaTotal
	      };
	
	      var Resource;
	
	      // TODO: add fisSharedCriteria to allow providing a criteria that multiple widgets can share.
	      //       It will be merged with the Criteria created by the grid (translated from kendo filters)
	      //       before being sent to fetchData in the params: {crit: mergedCriteria}
	      //       This is needed to be able to provide complex search outside of the grid.
	
	      if (!fixedResourceUrl && !functionExpression) {
	        // watch to see if the provided fisData value changes (checking references, not equality).
	        // this is to determine if the fisData will be handling RESTful fetching
	        var fisDataChangeWatch = $scope.$watch($attrs.fisData, function (newVal, oldVal) {
	          if (!newVal) {
	            // $attrs.fisData doesn't resolve to a value. We keep resource as-is.
	            return;
	          }
	          // when the watch is initialized, this function is called with identical newVal and oldVal
	          if (newVal !== oldVal) {
	            // if a String value, the user may have changed the endpoint of the resource
	            Resource = determineResource($attrs, newVal);
	
	            self.fireDataChanged(newVal);
	          }
	        });
	        $scope.$on('$destroy', function () {
	          if (fisDataChangeWatch) {
	            fisDataChangeWatch();
	          }
	        });
	      }
	
	      /**
	       * @return Returns the schema object to be used
	       */
	      self.getSchema = function () {
	        return schema;
	      };
	
	      /**
	       * Can be used by a widget directive to tell that the data has changed and that the underlying dom widget (kendo or other)
	       * can be notified of that change and be refreshed accordingly (by invoking fetchData again).
	       * Note that fisData will already invoke this if it detects that the reference to the model has changed.
	       */
	      self.fireDataChanged = function (data) {
	        invokeListeners(dataChangedListeners, data);
	      };
	
	      /**
	       * @returns a promise that will resolve into an object with two properties:
	       * The data property will contain an array of objects and the total property will contain the total number
	       * of records available in the dataset, if this information is available. This total is used for pagination, so that
	       * widgets can calculate the total number of pages.
	       */
	      self.fetchData = function (params) {
	        if ($attrs.fisSort) {
	          // check if the attribute specified in fis-sort is assignable (scope object)
	          var fisSort = $parse($attrs.fisSort);
	          if (fisSort.assign && params) {
	            // add params to check to prevent widgets with fis-sort breaking if no params defined for assignable expression
	            // if fis-sort expression is assignable, update the expression whenever user interacts with the grid
	            // (manual sorting by clicking on column headers)
	            var sortExpressionArray = [];
	            if (odataV3Adaptor) {
	              var sortExpr = params.sort;
	              if (sortExpr) {
	                var sortDefs = sortExpr.split(',');
	                angular.forEach(sortDefs, function (sortDef) {
	                  var parts = sortDef.split(' ');
	                  if (parts.length === 2) {
	                    sortExpressionArray.push({ field: parts[0], dir: parts[1] });
	                  }
	                });
	              }
	            } else {
	              angular.forEach(params.sort, function (sortedParam) {
	                // here the param.sort received is in the format ["fieldName,sortOrder","fieldName,sortOrder",..]
	                // Convert it to [{field:fieldName, dir:sortOrder},{field:fieldName, dir:sortOrder}..] format
	                var parts = sortedParam.split(',');
	                sortExpressionArray.push({ field: parts[0], dir: parts[1] });
	              });
	            }
	            // Update the fis-sort assignable expression to the changed value
	            fisSort.assign($scope, sortExpressionArray.length === 1 ? sortExpressionArray[0] : sortExpressionArray);
	          }
	        }
	
	        // If not explicitely set to just fetch when visible the fetch function is always called
	        if (!isAlwaysFetch()) {
	          /*
	          Only fetch the data when the fetching is allowed (since the element is visible) - otherwise
	          enter this if and return just a promise that will be resolved once.
	            */
	          if (!$scope.allowFetch) {
	            // Store any provided parameters for later execution
	            $scope.lastParams = params;
	            if ($scope.deferred) {
	              // There is already a deferred execution of fetchData - return a new promise here as the resolution
	              var newDeferred = $q.defer();
	              $scope.deferred.resolve(newDeferred.promise);
	              $scope.deferred = newDeferred;
	            } else {
	              // This is the first call to fetchData since the element is invisible
	              $scope.deferred = $q.defer();
	            }
	
	            // Return just a promise for now - the watch on the visibility will resolve it later
	            return $scope.deferred.promise;
	          }
	        }
	
	        if ($attrs.fisCriteria) {
	          var mergedCriteria;
	          var mergedOperands;
	          var fisCriteria = fisCriteriaService.newCriteria($parse($attrs.fisCriteria)($scope));
	
	          if (params.crit) {
	            mergedOperands = [];
	            fisCriteria.operands.concat(params.crit.operands).forEach(function (operand) {
	              if (mergedOperands.indexOf(operand) === -1) {
	                mergedOperands.push(operand);
	              }
	            });
	            mergedCriteria = angular.extend(fisCriteria, params.crit);
	            mergedCriteria.operands = mergedOperands;
	          } else {
	            mergedCriteria = fisCriteria;
	          }
	          params.crit = mergedCriteria.toString();
	        }
	
	        Resource = determineResource($attrs);
	        invokeListeners(beforeFetchListeners, params);
	
	        params = fisElementUtils.copyProperties($attrs, queryParameterPrefix, params);
	
	        // When running in isolated scope, e.g. in fisGrid, we don't have access to the outer scope.
	        // Someone using a parameter like fis-param-foo="{{foo}}" would need to use {{$parent.foo}}
	        // to escape the isolated scope of fisGrid. To avoid that, we reevaluate the fis-param-*
	        // expressions against the parent scope. This way, the use doesn't need to care whether
	        // the directive uses isolated scope or not.
	        if ($scope.hasOwnProperty('$$isolateBindings') && $scope) {
	          // Loop over the parameter expressions that we saved in the compile function.
	          // The variables are not interpolated at this stage.
	          angular.forEach($attrs._paramVariables, function (val, key) {
	            // Interpolate the variable ourselves using the $interpolate service
	            // We use the parent scope to resolve the variables.
	            var interpolatedValue = $interpolate(val)($scope);
	
	            // Assign the variable to the respective entry in the params object,
	            // overwriting any value that was previously there.
	            params[key] = interpolatedValue;
	          });
	        }
	
	        if (Resource) {
	          return getDataFromResource(params);
	        }
	        // data retrieval is managed externally (could still come from a server)
	        var getter = $parse($attrs.fisData);
	        var promise;
	
	        if (functionExpression) {
	          // function expression
	          // wrap in a promise, chain promises if function also returns a promise
	          promise = $q.when(getter($scope, { params: params })).then(function (data) {
	            var resultData = invokeListeners(afterFetchListeners, normalizeData(data));
	            if (angular.isFunction(schema.data)) {
	              resultData.data = retrieveDataFromSchemaData(data);
	            }
	            return resultData;
	          }, function () {
	            // TODO: define exceptions
	            throw new Error('fisData could not get data from ' + $attrs.fisData);
	          });
	        } else {
	          var scoped = getter($scope);
	          if (angular.isFunction(scoped)) {
	            var result = scoped(params);
	            promise = $q.when(result).then(function (data) {
	              var resultData = invokeListeners(afterFetchListeners, normalizeData(data));
	              if (angular.isFunction(schema.data)) {
	                resultData.data = retrieveDataFromSchemaData(data);
	              }
	              return resultData;
	            }, function () {
	              throw new Error('fisData could not get data from ' + $attrs.fisData);
	            });
	          } else {
	            var deferred = $q.defer();
	            var resultData = invokeListeners(afterFetchListeners, normalizeData(scoped));
	            if (angular.isFunction(schema.data)) {
	              resultData.data = retrieveDataFromSchemaData(scoped);
	            }
	            deferred.resolve(resultData);
	            promise = deferred.promise;
	          }
	        }
	
	        return promise;
	      };
	
	      function retrieveDataFromSchemaData(data) {
	        var resultData = [];
	        var results = schema.data(data);
	        angular.forEach(results, function (item) {
	          resultData.push(item);
	        });
	        return resultData;
	      }
	
	      self.addDataChangedListener = function (listener) {
	        if (dataChangedListeners.indexOf(listener) === -1) {
	          dataChangedListeners.push(listener);
	        }
	        return function () {
	          var idx = dataChangedListeners.indexOf(listener);
	          if (idx !== -1) {
	            dataChangedListeners.splice(idx, 1);
	          }
	        };
	      };
	
	      self.addBeforeFetchListener = function (listener) {
	        if (beforeFetchListeners.indexOf(listener) === -1) {
	          beforeFetchListeners.push(listener);
	        }
	        return function () {
	          var idx = beforeFetchListeners.indexOf(listener);
	          if (idx !== -1) {
	            beforeFetchListeners.splice(idx, 1);
	          }
	        };
	      };
	
	      self.addAfterFetchListener = function (listener) {
	        if (afterFetchListeners.indexOf(listener) === -1) {
	          afterFetchListeners.push(listener);
	        }
	        return function () {
	          var idx = afterFetchListeners.indexOf(listener);
	          if (idx !== -1) {
	            afterFetchListeners.splice(idx, 1);
	          }
	        };
	      };
	
	      function normalizeData(data) {
	        if (data.data) {
	          return data;
	        }
	
	        if (angular.isArray(data)) {
	          if (data.length > 1) {
	            return {
	              data: data
	            };
	          } else if (data.length === 1) {
	            return {
	              data: data,
	              obj: data[0]
	            };
	          }
	        }
	        if (angular.isArray(data)) {
	          return {
	            data: data
	          };
	        }
	        if (schema && schema.data) {
	          var resultData = {
	            data: []
	          };
	          angular.extend(resultData, data);
	          if (schema.data !== 'data') {
	            var results;
	            if (angular.isString(schema.data)) {
	              results = fisUtilService.extractData(schema.data, data);
	            }
	            angular.forEach(results, function (item) {
	              resultData.data.push(item);
	            });
	          }
	
	          if (schema.total) {
	            resultData.total = data[schema.total];
	          }
	          if (schema.data !== 'data') {
	            delete resultData[schema.data];
	          }
	          if (schema.total !== 'total') {
	            delete resultData[schema.total];
	          }
	          return resultData;
	        }
	        return {
	          data: [data]
	        };
	      }
	
	      function invokeListeners(listeners, data) {
	        angular.forEach(listeners, function (listener) {
	          // invoke the listener and make sure it's returned data is normalized so that all listeners can expect the same format.
	          data = normalizeData(listener(data) || data);
	        });
	        return data;
	      }
	
	      function getDataFromResource(params) {
	        var instance;
	        var deferred = $q.defer();
	        var promise;
	
	        // here you can receive params that are objects but that you may not want to transform to JSON
	        // to pass as query parameters. Make sure they are marshalled to a string that is appropriate
	        // to the backend.
	        // TODO: provide a hook to marshall special objects (decorate params). For now, only translating Criteria to its string form
	        if (params.crit) {
	          params.crit = params.crit.toString();
	        }
	        if (odataV3Adaptor) {
	          if (params.crit) {
	            params.$filter = params.crit.toString();
	            delete params.crit;
	          }
	
	          if (angular.isNumber(params.offset)) {
	            params.$skip = params.offset;
	            delete params.offset;
	          }
	
	          if (angular.isNumber(params.limit)) {
	            params.$top = params.limit;
	            delete params.limit;
	          }
	
	          if (params.sort) {
	            params.$orderby = params.sort;
	            delete params.sort;
	          }
	          // TODO add $inlinecount only when schema.total is defined
	          // params.$inlinecount = 'allpages'; // ask for the total in the response
	          params.$format = 'json';
	        }
	        instance = Resource.getData(params, function () {
	          // don't return just instance.data, send back everything
	          deferred.resolve(invokeListeners(afterFetchListeners, instance));
	        }, function (d) {
	          // TODO: define exceptions (fisException service?)
	          deferred.reject(invokeListeners(afterFetchListeners, d));
	        });
	        promise = deferred.promise;
	        promise.data = instance.data;
	        return promise;
	      }
	
	      function determineResource(attrs, val) {
	        if (functionExpression) {
	          // fisData will not handle invoking the rest resource and will delegate to the function expression
	          return null;
	        }
	        val = val || fixedResourceUrl && attrs.fisData || $parse(attrs.fisData)($scope);
	
	        if (angular.isString(val)) {
	          // the value refers to a $resource URL
	          // fisData will handle RESTful fetching
	          return fisResourceService(val, null, null, schema);
	        } else if (!val) {
	          // $attrs.fisData is not empty but doesn't resolve to a scoped value, consider the string in $attrs.fisData as a $resource URL
	          // fisData will handle RESTful fetching
	          return fisResourceService(attrs.fisData, null, null, schema);
	        }
	        // fisData will not handle RESTful fetching
	        return null;
	      }
	    }]
	
	  };
	}];

/***/ }),
/* 13 */
/*!************************************!*\
  !*** ./data/data-var.directive.js ***!
  \************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$parse", "$timeout", "fisMemoryUtilService", function ($parse, $timeout, fisMemoryUtilService) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    require: 'fisData',
	    link: function link(scope, elem, attrs, fisData) {
	      if (angular.isUndefined(attrs.fisDataVar) || attrs.fisDataVar.length === 0) {
	        throw new Error('The fisDataVar attribute must have a value.');
	      }
	
	      var fisDataVarAttr = attrs.fisDataVar;
	
	      var loadData = function loadData(event) {
	        // do not execute the event if event.preventDefault() has been called before
	        if (event && event.defaultPrevented) {
	          return;
	        }
	        var timeout1 = $timeout(function () {
	          var promise = fisData.fetchData();
	          promise.then(function (result) {
	            var dataVar = $parse(fisDataVarAttr);
	            dataVar.assign(scope, result.data);
	          }, function (result) {
	            console.warn('Problem loading data: ' + result);
	          });
	        });
	        fisMemoryUtilService.cancelTimeoutOnDestroy(scope, timeout1, $timeout);
	      };
	
	      // Refresh Event
	      if (angular.isDefined(attrs.fisRefresh)) {
	        scope.$on('fisRefresh', loadData);
	      }
	
	      // Adding listener on fisData, so that data is reloaded when fisData's endPoint changes
	      var dataChangeListener = function dataChangeListener() {
	        loadData();
	      };
	      fisData.addDataChangedListener(dataChangeListener);
	
	      // Does initial call to get data
	      loadData();
	    }
	  };
	}];

/***/ }),
/* 14 */
/*!*******************************************!*\
  !*** ./data/resource-service.provider.js ***!
  \*******************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  var self = this;
	
	  self.$get = ['$resource', 'fisUtilService', function ($resource, fisUtilService) {
	    return function (url, paramDefaults, actions, schema) {
	      var localResource = $resource(url, paramDefaults, actions);
	      localResource.getData = function (params, success, failure) {
	        var ret = {
	          data: []
	        };
	        if (schema && schema.data) {
	          localResource.get(params, function (d, headers) {
	            ret.data.length = 0;
	            angular.extend(ret, d);
	
	            if (schema.data !== 'data') {
	              if (schema.data === 'none') {
	                var res = {};
	                angular.forEach(d, function (key, val) {
	                  if (val.toString().indexOf('$') !== 0) {
	                    res[val] = key;
	                  }
	                });
	                ret.data.push(res);
	              } else {
	                var results;
	                if (angular.isString(schema.data)) {
	                  results = fisUtilService.extractData(schema.data, d);
	                } else if (angular.isFunction(schema.data)) {
	                  results = schema.data(d);
	                }
	                angular.forEach(results, function (item) {
	                  ret.data.push(item);
	                });
	              }
	            }
	
	            if (schema.total) {
	              ret.total = d[schema.total];
	            }
	            if (schema.data !== 'data' && schema.data !== 'none') {
	              delete ret[schema.data];
	            }
	            if (schema.total !== 'total') {
	              delete ret[schema.total];
	            }
	            success(ret, headers);
	          }, failure);
	        } else {
	          ret.data = localResource.query(params, function (d, headers) {
	            // send normalized data structure to success callback
	            success(ret, headers);
	          }, failure);
	        }
	        // always returns an object with an empty data array that gets filled when request is successful
	        return ret;
	      };
	
	      return localResource;
	    };
	  }];
	};

/***/ }),
/* 15 */
/*!*******************************************!*\
  !*** ./data/criteria-service.provider.js ***!
  \*******************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  function toInt(str) {
	    return parseInt(str, 10);
	  }
	
	  function parseISODate(value) {
	    var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
	    var match;
	    if (match = value.match(R_ISO8601_STR)) {
	      var date = new Date(0);
	      var tzHour = 0;
	      var tzMin = 0;
	      var dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear;
	      var timeSetter = match[8] ? date.setUTCHours : date.setHours;
	
	      if (match[9]) {
	        tzHour = toInt(match[9] + match[10]);
	        tzMin = toInt(match[9] + match[11]);
	      }
	      dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
	      var h = toInt(match[4] || 0) - tzHour;
	      var m = toInt(match[5] || 0) - tzMin;
	      var s = toInt(match[6] || 0);
	      var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
	      timeSetter.call(date, h, m, s, ms);
	      return date;
	    }
	    return value;
	  }
	
	  var self = this;
	
	  self.$get = [function () {
	    var service = {};
	
	    service.operators = ['and', 'or'];
	    service.operators.AND = service.operators[0];
	    service.operators.OR = service.operators[1];
	
	    service.constraints = ['eq', 'contains', 'ne', 'gt', 'ge', 'lt', 'le', 'startswith', 'endswith', 'is_null', 'not_contains', 'not_endswith', 'not_null', 'in_rel_range', 'not_in_rel_range', 'in_future', 'in_past', 'is_between', 'not_is_between', 'in', 'not_in', 'is_empty', 'not_empty', 'not_startswith'];
	    service.constraints.EQ = service.constraints[0];
	    service.constraints.CONTAINS = service.constraints[1];
	    service.constraints.NE = service.constraints[2];
	    service.constraints.GT = service.constraints[3];
	    service.constraints.GE = service.constraints[4];
	    service.constraints.LT = service.constraints[5];
	    service.constraints.LE = service.constraints[6];
	    service.constraints.STARTS_WITH = service.constraints[7];
	    service.constraints.ENDS_WITH = service.constraints[8];
	    service.constraints.IS_NULL = service.constraints[9];
	    service.constraints.NOT_CONTAINS = service.constraints[10];
	    service.constraints.NOT_ENDS_WITH = service.constraints[11];
	    service.constraints.NOT_NULL = service.constraints[12];
	    service.constraints.IN_REL_RANGE = service.constraints[13];
	    service.constraints.NOT_IN_REL_RANGE = service.constraints[14];
	    service.constraints.IN_FUTURE = service.constraints[15];
	    service.constraints.IN_PAST = service.constraints[16];
	    service.constraints.BETWEEN = service.constraints[17];
	    service.constraints.NOT_BETWEEN = service.constraints[18];
	    service.constraints.IN = service.constraints[19];
	    service.constraints.NOT_IN = service.constraints[20];
	    service.constraints.IS_EMPTY = service.constraints[21];
	    service.constraints.NOT_EMPTY = service.constraints[22];
	    service.constraints.NOT_STARTS_WITH = service.constraints[23];
	
	    var constraintsWithoutValue = [service.constraints.IS_EMPTY, service.constraints.NOT_EMPTY, service.constraints.IS_NULL, service.constraints.NOT_NULL];
	
	    function Criteria(operator) {
	      if (angular.isString(operator)) {
	        this.operator = operator || service.operators.AND;
	        this.operands = [];
	      } else if (angular.isObject(operator)) {
	        var jsonObj = operator;
	        var currentOperator = service.operators.AND;
	        if (jsonObj.operator) {
	          currentOperator = jsonObj.operator;
	        }
	        if (service.operators.indexOf(currentOperator) === -1) {
	          throw new Error('Invalid operator : ' + currentOperator);
	        }
	
	        var newCrit = service.newCriteria(currentOperator);
	
	        if (angular.isArray(jsonObj.operands)) {
	          completeCriteriaFromOperands(jsonObj.operands, newCrit);
	        }
	
	        return newCrit;
	      }
	    }
	
	    function completeCriteriaFromOperands(inputoperands, origCrit) {
	      for (var i = 0; i < inputoperands.length; i++) {
	        var operand = inputoperands[i];
	        if (operand.operator) {
	          var newCrit = service.newCriteria(operand.operator);
	          if (operand.operands) {
	            completeCriteriaFromOperands(operand.operands, newCrit);
	            origCrit.add(newCrit);
	          }
	        } else {
	          origCrit.add(new service.Criterion(operand.property, operand.value, operand.constraint, operand.type, operand.skipValidation));
	        }
	      }
	    }
	
	    Criteria.prototype.setOperator = function (operator) {
	      if (service.operators.indexOf(operator) === -1) {
	        throw new Error('Invalid operator : ' + operator);
	      }
	      this.operator = operator;
	      return this;
	    };
	
	    Criteria.prototype.add = function (operand) {
	      operand.validate();
	      this.operands.push(operand);
	      return this;
	    };
	
	    Criteria.prototype.setOperands = function (operands) {
	      this.operands = operands;
	      return this;
	    };
	
	    Criteria.prototype.isValid = function (isChild) {
	      if (service.operators.indexOf(this.operator) === -1) {
	        return false;
	      }
	      if (isChild && this.operands.length === 0) {
	        return false;
	      }
	      for (var i = 0; i < this.operands.length; i++) {
	        var operand = this.operands[i];
	        if (!angular.isUndefined(operand.skipValidation) && !operand.skipValidation && !operand.isValid(true)) {
	          return false;
	        }
	        var j = i + 1;
	        var nextOperand = this.operands[j];
	        if (nextOperand) {
	          if (!angular.isUndefined(nextOperand.skipValidation) && !nextOperand.skipValidation && !nextOperand.isValid(true)) {
	            return false;
	          }
	          if (service.operators.indexOf(this.operator) === -1) {
	            return false;
	          }
	        }
	      }
	      return true;
	    };
	
	    Criteria.prototype.validate = function () {
	      if (!this.isValid()) {
	        throw new Error('Invalid Criteria: ' + this);
	      }
	    };
	
	    Criteria.prototype.validateWithoutError = function () {
	      console.warn('DEPRECATED: Criteria.validateWithoutError. Use Criteria.isValid.');
	      return this.isValid();
	    };
	
	    Criteria.prototype.toString = function () {
	      var crit = this.getAsString();
	      var finalCrit = '';
	      if (crit) {
	        finalCrit = crit.substring(1);
	        finalCrit = finalCrit.substring(0, finalCrit.length - 1);
	      }
	      return finalCrit;
	    };
	
	    Criteria.prototype.getAsString = function () {
	      var crit = '(';
	      for (var i = 0; i < this.operands.length; i++) {
	        var operand = this.operands[i];
	        crit += operand.getAsString();
	        var j = i + 1;
	        var next = this.operands[j];
	        if (next) {
	          crit += ' ';
	          crit += this.operator;
	          crit += ' ';
	        }
	      }
	      crit += ')';
	
	      return crit;
	    };
	
	    function isNumber(value) {
	      return !isNaN(parseFloat(value)) && isFinite(value);
	    }
	
	    function isValidValue(value, constraint, type) {
	      if ((angular.isUndefined(value) || value === '') && value !== 0) {
	        if (constraintsWithoutValue.indexOf(constraint) === -1) {
	          return false;
	        }
	        return true;
	      } else if (constraintsWithoutValue.indexOf(constraint) > -1) {
	        return false;
	      }
	
	      if ((type === 'integer' || type === 'number' || type === 'double') && !isNumber(value)) {
	        return false;
	      }
	      if (type === 'date' || type === 'datetime' || type === 'time') {
	        if (!value.toISOString) {
	          try {
	            new Date(value).toISOString();
	          } catch (e) {
	            // SDHTML-13812 - IE javascript engine cannot parse date in '2016-06-06T00:16:07+0000' format
	            value = parseISODate(value);
	            if (!angular.isUndefined(value)) {
	              try {
	                return Boolean(angular.isDate(value) ? value.toISOString() : new Date(value).toISOString());
	              } catch (e) {
	                return false;
	              }
	            }
	            return false;
	          }
	        }
	      }
	      if (type === 'boolean') {
	        if (typeof value !== 'boolean' && value !== 'true' && value !== 'false') {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    // criterion object
	    function Criterion(property, value, constraint, type, skipValidation) {
	      this.property = property || null;
	      this.value = angular.isUndefined(value) ? '' : value;
	      this.constraint = constraint || service.constraints.EQ;
	      this.type = type;
	      this.skipValidation = skipValidation;
	    }
	
	    function marshallValue(value, type) {
	      if (type === 'integer' || type === 'boolean' || type && type.substring(0, 6) === 'double' || type === 'number') {
	        return value;
	      }
	      if (type === 'date' || type === 'datetime' || type === 'time') {
	        if (!value.toISOString) {
	          /* eslint-disable no-negated-condition */
	          if (!isNaN(Date.parse(value))) {
	            value = new Date(value);
	          } else {
	            // SDHTML-13812 - IE javascript engine cannot parse date in '2016-06-06T00:16:07+0000' format
	            value = parseISODate(value);
	          }
	          /* eslint-enable no-negated-condition */
	        }
	        return 'datetime\'' + value.toISOString() + '\'';
	      }
	      return '\'' + value.toString().replace(/'/g, '\'\'') + '\'';
	    }
	
	    Criterion.prototype.getAsString = function () {
	      // var spaceWithStarIfCaseInsensitive = this.ignoreCase ? '' : '*';
	      var result = '';
	      switch (this.constraint) {
	        case 'startswith':
	        case 'endswith':
	          result = this.constraint + '(' + this.property + ',' + marshallValue(this.value, this.type) + ')';
	          break;
	        case 'not_startswith':
	        case 'not_endswith':
	          result = 'not ' + this.constraint.substring(this.constraint.indexOf('_') + 1) + '(' + this.property + ',' + marshallValue(this.value, this.type) + ')';
	          break;
	        case 'contains':
	          result = 'substringof(' + marshallValue(this.value, this.type) + ',' + this.property + ') eq true';
	          break;
	        case 'not_contains':
	          result = 'substringof(' + marshallValue(this.value, this.type) + ',' + this.property + ') eq false';
	          break;
	        case 'is_null':
	          result = this.property + ' eq null';
	          break;
	        case 'not_null':
	          result = this.property + ' ne null';
	          break;
	        case 'is_empty':
	          result = this.property + ' eq \'\'';
	          break;
	        case 'not_empty':
	          result = this.property + ' ne \'\'';
	          break;
	        default:
	          if (this.skipValidation || service.constraints.indexOf(this.constraint) < 0) {
	            result = this.property + ' ' + this.constraint + ' ' + this.value;
	          } else {
	            result = this.property + ' ' + this.constraint + ' ' + marshallValue(this.value, this.type);
	          }
	      }
	      return result;
	    };
	
	    Criterion.prototype.isValid = function () {
	      if (!this.property || service.constraints.indexOf(this.constraint) === -1 || !isValidValue(this.value, this.constraint, this.type)) {
	        return false;
	      }
	      return true;
	    };
	
	    Criterion.prototype.validate = function () {
	      if (!angular.isUndefined(this.skipValidation) && !this.skipValidation && !this.isValid()) {
	        throw new Error('Invalid Criterion: ' + this);
	      }
	    };
	
	    Criterion.prototype.validateWithoutError = function () {
	      console.warn('DEPRECATED: Criterion.validateWithoutError. Use Criterion.isValid.');
	      return this.isValid();
	    };
	
	    Criterion.prototype.setProperty = function (property) {
	      if (!property) {
	        throw new Error('Invalid property');
	      }
	      this.property = property;
	      return this;
	    };
	
	    Criterion.prototype.setValue = function (value) {
	      this.value = value;
	      return this;
	    };
	
	    Criterion.prototype.setConstraint = function (constraint) {
	      if (service.constraints.indexOf(constraint) === -1) {
	        throw new Error('Invalid constraint : ' + constraint);
	      }
	      this.constraint = constraint;
	      return this;
	    };
	
	    service.newCriteria = function (operator) {
	      if (!operator) {
	        operator = service.operators.AND;
	      }
	      if (angular.isString(operator)) {
	        if (service.operators.indexOf(operator) === -1) {
	          throw new Error('Invalid operator : ' + operator);
	        }
	      }
	      return new Criteria(operator);
	    };
	
	    service.Criteria = Criteria;
	    service.Criterion = Criterion;
	
	    return service;
	  }];
	};

/***/ }),
/* 16 */
/*!**********************************************!*\
  !*** ./data/constraints-factory.provider.js ***!
  \**********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  self.$get = ['typeBasedConstraints', function (typeBasedConstraints) {
	    var constraintsFactory = {};
	
	    constraintsFactory.getConstraintsByType = function (type) {
	      var result = typeBasedConstraints[type];
	      if (angular.isDefined(result)) {
	        return result;
	      }
	      return typeBasedConstraints.string;
	    };
	
	    return constraintsFactory;
	  }];
	};

/***/ }),
/* 17 */
/*!**********************************************!*\
  !*** ./data/type-based-constraints.value.js ***!
  \**********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var basicConstraints = [{ value: 'eq', label: 'is' }, { value: 'ne', label: 'is not' }, { value: 'is_null', label: 'is null' }, { value: 'not_null', label: 'is not null' }];
	
	var numberConstraints = basicConstraints.concat([{ value: 'gt', label: 'greater than' }, { value: 'ge', label: 'greater than or equal to' }, { value: 'lt', label: 'less than' }, { value: 'le', label: 'less than or equal to' }]);
	
	var defaultConstraints = basicConstraints.concat([{ value: 'contains', label: 'contains' }, { value: 'not_contains', label: 'not contains' }, { value: 'is_empty', label: 'is empty' }, { value: 'not_empty', label: 'is not empty' }, { value: 'startswith', label: 'starts with' }, { value: 'not_startswith', label: 'not starts with' }, { value: 'endswith', label: 'ends with' }, { value: 'not_endswith', label: 'not ends with' }]);
	
	exports.default = {
	    string: defaultConstraints,
	    integer: numberConstraints,
	    currency: numberConstraints,
	    percentage: numberConstraints,
	    number: numberConstraints,
	    double: numberConstraints,
	    date: numberConstraints,
	    datetime: numberConstraints,
	    time: numberConstraints,
	    defaultType: defaultConstraints,
	    boolean: basicConstraints
	};

/***/ }),
/* 18 */
/*!*****************************!*\
  !*** ./directives/index.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _utils = __webpack_require__(/*! ./utils */ 19);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _dragdrop = __webpack_require__(/*! ./dragdrop */ 29);
	
	var _dragdrop2 = _interopRequireDefault(_dragdrop);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.directives', [_utils2.default, _dragdrop2.default]);
	
	exports.default = ngModule.name;

/***/ }),
/* 19 */
/*!***********************************!*\
  !*** ./directives/utils/index.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _elementUtils = __webpack_require__(/*! ./element-utils.factory */ 20);
	
	var _elementUtils2 = _interopRequireDefault(_elementUtils);
	
	var _fieldDirectiveFactory = __webpack_require__(/*! ./field-directive-factory.factory */ 21);
	
	var _fieldDirectiveFactory2 = _interopRequireDefault(_fieldDirectiveFactory);
	
	var _scopeUtils = __webpack_require__(/*! ./scope-utils.factory */ 23);
	
	var _scopeUtils2 = _interopRequireDefault(_scopeUtils);
	
	var _uniqueIdService = __webpack_require__(/*! ./unique-id-service.factory */ 24);
	
	var _uniqueIdService2 = _interopRequireDefault(_uniqueIdService);
	
	var _input = __webpack_require__(/*! ./input.directive */ 25);
	
	var _input2 = _interopRequireDefault(_input);
	
	var _applyClassDirective = __webpack_require__(/*! ./apply-class-directive.directive */ 26);
	
	var _applyClassDirective2 = _interopRequireDefault(_applyClassDirective);
	
	var _triggerDirectives = __webpack_require__(/*! ./trigger-directives.directive */ 27);
	
	var _triggerDirectives2 = _interopRequireDefault(_triggerDirectives);
	
	var _uniqueId = __webpack_require__(/*! ./unique-id.directive */ 28);
	
	var _uniqueId2 = _interopRequireDefault(_uniqueId);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Utilities for component/directive authoring
	
	var ngModule = _angular2.default.module('fis.core.directives.utils', []);
	
	ngModule.factory('fisElementUtils', _elementUtils2.default);
	ngModule.factory('fisFieldDirectiveFactory', _fieldDirectiveFactory2.default);
	ngModule.factory('fisScopeUtils', _scopeUtils2.default);
	ngModule.factory('fisUniqueIdService', _uniqueIdService2.default);
	
	ngModule.directive('fisInput', _input2.default);
	ngModule.directive('fisApplyClassDirective', _applyClassDirective2.default);
	ngModule.directive('fisUniqueId', _uniqueId2.default);
	
	['fisReinit', 'fisRefresh'].forEach(function (directive) {
	  ngModule.directive(directive, (0, _triggerDirectives2.default)(directive));
	});
	
	exports.default = ngModule.name;

/***/ }),
/* 20 */
/*!***************************************************!*\
  !*** ./directives/utils/element-utils.factory.js ***!
  \***************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'ngInject';
	
	  var service = {};
	
	  /**
	   * @description Allows filtering properties of a provided source object to set them without the provided prefix
	   * on a target object.
	   * @param {Object} sourceObject The object from which the properties should be taken.
	   * @param {String} prefix The not empty prefix applied to filter the properties of the source object.
	   * @param {Object} targetObject The optional target object on which to set the properties. If not provided, a new object is created.
	   */
	  service.copyProperties = function (sourceObject, prefix, targetObject) {
	    if (sourceObject === undefined) {
	      throw 'sourceObject must be provided'; // eslint-disable-line
	    }
	
	    if (prefix === undefined || typeof prefix !== 'string' || prefix.length < 1) {
	      throw 'no not empty string prefix provided. Got ' + prefix; // eslint-disable-line
	    }
	
	    if (targetObject === undefined) {
	      targetObject = {};
	    }
	
	    // Filter all object properties for the prefix
	    var propertyNames = Object.keys(sourceObject).filter(function (property) {
	      return property.substring(0, prefix.length) === prefix;
	    });
	
	    // Add the property values to the target object
	    if (propertyNames !== undefined) {
	      angular.forEach(propertyNames, function (propertyName) {
	        // truncate the name, throw away the prefix
	        var truncatedName = propertyName.substr(prefix.length);
	
	        // Adjust the first letter to be lowerCase
	        truncatedName = truncatedName.substring(0, 1).toLowerCase() + truncatedName.substring(1);
	
	        targetObject[truncatedName] = sourceObject[propertyName];
	      });
	    }
	
	    return targetObject;
	  };
	
	  /**
	   * Helps in migrating attrs.$observe invocations from AngularJS 1.2.x to 1.3+.
	   * 1.2 used to invoke the listener function once if the attribute is undefined.
	   * IT IS PREFERABLE TO REFACTOR YOUR CODE THAN TO USE THIS FUNCTION.
	   */
	  service.invokeAndObserve = function (attrs, key, fn) {
	    // if attribute is present, no need to invoke since observe will.
	    if (!angular.isDefined(attrs[key])) {
	      fn(undefined);
	    }
	    attrs.$observe(key, fn);
	  };
	
	  return service;
	};

/***/ }),
/* 21 */
/*!*************************************************************!*\
  !*** ./directives/utils/field-directive-factory.factory.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(_) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisUniqueIdService", "fisScopeUtils", function (fisUniqueIdService, fisScopeUtils) {
	  'ngInject';
	
	  var fieldTemplate = '<div class="fis-field control-group">\n                <%var isExpVal=false;if (field.attrs.fisLabel  || field.attrs.required !== undefined) {if(field.attrs.fisLabel && field.attrs.fisLabel.indexOf("\'") > -1){field.attrs.fisLabel = field.attrs.fisLabel.replace(/\'/g,\'"\');}if(field.attrs.fisLabel && field.attrs.fisLabel.indexOf("{{") > -1){field.attrs.fisLabel = field.attrs.fisLabel.replace(/{|}/g,"");isExpVal=true;}%><label class="control-label"><span><span class="fis-req">*</span><%if(isExpVal){%><span ng-bind-html="<%- field.attrs.fisLabel %>"></span><%} else{%><span ng-bind-html="\'<%- field.attrs.fisLabel %>\'"></span><%}%></span></label><%}%>\n                <div class="controls">\n                    <div ng-show="fisEditMode" class="wrap fis-inputs" fis-unique-id="edit_mode">\n                    <%= field.editTemplate %>\n                    </div>\n                    <div ng-show="!fisEditMode" class="wrap fis-view-value control-label-view" fis-unique-id="not_edit_mode">\n                    <%= field.viewTemplate %>\n                    </div>\n                    <% if (field.attrs.fisInstruct){ %><span ng-show="fisEditMode" class="fis-instruct-message"><%- field.attrs.fisInstruct %></span> <% } %>\n                    <span ng-show="fisEditMode" fis-field-message></span>\n                </div>\n            </div>';
	
	  var FieldController = function FieldController($scope, $element, $attrs, $transclude, $parse) {
	    if ($scope.$parent.fisEditMode !== true && $scope.$parent.fisEditMode !== false) {
	      // set fisEditMode on the parent if it is not already set.
	      // this takes care of fields that are outside of an fisFields directive.
	      $scope.$parent.fisEditMode = true;
	    }
	
	    fisScopeUtils.watch($scope.$parent, $attrs.fisDisabled, function (disabled) {
	      $scope.fisDisabled = disabled;
	
	      var required = $parse($attrs.fisRequired)($scope);
	
	      if (required === true) {
	        if (disabled === true) {
	          // Was required, is now disabled, so remove the required flag
	          $scope.fisRequired = false;
	          $element.removeClass('fis-required');
	        } else {
	          // Was required, the flag might have been removed earlier, so re-add it
	          $scope.fisRequired = true;
	          $element.addClass('fis-required');
	        }
	      }
	    });
	
	    fisScopeUtils.watch($scope.$parent, $attrs.fisRequired, function (required) {
	      $scope.fisRequired = required;
	
	      if (required) {
	        $element.addClass('fis-required');
	      } else if ($attrs.required == null) {
	        // eslint-disable-line
	        $element.removeClass('fis-required');
	      }
	    });
	
	    fisScopeUtils.watch($scope.$parent, $attrs.fisEditMode, function (editMode) {
	      $scope.fisEditMode = editMode;
	    });
	
	    /**
	     * @name registeredInputs
	     * @description Hash of model property to ngModel.
	     * Used by fisFieldMessage to dispatch valid state to ngModel
	     * @methodOf FieldController
	     */
	    $scope.registeredInputs = {};
	
	    var models = [];
	
	    /**
	     * @name registerInput
	     * @description Registers a ngModel controller. Invoked by fisInput controller
	     * @methodOf FieldController
	     */
	    $scope.registerInput = function (ngModel) {
	      if (ngModel.fisProperty) {
	        $scope.registeredInputs[ngModel.fisProperty] = ngModel;
	        models.push(ngModel);
	      }
	    };
	
	    $scope.unregisterInput = function (ngModel) {
	      if (ngModel.fisProperty && $scope.registeredInputs[ngModel.fisProperty] === ngModel) {
	        delete $scope.registeredInputs[ngModel.fisProperty];
	
	        var idx = models.indexOf(ngModel);
	        if (idx > -1) {
	          delete models[idx];
	        }
	      }
	    };
	
	    $scope.fieldValue = function () {
	      // TODO: provide access to fis-input element(s) inside transclusion
	      // scope.fisFieldValueFn is the callback that is provided by the linkWrapper
	      return $scope.fisFieldValueFn($scope, $element, $attrs, models);
	    };
	  };
	
	  // default function used by scope.fieldValue which only takes care of single input fields (single ngModel per field)
	  // the models passed to it will be decorated with fisLabel, fisProperty and fisInput properties (this is done in fisInput directive)
	  function fieldValueFn(scope, element, attrs, models) {
	    return models[0] && models[0].$modelValue || '';
	  }
	
	  /**
	   * @name FieldDirective
	   * @methodOf fis.fis.core.forms
	   */
	  var FieldDirective = function FieldDirective(options) {
	    var self = this;
	    options = options || {};
	
	    // Using default priority of 0, just like any other directive does
	    self.priority = 0;
	
	    // Overwrite it with whatever the user has specified.
	    // Don't use the || approach since it doesn't handle 0 gracefully.
	    if (options.priority !== undefined) {
	      self.priority = options.priority;
	    }
	
	    self.restrict = options.restrict || 'ACE';
	    self.require = options.require; // should merge with this and only return array of required to outside link fn
	    self.transclude = options.transclude || false;
	    self.scope = true;
	    self.editTemplate = options.editTemplate || '';
	    self.viewTemplate = options.viewTemplate || '{{fieldValue()}}';
	    self.fieldValue = options.fieldValue || fieldValueFn;
	
	    self.compiledTemplate = _.template(fieldTemplate);
	
	    self.controller = options.controller || ['$scope', '$element', '$attrs', '$transclude', '$parse', FieldController];
	
	    self.compile = function (element, attrs, transclude) {
	      var context = {
	        editTemplate: self.editTemplate,
	        viewTemplate: self.viewTemplate,
	        attrs: attrs
	      };
	
	      attrs.fisSize = attrs.fisSize || 'large';
	
	      // attaching the editTemplate and viewTemplate to the main fieldTemplate
	      var markup = self.compiledTemplate({ field: context });
	
	      if (markup.indexOf('<%') !== -1) {
	        markup = _.template(markup)({ field: context });
	      }
	
	      var tplElement = angular.element(markup);
	
	      /* Call moveAssignAttributesToInputs to move and assign attributes to inputs element
	        * - If elements have compile function with transclusion then input element added after compilation,
	        *  so in this case move and assign attributes after compilation done.
	        * - If input elements have link function then input element already added,
	        *  so in this case first move and assign attributes to input element and then call link function.
	        */
	      var result;
	
	      if (options.compile) {
	        // if the FieldDirective was provided with a compile function, invoke it.
	        // We pass it the tplElement we just created but also the original element to allow
	        // inspecting it in a provided compile function before it gets replaced below.
	        result = linkWrapper(options.compile(tplElement, attrs, transclude, element), self.fieldValue);
	        moveAssignAttributesToInputs(attrs, tplElement);
	      } else {
	        moveAssignAttributesToInputs(attrs, tplElement);
	        // return the link function
	        result = linkWrapper(options.link || angular.noop, self.fieldValue);
	      }
	
	      // replace the provided element with the newly constructed one.
	      element.replaceWith(tplElement);
	
	      return result;
	    };
	    return self;
	  };
	
	  // Function mo ves and assign attributes to input element
	  function moveAssignAttributesToInputs(attrs, tplElement) {
	    // find the input elements in the assembled template element
	    var inputs = findInputs(tplElement);
	
	    // find the label element in the assembled template element
	    var labels = findLabel(tplElement);
	
	    // move attributes from the template's root element to each input element found, following naming convention
	    moveAttributesToInputs(attrs, tplElement, inputs);
	
	    // assign additional attributes to inputs (e.g. ng-disabled)
	    assignAttributesToInputs(attrs, tplElement, inputs);
	
	    // move attributes from the template's root element to each label element found, following naming convention
	    moveAttributesToLabel(attrs, tplElement, labels);
	  }
	
	  function linkWrapper(linkFn, valueFn) {
	    return function (scope, element, attrs, ctrls) {
	      if (attrs.fisLabel === undefined) {
	        if (attrs.required != null) {
	          // eslint-disable-line
	          element.find('.control-label').addClass('without-fis-label');
	        }
	        element.find('.controls').addClass('without-fis-label');
	      }
	
	      attrs.$observe('ngRequiredInput', function (value) {
	        if (value === 'true') {
	          element.addClass('fis-required');
	        }
	      });
	
	      var editModelName = element.find('input').attr('ng-model');
	
	      if (!editModelName) {
	        editModelName = element.find('select').attr('ng-model');
	      }
	
	      fisUniqueIdService.generateUniqueId(scope, element.find('.fis-view-value'), attrs, 'view_' + editModelName);
	
	      scope.fisFieldValueFn = valueFn;
	      if (linkFn) {
	        linkFn(scope, element, attrs, ctrls);
	      }
	    };
	  }
	
	  /*
	    * @name moveAttributes
	    * @param attrs The angular Attributes object for the directive
	    * @param rootElement The angular decorated root element of the directive
	    * @param inputs A hash of input element name to decorate element.
	    * @private
	    */
	  function moveAttributesToInputs(attrs, rootElement, inputs) {
	    var rootAttrs = attrs;
	
	    // move attributes for each input found
	    angular.forEach(inputs, function (elem, name) {
	      var inputAttrs = getAttributesForInput(attrs, name);
	      // remove the attributes found from the rootAttrs
	      rootAttrs = _.omit(rootAttrs, _.keys(inputAttrs));
	      // Object.keys(inputAttrs).forEach(function (inputAttr){
	      //    rootAttrs[inputAttr] = undefined;
	      // });
	      // copy the attributes minus the ending part (i.e. ng-model-input becomes ng-model for the element marked as 'input')
	      angular.forEach(inputAttrs, function (attr) {
	        elem.attr(attr.name, attr.val);
	      });
	    });
	
	    // rootAttrs now contains only the attributes that were not assigned to inputs
	    // add them to the root element of the directive
	    angular.forEach(rootAttrs, function (val, key) {
	      if (key === 'class') {
	        rootElement.addClass(val);
	      } else {
	        var denormalized = attrs.$attr[key];
	        if (denormalized) {
	          rootElement.attr(denormalized, val);
	        }
	      }
	    });
	  }
	
	  /*
	    * @name moveAttributesToLabel
	    * @param attrs The angular Attributes object for the directive
	    * @param rootElement The angular decorated root element of the directive
	    * @param label A hash of label element name to decorate element.
	    * @private
	    */
	  function moveAttributesToLabel(attrs, rootElement, label) {
	    var rootAttrs = attrs;
	
	    // move attributes for each label found
	    angular.forEach(label, function (elem, name) {
	      var labelAttrs = getAttributesForLabel(attrs, name);
	
	      // remove the attributes found from the rootAttrs
	      rootAttrs = _.omit(rootAttrs, _.keys(labelAttrs));
	      // Object.keys(labelAttrs).forEach(function (labelAttr){
	      //    rootAttrs[labelAttr] = undefined;
	      // });
	
	      // copy the attributes minus the ending part (i.e. class-label becomes class for the element marked as 'label')
	      angular.forEach(labelAttrs, function (attr) {
	        if (attr.name === 'class') {
	          elem.addClass(attr.val);
	        } else {
	          elem.attr(attr.name, attr.val);
	        }
	      });
	    });
	
	    // rootAttrs now contains only the attributes that were not assigned to inputs
	    // add them to the root element of the directive
	    angular.forEach(rootAttrs, function (val, key) {
	      if (key === 'class') {
	        rootElement.addClass(val);
	      } else {
	        var denormalized = attrs.$attr[key];
	
	        if (denormalized) {
	          rootElement.attr(denormalized, val);
	        }
	      }
	    });
	  }
	
	  /*
	    * @description This function will make sure the template elements to be compiled follow our form field conventions
	    * so that widget developers and page developers don't have to know about them.
	    * @param {Object} attrs Angular Attributes object for the root element
	    * @param {Object} root The template's root element
	    * @param {Object} inputs The array of input elements
	    * @private
	    */
	  function assignAttributesToInputs(attrs, root, inputs) {
	    // TODO: if any of the input is marked required by a ng-required-value for example, put fis-required class on root element
	    angular.forEach(inputs, function (elem) {
	      elem.attr('ng-disabled', 'fisDisabled');
	      elem.attr('fis-unique-id', '');
	
	      if (attrs.required != null) {
	        // eslint-disable-line
	        // let's empty string ("") through, DON'T CHANGE TO !== ELSE THINGS BREAK
	        elem.attr('required', true);
	      } else {
	        elem.attr('ng-required', 'fisRequired');
	      }
	    });
	
	    if (attrs.required != null) {
	      // eslint-disable-line
	      // DON'T CHANGE TO !== ELSE THINGS BREAK
	      root.addClass('fis-required');
	    }
	  }
	
	  function getAttributesForInput(attrs, name) {
	    var ret = {};
	    var endsWith = '-' + name;
	    var re = new RegExp(endsWith + '$');
	
	    angular.forEach(attrs, function (val, key) {
	      var denormalized = attrs.$attr[key];
	
	      if (denormalized && denormalized.match(re)) {
	        // remove the last part of the attribute name
	        var attrName = denormalized.substring(0, denormalized.length - endsWith.length);
	        ret[key] = { name: attrName, val: val };
	      }
	    });
	
	    return ret;
	  }
	
	  function getAttributesForLabel(attrs, name) {
	    var ret = {};
	    var endsWith = '-' + name;
	    var re = new RegExp(endsWith + '$');
	
	    angular.forEach(attrs, function (val, key) {
	      var denormalized = attrs.$attr[key];
	
	      if (denormalized && denormalized.match(re)) {
	        // remove the last part of the attribute name
	        if (denormalized !== 'fis-label') {
	          var attrName = denormalized.substring(0, denormalized.length - endsWith.length);
	          ret[key] = { name: attrName, val: val };
	        }
	      }
	    });
	
	    return ret;
	  }
	
	  function findInputs(parent) {
	    var ret = {};
	
	    var nodeList = parent[0].querySelectorAll('[fis-input]');
	    for (var i = 0; i < nodeList.length; ++i) {
	      var elem = angular.element(nodeList[i]);
	      ret[elem.attr('fis-input') || 'input'] = elem;
	    }
	
	    return ret;
	  }
	
	  function findLabel(parent) {
	    var ret = {};
	
	    parent.find('label').each(function (index, n) {
	      var elem = angular.element(n);
	      ret[elem.attr('fis-label') || 'label'] = elem;
	    });
	
	    return ret;
	  }
	
	  return {
	
	    create: function create(options) {
	      return new FieldDirective(options);
	    },
	
	    // TODO: remove this when we have removed requireJS, only needed for tests to be able to access
	    _FieldController: FieldController
	
	  };
	}];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! underscore */ 22)))

/***/ }),
/* 22 */
/*!********************!*\
  !*** external "_" ***!
  \********************/
/***/ (function(module, exports) {

	module.exports = _;

/***/ }),
/* 23 */
/*!*************************************************!*\
  !*** ./directives/utils/scope-utils.factory.js ***!
  \*************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var service = {};
	
	  /**
	   * @description Allows setting a watch on a specified scope and invoke a callback with the watched value as an argument
	   * It also treats 'true'/'false' as hardcoded values and will not put a watch in these cases. This is useful when you are watching a directive attribute.
	   * @param {Object} scope The scope on witch to put a watch.
	   * @param {String} watched The scoped model to watch. If 'true' or 'false', the value is converted to a boolean and passed directly to the callback.
	   * @param {function} cb Callback to be invoked when the value changes. Can be invoked many times in the same $digest. Should be idempotent.
	   * @param {Object|String} def If provided, def will be passed to the callback if watched is falsy.
	   */
	  service.watch = function (scope, watched, cb, def) {
	    if (!cb) {
	      throw new Error('No callback provided!');
	    }
	
	    if (!watched) {
	      // check for null and undefined. DON'T CHANGE TO !== ELSE THINGS BREAK.
	      if (def != null) {
	        // eslint-disable-line
	        cb(def);
	      }
	      return;
	    }
	
	    if (watched === 'true') {
	      cb(true);
	    } else if (watched === 'false') {
	      cb(false);
	    } else {
	      scope.$watch(watched, function (value) {
	        cb(value);
	      });
	    }
	  };
	
	  /**
	   * Trigger a watch function once after a digest cycle competed
	   * @param scope scope to create the $watch at
	   * @param listener function returning the property to watch for (similarly to the first parameter you pass to regular scope.$watch)
	   * @param callback function ti be executed after the digest cycle completed
	   * @param $timeout reference to angular $timeout service
	   * @param apply boolean, true if the callback should be wrapped in scope.$apply, false to execute without wrapping
	   */
	  service.postDigest = function (scope, listener, callback, $timeout, apply) {
	    return function () {
	      var unregister;
	      var previous;
	      var timeout;
	
	      // Register some cleanup methods at the scope
	      scope.$on('$destroy', function () {
	        if (timeout) {
	          $timeout.cancel(timeout);
	        }
	        if (unregister) {
	          unregister();
	        }
	      });
	
	      function postDigest(callback) {
	        // Register a $watch with custom function as watchExpression.
	        // A watchExpression will be executed in every digest cycle
	        unregister = scope.$watch(function () {
	          // In the first digest cycle unregister this watch again
	          // to avoid creating multiple timeouts (infinity loop)
	          unregister();
	          // Create a timeout, this timeout will be executed after the digest cycle finished
	          timeout = $timeout(function () {
	            var current = listener();
	            // Check whether our listener changed
	            if (current !== previous) {
	              if (apply) {
	                // Execute callback in $scope.$apply phase
	                (function (current, previous) {
	                  scope.$apply(function () {
	                    callback(current, previous);
	                  });
	                })(current, previous);
	              } else {
	                callback(current, previous);
	              }
	              previous = current;
	            }
	            // Recursive call to register for the next digest cycle
	            postDigest(callback);
	          }, 0, false);
	        });
	      }
	
	      // Start postDigest Cycle
	      postDigest(callback);
	    }();
	  };
	
	  return service;
	};

/***/ }),
/* 24 */
/*!*******************************************************!*\
  !*** ./directives/utils/unique-id-service.factory.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  /**
	   * Replace all non alphanumeric characters by an underscore
	   * @param value which should be cleaned up
	   * @param spacesOnly boolean, whether only spaces should be replaced or all non alphanumeric characters
	   * @returns {String}
	   */
	  function replaceNonAlphaNumeric(value, spacesOnly) {
	    var pattern = /[^\w_\-]+/g;
	    if (spacesOnly) {
	      pattern = /[^\w]+/g;
	    }
	    return value.replace(pattern, '_');
	  }
	
	  /**
	   * Append extend to base, separated by an underscore if base is a string of non-zero length
	   * Otherwise extend gets returned
	   * @param base
	   * @param extend
	   * @returns {String} concatenation of base and extend, separated by underscore
	   */
	  function appendOrReplace(base, extend) {
	    var ret = base;
	    if (angular.isString(extend)) {
	      if (angular.isString(base) && base.length > 0) {
	        ret = base + '_' + extend;
	      } else {
	        ret = extend;
	      }
	    }
	    return ret;
	  }
	
	  var service = {
	
	    generateUniqueId: function () {
	      return function (scope, element, attributes, idBase, allowOverride, seed) {
	        if (angular.isString(idBase) && idBase.indexOf(' ') !== -1) {
	          return service.generateIdWithStaticSeed(scope, element, attributes, undefined, undefined, replaceNonAlphaNumeric(idBase, true), seed);
	        }
	
	        if (fis.initParams().appStage === 'T' || fis.initParams().appStage === 'D') {
	          // test appStage
	          return service.generateUniqueIdForce(scope, element, attributes, idBase, allowOverride, seed);
	        }
	      };
	    }(),
	
	    generateUniqueIdForce: function () {
	      var idCounter = {};
	      var initialized = false;
	
	      return function (scope, element, attributes, idBase, allowOverride, seed) {
	        if (!initialized) {
	          scope.$root.$on('$routeChangeStart', function () {
	            idCounter = {};
	          });
	          initialized = true;
	        }
	
	        // if the element already has an fisid we do not want to change it.
	        if (!allowOverride && element && angular.isDefined(element.attr('fisid'))) {
	          var nonGenId = element.attr('fisid');
	          return nonGenId;
	        }
	
	        var returnValue = idBase || '';
	
	        if (!returnValue) {
	          if (attributes.ngModel) {
	            returnValue = attributes.ngModel;
	          } else if (attributes.ngClick) {
	            if (scope.item && scope.item.path) {
	              returnValue = scope.item.path;
	            } else {
	              returnValue = attributes.ngClick;
	            }
	          } else if (attributes.fisI18n) {
	            returnValue = attributes.fisI18n;
	          }
	        }
	
	        if (seed === undefined) {
	          seed = '';
	        }
	
	        returnValue = replaceNonAlphaNumeric(returnValue) + seed;
	
	        if (idCounter[returnValue]) {
	          idCounter[returnValue] += 1;
	        } else {
	          idCounter[returnValue] = 1;
	        }
	        returnValue = returnValue + '_' + idCounter[returnValue];
	
	        if (element && (allowOverride || !element.attr('fisid'))) {
	          element.attr('fisid', returnValue);
	        }
	
	        return returnValue;
	      };
	    }(),
	
	    generateIdWithStaticSeed: function () {
	      return function (scope, element, attributes, idBase, childIdBase, staticId, seed) {
	        var idPrefix = attributes.fisUniqueIdSeed || idBase || '';
	
	        if (childIdBase) {
	          idPrefix += childIdBase;
	        }
	
	        idPrefix = appendOrReplace(idPrefix, angular.isArray(staticId) ? staticId.join('_') : staticId);
	
	        idPrefix = replaceNonAlphaNumeric(idPrefix);
	
	        if (seed === undefined) {
	          seed = '';
	        }
	        idPrefix += seed;
	
	        if (element && !element.attr('fisid')) {
	          element.attr('fisid', idPrefix);
	        }
	
	        return idPrefix;
	      };
	    }()
	
	  };
	
	  return service;
	};

/***/ }),
/* 25 */
/*!*********************************************!*\
  !*** ./directives/utils/input.directive.js ***!
  \*********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  function extractProperty(path, sep, $scope) {
	    var parts = path.split('.');
	
	    // To handle component case where user provide ng-model like '$ctrl.user.name'
	    if (parts.length > 1 && $scope && $scope.$ctrl && $scope.$ctrl.constructor.name !== 'AppComponentController') {
	      parts.splice(0, 1);
	    }
	
	    if (parts.length > 1) {
	      parts.splice(0, 1);
	    }
	
	    var result;
	    if (sep) {
	      result = parts.join(sep).replace(/[[\]]+/g, sep);
	    } else {
	      result = parts.join('.');
	    }
	    return result;
	  }
	
	  return {
	    restrict: 'AC',
	    priority: 400,
	    require: 'ngModel',
	    controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {
	      // before the ngModel controller is loaded (directive priority is higher),
	      // make sure there's a name assigned to the input so that the ngModel controller
	      // can register itself to the form with that name.
	      if (!$attrs.name && $attrs.ngModel) {
	        $attrs.name = extractProperty($attrs.ngModel, '_', $scope);
	      }
	    }],
	    link: function link(scope, element, attrs, ngModel) {
	      element.addClass('fis-input');
	
	      if (scope.registerInput) {
	        ngModel.fisProperty = extractProperty(attrs.ngModel, undefined, scope);
	        // useful when passed to FieldDirective's fieldValueFn.
	        ngModel.fisInput = attrs.fisInput || 'input';
	        ngModel.fisLabel = attrs.fisLabel;
	        if (attrs.name) {
	          ngModel.fisName = attrs.name;
	        }
	        scope.registerInput(ngModel);
	        element.on('$destroy', function () {
	          scope.unregisterInput(ngModel);
	        });
	      }
	    }
	  };
	};

/***/ }),
/* 26 */
/*!*************************************************************!*\
  !*** ./directives/utils/apply-class-directive.directive.js ***!
  \*************************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$compile", function ($compile) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    priority: 590,
	    terminal: true,
	    compile: function compile() {
	      return function postLink(scope, element, attrs) {
	        element.addClass(scope.$eval(attrs.fisApplyClassDirective));
	
	        $compile(element, null, 590)(scope);
	      };
	    }
	  };
	}];

/***/ }),
/* 27 */
/*!**********************************************************!*\
  !*** ./directives/utils/trigger-directives.directive.js ***!
  \**********************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (directive) {
	  return function () {
	    return {
	      restrict: 'A',
	      controller: ['$scope', '$attrs', function ($scope, $attrs) {
	        var self = this;
	
	        // put a watch on the attribute's expression and invoke the controller's trigger function
	        $scope.$watch($attrs[directive], function (newVal, oldVal) {
	          if (newVal !== oldVal) {
	            self.trigger($scope, newVal, oldVal);
	          }
	        }, true); // uses angular.equals
	
	        // default trigger function $broadcasts an event with the same name as the directive.
	        // Directives that require this directive can override this function and provide their own.
	        // Like this: triggerCtrl.trigger = function(scope, newVal, oldVal) {...}
	        self.trigger = function (scope, newVal, oldVal) {
	          scope.$broadcast(directive, { value: newVal, oldValue: oldVal });
	        };
	      }]
	    };
	  };
	};

/***/ }),
/* 28 */
/*!*************************************************!*\
  !*** ./directives/utils/unique-id.directive.js ***!
  \*************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisUniqueIdService", function (fisUniqueIdService) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    link: function link(scope, element, attributes) {
	      var seed = attributes.fisSeed;
	      if (seed === undefined) {
	        seed = '';
	      }
	      // if test mode, then we build up seeds for unique id's based on parents that contain fis-seed attributes
	      if (fis.initParams().appStage === 'T' || fis.initParams().appStage === 'D') {
	        if (seed.length > 0 && seed.charAt(0) !== '_') {
	          seed = '_' + seed;
	        }
	        var seedArr = element.parents('[fis-seed]');
	        if (seedArr.length > 0) {
	          for (var i = 0; i < seedArr.length; i++) {
	            var elem = angular.element(seedArr[i]);
	            seed = seed + '_' + elem.attr('fis-seed');
	            elem = undefined;
	          }
	        }
	      }
	      if (angular.isDefined(attributes.fisIdNoIncrement) && attributes.fisIdNoIncrement) {
	        fisUniqueIdService.generateIdWithStaticSeed(scope, element, attributes, undefined, undefined, attributes.fisUniqueId, seed);
	      } else if (attributes.fisIdNoIncrement !== '' && attributes.fisIdNoIncrement !== null) {
	        fisUniqueIdService.generateUniqueId(scope, element, attributes, attributes.fisUniqueId, undefined, seed);
	      } else {
	        fisUniqueIdService.generateUniqueId(scope, element, attributes, undefined, undefined, seed);
	      }
	    }
	  };
	}];

/***/ }),
/* 29 */
/*!**************************************!*\
  !*** ./directives/dragdrop/index.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _draggable = __webpack_require__(/*! ./draggable.directive */ 30);
	
	var _draggable2 = _interopRequireDefault(_draggable);
	
	var _dropTarget = __webpack_require__(/*! ./drop-target.directive */ 31);
	
	var _dropTarget2 = _interopRequireDefault(_dropTarget);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.directives.dragdrop', []);
	
	ngModule.directive('fisDraggable', _draggable2.default);
	ngModule.directive('fisDropTarget', _dropTarget2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 30 */
/*!****************************************************!*\
  !*** ./directives/dragdrop/draggable.directive.js ***!
  \****************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisPubSubService", function (fisPubSubService) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    link: function link(scope, element, attrs) {
	      var draggable = attrs.fisDraggable === true || attrs.fisDraggable === 'true';
	      element.attr('draggable', draggable);
	
	      var dragStartEvent = 'fisOnDragStart.' + attrs.fisDragDropType;
	      var dragEvent = 'fisOnDrag.' + attrs.fisDragDropType;
	      var dragEndEvent = 'fisOnDragEnd.' + attrs.fisDragDropType;
	
	      element.get(0).addEventListener('dragstart', function (e) {
	        fisPubSubService.publish(dragStartEvent, { event: e });
	      });
	
	      element.get(0).addEventListener('dragover', function (e) {
	        e.preventDefault();
	      });
	
	      element.get(0).addEventListener('drag', function (e) {
	        fisPubSubService.publish(dragEvent, { event: e });
	      });
	
	      element.get(0).addEventListener('dragend', function (e) {
	        fisPubSubService.publish(dragEndEvent, { event: e });
	      });
	    }
	  };
	}];

/***/ }),
/* 31 */
/*!******************************************************!*\
  !*** ./directives/dragdrop/drop-target.directive.js ***!
  \******************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisPubSubService", function (fisPubSubService) {
	  'ngInject';
	
	  return {
	    restrict: 'A',
	    link: function link(scope, element, attrs) {
	      var dragEnterEvent = 'fisOnDragEnter.' + attrs.fisDragDropType;
	      var dragLeaveEvent = 'fisOnDragLeave.' + attrs.fisDragDropType;
	      var dropEvent = 'fisOnDrop.' + attrs.fisDragDropType;
	
	      element.get(0).addEventListener('dragover', function (e) {
	        e.preventDefault();
	      });
	
	      element.get(0).addEventListener('dragenter', function (e) {
	        fisPubSubService.publish(dragEnterEvent, { event: e });
	      });
	
	      element.get(0).addEventListener('dragleave', function (e) {
	        fisPubSubService.publish(dragLeaveEvent, { event: e });
	      });
	
	      element.get(0).addEventListener('drop', function (e) {
	        e.preventDefault();
	        fisPubSubService.publish(dropEvent, { event: e });
	      });
	    }
	  };
	}];

/***/ }),
/* 32 */
/*!**************************!*\
  !*** ./filters/index.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _interpolate = __webpack_require__(/*! ./interpolate.filter */ 33);
	
	var _interpolate2 = _interopRequireDefault(_interpolate);
	
	var _search = __webpack_require__(/*! ./search.filter */ 34);
	
	var _search2 = _interopRequireDefault(_search);
	
	var _uncamelcase = __webpack_require__(/*! ./uncamelcase.filter */ 35);
	
	var _uncamelcase2 = _interopRequireDefault(_uncamelcase);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.filters', []);
	
	ngModule.filter('interpolate', _interpolate2.default);
	ngModule.filter('search', _search2.default);
	ngModule.filter('uncamelcase', _uncamelcase2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 33 */
/*!***************************************!*\
  !*** ./filters/interpolate.filter.js ***!
  \***************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                                               * @name interpolate
	                                                                                                                                                                                                                                                                               * @description This filter allows replacing markers in a string with values.
	                                                                                                                                                                                                                                                                               * You can give it an array of string values, a string or an object hash to map a string value to a name.</p>
	                                                                                                                                                                                                                                                                               * <p>For an array or a string, the interpolation markers need to contain the index:</p>
	                                                                                                                                                                                                                                                                               * <pre>'Hello {0}' | interpolate ['World'] => 'Hello World'
	                                                                                                                                                                                                                                                                               * 'Hello {0} | interpolate 'Pierre' => 'Hello Pierre'</pre>
	                                                                                                                                                                                                                                                                               * <p>For an object hash, the interpolation markers need to contain the hash keys:</p>
	                                                                                                                                                                                                                                                                               * <pre>'Hello {firstName} {lastName} | interpolate {firstName: 'Pierre', lastName: 'Asselin'} => Hello Pierre Asselin</pre>
	                                                                                                                                                                                                                                                                               * <p>You can also use this filter inside a service or a controller by injecting the $filter service:</p>
	                                                                                                                                                                                                                                                                               * <pre>$filter('interpolate')('Hello {0}')</pre>
	                                                                                                                                                                                                                                                                               * @param {String} text The text to interpolate the values with
	                                                                                                                                                                                                                                                                               * @param {Object|String[]|String} val The value(s) to use for interpolation
	                                                                                                                                                                                                                                                                               * @methodOf fis.core.filters
	                                                                                                                                                                                                                                                                               */
	
	
	exports.default = function () {
	  'use strict';
	
	  return function (text, val) {
	    if (text) {
	      var str = String(text);
	
	      if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) !== 'object' && typeof val !== 'array') {
	        // eslint-disable-line
	        val = [val];
	      }
	      for (var itm in val) {
	        if (itm) {
	          var re = new RegExp('\\{' + itm + '\\}', 'mg');
	          str = str.replace(re, val[itm]);
	        }
	      }
	      return str;
	    }
	
	    return '';
	  };
	};

/***/ }),
/* 34 */
/*!**********************************!*\
  !*** ./filters/search.filter.js ***!
  \**********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  return function (list, queryObj, property) {
	    var requiredObj;
	    var queryKeys = queryObj ? Object.keys(queryObj) : [];
	    list.some(function (item) {
	      var currentItemMatchesQueryObj = queryKeys.every(function (queryKey) {
	        return queryObj[queryKey] === item[queryKey];
	      });
	      if (currentItemMatchesQueryObj) {
	        requiredObj = item;
	        return true;
	      }
	      return false;
	    });
	    if (requiredObj) {
	      if (property) {
	        return requiredObj[property] || '';
	      }
	      return requiredObj;
	    }
	    return '';
	  };
	};

/***/ }),
/* 35 */
/*!***************************************!*\
  !*** ./filters/uncamelcase.filter.js ***!
  \***************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  return function (text) {
	    if (text) {
	      return text
	      // insert a space between lower & upper
	      .replace(/([a-z])([A-Z])/g, '$1 $2')
	      // space before last upper in a sequence followed by lower
	      .replace(/\b([A-Z]+)([A-Z])([a-z])/, '$1 $2$3')
	      // uppercase the first character
	      .replace(/^\w/, function (str) {
	        return str.toUpperCase();
	      });
	    }
	    return '';
	  };
	};

/***/ }),
/* 36 */
/*!***********************!*\
  !*** ./i18n/index.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _translate = __webpack_require__(/*! ./translate.filter */ 37);
	
	var _translate2 = _interopRequireDefault(_translate);
	
	var _i18n = __webpack_require__(/*! ./i18n.filter */ 38);
	
	var _i18n2 = _interopRequireDefault(_i18n);
	
	var _i18nService = __webpack_require__(/*! ./i18n-service.provider */ 39);
	
	var _i18nService2 = _interopRequireDefault(_i18nService);
	
	var _translate3 = __webpack_require__(/*! ./translate.provider */ 40);
	
	var _translate4 = _interopRequireDefault(_translate3);
	
	var _i18n3 = __webpack_require__(/*! ./i18n.directive */ 41);
	
	var _i18n4 = _interopRequireDefault(_i18n3);
	
	var _translate5 = __webpack_require__(/*! ./translate.directive */ 42);
	
	var _translate6 = _interopRequireDefault(_translate5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.i18n', []);
	
	ngModule.filter('translate', _translate2.default);
	ngModule.filter('i18n', _i18n2.default);
	
	ngModule.provider('fisI18nService', _i18nService2.default);
	ngModule.provider('$translate', _translate4.default);
	
	ngModule.directive('fisI18n', _i18n4.default);
	ngModule.directive('translate', _translate6.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 37 */
/*!**********************************!*\
  !*** ./i18n/translate.filter.js ***!
  \**********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$translate", function ($translate) {
	  'ngInject';
	
	  return function (key, defaultValue) {
	    console.warn('You are using dummy translate filter. Please load and use angular-translate in your application or add a dependency on fis.i18n module');
	    return $translate.instant(key, defaultValue);
	  };
	}];

/***/ }),
/* 38 */
/*!*****************************!*\
  !*** ./i18n/i18n.filter.js ***!
  \*****************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["fisI18nService", "fisViewPanelService", function (fisI18nService, fisViewPanelService) {
	  'ngInject';
	
	  return function (key, DefalutValue) {
	    if (angular.isDefined(key)) {
	      if (key.indexOf('.') === -1) {
	        var view = fisViewPanelService.activeViewPanel();
	        if (view) {
	          key = [view.module, view.id, key];
	        }
	      }
	      return fisI18nService.translate(key, DefalutValue);
	    }
	  };
	}];

/***/ }),
/* 39 */
/*!***************************************!*\
  !*** ./i18n/i18n-service.provider.js ***!
  \***************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  var self = this;
	  var NOT_FOUND = '__NOT_FOUND__';
	
	  var defaultLocale = 'en';
	  self.setDefaultLocale = function (locale) {
	    defaultLocale = locale;
	  };
	
	  self.$get = ['$rootScope', '$http', '$q', '$location', 'fisPubSubService', 'fisConfig', '$translate', function ($rootScope, $http, $q, $location, fisPubSubService, conf, $translate) {
	    var serv = {};
	
	    var supportedLanguagesDeferred = $q.defer();
	    serv.supportedLanguages = supportedLanguagesDeferred.promise;
	
	    /**
	     * @name defaultLocale
	     * @description Getter function to access the framework default locale
	     * @return the default framework locale
	     * @methodOf angular.module('fis.core').fisI18nService
	     */
	    serv.defaultLocale = function () {
	      return defaultLocale;
	    };
	
	    var cancelTranslateLoadingSuccess = $rootScope.$on('$translateLoadingSuccess', function () {
	      fisPubSubService.publish('shell.i18nReady');
	      cancelTranslateLoadingSuccess();
	    });
	
	    /**
	     * @name locale
	     * @description Getter/setter function to access the current locale
	     *  @param [locale] The locale string to be set (optional).
	     *  @return the current locale
	     *  @methodOf angular.module('fis.core').fisI18nService
	     */
	    serv.locale = function (locale) {
	      if (locale) {
	        // only way to only request a single language is to
	        $translate.use(locale);
	        $http.defaults.headers.common['Accept-Language'] = locale;
	        fisPubSubService.publish('fisLocaleChanged', locale);
	      }
	
	      return locale || $translate.proposedLanguage();
	    };
	
	    serv.isTranslationReady = function () {
	      if ($translate.isReady() && $translate.getTranslationTable($translate.proposedLanguage()) !== null) {
	        return true;
	      }
	      return false;
	    };
	
	    function processLocaleConfiguration(defaultLang) {
	      var initLang = $location.search().lang || serv.defaultLocale();
	      if (initLang !== defaultLang && conf.supportedLanguages) {
	        // First check for actual language code like "de-CH" from supported language list
	        var foundLang;
	        conf.supportedLanguages.some(function (language) {
	          if (angular.equals(language.value, defaultLang)) {
	            foundLang = language;
	            return true;
	          }
	          return false;
	        });
	        // if not found then check for a fallback standard language code
	        // like "de" from supported language list
	        if (angular.isUndefined(foundLang)) {
	          var standardLangCode = defaultLang.split('-');
	          conf.supportedLanguages.some(function (language) {
	            if (angular.equals(language.value, standardLangCode[0])) {
	              foundLang = language;
	              return true;
	            }
	            return false;
	          });
	        }
	        if (angular.isDefined(foundLang)) {
	          initLang = foundLang.value ? foundLang.value : initLang;
	        }
	      }
	
	      $http.defaults.headers.common['Accept-Language'] = initLang;
	
	      $translate.use(initLang);
	
	      // only invoked once on load of the page (once config is loaded)
	      fisPubSubService.publish('fisLocaleSet', initLang);
	
	      supportedLanguagesDeferred.resolve(conf.supportedLanguages);
	      // Put the $location in the rootScope so that we can watch it
	      $rootScope.location = $location;
	
	      // put a watch on the lang request parameter and change the locale according to that parameter
	      $rootScope.$watch('location.search().lang', function (lang) {
	        if (lang && lang !== serv.locale()) {
	          serv.locale(lang);
	          // FIXME: removing the lang param because it screws up routes.
	          $rootScope.location.search('lang', null);
	        }
	      });
	    }
	    processLocaleConfiguration(fetchLocaleFromConfig());
	    // return config locale or fetch locale from browser
	    function fetchLocale() {
	      if (angular.isDefined(conf.locale)) {
	        return conf.locale;
	      }
	      return findBestDefaultLanguage();
	    }
	
	    // Retrieve locale as per configuration provided by user
	    function fetchLocaleFromConfig() {
	      var defaultLang = serv.defaultLocale();
	      if (angular.isDefined(conf.preferredLocale)) {
	        if (conf.preferredLocale === 'browser') {
	          defaultLang = findBestDefaultLanguage();
	        } else {
	          defaultLang = fetchLocale();
	        }
	      } else {
	        defaultLang = fetchLocale();
	      }
	      return defaultLang;
	    }
	
	    // find the closest language we can from what is sent through the "Accept-Language" header.
	    // After invocation of processLocaleConfiguration, we set the Accept-Language headers.
	    // Therefore, the config service's request is made using the browser's Accept-Language so the
	    // server can also return the language it receives.
	    function findBestDefaultLanguage() {
	      // Chrome and Firefox return the Accept-Language languages with navigator.languages.
	      // Not supported in other browsers
	      if (window.navigator.languages) {
	        return window.navigator.languages[0];
	      }
	
	      // Most supported. Returns Accept-Language on older firefox and OS language on IE 11
	      if (window.navigator.language) {
	        return window.navigator.language;
	      }
	
	      // IE specific property. Returns the operating system's natural language setting.
	      // http://msdn.microsoft.com/en-us/library/ie/ms535867(v=vs.85).aspx
	      if (window.navigator.userLanguage) {
	        return window.navigator.userLanguage;
	      }
	
	      // all supported browsers should have returned already
	      return 'en';
	    }
	
	    // This function is used to get the translated values for the specified keys
	    function getTranslatedValues(keysToTranslate, def, key, translations, translation) {
	      for (var i = 0; i < keysToTranslate.length; i++) {
	        // $translate.instant removes white spaces from string so compare trimmed value here as well
	        if (translations[keysToTranslate[i]] !== keysToTranslate[i].trim()) {
	          translation = translations[keysToTranslate[i]];
	          break;
	        }
	      }
	      return translation === NOT_FOUND ? (def === null || def === undefined) && key.join('.') || def : translation;
	    }
	
	    // This function returns the keysToTranslate array
	    function getKeysToTranslate(key) {
	      if (angular.isArray(key)) {
	        var ns = angular.copy(key);
	        var keysToTranslate = [];
	        while (ns.length > 0) {
	          if (ns[0]) {
	            keysToTranslate.push(ns.join('.'));
	          }
	          ns.shift();
	        }
	        return keysToTranslate;
	      }
	    }
	
	    /**
	     * @name translate
	     * @description provides a translation for the provided key
	     * @param {string|string[]} key The key to be translated. If an array, the service will try from the most significant (all elements joined to form a key) to the least significant (only the last element is used as the key)
	     * @param {string} [def] The default string to use if no translations are available
	     * @return The translated text if found, the default string provided or the key itself if nothing else can be returned
	     * @methodOf angular.module('fis.core').fisI18nService
	     */
	
	    // using $translate.instant
	    serv.translate = function (key, def) {
	      var translation = NOT_FOUND;
	      if (angular.isString(key)) {
	        key = key.split('.');
	      }
	      if (angular.isArray(key)) {
	        var keysToTranslate = getKeysToTranslate(key);
	        var translations = $translate.instant(keysToTranslate);
	        return getTranslatedValues(keysToTranslate, def, key, translations, translation);
	      }
	      return def || key;
	    };
	
	    /**
	     * @name translateAsync
	     * @description provides a translation for the provided key when translation data is not yet loaded
	     * @param {string|string[]} key The key to be translated. If an array, the service will try from the most significant (all elements joined to form a key) to the least significant (only the last element is used as the key)
	     * @param {string} [def] The default string to use if no translations are available
	     * @return Promise which will get resolved to the translated text if found, the default string provided or the key itself if nothing else can be returned
	     * @methodOf angular.module('fis.core').fisI18nService
	     */
	    serv.translateAsync = function (key, def) {
	      var translation = NOT_FOUND;
	      var translations;
	      var asyncTranslation = $q.defer();
	      if (angular.isString(key)) {
	        key = key.split('.');
	      }
	      var keysToTranslate = getKeysToTranslate(key);
	      // We have subscribed to '$translateChangeSuccess' event published by angular.translate module.
	      // Once the translation object is available, we will resolve the promise for UI translation of data.
	      var cancelTranslateChangeSuccess = $rootScope.$on('$translateChangeSuccess', function () {
	        translations = $translate.instant(keysToTranslate);
	        var result = getTranslatedValues(keysToTranslate, def, key, translations, translation);
	        asyncTranslation.resolve(result);
	        // un-registering '$translateChangeSuccess' event handler
	        cancelTranslateChangeSuccess();
	      });
	      return asyncTranslation.promise;
	    };
	    return serv;
	  }];
	};

/***/ }),
/* 40 */
/*!************************************!*\
  !*** ./i18n/translate.provider.js ***!
  \************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  var warningPrinted = false;
	  function dummy() {
	    if (!warningPrinted) {
	      warningPrinted = true;
	      console.warn('You are using dummy angular-translate APIs. Please load and use angular-translate in your application or add a dependency on fis.i18n module');
	    }
	  }
	
	  self.preferredLanguage = self.use = self.translations = dummy;
	
	  self.$get = ['$q', function ($q) {
	    var lang = '';
	    var $translate = function $translate(translationId, interpolateParams, interpolationId, defaultTranslationText /* , forceLanguage*/) {
	      dummy();
	      var deferred = $q.defer();
	      if (defaultTranslationText) {
	        deferred.resolve(defaultTranslationText);
	      } else {
	        deferred.resolve($translate.instant(translationId));
	      }
	      return deferred.promise;
	    };
	
	    $translate.instant = function (translationId /* , interpolateParams, interpolationId , forceLanguage*/) {
	      dummy();
	      var result = '';
	      if (angular.isArray(translationId) && translationId.length > 0) {
	        result = {};
	        translationId.forEach(function (key) {
	          result[key] = key;
	        });
	      } else {
	        result = translationId;
	      }
	      return result;
	    };
	
	    $translate.use = function (language) {
	      lang = language;
	      dummy();
	    };
	
	    $translate.proposedLanguage = function () {
	      dummy();
	      return lang;
	    };
	
	    return $translate;
	  }];
	};

/***/ }),
/* 41 */
/*!********************************!*\
  !*** ./i18n/i18n.directive.js ***!
  \********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    restrict: 'A',
	    link: function link(scope, element, attrs) {
	      if (!attrs.fisI18n) {
	        throw new Error('Should provide a value for the fis-i18n attribute');
	      }
	      element.html(scope.i18n(attrs.fisI18n, element.html() || undefined));
	    }
	  };
	};

/***/ }),
/* 42 */
/*!*************************************!*\
  !*** ./i18n/translate.directive.js ***!
  \*************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    restrict: 'AE',
	    link: function link(scope, element, attrs) {
	      console.warn('You are using dummy translate directive. Please load and use angular-translate in your application or add a dependency on fis.i18n module');
	      if (attrs.translate) {
	        element.html(attrs.translate);
	      } else {
	        element.html(element.text());
	      }
	    }
	  };
	};

/***/ }),
/* 43 */
/*!*************************!*\
  !*** ./pubsub/index.js ***!
  \*************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _pubsub = __webpack_require__(/*! ./pubsub.directive */ 44);
	
	var _pubsub2 = _interopRequireDefault(_pubsub);
	
	var _pubsub3 = __webpack_require__(/*! ./pubsub.service */ 45);
	
	var _pubsub4 = _interopRequireDefault(_pubsub3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.pubsub', []);
	
	ngModule.directive('fisPubSub', _pubsub2.default);
	ngModule.service('fisPubSubService', _pubsub4.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 44 */
/*!************************************!*\
  !*** ./pubsub/pubsub.directive.js ***!
  \************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                                               * @name fisPubSub
	                                                                                                                                                                                                                                                                               * @description event handling service for the framework
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               */
	
	
	exports.default = function () {
	  return {
	    restrict: 'A',
	    controller: ['$scope', 'fisPubSubService', function ($scope, fisPubSubService) {
	      var unsubs = [];
	      $scope.subscribe = function (topic, cb) {
	        var unsubscribe = fisPubSubService.subscribe(topic, cb);
	        unsubs.push(unsubscribe);
	        return unsubscribe;
	      };
	
	      $scope.publish = function (topic, payload) {
	        if ((typeof payload === 'undefined' ? 'undefined' : _typeof(payload)) === 'object') {
	          payload.$scope = $scope;
	        }
	
	        if ($scope.$root.$$phase === '$apply' || $scope.$root.$$phase === '$digest') {
	          return fisPubSubService.publish(topic, payload);
	        }
	
	        $scope.$apply(function () {
	          return fisPubSubService.publish(topic, payload);
	        });
	      };
	
	      // unsubscribe events when scope is destroyed
	      $scope.$on('$destroy', function () {
	        while (unsubs.length > 0) {
	          unsubs.pop()(); // pop the unsubscribe function and invoke it.
	        }
	      });
	    }]
	  };
	};

/***/ }),
/* 45 */
/*!**********************************!*\
  !*** ./pubsub/pubsub.service.js ***!
  \**********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$q", function ($q) {
	  'ngInject';
	
	  var listeners = {};
	  var count = 0;
	
	  function addListener(topic, callback, sticky) {
	    var id = count++;
	    if (!callback || !topic) {
	      return;
	    }
	    listeners[topic] = listeners[topic] || {};
	    listeners[topic]._sticky = sticky || listeners[topic]._sticky;
	    listeners[topic][id] = callback;
	
	    if (sticky && listeners[topic]._lastPayload !== undefined) {
	      // invoke callback immediately with the last payload
	      callback.call(listeners[topic]._lastPayload, listeners[topic]._lastPayload, topic);
	    }
	    var ret = function ret() {
	      // handle allows removing the listener
	      if (listeners[topic] && listeners[topic][id]) {
	        delete listeners[topic][id];
	      }
	    };
	    // add properties to function to allow inspecting the topic it is attached to.
	    ret.topic = topic;
	    ret.id = id;
	    return ret;
	  }
	
	  /**
	   * @name publish
	   * @description Publish to a topic
	   * @param [topic, payload] Passing the topic information and payload information.
	   */
	  this.publish = function (topic, payload) {
	    var deferred = $q.defer();
	    var retPromises = [];
	    var l = listeners[topic] || {};
	
	    if (l._sticky) {
	      l._lastPayload = payload;
	    }
	    for (var i in l) {
	      if (i.indexOf('_') !== 0) {
	        // Wrap every returned value into a promise. Non-promise return values will be resolved
	        // immediately.
	        retPromises.push($q.when(l[i].call(payload, payload, topic)));
	      }
	    }
	
	    $q.all(retPromises).then(function (retVals) {
	      if (retVals.indexOf(false) > -1) {
	        deferred.reject();
	      } else {
	        deferred.resolve(retVals);
	      }
	    }, function () {
	      deferred.reject();
	    });
	
	    return deferred.promise;
	  };
	
	  /**
	   * @name subscribe
	   * @description Subscribe to a topic
	   * @param [topic, callback, sticky]
	   * @memberOf sungard.event
	   * @returns Adds the listener and passes the handle.
	   */
	  this.subscribe = function (topic, callback, sticky) {
	    return addListener(topic, callback, sticky);
	  };
	
	  /**
	   * @name unsubscribe
	   * @description Unsubscribe to a topic
	   * @param [handle] Passing the handle to find out the topic information from the handle.
	   * @memberOf sungard.event
	   */
	  this.unsubscribe = function (handle) {
	    if (typeof handle === 'function') {
	      handle();
	    } else if (listeners[handle.topic] && listeners[handle.topic][handle.id]) {
	      delete listeners[handle.topic][handle.id];
	    }
	  };
	}];

/***/ }),
/* 46 */
/*!***************************!*\
  !*** ./services/index.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _exceptionHandler = __webpack_require__(/*! ./exception-handler.decorator */ 47);
	
	var _exceptionHandler2 = _interopRequireDefault(_exceptionHandler);
	
	var _clientStorageService = __webpack_require__(/*! ./client-storage-service.provider */ 48);
	
	var _clientStorageService2 = _interopRequireDefault(_clientStorageService);
	
	var _conditionalLoaderService = __webpack_require__(/*! ./conditional-loader-service.factory */ 49);
	
	var _conditionalLoaderService2 = _interopRequireDefault(_conditionalLoaderService);
	
	var _configServiceProvider = __webpack_require__(/*! ./config-service.provider.js */ 50);
	
	var _configServiceProvider2 = _interopRequireDefault(_configServiceProvider);
	
	var _httpErrorInterceptorProvider = __webpack_require__(/*! ./http-error-interceptor.provider.js */ 51);
	
	var _httpErrorInterceptorProvider2 = _interopRequireDefault(_httpErrorInterceptorProvider);
	
	var _templateCacheServiceProvider = __webpack_require__(/*! ./template-cache-service.provider.js */ 52);
	
	var _templateCacheServiceProvider2 = _interopRequireDefault(_templateCacheServiceProvider);
	
	var _userContextServiceProvider = __webpack_require__(/*! ./user-context-service.provider.js */ 53);
	
	var _userContextServiceProvider2 = _interopRequireDefault(_userContextServiceProvider);
	
	var _httpErrorInterceptorConfig = __webpack_require__(/*! ./http-error-interceptor.config.js */ 54);
	
	var _httpErrorInterceptorConfig2 = _interopRequireDefault(_httpErrorInterceptorConfig);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.services', []);
	
	ngModule.decorator('$exceptionHandler', _exceptionHandler2.default);
	
	ngModule.provider('fisClientStorageService', _clientStorageService2.default);
	ngModule.provider('fisConfigService', _configServiceProvider2.default);
	ngModule.provider('fisHttpErrorInterceptor', _httpErrorInterceptorProvider2.default);
	ngModule.provider('fisTemplateCacheService', _templateCacheServiceProvider2.default);
	ngModule.provider('fisUserContextService', _userContextServiceProvider2.default);
	
	ngModule.factory('fisConditionalLoaderService', _conditionalLoaderService2.default);
	
	ngModule.config(_httpErrorInterceptorConfig2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 47 */
/*!*************************************************!*\
  !*** ./services/exception-handler.decorator.js ***!
  \*************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$delegate", function ($delegate) {
	  'ngInject';
	
	  var doc = '\nSee https://www.csa.sungard.com/wiki/x/9xVMB';
	  var interceptors = {};
	  var ANY = '_any';
	
	  var handler = function exceptionHandler(exception, cause) {
	    var prop;
	    for (prop in interceptors) {
	      if (prop === ANY || exception.hasOwnProperty(prop)) {
	        interceptors[prop](exception, cause);
	      }
	    }
	
	    $delegate(exception, cause);
	  };
	
	  handler.intercept = function intercept(property, cb) {
	    if (!property) {
	      delete interceptors[ANY];
	      return;
	    }
	
	    if (angular.isFunction(property)) {
	      cb = property;
	      property = ANY;
	    }
	
	    if (angular.isString(property)) {
	      if (angular.isFunction(cb)) {
	        interceptors[property] = cb;
	      } else {
	        delete interceptors[property];
	      }
	    }
	  };
	
	  handler.intercept('userMessage', function (exception) {
	    exception.message += doc;
	  });
	
	  return handler;
	}];

/***/ }),
/* 48 */
/*!*****************************************************!*\
  !*** ./services/client-storage-service.provider.js ***!
  \*****************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  self.$get = ['$window', 'fisUserContextService', function ($window, fisUserContextService) {
	    var service = {};
	    var separator = '_';
	    var inited = false;
	    var appId;
	
	    service.init = function (id) {
	      appId = id;
	      inited = true;
	    };
	
	    function createStorageKey(key) {
	      var userKey = fisUserContextService.context() ? fisUserContextService.context().userId : null;
	      if (appId) {
	        if (userKey) {
	          return appId + separator + userKey + separator + key;
	        }
	        return appId + separator + key;
	      } else if (userKey) {
	        return userKey + separator + key;
	      }
	      return key;
	    }
	
	    /**
	     * method to persist data in client storage
	     * @param {String} key    key
	     * @param {Object} val    Object to be stored in client storage
	     * @param {Object|String} opts Optional additional attributes like scope (app or user) and storageType (session or default) | storageType
	     */
	    service.setItem = function (key, val, opts) {
	      if (!inited) {
	        throw new Error('Service not initialized with appId');
	      }
	      var storageKey = createStorageKey(key);
	      if ($window.sessionStorage && $window.localStorage) {
	        if (opts && (opts === 'session' || opts.storageType === 'session')) {
	          // options present, work with it
	          $window.sessionStorage.setItem(storageKey, angular.toJson(val));
	        } else {
	          // Add to localStorage
	          $window.localStorage.setItem(storageKey, angular.toJson(val));
	        }
	      } else {
	        throw new Error('localStorage/sessionStorage not supported by browser');
	      }
	    };
	
	    /**
	     * Method to get item from Client Storage
	     * @param  {String} key   Key
	     * @return {Object}       Object stored in Client storage
	     */
	    service.getItem = function (key) {
	      if (!inited) {
	        throw new Error('Service not initialized with appId');
	      }
	      if ($window.sessionStorage && $window.localStorage) {
	        var storageKey = createStorageKey(key);
	        return angular.fromJson($window.localStorage.getItem(storageKey)) || angular.fromJson($window.sessionStorage.getItem(storageKey));
	      }
	      throw new Error('localStorage/sessionStorage not supported by browser');
	    };
	
	    /**
	     * Method to remove item from Client Storage
	     * @param  {String} key   Key of the item to be removed
	     */
	    service.removeItem = function (key) {
	      if (!inited) {
	        throw new Error('Service not initialized with appId');
	      }
	      if ($window.sessionStorage && $window.localStorage) {
	        var storageKey = createStorageKey(key);
	        $window.localStorage.removeItem(storageKey);
	        $window.sessionStorage.removeItem(storageKey);
	      } else {
	        throw new Error('localStorage/sessionStorage not supported by browser');
	      }
	    };
	
	    return service;
	  }];
	};

/***/ }),
/* 49 */
/*!********************************************************!*\
  !*** ./services/conditional-loader-service.factory.js ***!
  \********************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$resource", "$q", "fisPubSubService", "$injector", function ($resource, $q, fisPubSubService, $injector) {
	  'ngInject';
	
	  function publishEvent(name, value) {
	    if (name) {
	      fisPubSubService.publish(name, value);
	    }
	  }
	
	  function conditionalLoader(constantName, urlTemplate, urlParams, eventName) {
	    var deferred;
	    var event = eventName || constantName && constantName + '.loaded';
	    var value;
	
	    if ($injector.has(constantName)) {
	      value = $injector.get(constantName);
	      publishEvent(event, value);
	      value.then = function syncThen(cb) {
	        return cb(value);
	      };
	      return value;
	    }
	    // return an aync promise
	    deferred = $q.defer();
	
	    if (!urlTemplate) {
	      deferred.reject('No ' + constantName + ' constant found and no URL to GET.');
	      return deferred.promise;
	    }
	
	    $resource(urlTemplate).get(urlParams || {}, function loadSuccess(value) {
	      var prop;
	
	      deferred.resolve(value);
	      publishEvent(event, value);
	
	      for (prop in value) {
	        if (value.hasOwnProperty(prop)) {
	          deferred.promise[prop] = value[prop];
	        }
	      }
	    }, function loadFailure(httpResponse) {
	      deferred.reject(httpResponse);
	    });
	    return deferred.promise;
	  }
	
	  return conditionalLoader;
	}];

/***/ }),
/* 50 */
/*!*********************************************!*\
  !*** ./services/config-service.provider.js ***!
  \*********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  var provider = this;
	  var eventName = 'shell.configReady';
	  var defaultFactory;
	
	  provider.config = function setConfig(cfg) {
	    if (angular.isObject(cfg)) {
	      cfg.then = function (cb) {
	        return cb(cfg);
	      };
	      provider.$get = function () {
	        return cfg;
	      };
	    } else {
	      provider.$get = defaultFactory;
	    }
	  };
	
	  defaultFactory = provider.$get = ['$resource', '$q', 'fisPubSubService', '$injector', 'fisConditionalLoaderService', function ($resource, $q, fisPubSubService, $injector, loader) {
	    var configPromise;
	
	    if (!$injector.has('fisConfig')) {
	      console.warn('DEPRECATED. Use a fisConfig constant instead to improve load speed.', 'https://www.csa.sungard.com/wiki/x/ggfNAg');
	    }
	
	    configPromise = loader('fisConfig', fis.initParams().configEndpoint, {}, eventName);
	
	    configPromise.then(function success() {
	      console.log('- Framework config loaded.');
	    }, function failure(err) {
	      // If err is a http response object, throw an error to notify developer the
	      // config endpoint used is not working.
	      // If not a response object, it means the developer intentionally left the configEnpoint empty
	      // and does not use the config service. This is not possible when using fis.start.
	      if (err.status) {
	        throw new Error('Framework config is required!');
	      }
	    });
	
	    return configPromise;
	  }];
	};

/***/ }),
/* 51 */
/*!*****************************************************!*\
  !*** ./services/http-error-interceptor.provider.js ***!
  \*****************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var provider = this;
	
	  // default HTTP status for firing fisLoginRequired: 403 Forbidden
	  var loginStatuses = [403];
	
	  provider.setLoginRequiredStatus = function (httpStatuses) {
	    var i;
	    loginStatuses = [];
	    if (angular.isNumber(httpStatuses)) {
	      loginStatuses = [httpStatuses];
	    } else if (angular.isArray(httpStatuses)) {
	      for (i = 0; i < httpStatuses.length; i++) {
	        if (angular.isNumber(httpStatuses[i])) {
	          loginStatuses.push(httpStatuses[i]);
	        }
	      }
	    }
	  };
	
	  provider.$get = ['$rootScope', '$q', 'fisPubSubService', function ($rootScope, $q, fisPubSubService) {
	    var successFn = function success(response) {
	      return response;
	    };
	
	    // default strategy is to reject but fire events.
	    // Another strategy could be to allow trying requests again after app confirms login (https://github.com/witoldsz/angular-http-auth)
	    var rejectNoRetry = function error(response) {
	      // check if the received error is in the HTTP statuses configured to $broadcast a fisLoginRequired event
	      if (loginStatuses.indexOf(response.status) !== -1) {
	        $rootScope.$broadcast('fisLoginRequired', response);
	      }
	
	      // publish response to the fisHTTPError topic
	      if (response.status >= 400 || response.status === 0) {
	        fisPubSubService.publish('fisHTTPError', response);
	      }
	      // 3xx range statuses are also going through this error callback but are not errors
	      // A strategy could try to load the location received in the response headers before rejecting the promise.
	
	      // reject the response and continue in chain
	      return $q.reject(response);
	    };
	
	    return {
	      response: successFn,
	      responseError: rejectNoRetry
	    };
	  }];
	};

/***/ }),
/* 52 */
/*!*****************************************************!*\
  !*** ./services/template-cache-service.provider.js ***!
  \*****************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  /**
	  * @private
	  */
	  var self = this;
	
	  /**
	  * @name $get
	  * @methodOf fisTemplateCacheService
	  * @description <p>Factory method to create instance of fisTemplateCacheService.</p>
	  */
	  self.$get = ['$templateCache', function ($templateCache) {
	    var service = {};
	
	    service.getTemplate = function (templateName) {
	      return $templateCache.get(templateName);
	    };
	
	    service.addTemplate = function (templateName, template) {
	      $templateCache.put(templateName, template);
	    };
	
	    service.removeTemplate = function (templateName) {
	      $templateCache.remove(templateName);
	    };
	
	    return service;
	  }];
	};

/***/ }),
/* 53 */
/*!***************************************************!*\
  !*** ./services/user-context-service.provider.js ***!
  \***************************************************/
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  self.$get = [function () {
	    var serv = {};
	
	    var userInContext;
	
	    serv.context = function (user) {
	      if (arguments.length === 1) {
	        userInContext = user;
	      } else {
	        var clonedUser = angular.copy(userInContext);
	        return clonedUser;
	      }
	    };
	    return serv;
	  }];
	};

/***/ }),
/* 54 */
/*!***************************************************!*\
  !*** ./services/http-error-interceptor.config.js ***!
  \***************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$httpProvider", function ($httpProvider) {
	  'ngInject';
	
	  $httpProvider.interceptors.push('fisHttpErrorInterceptor');
	}];

/***/ }),
/* 55 */
/*!************************!*\
  !*** ./utils/index.js ***!
  \************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _memoryUtilService = __webpack_require__(/*! ./memory-util-service.provider */ 56);
	
	var _memoryUtilService2 = _interopRequireDefault(_memoryUtilService);
	
	var _utilService = __webpack_require__(/*! ./util-service.provider */ 57);
	
	var _utilService2 = _interopRequireDefault(_utilService);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.utils', []);
	
	ngModule.provider('fisMemoryUtilService', _memoryUtilService2.default);
	ngModule.provider('fisUtilService', _utilService2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 56 */
/*!***********************************************!*\
  !*** ./utils/memory-util-service.provider.js ***!
  \***********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  self.$get = [function () {
	    var service = {};
	
	    service.enabled = true;
	    service.logging = false;
	
	    if (!service.enabled) {
	      console.warn('fisMemoryUtilService has been disabled!');
	    }
	
	    /**
	     * Convenience method attempty to clean off all references to enable garbage collection
	     * @param node -  the element to be cleaned
	     */
	    service.callCleanAll = function (node) {
	      service.removeListeners(node);
	      service.destroyNode(node);
	    };
	
	    /**
	     * Attempts to remove all listeners from node.
	     * @param domNode
	     */
	    service.removeListeners = function (domNode) {
	      if (angular.isDefined(domNode)) {
	        var node = $(domNode);
	        if (node.length === 1) {
	          var children = node.children();
	          if (angular.isDefined(children) && children.length > 0) {
	            children.get().forEach(function (child) {
	              service.removeListeners(child);
	            });
	          }
	        }
	        if (node.length > 1) {
	          // node is a "jQuery" object
	          node.get().forEach(function (child) {
	            service.removeListeners(child);
	          });
	        } else {
	          if (node.scope()) {
	            node.scope().$destroy(); // in case this is implemented in scope.
	          }
	          node.unbind();
	        }
	      }
	    };
	
	    /**
	     * Utility method to destroy node (html elements like dom nodes)
	     * https://developer.mozilla.org/en-US/docs/Web/API/Node.removeChild
	     * @param node to be destroyed.
	     */
	    service.destroyNode = function (node) {
	      if (node) {
	        service.destroyAllChildNodes(node);
	        if (node.parent) {
	          var parent = node.parent();
	          service.destroyAllChildNodes(parent);
	        }
	        node = null;
	      }
	    };
	
	    /**
	     * Utility method to destroy All Children Nodes (html elements like dom nodes)
	     * https://developer.mozilla.org/en-US/docs/Web/API/Node.removeChild
	     * @param parentNode to be destroyed.
	     */
	    service.destroyAllChildNodes = function (parentNode) {
	      if (angular.isUndefined(parentNode)) {
	        return;
	      }
	      if (parentNode.length && parentNode.length === 1) {
	        if (angular.isDefined(parentNode.children()) && parentNode.children().length > 0) {
	          var child = parentNode.children();
	          child.remove();
	          child = null;
	        }
	      }
	      if (parentNode.length && parentNode.length > 1) {
	        angular.forEach(parentNode, function (child) {
	          service.destroyAllChildNodes(child);
	        });
	      }
	    };
	
	    /**
	     * Utility to cancel timeout
	     * @param scope
	     * @param timeout
	     * @param $timeout
	     */
	    service.cancelTimeoutOnDestroy = function (scope, timeout, $timeout) {
	      if (angular.isDefined(scope)) {
	        scope.$on('$destroy', function () {
	          if (timeout) {
	            $timeout.cancel(timeout);
	          }
	        });
	      } else {
	        console.warn('Memory cleanup failed scope is undefined');
	      }
	    };
	
	    /**
	     * Utility to cancel timeout
	     * @param compCtrl - the component controller instance
	     * @param timeout
	     * @param $timeout
	     */
	    service.cancelTimeoutOnComponentCtrlDestroy = function (compCtrl, timeout, $timeout) {
	      if (compCtrl) {
	        compCtrl.$onDestroy = function () {
	          if (timeout) {
	            $timeout.cancel(timeout);
	          }
	        };
	      }
	    };
	
	    /**
	     * Utility to cancel timeout
	     * @param scope
	     * @param watch
	     */
	    service.cancelWatchOnDestroy = function (scope, watch) {
	      scope.$on('$destroy', function () {
	        if (watch) {
	          watch(); // unbinds watch
	        }
	      });
	    };
	
	    /**
	     * Utility to destroy scope and data
	     * @param scope
	     * @param element
	     */
	    service.destroyScopeAndData = function (scope, element) {
	      if (scope) {
	        scope.$destroy();
	      }
	      if (element) {
	        $(element).removeData('$scope').removeData('$isolateScope').removeData('$isolateScopeNoTemplate').removeClass('ng-scope');
	      }
	    };
	
	    /**
	     * Utility to destroy kendo widgets
	     * @param widgets - kendo widgets to destroy
	     * @param element
	     */
	    // https://github.com/telerik/kendo-ui-core/issues/99
	    // https://github.com/kendo-labs/knockout-kendo/issues/140
	    service.destroyKendoWidgets = function (widgets) {
	      if (widgets) {
	        try {
	          widgets.destroy();
	          widgets = null;
	        } catch (e) {}
	      }
	    };
	
	    service.purgeAttributes = function (elements) {
	      if (elements !== undefined && elements.length > 0) {
	        for (var e = 0; e < elements.length; e++) {
	          var element = elements[e];
	          angular.element(element).removeData().removeAttr(); // try clear jqlite / jquery cache
	          if (element.attributes !== undefined && element.attributes.length > 0) {
	            for (var a = element.attributes.length - 1; a >= 0; a--) {
	              if (element.attributes[a].name !== 'class') {
	                // so kendo doesnt break, we leave the classlist in
	                element.removeAttribute(element.attributes[a].name);
	              }
	            }
	          }
	          if (element.children !== undefined && element.children.length > 0) {
	            service.purgeAttributes(element.children);
	          }
	          a = undefined; // eslint-disable-line
	        }
	      }
	    };
	
	    return service;
	  }];
	};

/***/ }),
/* 57 */
/*!****************************************!*\
  !*** ./utils/util-service.provider.js ***!
  \****************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  self.$get = [function () {
	    var service = {};
	
	    /**
	     *@name calculateContainerWidth
	     *@param {Object} currentTabstrip.
	     *
	     *@description Returns the width of the Div containing the tabstrip.
	     * The extra width ensures there is always some space on the tabstrip.
	     * This method is in fisUtilService because it breaks the unit tests - uses jQuery to calculate the width of component on screen
	     * which is a problem for phantomJS which is headless
	     *
	     */
	    service.calculateContainerWidth = function (component) {
	      return parseFloat(component.width());
	    };
	
	    function queryStringToObject(queryString) {
	      var ret = {};
	      var queryPairs;
	
	      if (angular.isString(queryString)) {
	        queryPairs = queryString.split('&');
	      } else if (angular.isObject(queryPairs)) {
	        queryPairs = queryString;
	      }
	
	      queryPairs.forEach(function (queryElem) {
	        var elemParts = queryElem.split('=');
	        ret[elemParts[0]] = elemParts[1];
	      });
	      return ret;
	    }
	
	    function objectToQueryString(object) {
	      var str = '';
	      Object.keys(object).forEach(function (key) {
	        var val = object[key];
	        if (val !== null) {
	          str += key + '=';
	          if (angular.isDefined(val)) {
	            str += val;
	          }
	          str += '&';
	        }
	      });
	      return str.slice(0, -1);
	    }
	
	    /**
	     * Append custom parameters to a given URL. Already existing parameters will be overridden.
	     * Set the value of key to null to remove it from the url. Keeps existing anchors in the URL.
	     * @param url {String} The URL the parameters should be appended to.
	     * @param params {string|object} Object holding key-value pairs of parameters or query string in format "key=value" separated by &
	     * @returns {String} url enhanced by the parameters
	     */
	    service.appendQueryParameters = function (url, params) {
	      var pathString = url.match(/^([^?#]*)/i);
	      var queryString = url.match(/\?([^#]*)/i);
	      var anchorString = url.match(/(#.*)$/i);
	
	      // Set to empty String of no matches found, otherwise use the first (and hopefully only) match
	      pathString = pathString === null ? '' : pathString[1];
	      anchorString = anchorString === null ? '' : anchorString[1];
	
	      var queryObject = {};
	
	      if (queryString !== null) {
	        queryObject = queryStringToObject(queryString[1]);
	      }
	      if (angular.isString(params)) {
	        params = queryStringToObject(params);
	      }
	      var mergedQueryString = objectToQueryString(angular.extend(queryObject, params));
	      if (mergedQueryString !== '') {
	        pathString += '?';
	      }
	      return pathString + mergedQueryString + anchorString;
	    };
	
	    /**
	     * Append version and appStage parameters to a given URL
	     * @param url The URL the parameters should be appended to
	     * @param customVersion {String} optional Override the version value
	     * @returns {String} url with the cache query parameters added
	     */
	    service.appendCacheQueryParameter = function (url, customVersion) {
	      var cacheQueryObject = fis.getCacheQuery();
	      if (angular.isDefined(customVersion)) {
	        // Clone the object to not change the version setting
	        cacheQueryObject = angular.extend({}, cacheQueryObject);
	        cacheQueryObject.version = customVersion;
	      }
	      return service.appendQueryParameters(url, cacheQueryObject);
	    };
	
	    /**
	     * Extract data from complex JSON for nested path (multi level)
	     * @param schema JSON path
	     * @param data JSON response
	     * @returns extracted data from JSON response
	     */
	    service.extractData = function (schema, data) {
	      var results;
	      var temp = angular.copy(data);
	      var tokens = schema.split(/\.|(\(\))|(\[\d+?])/).filter(function (t) {
	        return t;
	      });
	      if (tokens.length === 1) {
	        results = temp[schema];
	      } else {
	        var isTokenArrayAccess = /^\[\d+\]$/;
	        for (var i = 0; i < tokens.length; i++) {
	          var extractValue;
	          if (isTokenArrayAccess.test(tokens[i])) {
	            extractValue = temp[parseInt(tokens[i].substr(1), 10)];
	          } else {
	            extractValue = temp[tokens[i]];
	          }
	          if (angular.isDefined(extractValue)) {
	            temp = extractValue;
	            results = temp;
	          }
	        }
	      }
	      return results;
	    };
	
	    /*
	    * This function does a proper boolean check and is necessary anywhere
	    * that an angular directive is pulling in an attribute that is meant
	    * to be a boolean. Sometimes the value coming in will be a string,
	    * so the shortcut ways of checking boolean state don't work.
	    */
	    service.booleanCheck = function (actualValue, defaultValue) {
	      if (actualValue === undefined || actualValue === null) {
	        // no value specified, so resort to default value
	        return defaultValue;
	      } else if (typeof actualValue === 'boolean') {
	        // specific check to make sure its boolean
	        return actualValue;
	      }
	      var lowercase = actualValue.toLowerCase();
	      // we have to be specific here, otherwise use the default
	      if (lowercase === 'true') {
	        return true;
	      } else if (lowercase === 'false') {
	        return false;
	      }
	      return defaultValue;
	    };
	
	    /**
	     * Checks whether a given value is NaN.
	     * This is not the same as the native isNaN function, which will
	     * also return true for many other not-number values, such as undefined.
	     *
	     * @param value
	     * @returns {boolean}
	     */
	    service.isNaN = function (value) {
	      return toString.call(value) === '[object Number]' && value !== Number(value);
	    };
	
	    return service;
	  }];
	};

/***/ }),
/* 58 */
/*!************************!*\
  !*** ./views/index.js ***!
  \************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _angular = __webpack_require__(/*! angular */ 2);
	
	var _angular2 = _interopRequireDefault(_angular);
	
	var _angularAnimate = __webpack_require__(/*! angular-animate */ 5);
	
	var _angularAnimate2 = _interopRequireDefault(_angularAnimate);
	
	var _angularRoute = __webpack_require__(/*! angular-route */ 59);
	
	var _angularRoute2 = _interopRequireDefault(_angularRoute);
	
	var _views = __webpack_require__(/*! ./views.config */ 60);
	
	var _views2 = _interopRequireDefault(_views);
	
	var _element = __webpack_require__(/*! ./element.directive */ 61);
	
	var _element2 = _interopRequireDefault(_element);
	
	var _views3 = __webpack_require__(/*! ./views.directive */ 62);
	
	var _views4 = _interopRequireDefault(_views3);
	
	var _viewPanelService = __webpack_require__(/*! ./view-panel-service.provider */ 63);
	
	var _viewPanelService2 = _interopRequireDefault(_viewPanelService);
	
	var _viewService = __webpack_require__(/*! ./view-service.provider */ 64);
	
	var _viewService2 = _interopRequireDefault(_viewService);
	
	var _navigationService = __webpack_require__(/*! ./navigation-service.provider */ 65);
	
	var _navigationService2 = _interopRequireDefault(_navigationService);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ngModule = _angular2.default.module('fis.core.views', [_angularAnimate2.default, _angularRoute2.default]);
	
	ngModule.config(_views2.default);
	
	ngModule.directive('fisElement', _element2.default);
	ngModule.directive('fisViews', _views4.default);
	
	ngModule.provider('fisViewPanelService', _viewPanelService2.default);
	ngModule.provider('fisViewService', _viewService2.default);
	ngModule.provider('fisNavigationService', _navigationService2.default);
	
	exports.default = ngModule.name;

/***/ }),
/* 59 */
/*!****************************!*\
  !*** external "'ngRoute'" ***!
  \****************************/
/***/ (function(module, exports) {

	module.exports = 'ngRoute';

/***/ }),
/* 60 */
/*!*******************************!*\
  !*** ./views/views.config.js ***!
  \*******************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$routeProvider", "$locationProvider", "fisViewServiceProvider", function ($routeProvider, $locationProvider, fisViewServiceProvider) {
	  'ngInject';
	  // Reset the location hashPrefix to the pre-1.6 default value of empty string for backward compatibility reasons
	  // https://docs.angularjs.org/guide/migration#commit-aa077e8
	  // https://github.com/angular/angular.js/commit/aa077e81129c740041438688dff2e8d20c3d7b52
	
	  $locationProvider.hashPrefix('');
	
	  // Store a reference to the routeProvider for further use once the menu items are loaded.
	  fisViewServiceProvider.$routeProvider = $routeProvider;
	}];

/***/ }),
/* 61 */
/*!************************************!*\
  !*** ./views/element.directive.js ***!
  \************************************/
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return function (scope, element, attrs) {
	    if (attrs.fisElement) {
	      var obj = scope[attrs.fisElement];
	      obj.$element = element;
	    }
	  };
	};

/***/ }),
/* 62 */
/*!**********************************!*\
  !*** ./views/views.directive.js ***!
  \**********************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = ["$route", "$anchorScroll", "$compile", "$controller", "$animate", "fisI18nService", "$timeout", function ($route, $anchorScroll, $compile, $controller, $animate, fisI18nService, $timeout) {
	  'ngInject';
	  // Makes a scope "freezable". This means it can be detached and re-attached
	  // to the scope hierarchy. This code is specific to the fisView and can't be reused
	  // for any scope. A frozen scope will not participate in the $apply cycle so
	  // watches inside it will not be checked.
	  // The scope keeps the same prototype so it could still modify models in the parent.
	  // It will not be able to $emit events to the parent and the parent will not be able to $broadcast to it.
	  // The reason we are freezing the scope is to prevent performance degradation when
	  // multiple tabs are opened.
	
	  function makeFreezable(s) {
	    // make sure that when the parent scope is destroyed,
	    // we re-attach the scope so that it can also be destroyed
	    s.$parent.$on('$destroy', function () {
	      if (s.$$frozen) {
	        s.$freeze(false);
	      }
	      // tell fisViews that if the lastSelectedPanel was destroyed, ignore it and lose the reference on it so it can be GC'd
	      s.$$fisGC = true;
	    });
	
	    s.$freeze = function (freeze) {
	      if (freeze && !this.$$frozen) {
	        // let the scope know it is about to be frozen
	        this.$broadcast('fisFreezing');
	
	        // marker to indicate the scope is frozen
	        this.$$frozen = {};
	        // preserve the parent (ngRepeat scope)
	        this.$$frozen.$parent = this.$parent;
	
	        // detach from the parent
	        this.$parent.$$childHead = null;
	        this.$parent.$$childTail = null;
	
	        this.$parent = null;
	        // let the scope know it has been frozen
	        this.$broadcast('fisFrozen');
	      } else if (!freeze && this.$$frozen) {
	        // let the scope know it is about to be unfrozen
	        this.$broadcast('fisUnfreezing');
	
	        // re-attach the scope to its parent
	        this.$parent = this.$$frozen.$parent;
	        this.$parent.$$childHead = this;
	        this.$parent.$$childTail = this;
	        this.$$frozen = null;
	
	        // let the scope know it has been unfrozen
	        this.$broadcast('fisUnfrozen');
	      }
	    };
	
	    return s;
	  }
	
	  return {
	    restrict: 'EA',
	    scope: true, // needed because we now put stuff in the scope
	    replace: true,
	    controller: ['$scope', '$attrs', 'fisPubSubService', function ($scope, $attrs, fisPubSubService) {
	      /**
	       * Provides translation for the view displayed in the view panel.
	       * This overrides the shell controller's i18n function and provides
	       * automatic namespacing based on the current view panel's module and id.
	       * e.g. for a view panel in the "desktop-ui" module and an id of "dashboard", the key,
	       * if it doesn't already contain dots ".", will be prefixed by "desktop-ui.dashboard.".
	       * @param {string} key the i18n key to provide a translation for
	       * @param {string} def t{{item.label}}he default value, if the key can't be found
	       */
	      var unsubscribe = fisPubSubService.subscribe('shell.i18nReady', function () {
	        $scope.i18n = function (key, def) {
	          if (angular.isDefined(key)) {
	            if (key.indexOf('.') === -1) {
	              // TODO: when we allow reuse of viewPanels, the view panel should not be the active view panel
	              //      because this fisViewPanel directive will occur multiple times in the dom (once for each tab).
	              //      If we leave it like that, all strings of all views will get changed each time the active view is changed.
	              var view = $scope.activeViewPanel();
	              if (view) {
	                key = [view.module, view.id, key];
	              }
	            }
	            return fisI18nService.translate(key, def);
	          }
	        };
	        // Un-subscribing shell.i18nReady event
	        unsubscribe();
	      });
	
	      $scope.setTitle = function (value) {
	        $scope.activeViewPanel().setTitle(value);
	      };
	
	      $scope.resetTitle = function () {
	        $scope.activeViewPanel().resetTitle();
	      };
	
	      $scope.setIcon = function (value) {
	        $scope.activeViewPanel().setIcon(value);
	      };
	
	      if ($attrs.fisStacked && $attrs.fisStacked === 'false') {
	        $scope.fisStacked = false;
	      } else {
	        $scope.fisStacked = true;
	      }
	    }],
	    template: '<div fis-message-container>\n                  <div class="fis-info-panel"></div>\n                  <div ng-repeat="panel in panels" class="fis-panel-container ng-hide" fis-element="panel" fis-pub-sub></div>\n                  <div class="default-panel"></div>\n                </div>',
	    link: function link(scope, element, attrs) {
	      // the default panel is used if none of the provided panels are selected or if no panels are provided
	      var defaultPanel;
	      // the previously selected panel
	      var lastSelectedPanel;
	      // expression to evaluate when contents is loaded
	      var onloadExp = attrs.fisOnLoad || '';
	      var updateTimeout;
	      // start with no panels
	      scope.panels = undefined;
	
	      function matchingPathParams(currentParams, panelParams) {
	        if (Object.keys(currentParams).length > 0) {
	          for (var prop in currentParams) {
	            if (currentParams[prop] != panelParams[prop]) {
	              // eslint-disable-line
	              return false;
	            }
	          }
	        }
	        return true;
	      }
	
	      function updatePanel(panel) {
	        lastSelectedPanel = panel;
	        // we need the current route...
	        var current = $route.current;
	        // and the current route's local variables
	        var locals = current && current.locals;
	        // and the template for that route
	        var template = locals && locals.$template;
	
	        var activePanel = scope.activeViewPanel();
	
	        if (current && current.templateUrl && activePanel && current.templateUrl.indexOf(activePanel.partial) !== -1 && matchingPathParams(current.pathParams, activePanel.params)) {
	          // if the selected panel is for the current route, simply unfreeze its scope
	          if (current && panel.$route && panel.$route.originalPath === current.$$route.originalPath) {
	            // detach the scope from the scope hierarchy
	            panel.$scope.$freeze(false);
	            // panel already loaded, just broadcast it
	            panel.$scope.$broadcast('$panelContentLoaded');
	          } else if (template) {
	            // The panel is not for the current route, replace its contents with the route's template
	            // Clear the contents of the selected panel
	            clearContent(panel, false);
	            // associate with the current route
	            panel.$route = current.$$route;
	            // make the route template the panel's content in an animatable way
	            $animate.enter(angular.element('<div></div>').html(template).contents(), panel.$element);
	
	            // compile the panel's content
	            var link = $compile(panel.$element.contents());
	            var controller;
	            // grab a hold of the scope that the ng-repeat created for the panel div
	            var repeatScope = panel.$element.scope();
	            // create a child scope and make it freezable
	            panel.$scope = current.scope = makeFreezable(repeatScope.$new());
	            // if args are present in the item, make it available on the scope as viewArgs
	            if (panel.args) {
	              panel.$scope.viewArgs = panel.args;
	            }
	
	            // if the current route declares a controller
	            if (current.controller) {
	              // add the current panel's scope to the route's local variables
	              locals.$scope = panel.$scope;
	              // add the panel's element to the route's local variables
	              locals.$element = panel.$element;
	              // create the controller with the injectable locals
	              controller = $controller(current.controller, locals);
	              // attach to the panel
	              panel.$element.children().data('$ngControllerController', controller);
	            }
	
	            // link the compiled contents with the panel's scope
	            link(panel.$scope);
	            // emit the $viewContentLoaded event like ng-view does
	            panel.$scope.$emit('$viewContentLoaded');
	
	            // execute the onload handler
	            panel.$scope.$eval(onloadExp);
	
	            // $anchorScroll might listen on event...
	            $anchorScroll();
	          } else if (panel.$scope && panel.args.targetScope.location.$$url) {
	            // check for presence of scope.alert and scope.open: these are defined in the shell
	            // and this could be used outside the shell since it is in fis-components.
	            // no template for this route, display relevant message alert box (if a message is available)
	            var msg;
	            if (scope.alert && (msg = fisI18nService.translate('error-path-not-found', ''))) {
	              scope.alert(msg, { title: fisI18nService.translate('error-dialog-title') });
	            }
	            // open the last open panel
	            if (scope.open) {
	              scope.open(lastSelectedPanel.path);
	            }
	          }
	        }
	      }
	
	      function update() {
	        // find the selected panel
	        var panel = getSelectedPanel();
	        // ensure we are not dealing with a lastSelectedPanel that was destroyed
	        // this can happen when switching menus
	        if (lastSelectedPanel && lastSelectedPanel.$scope && lastSelectedPanel.$scope.$$fisGC) {
	          // the scope (and therefore the panel) was destroyed. Lose the references
	          clearContent(lastSelectedPanel, true);
	          lastSelectedPanel = null;
	        }
	
	        if (lastSelectedPanel !== panel) {
	          // eslint-disable-line
	          // we are changing panel, or the last panel was destroyed...
	          if (lastSelectedPanel) {
	            // hide the previous one if it still exists
	            $animate.addClass(lastSelectedPanel.$element, 'ng-hide');
	            lastSelectedPanel.$element.removeClass('fis-selected');
	
	            if (lastSelectedPanel.saveState === false) {
	              // View doesn't want state saving. Destroy the scope.
	              clearContent(lastSelectedPanel, false);
	            } else if (lastSelectedPanel.$scope) {
	              // freeze the scope on the previous panel
	              // scope may not be there for nav item without partial and secondary menu
	              lastSelectedPanel.$scope.$freeze(true);
	            }
	          }
	          // show the selected one
	          if (panel.$element) {
	            $animate.removeClass(panel.$element, 'ng-hide').then(function () {
	              panel.$element.addClass('fis-selected');
	              if (updateTimeout) {
	                $timeout.cancel(updateTimeout);
	              }
	              updateTimeout = $timeout(function () {
	                updatePanel(panel);
	              }, 0);
	            });
	          }
	        } else {
	          updatePanel(panel);
	        }
	      }
	
	      // This function is invoked when a panel is already opened but
	      // the route it is currently associated to needs to change
	      function clearContent(panel, removeElementRef) {
	        // remove the contents, if any, in an animatable way
	        var contents = panel.$element.contents();
	
	        if (contents.length > 0) {
	          $animate.leave(contents);
	        }
	
	        if (panel.$scope) {
	          // destroy the scope associated to the panel's content
	          panel.$scope.$destroy();
	          // make sure we don't keep a reference on it for GC
	          panel.$scope = null;
	          // make sure no route is associated to this panel
	          panel.$route = null;
	          // make sure no element is associated to this panel
	          if (removeElementRef) {
	            panel.$element = null;
	          }
	        }
	      }
	
	      function getSelectedPanel() {
	        if (angular.isNumber(scope.selectedIndex) && scope.selectedIndex !== -1) {
	          return scope.panels[scope.selectedIndex];
	        }
	
	        return getDefaultPanel();
	      }
	
	      function getDefaultPanel() {
	        if (!defaultPanel) {
	          // initialize default panel since we need it.
	          defaultPanel = {};
	          defaultPanel.$element = angular.element(element[0].getElementsByClassName('default-panel')[0]);
	        }
	        return defaultPanel;
	      }
	
	      if (scope.fisStacked && attrs.fisViews && attrs.fisSelectedIndex) {
	        // if a fisViews attribute is provided, operate in state preservation mode
	        scope.$watchCollection(attrs.fisViews, function (value) {
	          // don't need to find out what was added; scopes will be added if selected and a route is followed
	          scope.panels = value;
	        });
	        scope.$watch(attrs.fisSelectedIndex, function (idx) {
	          scope.selectedIndex = idx;
	        });
	      }
	
	      element.addClass('fis-view-panel');
	
	      scope.$on('$routeChangeSuccess', update);
	    }
	  };
	}];

/***/ }),
/* 63 */
/*!**********************************************!*\
  !*** ./views/view-panel-service.provider.js ***!
  \**********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* jshint maxparams:12 */
	/**
	 * @class
	 * @name fisViewPanelService
	 * @requires $locatio* @requires $timeout
	 * @requires fisViewService
	 * @description
	 <p>Provides ViewPanel management functionality to the application.<p>
	 <p>This service subscribes to <em>shell.navReady</em> event to get a list of
	 top-level Navigation Items with partials configured and opens up non-closeable ViewPanels for these
	 as the landing view for a user.</p>
	 <p>The provider for this service, <em>fisViewPanelServiceProvider</em>, can be configured with View opening
	 strategy during the module configuration phase. This can be a function or string. Possible value for string argument
	 is <em>mdi</em> at the moment, while <em>sdi</em> and <em>hybrid</em> options would be made available in future.</p>
	 */
	
	
	exports.default = function () {
	  'use strict';
	
	  var DEFAULT_OPEN_STRAT = 'mdi';
	  var CUSTOM_OPEN_STRAT = 'custom function';
	
	  var provider = this;
	  var openStratStr = null;
	  var customStrategyFn = null;
	  var preventBrowserNavigation = true;
	
	  /**
	   * @name setViewOpeningStrategy
	   * @methodOf fisViewPanelServiceProvider
	   * @param {String | Function} Function reference of custom view opening strategy or string from enum (only 'mdi' and 'browser' at this point in time)
	   * @description
	   * <p>Configures the provider with a View Panel Opening strategy that is then used by the <em>fisViewPanelService</em> to open
	   * View Panels.</p>
	   */
	  this.setViewOpeningStrategy = function (fn) {
	    if (angular.isFunction(fn)) {
	      openStratStr = CUSTOM_OPEN_STRAT;
	      customStrategyFn = fn;
	    } else if (angular.isString(fn)) {
	      openStratStr = fn;
	    } else {
	      openStratStr = DEFAULT_OPEN_STRAT;
	    }
	  };
	
	  /**
	   * @name getViewOpeningStrategy
	   * @methodOf fisViewPanelServiceProvider
	   * @description
	   * <p>Get the view opening strategy string reference or custom function if one was set.</p>
	   */
	  this.getViewOpeningStrategy = function () {
	    if (openStratStr === null) {
	      return DEFAULT_OPEN_STRAT;
	    } else if (openStratStr === CUSTOM_OPEN_STRAT) {
	      return customStrategyFn;
	    }
	    return openStratStr;
	  };
	
	  /**
	   * @name setPreventBrowserNavigation
	   * @methodOf fisViewPanelServiceProvider
	   * @param {Boolean} True for preventing browser reloading while navigating
	   * @description
	   * <p>Set a flag to prevent browser default navigation while using <em>fisViewPanelService</em>.</p>
	   */
	  this.setPreventBrowserNavigation = function (val) {
	    preventBrowserNavigation = Boolean(val);
	  };
	
	  /**
	   * @name getPreventBrowserNavigation
	   * @methodOf fisViewPanelServiceProvider
	   * @description
	   * <p>Get if the view panel should prevent the default browser navigation.</p>
	   */
	  this.getPreventBrowserNavigation = function () {
	    return preventBrowserNavigation;
	  };
	
	  /**
	   * @name ViewPanel
	   * @methodOf fisViewPanelService
	   * @param {viewDef} navigation Item
	   * @description extends and decorates the nav item with a label and ability to change this via method call.
	   */
	  var ViewPanel = function ViewPanel(viewDef, $filter) {
	    angular.extend(this, viewDef);
	
	    this.$filter = $filter;
	    this.navItem = angular.copy(viewDef);
	    this.title = viewDef.label;
	  };
	
	  ViewPanel.prototype.setTitle = function (stringOrObject) {
	    if ((typeof stringOrObject === 'undefined' ? 'undefined' : _typeof(stringOrObject)) !== 'object') {
	      // eslint-disable-line
	      this.navItem.customTitle = stringOrObject;
	    } else {
	      var tl = '';
	      var sep = '|';
	
	      if (stringOrObject.sep) {
	        sep = stringOrObject.sep;
	      }
	
	      if (stringOrObject.prefix) {
	        tl = stringOrObject.prefix;
	        tl += sep;
	      }
	
	      tl += this.$filter('interpolate')(this.navItem.label, stringOrObject);
	
	      if (stringOrObject.suffix) {
	        tl += sep;
	        tl += stringOrObject.suffix;
	      }
	
	      this.navItem.customTitle = tl;
	    }
	  };
	
	  ViewPanel.prototype.setIcon = function (cssClass) {
	    this.navItem.customIcon = cssClass;
	  };
	
	  ViewPanel.prototype.resetIcon = function () {
	    this.navItem.customIcon = undefined;
	  };
	
	  // Returns the title the view want's to be shown in the tab.
	  // (fisTabsBar may display parentTitle due to config if no customTitle supplied)
	  ViewPanel.prototype.getTitle = function () {
	    if (this.navItem && this.navItem.customTitle) {
	      return this.navItem.customTitle;
	    }
	
	    return this.title;
	  };
	
	  // Returns the icon the view want's to be shown in the tab.
	  // (fisTabsBar may display parentIcon due to config if no customIcon supplied)
	  ViewPanel.prototype.getIcon = function () {
	    if (this.navItem && this.navItem.customIcon) {
	      return this.navItem.customIcon;
	    }
	
	    return this.icon;
	  };
	
	  // we merge properties from the routeParams with the already manually set params.
	  // jQuery.extend(this.params, $routeParams);
	  ViewPanel.prototype.resetTitle = function () {
	    this.navItem.customTitle = undefined;
	  };
	
	  this.ViewPanel = ViewPanel;
	
	  /**
	   * @name $get
	   * @methodOf fisViewPanelServiceProvider
	   * @description
	   * <p>Factory method to create instance of fisViewPanelService.</p>
	   */
	  this.$get = ['$location', '$timeout', 'fisViewService', 'fisConfig', '$filter', '$route', 'fisPubSubService', 'fisI18nService', '$routeParams', '$rootScope', '$q', '$controller', function ($location, $timeout, fisViewService, fisConfig, $filter, $route, fisPubSubService, fisI18nService, $routeParams, $rootScope, $q, $controller) {
	    var service = {};
	    var selectedPanelPath;
	    var selectedPanelUnresolvedPath;
	    var selectedPanelParams;
	    var tabs = [];
	    var navigationUnderWay = false;
	    var changeLocationNavigationUnderway = false;
	    var strategies = {};
	    var keepSameTabsOpenOnReload;
	    var keepTabsOpenVariableLoaded;
	    var tabsAfterNavReadySet;
	    var preventBrowserNavigationSet;
	    var refreshInterval;
	
	    function init() {
	      startAvailableStrategies();
	
	      loadKeepTabsOpenVariable(); // sets keepSameTabsOpenOnReload variable
	
	      setupTabsAfterNavReady();
	
	      setupPreventBrowserNavigation();
	
	      setupLocaleChangeHandle();
	
	      refreshInterval = setInterval(publishNavComplete, 100);
	    }
	
	    function publishNavComplete() {
	      if (keepTabsOpenVariableLoaded && tabsAfterNavReadySet && preventBrowserNavigationSet) {
	        // publish event navigation done...
	        clearInterval(refreshInterval);
	        fisPubSubService.publish('shell.viewPanelReady');
	      }
	    }
	
	    /**
	     * Setup the initially available opening strategies
	     * by placing them in the private strategies object
	     */
	    function startAvailableStrategies() {
	      strategies = {
	        mdi: mdiFunction,
	        browser: browserFunction
	      };
	    }
	
	    function isDuplicatePath(path, items) {
	      return items.some(function (item) {
	        return path === item.path;
	      });
	    }
	
	    function loadKeepTabsOpenVariable() {
	      if (angular.isUndefined(keepSameTabsOpenOnReload)) {
	        if (fisConfig.widgets && fisConfig.widgets.fisTabsBar && angular.isDefined(fisConfig.widgets.fisTabsBar.keepSameTabsOpenOnReload)) {
	          keepSameTabsOpenOnReload = fisConfig.widgets.fisTabsBar.keepSameTabsOpenOnReload;
	        } else {
	          keepSameTabsOpenOnReload = false;
	        }
	        keepTabsOpenVariableLoaded = true;
	        return keepSameTabsOpenOnReload;
	      }
	
	      keepTabsOpenVariableLoaded = true;
	      return keepSameTabsOpenOnReload;
	    }
	
	    function setupTabsAfterNavReady() {
	      fisPubSubService.subscribe('shell.navReady', function (nav) {
	        if (keepSameTabsOpenOnReload) {
	          // Clearing all tabs not in new nav structure
	          if (tabs.length > 0) {
	            for (var i = tabs.length; i-- > 0;) {
	              var tabItem = tabs[i];
	              var item = fisViewService.findNavItem(tabItem.path);
	
	              // remove tab not in new nav structure but do not remove untitled tab (':vmcount')
	              if (!item && tabItem.id !== ':vmCount') {
	                tabs.splice(i, 1);
	              }
	            }
	          }
	        } else {
	          tabs = [];
	        }
	
	        // Get static tabs from nav structure
	        var newTabs = getNewTabs(nav.main);
	
	        // Checks to see which static pages need to be added or which static pages already in tabs
	        newTabs.forEach(function (newTab, index) {
	          // Checks to see if newTab exists in current or new nav structure
	          var item = fisViewService.findNavItem(newTab.path);
	
	          // it exists in nav structure
	          if (item) {
	            // Checking if newTab already in tabs
	            if (!isDuplicatePath(item.path, tabs)) {
	              // Adds static page to tabs
	              var newStaticPage = new provider.ViewPanel(item, $filter);
	              tabs.splice(index, 0, newStaticPage);
	            }
	          }
	        });
	
	        resetSelectedPanelPath();
	        tabsAfterNavReadySet = true;
	      }, true);
	    }
	
	    function getNewTabs(items) {
	      var tabs = [];
	      var count = 0;
	
	      items.forEach(function (item) {
	        item.location = 'main';
	        if (isValidTab(item)) {
	          tabs[count++] = new provider.ViewPanel(item, $filter);
	        }
	      });
	
	      return tabs;
	    }
	
	    function isValidTab(item) {
	      return hasNonCloseableFlag(item) || hasDropdownSecondaryMenu(item);
	    }
	
	    function hasNonCloseableFlag(item) {
	      return angular.isDefined(item.closeable) && !item.closeable;
	    }
	
	    function hasDropdownSecondaryMenu(item) {
	      return item.secondaryNav === 'dropdown';
	    }
	
	    function resetSelectedPanelPath() {
	      // This is important when reloading navigation at runtime.
	      selectedPanelPath = undefined;
	      selectedPanelUnresolvedPath = undefined;
	      selectedPanelParams = undefined;
	    }
	
	    function setupPreventBrowserNavigation() {
	      if (provider.getPreventBrowserNavigation()) {
	        $rootScope.$on('$locationChangeStart', onLocationChangeStart);
	      } else {
	        $rootScope.$on('$locationChangeStart', onLocationChangeStartNavigate);
	      }
	    }
	
	    var shellReady = false;
	
	    function onLocationChangeStartNavigate() {
	      fisPubSubService.subscribe('shell.navReady', function () {
	        shellReady = true;
	      });
	
	      if (!navigationUnderWay && shellReady) {
	        changeLocationNavigationUnderway = true;
	        service.open($location.path());
	      }
	
	      navigationUnderWay = false;
	
	      preventBrowserNavigationSet = true;
	    }
	
	    function onLocationChangeStart(event, newPath, oldPath) {
	      if (!navigationUnderWay) {
	        // eslint-disable-line
	        var newUrl = getUrlWithoutHash(newPath);
	        var oldUrl = getUrlWithoutHash(oldPath);
	
	        if (newUrl !== oldUrl) {
	          // Old and new path are not the same, which means that someone is trying to navigate away from the current page.
	          // prevent the location change (this will revert the url in the address bar to what it was
	          event.preventDefault();
	        }
	      } else {
	        navigationUnderWay = false;
	      }
	
	      preventBrowserNavigationSet = true;
	    }
	
	    function setupLocaleChangeHandle() {
	      fisPubSubService.subscribe('fisLocaleChanged', function () {
	        // Reload the navigation if the locale setting changed
	        var activePanel = service.activeViewPanel();
	        fisViewService.load().then(function () {
	          $timeout(function () {
	            if (activePanel) {
	              // get the path the to take care of unicode path
	              var item = fisViewService.getItemFromPath2Item(activePanel.path);
	              if (item) {
	                service.open(item.path, null, activePanel.params); // Open active one last.
	              } else {
	                // untitled tab
	                service.open(activePanel.path, null, activePanel.params); // Open active one last.
	              }
	            }
	          }, 0);
	        });
	      });
	    }
	
	    function checkAndSetForSecondaryNavItem(navItem, event, params) {
	      var navParent = getSecondaryNavThroughPaths(navItem);
	
	      if (navParent) {
	        // set the parent title for display
	        var paramsToUse = params ? params : navParent.params;
	
	        // check if tab is already present - if it is, do not update parentTitle, as it can mess up with tab title
	        var tabAlreadyPresent = false;
	
	        tabs.forEach(function (tab) {
	          if (tab.path === navItem.path) {
	            tabAlreadyPresent = true;
	          }
	        });
	
	        // change parent title only if tab is not already present and there are parameters
	        if (!tabAlreadyPresent && paramsToUse) {
	          navItem.parentTitle = $filter('interpolate')(navParent.label, paramsToUse);
	        } else if (!tabAlreadyPresent && !paramsToUse && navParent.label && navParent.label.indexOf('{') < 0 && navParent.label.indexOf('}') < 0) {
	          navItem.parentTitle = navParent.label;
	        }
	
	        navItem.parentIcon = navParent.icon ? navParent.icon : null;
	        var newNavItem = openSecNavItem(navItem, event, params);
	        if (newNavItem) {
	          navItem = newNavItem;
	        }
	      }
	    }
	
	    function getSecondaryNavThroughPaths(navItem) {
	      var navParent = null;
	
	      if (navItem !== undefined && navItem !== null) {
	        if (navItem.unresolvedPath) {
	          navParent = getSecondaryNavParent(navItem.unresolvedPath);
	        }
	
	        if (navParent === null) {
	          navParent = getSecondaryNavParent(navItem.path);
	        }
	      }
	      return navParent;
	    }
	
	    function publishViewPanelChange(navItem, previousViewPanel, event) {
	      if (navItem && navItem.params) {
	        navItem.decodedParams = addDecodedParams(navItem.params);
	      }
	
	      fisPubSubService.publish('fisActiveViewPanelChanged', {
	        before: previousViewPanel,
	        after: selectedPanelPath,
	        currentNavItem: navItem,
	        event: event
	      });
	    }
	
	    function addDecodedParams(params) {
	      var decodedParams = {};
	      if (params) {
	        for (var key in params) {
	          if (params.hasOwnProperty(key)) {
	            var paramValue = params[key];
	            // decode only if url contains : or / characters
	            if (paramValue && typeof paramValue === 'string' && (paramValue.indexOf('%2F') > -1 || paramValue.indexOf('%3A') > -1)) {
	              decodedParams[key] = decodeURIComponent(paramValue);
	            }
	          }
	        }
	      }
	      return decodedParams;
	    }
	
	    /**
	     * Call the appropriate opening strategy which decides whether to open
	     * a new tab or reuse the current one
	     * @param navItem object containing information about the view to be opened
	     * @param localEvent
	     */
	    function callRelevantStrategy(navItem, localEvent, parameters) {
	      // Check for boolean values as localEvent to override strategy
	      if (typeof localEvent === 'boolean') {
	        if (localEvent) {
	          openInNewTab(navItem, null, parameters);
	        } else {
	          openInSameTab(navItem, null, parameters);
	        }
	      } else {
	        // No overriding, continue as usual
	        var openingStrategy = provider.getViewOpeningStrategy();
	
	        if (angular.isFunction(customStrategyFn) && openStratStr === CUSTOM_OPEN_STRAT) {
	          // We've got a custom strategy and should use it
	          customStrategyFn.call(service, navItem, localEvent, parameters);
	        } else {
	          // Use one of the framework pre-implemented strategies
	          var stratFn = strategies[openingStrategy];
	
	          if (angular.isFunction(stratFn)) {
	            stratFn.call(service, navItem, localEvent, parameters);
	          } else {
	            // Framework default/Fallback if we do not have a strategy function
	            // matching this name or one at all
	            strategies[DEFAULT_OPEN_STRAT].call(service, navItem, localEvent, parameters);
	            console.warn('Unable to find opening strategy ' + openingStrategy + ', will use default ' + DEFAULT_OPEN_STRAT);
	          }
	        }
	      }
	    }
	
	    function validateNavItem(navItem, navPath) {
	      setPathNotFoundError(navItem, navPath);
	
	      setPartialNotFoundError(navItem);
	    }
	
	    function setPathNotFoundError(navItem, navPath) {
	      // if (hasNoItemButTabs(navItem)) {
	      // we need to display path-not-found error even if there are no tabs open
	      if (!navItem && navPath !== '' && navPath !== '/') {
	        throwNoItemDefinedError(fisI18nService.translate('error-path-not-found', ''));
	      }
	    }
	
	    function hasNoItemButTabs(navItem) {
	      return !navItem && tabs.length > 0;
	    }
	
	    function throwNoItemDefinedError(userMessage) {
	      // TODO: replace with a fisMessageCenterService
	      var err = new Error('No nav item defined for this path');
	      err.userMessage = userMessage;
	      throw err;
	    }
	
	    function setPartialNotFoundError(navItem) {
	      if (hasTabsButNoPartial(navItem)) {
	        throwNoPartialFoundError(navItem, fisI18nService.translate('error-partial-not-found', ''));
	      }
	    }
	
	    function hasTabsButNoPartial(navItem) {
	      return navItem && // item exists
	      !navItem.partial && // but no partial
	      !navItem.secondaryNav && // neither secondary nav
	      !navItem.action && // or action
	      tabs.length > 0; // and the service has tabs
	    }
	
	    function throwNoPartialFoundError(navItem, userMessage) {
	      // TODO: replace with a fisMessageCenterService
	      var err = new Error('Nav item "' + navItem.label + '" does not have a partial to load');
	      err.userMessage = userMessage;
	      throw err;
	    }
	
	    function substituteParams(path, localParams) {
	      while (path.indexOf(':') > -1) {
	        path = getReplacedPath(path, localParams);
	      }
	
	      return path;
	    }
	
	    function removeExtraParamsFromLocalParams(path, localParams) {
	      var localParamsToKeep = {};
	      while (path.indexOf(':') > -1) {
	        var paramStr = path.substring(path.indexOf(':') + 1);
	        var param = paramStr.indexOf('/') > -1 ? paramStr.substring(0, paramStr.indexOf('/')) : paramStr;
	        localParamsToKeep[param] = localParams[param];
	        path = path.substring(path.indexOf(':' + paramStr) + 1);
	      }
	      return localParamsToKeep;
	    }
	
	    function hasSpecialCharacter(paramVal) {
	      return !/^[a-zA-Z0-9-% ]*$/.test(paramVal);
	    }
	
	    function getReplacedPath(path, localParams) {
	      var paramStr = path.substring(path.indexOf(':') + 1);
	      var param = paramStr.indexOf('/') > -1 ? paramStr.substring(0, paramStr.indexOf('/')) : paramStr;
	      var remainingStr = paramStr.substring(param.length);
	
	      var paramValue;
	      var paramValueOrig = localParams[param];
	      if (paramValueOrig && (paramValueOrig.toString().indexOf('/') > -1 || paramValueOrig.toString().indexOf(':') > -1)) {
	        paramValue = encodeURIComponent(paramValueOrig);
	      } else if (hasSpecialCharacter(paramValueOrig)) {
	        paramValue = encodeURIComponent(paramValueOrig);
	        paramValue = decodeURIComponent(paramValue);
	      } else {
	        paramValue = decodeURIComponent(paramValueOrig);
	      }
	
	      if (localParams[param] !== paramValue) {
	        // This Is a reload
	        localParams[param] = paramValue; // Set Local param to decoded value so it can found
	      }
	      return path.substring(0, path.indexOf(':')) + paramValue + remainingStr;
	    }
	
	    // Updating tabs[] array with the data received from the translation object
	    // This is required to update the tab title correctly in case translation data is loading asynchronously
	    function updateTabsArray(path, navItem) {
	      if (tabs) {
	        for (var count = 0; count < tabs.length; count++) {
	          if (tabs[count].path === path) {
	            if (navItem && navItem.label) {
	              tabs[count].label = navItem.label;
	              tabs[count].title = navItem.label;
	            }
	            break;
	          }
	        }
	      }
	    }
	
	    function getSecondaryNavParent(navPath) {
	      var tempPath = navPath;
	      var navItemParent = null;
	      var itemWithSecNav = null;
	
	      while (!itemWithSecNav) {
	        if (tempPath) {
	          navItemParent = fisViewService.findNavItem(tempPath);
	          updateTabsArray(tempPath, navItemParent);
	          itemWithSecNav = getItemParentRefIfValid(navItemParent);
	          tempPath = tempPath.substring(0, tempPath.lastIndexOf('/'));
	        } else {
	          break;
	        }
	      }
	
	      // clear params from the item, since it may contain stale value
	      if (itemWithSecNav) {
	        itemWithSecNav.params = null;
	      }
	      return itemWithSecNav;
	    }
	
	    // Expose getSecondaryNavParent functionality required by breadcrumbs container to check for a tab
	    // whether its a secondary navigation tab or not
	    service._getSecondaryNavParent = getSecondaryNavParent;
	
	    function getItemParentRefIfValid(navItemParent) {
	      var value = null;
	      if (navItemParent && (navItemParent.secondaryNav === 'menubar' || navItemParent.secondaryNav === 'dropdown')) {
	        value = navItemParent;
	      }
	      return value;
	    }
	
	    function openSecNavItem(item, event, params) {
	      var navItem = getNavItemFromViewPanel(item);
	      var parameters = getParamsOrNavItemParams(params, navItem);
	      var substitutedNavItem = getSubstitutedUrlIfContainsParams(parameters, navItem);
	
	      openTestingByGroupOpened(substitutedNavItem, event, parameters);
	
	      if (isValidSecondaryMenuItem(navItem)) {
	        var itemWithSecNav = getSecondaryNavThroughPaths(navItem);
	        var children = getChildrenFromNavItem(navItem, itemWithSecNav);
	        var newNavItem = null;
	
	        updateAllChildren(itemWithSecNav);
	
	        setParamsAcessedBySecondaryMenu(itemWithSecNav, substitutedNavItem);
	
	        newNavItem = getNewNavItem(navItem, itemWithSecNav, children);
	
	        fisPubSubService.publish('fisSecondaryMenuClicked', itemWithSecNav);
	
	        return newNavItem;
	      }
	    }
	
	    function getNavItemFromViewPanel(item) {
	      var navItem = item;
	
	      if (navItem instanceof provider.ViewPanel) {
	        navItem = navItem.navItem;
	        if (navItem.params && navItem.unresolvedPath) {
	          navItem.path = navItem.unresolvedPath;
	        }
	      }
	
	      return navItem;
	    }
	
	    function getParamsOrNavItemParams(params, navItem) {
	      var parameters = params;
	
	      if (!parameters && navItem.params !== null) {
	        parameters = navItem.params;
	      }
	
	      return parameters;
	    }
	
	    function getSubstitutedUrlIfContainsParams(parameters, navItem) {
	      var substitutedNavItem = angular.copy(navItem);
	
	      if (parameters && navItem) {
	        // set the original parameterized path
	        if (!substitutedNavItem.unresolvedPath) {
	          substitutedNavItem.unresolvedPath = navItem.path;
	        }
	        substitutedNavItem.path = substituteParams(navItem.path, parameters);
	        substitutedNavItem.label = $filter('interpolate')(navItem.label, parameters);
	        substitutedNavItem.params = parameters;
	      }
	
	      return substitutedNavItem;
	    }
	
	    function openTestingByGroupOpened(substitutedNavItem, event, parameters) {
	      if ((isTrue(event) || angular.isUndefined(event) || angular.isObject(event)) && !isSecNavItemGroupOpen(substitutedNavItem) && !isPartOfSecondaryNav(getSecondaryNavParent(substitutedNavItem.path), service.activeViewPanel())) {
	        openInNewTab(substitutedNavItem, event);
	      } else {
	        openInSameTab(substitutedNavItem, event, parameters);
	      }
	    }
	
	    function isPartOfSecondaryNav(navItem, currentNavItem) {
	      var containsNavItem = false;
	      if (navItem !== null && currentNavItem !== null) {
	        if (navItem.id === currentNavItem.id) {
	          return true;
	        } else if (angular.isDefined(navItem.children) && angular.isArray(navItem.children)) {
	          navItem.children.forEach(function (childNavItem) {
	            if (containsNavItem !== true) {
	              containsNavItem = isPartOfSecondaryNav(childNavItem, currentNavItem);
	            }
	          });
	        } else {
	          return false;
	        }
	      }
	      return containsNavItem;
	    }
	
	    function isValidSecondaryMenuItem(navItem) {
	      return navItem && (navItem.secondaryNav || getSecondaryNavParent(navItem.path) || getSecondaryNavParent(navItem.unresolvedPath));
	    }
	
	    function getChildrenFromNavItem(navItem, itemWithSecNav) {
	      var children = null;
	
	      if (navItem.secondaryNav) {
	        children = navItem.children;
	      } else if (itemWithSecNav) {
	        children = itemWithSecNav.children;
	      }
	
	      return children;
	    }
	
	    function setParamsAcessedBySecondaryMenu(itemWithSecNav, substitutedNavItem) {
	      if (itemWithSecNav) {
	        itemWithSecNav.params = substitutedNavItem.params;
	      }
	    }
	
	    function getNewNavItem(navItem, itemWithSecNav, children) {
	      var newNavItem = angular.extend({}, navItem);
	      newNavItem.children = children;
	      newNavItem.secondaryNav = itemWithSecNav.secondaryNav;
	
	      return newNavItem;
	    }
	
	    function updateAllChildren(navItem) {
	      if (navItem && navItem.children) {
	        navItem.children.forEach(function (child) {
	          updateChildData(child);
	
	          updateAllChildren(child);
	        });
	      }
	    }
	
	    function updateChildData(child) {
	      if (child.partial) {
	        child.isStatic = true;
	      }
	
	      child.text = child.label;
	      child.items = child.children;
	
	      if (child.partial) {
	        child.url = child.path;
	      }
	    }
	
	    function isSecNavItemGroupOpen(navItem) {
	      var itemWithSecNav = getSecondaryNavThroughPaths(navItem);
	      var secNavItemGroupPresent = false;
	
	      if (itemWithSecNav !== null) {
	        // attach a property secondaryNavParent to the navItem in case the parent secondary navigation item has secondaryNav as dropdown
	        if (hasDropdownSecondaryMenu(itemWithSecNav)) {
	          navItem.secondaryNavParent = itemWithSecNav;
	        }
	
	        for (var i = 0; i < tabs.length; i++) {
	          if (isTabPathValid(tabs[i], navItem, itemWithSecNav)) {
	            secNavItemGroupPresent = true;
	            selectedPanelPath = tabs[i].path;
	            selectedPanelUnresolvedPath = tabs[i].unresolvedPath;
	            selectedPanelParams = tabs[i].params;
	
	            return secNavItemGroupPresent;
	          }
	        }
	      }
	    }
	
	    function isTabPathValid(tab, navItem, itemWithSecNav) {
	      if (navItem.unresolvedPath) {
	        return tabPathHasNavItemParams(tab, navItem, itemWithSecNav);
	      }
	      return tab.path.indexOf(itemWithSecNav.path) > -1;
	    }
	
	    function tabPathHasNavItemParams(tab, navItem /* , itemWithSecNav*/) {
	      var continueLooping = true;
	      var unresolvedPath = navItem.unresolvedPath;
	      var navPathUptoResolvedParam;
	      var paramValue;
	
	      while (continueLooping) {
	        var paramStr = unresolvedPath.substring(unresolvedPath.indexOf(':') + 1);
	        var param = paramStr.indexOf('/') > -1 ? paramStr.substring(0, paramStr.indexOf('/')) : paramStr;
	        var remainingStr = paramStr.substring(param.length);
	        paramValue = navItem.params[param];
	        navPathUptoResolvedParam = unresolvedPath.substring(0, unresolvedPath.indexOf(':')) + paramValue;
	        if (remainingStr.indexOf(':') > -1) {
	          unresolvedPath = unresolvedPath.substring(0, unresolvedPath.indexOf(':')) + paramValue + remainingStr;
	        } else {
	          continueLooping = false;
	        }
	      }
	
	      // check for the token length of navPathUptoResolvedParam and tab.path
	      // if the length of tokens of navPathUptoResolvedParam is greater than tab.path length and navPathUptoResolvedParam begins with tab.path,
	      // it means the current nav item to open is a child of the existing tab),
	      // If the length of tokens is same, it means the current nav item to open is not a child of the existing tab
	      // This check is needed for cases where the name of the new tab to open contains the name of the already open tab, for example Bank_of_Pune and Bank_of_Pune1
	      var navPathUptoResolvedParamTokens = getTokensFromNavPath(navPathUptoResolvedParam);
	      var tabPathTokens = getTokensFromNavPath(tab.path);
	      var navPathContainsTabPath = false;
	      if (navPathUptoResolvedParamTokens.length > tabPathTokens.length && navPathUptoResolvedParam.indexOf(tab.path) > -1) {
	        navPathContainsTabPath = true;
	      }
	
	      return tab.path.indexOf(navPathUptoResolvedParam) > -1 && paramValue === tab.label || navPathContainsTabPath;
	    }
	
	    function openInNewTab(navItem, event, parameters) {
	      if (isFalse(event)) {
	        openInSameTab(navItem, event, parameters);
	      }
	
	      if (navItem) {
	        if (!isAlreadyInTabs(navItem)) {
	          addNewTab(navItem);
	        }
	
	        setPathAndNavigateTo(navItem);
	      }
	    }
	    // Expose opening in a new tab functionality so custom opening strategies may use it
	    /**
	     * @name _openInNewTab
	     * @methodOf fisViewPanelService
	     * @param {Object} Navigation Item to be opened
	     * @param
	     * @description
	     * <p>Configures the provider with a View Panel Opening strategy that is then used by the <em>fisViewPanelService</em> to open
	     * View Panels.</p>
	     */
	    service._openInNewTab = openInNewTab;
	
	    function isAlreadyInTabs(navItem) {
	      return tabs.some(function (tab) {
	        return tab.path === navItem.path;
	      });
	    }
	
	    function addNewTab(navItem) {
	      tabs.push(new provider.ViewPanel(navItem, $filter));
	      publishViewPanelOpened(navItem, getLastTab());
	    }
	
	    function publishViewPanelOpened(navItem, tab) {
	      fisPubSubService.publish('fisViewPanelOpened', {
	        path: navItem.path,
	        viewPanel: tab
	      });
	    }
	
	    function getFirstTab() {
	      return tabs[0];
	    }
	
	    function getLastTab() {
	      return tabs[tabs.length - 1];
	    }
	
	    function openInSameTab(navItem, event, parameters) {
	      if (!isSecNavItemGroupOpen(navItem) && hasItemButNoTabsOrEvent(navItem, event)) {
	        openInNewTab(navItem, event, parameters);
	      } else if (hasItemAndTabs(navItem)) {
	        if (!shouldOpenInSameTab(navItem)) {
	          setPathAndNavigateTo(navItem, parameters);
	        }
	      }
	    }
	    // Expose opening in same tab functionality so custom opening strategies may use it
	    service._openInSameTab = openInSameTab;
	
	    function hasItemButNoTabsOrEvent(navItem, event) {
	      return hasItemButNoTabs(navItem) || isTrue(event);
	    }
	
	    function hasItemButNoTabs(navItem) {
	      return navItem && tabs.length === 0;
	    }
	
	    function hasItemAndTabs(navItem) {
	      return navItem && tabs.length > 0;
	    }
	
	    function shouldOpenInSameTab(navItem, parameters) {
	      var activeViewPanel = service.activeViewPanel();
	      var isOpeningAction = false;
	
	      if (isActiveAndNonCloseable(activeViewPanel, navItem)) {
	        openInNewTab(navItem, parameters);
	        isOpeningAction = true;
	      } else if (shouldReplaceViewPanel(activeViewPanel, navItem, parameters)) {
	        isOpeningAction = true;
	      }
	
	      return isOpeningAction;
	    }
	
	    function isActiveAndNonCloseable(activeViewPanel, navItem) {
	      return activeViewPanel && service.isNonCloseable(activeViewPanel) && !getSecondaryNavParent(navItem.path);
	    }
	
	    function findCurrentlyOpenedTab(activeViewPanel) {
	      if (!activeViewPanel) {
	        return null;
	      }
	
	      var activeViewPanelIndex = null;
	
	      tabs.forEach(function (tab, index) {
	        if (activeViewPanel.path === tab.path) {
	          activeViewPanelIndex = index;
	        }
	      });
	
	      return activeViewPanelIndex;
	    }
	
	    function shouldReplaceViewPanel(activeViewPanel, navItem, parameters) {
	      var navItemInTabs = isNavItemInTabs(navItem);
	      var activeViewPanelIndex = findCurrentlyOpenedTab(activeViewPanel);
	
	      if (activeViewPanel && !navItemInTabs) {
	        replaceViewPanel(activeViewPanel, navItem, parameters, activeViewPanelIndex);
	
	        return true;
	      }
	      return false;
	    }
	
	    function isNavItemInTabs(navItem) {
	      return tabs.some(function (tab) {
	        return tab.path === navItem.path;
	      });
	    }
	
	    function replaceViewPanel(activeViewPanel, navItem, parameters, index) {
	      var promise = publishViewPanelReplaceIntent(navItem, activeViewPanel);
	      promise.then(function () {
	        onViewPanelReplaceIntentSuccess(navItem, parameters, index);
	      }, function () {
	        // publish an event if view panel replacement has been vetoed.
	        fisPubSubService.publish('fisViewPanelReplaceVetoed', {
	          navItem: navItem,
	          viewPanel: activeViewPanel
	        });
	      });
	    }
	
	    function publishViewPanelReplaceIntent(navItem, activeViewPanel) {
	      return fisPubSubService.publish('fisViewPanelReplaceIntent', {
	        path: navItem.path,
	        viewPanel: activeViewPanel
	      });
	    }
	
	    function onViewPanelReplaceIntentSuccess(navItem, parameters, index) {
	      var tab = tabs[index] = new provider.ViewPanel(navItem, $filter);
	
	      publishViewPanelOpened(navItem.path, tab);
	      publishViewReplaced(navItem);
	
	      setPathAndNavigateTo(navItem);
	    }
	
	    function setPathAndNavigateTo(navItem) {
	      selectedPanelPath = navItem.path;
	      selectedPanelUnresolvedPath = navItem.unresolvedPath;
	      selectedPanelParams = navItem.params;
	      navigateTo(navItem);
	    }
	
	    function publishViewReplaced(navItem) {
	      fisPubSubService.publish('fisViewPanelReplaced', { path: navItem.path });
	    }
	
	    function getUrlWithoutHash(url) {
	      // Use the provided URL as the default value,
	      // this will ensure a correct return value even
	      // if it doesn't contain a trailing hash (anchor)
	      var iPound = url.lastIndexOf('#');
	      var iSlash = url.lastIndexOf('/');
	      var noHash = url;
	
	      // Only cut off the hash if the hash sign was
	      // found after the last slash in the path.
	      if (iPound > iSlash) {
	        // Take everything before the hash sign
	        noHash = url.substring(0, iPound);
	      }
	
	      return noHash;
	    }
	
	    function navigateTo(navItem) {
	      // Give time to angular to complete it's $apply cycle and then update path
	      // Reference - https://groups.google.com/d/msg/angular/FJwxJ-XbJaE/584zbwBjbU8J
	      $timeout(function () {
	        // Route change only occurs when $location.path changes
	        // In some cases, we want the route to be refreshed even if the path doesn't change:
	        // 1. The user clicks on a bookmark containing #/welcome for example. In this case,
	        //    open is called with #/welcome but $location.path() is already #/welcome
	        // 2. The navigation structure is changed with fisViewService.load and the current path is
	        //    #/welcome and the new path to open is also #/welcome. In this case, the paths may be the
	        //    same but they are referring to different views so we need to reload.
	        // Note that fisViews will not drop the current view panel and reload the route's template:
	        // it will notice the view panel is for the same route and will not do anything
	        // since it only means the user is navigating to the same page again, in which case we don't
	        // want the view to be reloaded.
	        if ($location.path() === navItem.path) {
	          $route.reload();
	        } else {
	          $location.path(navItem.path);
	        }
	
	        if (!changeLocationNavigationUnderway) {
	          // eslint-disable-line
	          /*
	              This variable is explicitly set to true because it is checked while updating the view
	              The '$locationChangeStart' event handler checks for this flag to be set to true, else it will
	              prevent the location change.
	              Since this function is called by the open method of framework, we want the $location to change
	          */
	          navigationUnderWay = true;
	        } else {
	          changeLocationNavigationUnderway = false;
	        }
	      }, 0);
	    }
	
	    function mdiFunction(navItem, event, parameters) {
	      if (isFalse(event)) {
	        openInSameTab(navItem, event, parameters);
	      } else {
	        openInNewTab(navItem, event, parameters);
	      }
	    }
	
	    function browserFunction(navItem, event, parameters) {
	      if (!event || event && !event.ctrlKey && !event.metaKey) {
	        // to open child page in the current tab.
	        openInSameTab(navItem, null, parameters);
	      } else {
	        // to open child page in new tab.
	        openInNewTab(navItem, null, parameters);
	      }
	    }
	
	    function isTrue(e) {
	      return e === true || e === 'true';
	    }
	
	    function isFalse(e) {
	      return e === false || e === 'false';
	    }
	
	    function resetLocationHash() {
	      // This is done to avoid carrying over the anchor
	      // location (hash, e.g. "#toc_3") to the new tab.
	
	      // We might have to revisit this if we want to
	      // support opening tabs and jumping to a
	      // specific location at the same time.
	      $location.hash('');
	    }
	
	    function getDefaultIfNoPath(navPath) {
	      if (navPath === undefined) {
	        return '';
	      }
	      return navPath;
	    }
	
	    function normalizeOpenArguments(args, event, params) {
	      var localEvent = null;
	      var localParams = {};
	
	      if (args.length === 2) {
	        localEvent = getValidatedEvent(args[1]);
	
	        if (isStrategyOverride(event)) {
	          localEvent = event;
	        } else {
	          // it's a params object, set it to localParams
	          localParams = args[1];
	        }
	      } else if (args.length === 3) {
	        localEvent = event;
	        localParams = params;
	      }
	
	      return {
	        localEvent: localEvent,
	        localParams: localParams
	      };
	    }
	
	    function getValidatedEvent(value) {
	      if (isEvent(value)) {
	        return value;
	      }
	      return null;
	    }
	
	    function isEvent(value) {
	      return value && value.target;
	    }
	
	    function isStrategyOverride(value) {
	      return value === 'true' || value === 'false' || value === true || value === false;
	    }
	
	    function checkIfTabIsAlreadyPresent(navPath, event, params) {
	      var navItem = null;
	      var tabFound = false;
	
	      tabs.forEach(function (tab) {
	        if (tab.path === navPath) {
	          tabFound = true;
	          navItem = tab;
	          checkAndSetForSecondaryNavItem(tab, event, params);
	        }
	      });
	
	      return {
	        navItem: navItem,
	        tabFound: tabFound
	      };
	    }
	
	    function tryOpenViewBasedOnDefaultParams(navItem, navPath, tabFound, event, params, localParams) {
	      if (isNavPathNotDefined(navPath, tabFound)) {
	        navItem = openDefaultView(event, params);
	      } else if (isRelativePath(navPath, tabFound)) {
	        navItem = openRelativeView(navPath, event, params, localParams);
	        if (navItem) {
	          navPath = navItem.path;
	        }
	      } else if (isSecondaryNavigation(navPath, tabFound)) {
	        navItem = openSecondaryView(navPath, event, params);
	      }
	
	      // When navItem has parameterized url, a copy of the navItem is created and processed. Hence, the
	      // isStatic property is not set even if secondary navigation is present.
	      // Hence, setting this property after all the processing is done
	      if (navItem && getSecondaryNavParent(navItem.path) && navItem.partial) {
	        navItem.isStatic = true;
	      }
	
	      return navItem;
	    }
	
	    function openDefaultView(event, params) {
	      // TODO: default if no root tab.
	      // Provide a way to configure default and open tabs if necessary?
	
	      var navItem = getFirstTab();
	
	      if (isNavItemDefined(navItem)) {
	        checkAndSetForSecondaryNavItem(navItem, event, params);
	        return navItem;
	      }
	      return null;
	    }
	
	    function isNavPathNotDefined(navPath, tabFound) {
	      return !navPath && tabFound === false;
	    }
	
	    function isNavItemDefined(navItem) {
	      return navItem && navItem.path;
	    }
	
	    function isRelativePath(navPath, tabFound) {
	      return navPath && navPath.indexOf('/') !== 0 && tabFound === false;
	    }
	
	    function openRelativeView(navPath, event, params, localParams) {
	      var navItemTemp = fisViewService.findNavItem(navPath, selectedPanelPath);
	      var key;
	
	      // if navItemTemp not found, look it up using selectedPanelUnresolvedPath
	      if (!navItemTemp) {
	        navItemTemp = fisViewService.findNavItem(navPath, selectedPanelUnresolvedPath);
	
	        // add the selectedPanelParams to localParams for substitution.
	        for (key in selectedPanelParams) {
	          if (selectedPanelParams.hasOwnProperty(key)) {
	            localParams[key] = selectedPanelParams[key];
	          }
	        }
	      }
	
	      // Add the selectedPanelParams to localParams for substitution in case navItemTemp is found.
	      // In this case add the param only if localParams does not have the key
	      if (navItemTemp) {
	        for (key in selectedPanelParams) {
	          if (selectedPanelParams.hasOwnProperty(key) && !localParams.hasOwnProperty(key)) {
	            localParams[key] = selectedPanelParams[key];
	          }
	        }
	      }
	
	      if (navItemTemp && navItemTemp.params && Object.keys(localParams).length === 0) {
	        localParams = navItemTemp.params;
	      }
	
	      // if no local params are defined, try to use params from the active view panel in this case; since the view to be opened is a relative view.
	      if (angular.isUndefined(localParams) || localParams === null || Object.keys(localParams).length === 0) {
	        if (service.activeViewPanel()) {
	          localParams = service.activeViewPanel().params;
	        }
	      }
	
	      // when a parent page is called from child page without giving any parameters, child page params are also added in localParams
	      // we need to remove such extra params from localParams
	      var navItem = null;
	      if (navItemTemp) {
	        localParams = removeExtraParamsFromLocalParams(navItemTemp.path, localParams);
	
	        var path = substituteParams(navItemTemp.path, localParams);
	
	        navItem = getNavItemForRelativePath(navItemTemp, path, localParams);
	        navItem.unresolvedPath = navItemTemp.path;
	
	        checkAndSetForSecondaryNavItem(navItem, event, params);
	      }
	
	      return navItem;
	    }
	
	    function getNavItemForRelativePath(navItem, path, localParams) {
	      var newItem = {};
	
	      angular.copy(navItem, newItem);
	
	      newItem.path = path;
	      newItem.label = $filter('interpolate')(newItem.label, localParams);
	      newItem.params = localParams;
	
	      return newItem;
	    }
	
	    function isSecondaryNavigation(navPath, tabFound) {
	      return getSecondaryNavParent(navPath) && tabFound === false;
	    }
	
	    function openSecondaryView(navPath, event, params) {
	      var navItem = fisViewService.findNavItem(navPath);
	
	      // case of handling parameterized navigation item with secondary menu
	      if (!navItem) {
	        var relativeData = extractRelativeUrlData(navItem, navPath);
	        params = relativeData.params;
	        navItem = relativeData.navItem;
	      }
	      checkAndSetForSecondaryNavItem(navItem, event, params);
	      if (navItem) {
	        navItem.params = params;
	      }
	      return navItem;
	    }
	
	    function findNavItemIfNotDefined(navItem, navPath) {
	      // TODO: should it instead just call navigation.navigate(navPath) and have tabs handled in view service?
	
	      if (!isNavItemDefined(navItem)) {
	        navItem = fisViewService.findNavItem(navPath, selectedPanelPath);
	      }
	
	      return navItem;
	    }
	
	    function extractRelativeUrlData(navItem, navPath) {
	      var tempPath = navPath;
	      var tokens = getTokensFromNavPath(navPath);
	      var parameters = {};
	      var tempNavPath = navPath;
	      var parsedData = null;
	      var hasMoreTokens = true;
	
	      while (hasMoreTokens) {
	        if (!hasPathToParse(tempNavPath)) {
	          break;
	        }
	
	        tempPath = tempPath.substring(0, tempPath.lastIndexOf('/'));
	        if (tempPath.length === 0) {
	          break;
	        }
	        var tempNavItem = fisViewService.findNavItem(tempPath);
	
	        if (tempNavItem) {
	          var parsedDataCopy = angular.copy(parsedData);
	
	          parsedData = findMatchedChildThroughNavPath({
	            navItem: navItem,
	            tokens: tokens,
	            tempPath: tempPath,
	            tempNavPath: tempNavPath,
	            tempNavItem: tempNavItem,
	            hasMoreTokens: true,
	            parameters: parameters
	          });
	
	          if (parsedData && parsedDataCopy && parsedData.navItem && parsedDataCopy.navItem && parsedData.navItem.id === parsedDataCopy.navItem.id) {
	            hasMoreTokens = false;
	            return {
	              params: null,
	              navItem: null
	            };
	          }
	
	          navItem = parsedData.navItem;
	          tokens = parsedData.tokens;
	          tempPath = parsedData.tempPath;
	          tempNavPath = parsedData.tempNavPath;
	          tempNavItem = parsedData.tempNavItem;
	          parameters = parsedData.parameters;
	
	          if (!parsedData.hasMoreTokens) {
	            break;
	          }
	        } else if (noMoreItems(tempNavItem, tempPath)) {
	          parsedData = findMatchedNoChild(navItem, parameters, tempPath, tempNavPath);
	
	          navItem = parsedData.navItem;
	          parameters = parsedData.parameters;
	
	          break;
	        }
	      }
	
	      var resolvedPath;
	      // compute resolvedPath only for cases when navPath contains tempPath -- this is needed in case there is a parameterized url,
	      // in which case, this navPath will have unresolved path (with ':' character), and tempPath will have resolved path with substituted parameters.
	      if (navItem) {
	        var navItemIdTokens = getTokensFromNavPath(navItem.id) || [];
	        if (navPath.indexOf(tempPath) > -1 && navItemIdTokens.length > 2) {
	          resolvedPath = navPath.substring(tempPath.length + 1);
	        }
	      }
	
	      return {
	        params: parameters,
	        navItem: navItem,
	        resolvedPath: resolvedPath
	      };
	    }
	
	    // exposing this method since it is used internally by breadcrumb widget to extract relative data
	    service._extractRelativeUrlData = extractRelativeUrlData;
	
	    function noMoreItems(tempNavItem, tempPath) {
	      return !tempNavItem && tempPath.lastIndexOf('/') === 0;
	    }
	
	    function hasSomeEquivalentParam(child, childPath) {
	      var childPathWithoutParam = child.id;
	      var withoutParamWord = childPathWithoutParam.substring(0, childPathWithoutParam.indexOf('/'));
	      var originalWord = childPath.substring(0, childPath.indexOf('/'));
	      return withoutParamWord === originalWord;
	    }
	
	    function getTokensFromNavPath(navPath) {
	      var tokens = [];
	
	      if (navPath && navPath.indexOf('/') > -1) {
	        tokens = navPath.split('/');
	      }
	
	      return tokens;
	    }
	
	    function hasPathToParse(path) {
	      return path && path.substring(0, path.lastIndexOf('/'));
	    }
	
	    function getChildTokens(childPath) {
	      return childPath.split('/');
	    }
	
	    function getChildDataFromPath(child, childPath, tokensLength, tempPath, tempNavPath, hasMoreTokens) {
	      var childData = {};
	      var childTokens = getChildTokens(childPath);
	      var itemTokens = child.path.split('/');
	
	      childData.paramName = child.id.substring(child.id.indexOf(':') + 1);
	      childData.paramVal = getParameterValue(child, childPath, childTokens);
	      childData.navItem = angular.copy(child);
	
	      if (tokensLength === itemTokens.length) {
	        childData.hasMoreTokens = false;
	        childData.tempPath = tempPath;
	        childData.tempNavPath = tempNavPath;
	      } else {
	        childData.hasMoreTokens = hasMoreTokens;
	        // remove tokens already resolved
	        spliceChildTokens(child, childTokens);
	        // Add to tempPath the resolved tokens and the unresolved tokens and start again :-)
	        childData.tempPath = tempPath + '/' + child.id + '/' + childTokens.join('/');
	        childData.tempNavPath = childData.tempPath; // start again - but with one token resolved
	      }
	
	      return childData;
	    }
	
	    function spliceChildTokens(child, childTokens) {
	      if (child.id.indexOf(':') === 0) {
	        childTokens.splice(0, 1);
	      } else {
	        childTokens.splice(0, 2);
	      }
	    }
	
	    function findMatchedChildThroughNavPath(defaultData) {
	      var childPath = defaultData.tempNavPath.substring(defaultData.tempPath.length + 1);
	      var cont = true;
	
	      while (cont) {
	        if (!defaultData.tempNavItem.children) {
	          break;
	        }
	
	        var parsedDataCopy = angular.copy(parsedData); // eslint-disable-line
	
	        var parsedData = parseChildDataFrom({
	          cont: cont,
	          navItem: defaultData.navItem,
	          childPath: childPath,
	          tokens: defaultData.tokens,
	          tempPath: defaultData.tempPath,
	          tempNavPath: defaultData.tempNavPath,
	          tempNavItem: defaultData.tempNavItem,
	          hasMoreTokens: defaultData.hasMoreTokens,
	          parameters: defaultData.parameters
	        });
	
	        if (parsedData && parsedDataCopy && parsedData.navItem && parsedDataCopy.navItem && parsedData.navItem.id === parsedDataCopy.navItem.id) {
	          cont = false;
	          return defaultData;
	        }
	
	        cont = parsedData.cont;
	        childPath = parsedData.childPath;
	        defaultData.navItem = parsedData.navItem;
	        defaultData.tokens = parsedData.tokens;
	        defaultData.tempPath = parsedData.tempPath;
	        defaultData.tempNavPath = parsedData.tempNavPath;
	        defaultData.tempNavItem = parsedData.tempNavItem;
	        defaultData.hasMoreTokens = parsedData.hasMoreTokens;
	        defaultData.parameters = parsedData.parameters;
	      }
	
	      return defaultData;
	    }
	
	    function findMatchedNoChild(_navItem, parameters, tempPath, tempNavPath) {
	      var navItem = fisViewService.getItemFromPath2Item(tempPath);
	      var navigationPanelParamValue = createUrlFillingParams(tempPath, tempNavPath);
	      var paramNameString;
	      if (navItem !== null) {
	        paramNameString = findParamName(navItem);
	      }
	
	      parameters[paramNameString] = navigationPanelParamValue;
	
	      return {
	        navItem: navItem,
	        parameters: parameters
	      };
	    }
	
	    function createUrlFillingParams(tempPath, tempNavPath) {
	      return tempNavPath.substring(tempPath.length + 1);
	    }
	
	    function findParamName(navItem) {
	      return navItem.id.substring(navItem.id.indexOf(':') + 1);
	    }
	
	    function parseChildDataFrom(defaultData) {
	      var i = 0;
	      var child = null;
	      var childData = null;
	
	      for (i = 0; i < defaultData.tempNavItem.children.length; i++) {
	        child = defaultData.tempNavItem.children[i];
	
	        if (child && child.id.indexOf(':') !== -1) {
	          var proceed = child.id.indexOf(':') === 0 ? true : hasSomeEquivalentParam(child, defaultData.childPath);
	          if (proceed) {
	            childData = getChildDataFromPath(child, defaultData.childPath, defaultData.tokens.length, defaultData.tempPath, defaultData.tempNavPath, defaultData.hasMoreTokens);
	
	            defaultData.cont = false;
	            defaultData.navItem = childData.navItem;
	            defaultData.hasMoreTokens = childData.hasMoreTokens;
	            defaultData.tempPath = childData.tempPath;
	            defaultData.tempNavPath = childData.tempNavPath;
	            defaultData.parameters[childData.paramName] = childData.paramVal;
	
	            break;
	          }
	        } else {
	          for (var j = 0; j < defaultData.tokens.length; j++) {
	            if (child.id === defaultData.tokens[j]) {
	              var itemTokens = child.path.split('/');
	              // commented below line otherwise it continously loops for the case mentioned in SDHTML-5237
	              // defaultData.tempPath = defaultData.tempPath + '/' + child.path + '/';
	              defaultData.tempNavPath = defaultData.tempPath;
	              if (defaultData.tokens.length === itemTokens.length) {
	                defaultData.hasMoreTokens = false;
	                defaultData.cont = false;
	                defaultData.navItem = angular.copy(child);
	              }
	              break;
	            }
	          }
	          defaultData.cont = false;
	        }
	      }
	      return defaultData;
	    }
	
	    function getParameterValue(child, childPath, childTokens) {
	      var paramVal;
	
	      if (child.id.indexOf(':') === 0) {
	        paramVal = childTokens[0];
	      } else {
	        paramVal = childTokens[1];
	      }
	
	      return paramVal;
	    }
	
	    function getParametersIfUndefined(parameters, params) {
	      if (parameters === null && angular.isDefined(params)) {
	        parameters = params;
	      }
	
	      return parameters;
	    }
	
	    function mergeParametersIfRequired(parameters, params) {
	      if (parameters === null && angular.isDefined(params)) {
	        parameters = params;
	      } else if (angular.isDefined(params)) {
	        $.extend(true, parameters, params);
	      }
	
	      return parameters;
	    }
	
	    function getNavItemCopyIfParams(navItem, parameters, resolvedPath) {
	      if (parameters && navItem) {
	        if (navItem instanceof provider.ViewPanel) {
	          navItem = navItem.navItem;
	        }
	        // if it is a parameterized URL, substitue the params in the navItem's path
	        navItem = angular.copy(navItem);
	        if (!navItem.unresolvedPath) {
	          navItem.unresolvedPath = navItem.path;
	        }
	        navItem.path = substituteParams(navItem.path, parameters);
	        if (navItem.path && navItem.path.indexOf('/undefined/') > -1 && resolvedPath) {
	          navItem = fisViewService.findNavItem(resolvedPath);
	          navItem.path = substituteParams(navItem.path, navItem.params);
	        }
	        navItem.label = $filter('interpolate')(navItem.label, parameters);
	        if (!resolvedPath) {
	          navItem.params = parameters;
	        }
	      }
	
	      return navItem;
	    }
	
	    function getPanelPath(navPath) {
	      var panelPath = null;
	
	      if (angular.isDefined(navPath)) {
	        panelPath = navPath;
	      } else {
	        panelPath = service.activeViewPanel().path;
	      }
	
	      return panelPath;
	    }
	
	    function forceSelectionOfLastPanel(force) {
	      if (hasNoSelectedPanelPathButTabs()) {
	        if (force === undefined || force) {
	          // TODO: is this needed? is it only used when closing a tab? could it be moved there?
	          selectedPanelPath = getLastTab().path;
	        } else {
	          // no opened view panel (tab) available to select and we don't force selection.
	          return null;
	        }
	      }
	    }
	
	    function hasNoSelectedPanelPathButTabs() {
	      return !selectedPanelPath && tabs && tabs.length > 0;
	    }
	
	    function createParamsIfNotDefined(activeViewPanel) {
	      if (activeViewPanel !== null) {
	        if (angular.isUndefined(activeViewPanel.params) || activeViewPanel.params === null) {
	          activeViewPanel.params = {}; // we create a new object
	        } else if (angular.isUndefined(activeViewPanel.decodedParams) || activeViewPanel.decodedParams === null) {
	          activeViewPanel.decodedParams = addDecodedParams(activeViewPanel.params);
	        }
	      }
	    }
	
	    function isSecondaryNavItemReplacingPrimary(item, isNonCloseable) {
	      var primaryItem = getSecondaryNavParent(item.path);
	
	      if (primaryItem === item) {
	        return false;
	      }
	      if (primaryItem) {
	        var stillOpenPrimaryItem = service.viewPanels().filter(function (panel) {
	          return panel.path === primaryItem.path;
	        });
	        if (stillOpenPrimaryItem.length === 0) {
	          // The parent is not open in another tab, the closability depends on the parents closability
	          return service.isNonCloseable(primaryItem);
	        }
	        // The parent is open in another tab, thus we now may close this children tab
	        return false;
	      }
	
	      return isNonCloseable;
	    }
	
	    function getDefaultViewPanelIfNotDefined(viewPanel, navPath) {
	      if (!navPath) {
	        viewPanel = service.activeViewPanel();
	      }
	
	      return viewPanel;
	    }
	
	    function getDefaultNavPathIfNotDefined(navPath) {
	      if (!navPath) {
	        navPath = service.activeViewPanel().path;
	      }
	
	      return navPath;
	    }
	
	    function getDataFromNavPath(viewPanel, navPath) {
	      var tabIndexToRemove = null;
	
	      if (navPath) {
	        for (var i = 0; i < tabs.length; i++) {
	          if (tabs[i].path === navPath) {
	            tabIndexToRemove = i;
	            break;
	          }
	        }
	
	        if (tabIndexToRemove !== undefined) {
	          viewPanel = tabs[tabIndexToRemove];
	        }
	      }
	
	      return {
	        viewPanel: viewPanel,
	        tabIndexToRemove: tabIndexToRemove
	      };
	    }
	
	    function closeViewPanel(viewPanel, navPath, tabIndexToRemove) {
	      var tabToFocus = null;
	      var deferred = $q.defer();
	
	      if (viewPanel) {
	        viewPanel.$isClosing = true;
	
	        var promise = publishViewPanelCloseIntent(viewPanel, navPath);
	
	        promise.then(function () {
	          // handle the case where another close call has been made before the current one ends
	          viewPanel = getDefaultViewPanelIfNotDefined(viewPanel, navPath);
	          navPath = getDefaultNavPathIfNotDefined(navPath);
	
	          tabToFocus = getTabFocusFromNavPath(navPath);
	          tabIndexToRemove = getTabIndexToRemove(tabIndexToRemove, navPath);
	
	          removeTabByIndex(viewPanel, navPath, tabIndexToRemove, tabToFocus);
	
	          deferred.resolve();
	        }, function () {
	          deferred.reject('Pos 3');
	        }).finally(function () {
	          // Had to use $timeout to wrap the publish call. Promises seems to behave in synchronous manner when
	          // resolved with non-promise values (returned by $q.when in fisPubSubService.publish code). Therefore
	          // when fisViewPanelCloseIntent is published, promise.then and promise.always is called immediately called
	          // and the fis-views directive doesn't get a chance to react to viewPanel.$isClosing change and add
	          // a loading indicator.
	          $timeout(function () {
	            viewPanel.$isClosing = false;
	          }, 0);
	        });
	      } else {
	        // The navPath was not open or invalid, so resolve it right away - there's nothing to close.
	        deferred.resolve();
	      }
	
	      return deferred.promise;
	    }
	
	    function getTabFocusFromNavPath(navPath) {
	      var tabToFocus = null;
	
	      if (navPath !== selectedPanelPath) {
	        tabToFocus = selectedPanelPath;
	      }
	
	      return tabToFocus;
	    }
	
	    function getTabIndexToRemove(tabIndexToRemove, navPath) {
	      for (var i = 0; i < tabs.length; i++) {
	        if (tabs[i].path === navPath) {
	          tabIndexToRemove = i;
	          break;
	        }
	      }
	
	      return tabIndexToRemove;
	    }
	
	    function openDefaultEmptyView() {
	      $location.path('');
	      navigationUnderWay = true;
	    }
	
	    function openLastTab() {
	      // TODO: open last activated from a stack
	      var params = getLastTab() ? getLastTab().params : null;
	      service.open(getLastTab().path, null, params);
	    }
	
	    function removeViewPanel(tabIndexToRemove) {
	      tabs.splice(tabIndexToRemove, 1);
	    }
	
	    function openViewAfterClose(tabToFocus) {
	      if (tabs.length === 0) {
	        openDefaultEmptyView();
	      } else if (tabs.length > 0 && tabToFocus === null) {
	        openLastTab();
	      }
	    }
	
	    function copyClosingPanel(viewPanel) {
	      // create a copy of the closed view panel but without any functions
	      // or properties starting with '$' as we do not want the subscriber to modify the
	      // closed view panel
	      var viewPanelCopy = {};
	      Object.keys(viewPanel).forEach(function (key) {
	        if (!key.match(/^\$/)) {
	          var value = viewPanel[key];
	          if (!angular.isFunction(value)) {
	            viewPanelCopy[key] = value;
	          }
	        }
	      });
	      return viewPanelCopy;
	    }
	
	    function removeTabByIndex(viewPanel, navPath, tabIndexToRemove, tabToFocus) {
	      if (tabIndexToRemove !== null) {
	        removeViewPanel(tabIndexToRemove);
	
	        openViewAfterClose(tabToFocus);
	
	        viewPanel = copyClosingPanel(viewPanel);
	
	        publishViewPanelClosed(viewPanel, navPath);
	      }
	    }
	
	    function publishViewPanelCloseIntent(viewPanel, navPath) {
	      return fisPubSubService.publish('fisViewPanelCloseIntent', {
	        path: navPath,
	        viewPanel: viewPanel
	      });
	    }
	
	    function publishViewPanelClosed(viewPanel, navPath) {
	      return fisPubSubService.publish('fisViewPanelClosed', {
	        path: navPath,
	        viewPanel: viewPanel
	      });
	    }
	
	    /**
	     * @name open
	     * @methodOf fisViewPanelService
	     * @param {string} navPath Navigation Path to open. Undefined or empty string will load the default view.
	     * @param {Object} [event] Optional triggering event (For example, click), can be 'true' or 'false' :
	     *         True means we want to force opening in a new tab (and bypass the strategy) and false means we force opening in the same tab.
	     * @param {Object} [params] Optional Additional parameters
	     * @description Opens a ViewPanel using the configured strategy (or framework defaults 'mdi' strategy if none is configured.)
	     */
	    service.open = function (_navPath, event, params) {
	      // Hash must be removed when moving between pages (no event is fired when pages are loaded from a bookmark,
	      // an event is defined when navigating the menu or moving between tabs.
	      if (angular.isDefined(event)) {
	        resetLocationHash();
	      }
	      var relativeData = null;
	      var parameters = null;
	      var navPath = getDefaultIfNoPath(_navPath);
	      var normalized = normalizeOpenArguments(arguments, event, params);
	      var localEvent = normalized.localEvent;
	      var localParams = normalized.localParams;
	      var previousViewPanel = service.activeViewPanel(false);
	      var presentData = checkIfTabIsAlreadyPresent(navPath, event, params);
	      var navItem = presentData.navItem;
	      var tabFound = presentData.tabFound;
	      var navItemExist = false;
	      navigationUnderWay = true;
	      var resolvedPath;
	
	      navItem = tryOpenViewBasedOnDefaultParams(navItem, navPath, tabFound, event, params, localParams);
	
	      navItem = findNavItemIfNotDefined(navItem, navPath);
	
	      if (DEFAULT_OPEN_STRAT === provider.getViewOpeningStrategy() && angular.isDefined(event)) {
	        if (event && event.shiftKey && event.shiftKey === true) {
	          if (angular.isDefined(navItem)) {
	            /* The original code, which only checks whether the "last" item in the array matches in the path property:
	            _.each(tabs,function(tab){
	                navItemExist = tab.path === navItem.path;
	            });
	             During the removal of underscore, the code has been adjusted
	             */
	            navItemExist = tabs.some(function (tab) {
	              return tab.path === navItem.path;
	            });
	            if (navItemExist === false) {
	              tabs.push(new provider.ViewPanel(navItem, $filter));
	              return;
	            }
	          }
	        }
	      }
	
	      // if navItem not found, check for possibility of the navPath having relative url.
	      if (hasNoItemButTabs(navItem)) {
	        relativeData = extractRelativeUrlData(navItem, navPath);
	
	        parameters = relativeData.params;
	        navItem = relativeData.navItem;
	        resolvedPath = relativeData.resolvedPath;
	      }
	
	      parameters = getParametersIfUndefined(parameters, params);
	
	      navItem = getNavItemCopyIfParams(navItem, parameters, resolvedPath);
	
	      if (navItem !== undefined && navItem !== null && navItem.parentTitle !== undefined) {
	        navItem.isStatic = true;
	      }
	
	      validateNavItem(navItem, navPath);
	
	      if (angular.isDefined(navItem) && angular.isUndefined(navItem.partial)) {
	        if (fisConfig.widgets && fisConfig.widgets.fisTabsBar) {
	          var openFirstChildIfEmpty = fisConfig.widgets.fisTabsBar.openFirstChildIfEmpty;
	
	          if (angular.isUndefined(openFirstChildIfEmpty) || openFirstChildIfEmpty) {
	            var firstChildWithPartial = findFirstChildWithPartial(navItem);
	
	            if (firstChildWithPartial !== null) {
	              $timeout(function () {
	                service.open(firstChildWithPartial.path, event, params);
	                fisPubSubService.publish('fisFirstSecondaryItemOpened');
	              });
	            }
	          }
	        }
	      }
	
	      if (!getSecondaryNavParent(navPath)) {
	        callRelevantStrategy(navItem, localEvent, localParams);
	      }
	
	      // Passing the event object through here allows listeners of this to determine the origin of the open
	      // e.g. was it a mega menu link or a tabbar link?
	      publishViewPanelChange(navItem, previousViewPanel, event);
	
	      if (navItem !== undefined && (navItem.closeable === true || navItem.closeable === 'true' || navItem.closeable === undefined)) {
	        // broadcast on the rootscope, so other external modules can listen for this
	        $rootScope.$broadcast('fisTabOpened', { path: _navPath });
	      }
	
	      $timeout(function () {
	        navigationUnderWay = false;
	      });
	    };
	
	    function findFirstChildWithPartial(navItem) {
	      if (angular.isDefined(navItem.children) && navItem.children.length > 0) {
	        if (angular.isUndefined(navItem.children[0].partial)) {
	          return findFirstChildWithPartial(navItem.children[0]);
	        }
	        return navItem.children[0];
	      }
	      return null;
	    }
	
	    /**
	     * @name viewPanels
	     * @methodOf fisViewPanelService
	     * @returns {Array} Open ViewPanels
	     * @description Returns array of open view panels
	     */
	    service.viewPanels = function () {
	      return tabs;
	    };
	
	    /**
	     * @name viewPanelByPath
	     * @methodOf fisViewPanelService
	     * @param {String} Navigation Path of the open View Panel
	     * @returns {Object} View Panel for the navigation path passed in
	     * @description Returns the view panel corresponding to the given nav path
	     */
	    service.viewPanelByPath = function (navPath) {
	      var viewPanel;
	
	      for (var i = 0; i < tabs.length; i++) {
	        if (tabs[i].path === navPath) {
	          viewPanel = tabs[i];
	
	          break;
	        }
	      }
	
	      return viewPanel;
	    };
	
	    /**
	     * @name reloadActiveViewPanel
	     * @methodOf fisViewPanelService
	     * @param {String} Navigation Path of the panel that needs to be reloaded - optional, if not provided, then the current active panel is used
	     * @description Reloads the current active panel
	     */
	    service.reloadActiveViewPanel = function (navPath, params) {
	      var panelPath = getPanelPath(navPath);
	      var parameters = null;
	
	      for (var j = 0; j < tabs.length; j++) {
	        if (tabs[j].path === panelPath) {
	          var navItem = fisViewService.findNavItem(panelPath);
	          // handling parameterized navigation item with resolved path
	          if (!navItem) {
	            var relativeData = extractRelativeUrlData(navItem, panelPath);
	            navItem = relativeData.navItem;
	            parameters = relativeData.params;
	          } else if (angular.isUndefined(params) || params.length === 0) {
	            // if params are undefined, try to use params from the active view panel in this case; since the view to be opened is a relative view.
	            parameters = service.activeViewPanel().params;
	          }
	
	          parameters = mergeParametersIfRequired(parameters, params);
	          navItem = getNavItemCopyIfParams(navItem, parameters);
	          // Replace ViewPanel - ng-repeat will detect change and destroy DOM (div and scope)
	          tabs[j] = new provider.ViewPanel(navItem, $filter);
	
	          service.open(panelPath, null, parameters);
	
	          break;
	        }
	      }
	    };
	
	    /**
	     * @name activeViewPanel
	     * @methodOf fisViewPanelService
	     * @returns {Object} Active View Panel
	     * @description Returns the active View Panel. This will always return an activeViewPanel
	     *      if there are opened view panels because it will select one.
	     * @param force undefined or a truthy value will force selection of the last tab.
	     */
	    service.activeViewPanel = function (force) {
	      var activeViewPanel = null;
	
	      forceSelectionOfLastPanel(force);
	
	      for (var i = 0; i < tabs.length; i++) {
	        if (tabs[i].path === selectedPanelPath) {
	          activeViewPanel = tabs[i];
	
	          break;
	        }
	      }
	
	      createParamsIfNotDefined(activeViewPanel);
	
	      return activeViewPanel;
	    };
	
	    /**
	     * @name activeViewPanelIndex
	     * @methodOf fisViewPanelService
	     * @returns {int} Active View Panel index
	     * @description Returns the active View Panel index
	     */
	    service.activeViewPanelIndex = function () {
	      for (var i = 0; i < tabs.length; i++) {
	        if (tabs[i].path === selectedPanelPath) {
	          return i;
	        }
	      }
	
	      return -1;
	    };
	
	    /**
	     * @name viewPanelParams
	     * @methodOf fisViewPanelService
	     * @returns {Object} params for active view panel
	     * @description Returns the params for active View Panel
	     */
	    service.viewPanelParams = function () {
	      var params = {};
	
	      if (service.activeViewPanel()) {
	        params = service.activeViewPanel().params;
	      }
	
	      return params;
	    };
	
	    /**
	     * @name selectedViewPanelPath
	     * @methodOf fisViewPanelService
	     * @returns {String} Active View Panel path
	     * @description Returns the active View Panel path
	     */
	    service.selectedViewPanelPath = function (path) {
	      if (arguments.length === 0) {
	        return selectedPanelPath;
	      }
	      service.selectedPanelPath = path;
	      service.open(path);
	    };
	
	    /**
	     * @name resetSelectedViewPanelPath
	     * @methodOf fisViewPanelService
	     * @description Removes the selected panel path reference
	     */
	    service.resetSelectedViewPanelPath = function () {
	      selectedPanelPath = undefined;
	    };
	
	    /**
	     * @name isNonCloseable
	     * @methodOf fisViewPanelService
	     * @param {Object} item View Panel
	     * @returns {boolean} true if the View Panel is non-closeable else false
	     * @description Returns if a View Panel is closeable or not. View Panels corresponding to top level
	     * Navigation Items that have partials attached to them are considered non-closeable.
	     */
	    service.isNonCloseable = function (item) {
	      var isNonCloseable = false;
	
	      if (isNavItemDefined(item)) {
	        if (angular.isDefined(item.closeable)) {
	          isNonCloseable = !item.closeable;
	        }
	
	        var parent = getItemParentRefIfValid(item);
	
	        if (parent !== item) {
	          isNonCloseable = isSecondaryNavItemReplacingPrimary(item, isNonCloseable);
	        }
	
	        if (isNavItemDefined(item) && hasDropdownSecondaryMenu(item)) {
	          isNonCloseable = true;
	        }
	      }
	
	      return isNonCloseable;
	    };
	
	    /**
	     * @name close
	     * @methodOf fisViewPanelService
	     * @param {String} _navPath Path corresponding to a View Panel
	     * @description Closes a View Panel associated to the nav Path
	     */
	    service.close = function (_navPath) {
	      var viewPanel = getDefaultViewPanelIfNotDefined(null, _navPath);
	      var navPath = getDefaultNavPathIfNotDefined(_navPath);
	      var navPathData = getDataFromNavPath(viewPanel, navPath);
	      var tabIndexToRemove = navPathData.tabIndexToRemove;
	
	      viewPanel = navPathData.viewPanel;
	
	      // broadcast on the rootscope, so other external modules can listen for this
	      $rootScope.$broadcast('fisTabClosed', { path: _navPath });
	
	      return closeViewPanel(viewPanel, navPath, tabIndexToRemove);
	    };
	
	    function findScopeForEvaluation(context, element) {
	      // check if the context is a scope (that's the case when the service function is invoked from an angular expression)
	      if (context.$eval) {
	        // it quacks like one
	        return context;
	      }
	
	      // no luck try with the element, if present
	      if (element && element.scope) {
	        return element.scope();
	      }
	
	      throw new Error('Cannot find a scope to evaluate expression in.');
	    }
	
	    function findElementFromEvent(event) {
	      return angular.isObject(event) && angular.isDefined(event.target) && angular.element(event.target);
	    }
	
	    function processActionView(context, viewDef, event, params) {
	      var locals;
	      var ret;
	      var destroyScope = false;
	      var element = findElementFromEvent(event);
	      var evalScope = findScopeForEvaluation(context, element);
	
	      if (angular.isObject(params)) {
	        locals = angular.copy(params);
	      } else {
	        locals = {};
	      }
	
	      locals.view = viewDef;
	      locals.$scope = evalScope;
	
	      if (angular.isString(viewDef.actionController)) {
	        // create a new child scope on which to attach the controller
	        locals.$scope = evalScope = evalScope.$new();
	        locals.$element = element;
	        $controller(viewDef.actionController, locals);
	        destroyScope = true;
	      }
	
	      // elements can't be referenced in angualr expressions
	      delete locals.$element;
	      // event put in locals only for the expression evaluation
	      locals.$event = event;
	
	      ret = evalScope.$eval(viewDef.action, locals);
	
	      if (destroyScope) {
	        evalScope.$destroy();
	      }
	
	      return ret;
	    }
	
	    service.openView = function (viewDef, event, params) {
	      var context = this;
	
	      if (viewDef.action) {
	        return processActionView(context, viewDef, event, params);
	      } else if (viewDef.path) {
	        return service.open.call(context, viewDef.path, event, params);
	      } else if (angular.isString(viewDef)) {
	        return service.open.call(context, viewDef, event, params);
	      }
	
	      throw new Error('Cannot open provided view definition object');
	    };
	
	    /* service.setNavigationComplete = function() {
	        $timeout (function () {
	            navigationUnderWay = false;
	        });
	    };*/
	
	    var activePanel;
	
	    fisPubSubService.subscribe('fisBeforeNavItemAdd', function () {
	      activePanel = service.activeViewPanel();
	    });
	
	    fisPubSubService.subscribe('fisAfterNavItemAdd', function (params) {
	      if (params.rootNav === 'main' && params.itemToAdd.partial) {
	        tabs.push(new provider.ViewPanel(params.itemToAdd, $filter));
	      }
	      if (params.openItemAfterAdd) {
	        service.open(params.itemToAdd.path, null, params.openParams);
	      } else {
	        service.open(activePanel.path, null, params.openParams);
	      }
	      fisPubSubService.publish('fisAfterNavItemAdded');
	    });
	
	    fisPubSubService.subscribe('fisBeforeNavItemRemove', function () {
	      activePanel = service.activeViewPanel();
	    });
	
	    fisPubSubService.subscribe('fisAfterNavItemRemove', function (params) {
	      var tabToClose = null;
	      var secondaryNavParent;
	
	      for (var i = 0; i < tabs.length; i++) {
	        if (tabs[i].id === params.itemToRemove.id) {
	          tabToClose = tabs[i];
	          break;
	        }
	      }
	      if (!params.openParentNode && tabToClose) {
	        service.close(tabToClose.path);
	      }
	
	      // see if the item to be removed is part of the currently open secondary menu bar
	      // if it is, the secondary menu bar should refresh irrespective of the openParentNode param value
	      if (params.itemToRemove.id !== service.activeViewPanel().id && service.activeViewPanel() && (service.activeViewPanel().unresolvedPath || service.activeViewPanel().path)) {
	        var activePanelPath = service.activeViewPanel().unresolvedPath ? service.activeViewPanel().unresolvedPath : service.activeViewPanel().path;
	        secondaryNavParent = getSecondaryNavParent(params.itemToRemove.path);
	        var secondaryNavParentForActiveTab = getSecondaryNavParent(activePanelPath);
	        if (secondaryNavParent && secondaryNavParentForActiveTab && secondaryNavParent.path === secondaryNavParentForActiveTab.path) {
	          if (tabToClose) {
	            service.close(tabToClose.path);
	          }
	          service.open(service.activeViewPanel().path, null, params.openParams);
	        }
	      }
	
	      if (params.openParentNode && params.parentItem && params.parentItem.partial) {
	        service.open(params.parentItem.path, null, params.openParams);
	      } else if (params.openParentNode && params.parentItem && !params.parentItem.partial) {
	        secondaryNavParent = getSecondaryNavParent(params.itemToRemove.path);
	        if (secondaryNavParent) {
	          service.open(secondaryNavParent.path, null, params.openParams);
	        } else if (tabToClose) {
	          service.close(tabToClose.path);
	        }
	      }
	
	      fisPubSubService.publish('fisAfterNavItemRemoved');
	    });
	
	    init();
	
	    return service;
	  }];
	};

/***/ }),
/* 64 */
/*!****************************************!*\
  !*** ./views/view-service.provider.js ***!
  \****************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  'use strict';
	
	  var self = this;
	  // filters allow modifying the incoming nav structure before it gets
	  // processed. It could be used to define the nav structure on the client
	  // instead of on the server.
	  // filter signature: function( items, params )
	  // item: array of root nav items
	  // params: params sent to navigation.refresh method.
	  var filters = [];
	  self.addFilter = function (filter) {
	    return filters.push(filter);
	  };
	
	  self.removeFilter = function (idx) {
	    delete filters[idx];
	  };
	
	  // set to false to prevent service from invoking the navigation rest endpoint
	  self.remote = true;
	
	  var staticViews = null;
	  self.setViews = function (views) {
	    staticViews = views;
	  };
	
	  // the default RESTful resource endpoint
	  var defaultEndpoint = 'api/navigation.json';
	  var endpoint = null;
	  self.endpoint = function (ep) {
	    if (ep) {
	      endpoint = ep;
	    }
	    return endpoint;
	  };
	
	  // reference to angular's $routeProvider
	  self.$routeProvider = null;
	
	  self.$get = ['$templateCache', '$resource', '$route', '$rootScope', '$log', 'fisConfig', '$q', 'fisPubSubService', 'fisUtilService', '$injector', 'fisNavigationService', 'fisI18nService', function ($templateCache, $resource, $route, $rootScope, $log, fisConfig, $q, fisPubSubService, fisUtilService, $injector, fisNavigationService, fisI18nService) {
	    var nav = null;
	    var path2Item = {};
	    var id2Item = {};
	    var serv = {};
	
	    /**
	     * @name applyFilter
	     * @description Utility function to filter navigation model.
	     * @param model model to apply filters to
	     * @param params filter parameters
	     * @return
	     * @methodOf fisViewService
	     * @private
	     */
	    function applyFilters(model, params) {
	      for (var i = 0; i < filters.length; i++) {
	        filters[i](model, params);
	      }
	    }
	
	    /**
	     * @name traverse
	     * @description Utility function to traverse and process navigation
	     * structure
	     * @param items structure to traverse
	     * @param cb calback to apply during traversal
	     * @param navPath tracks position in structure.
	     * @return
	     * @methodOf fisViewService
	     * @private
	     */
	    function traverse(items, cb, navPath) {
	      var path = navPath || [];
	      angular.forEach(items, function (itm /* , key*/) {
	        var ret = cb.apply(this, [itm, path]);
	        if (ret === false) {
	          return false;
	        }
	        if (itm.children) {
	          path.push(itm);
	          traverse(itm.children, cb, path);
	          path.pop();
	        }
	        if (itm.quickLinks) {
	          angular.forEach(itm.quickLinks, function (quickLinks) {
	            path.push(itm);
	            path.push(quickLinks); // include quicklinks in path
	            traverse(quickLinks.children, cb, path);
	            path.pop();
	            path.pop();
	          });
	        }
	      }, items);
	    }
	
	    /**
	     * @name normalizeLabel
	     * @description Normalises text to acceptable characters
	     * @param label text to normalise
	     * @return normalized text
	     * @methodOf fisViewService
	     * @private
	     */
	    function normalizeLabel(label) {
	      return label.toLowerCase().replace(' ', '-');
	    }
	
	    function updatePath2Item(itm, path) {
	      if (!itm.id) {
	        itm.id = normalizeLabel(itm.label);
	      }
	      if (!itm.path) {
	        var a = [];
	        for (var i = 0; i < path.length; i++) {
	          a.push(path[i].id);
	        }
	        a.push(itm.id);
	        itm.path = '/' + a.join('/');
	        path2Item[itm.path] = itm;
	      }
	      // In case, translation data is loading asynchronously, updating the label and title in path2Item[] array
	      if (path2Item[itm.path] !== undefined) {
	        path2Item[itm.path].label = itm.label;
	        path2Item[itm.path].title = itm.title;
	      }
	    }
	
	    function updateId2Item(itm) {
	      if (itm.id.indexOf('/') > -1) {
	        var isAlreadyIncluded = Object.keys(id2Item).some(function (key) {
	          return id2Item[key] === itm;
	        });
	        if (!isAlreadyIncluded) {
	          id2Item[itm.id] = itm;
	        }
	      }
	    }
	
	    /**
	     * @name normalizeModel
	     * @description Normalizes text to acceptable characters for model
	     * @param model structure with labels to normalize
	     * @methodOf fisViewService
	     * @private
	     */
	    function normalizeModel(model) {
	      angular.forEach(model, function (navItems /* , key*/) {
	        traverse(navItems, function (itm, path) {
	          updatePath2Item(itm, path);
	          updateId2Item(itm);
	
	          // i18n support of navigation item's label and title
	          if (itm.label && itm.label.indexOf('i18n(') === 0) {
	            itm.label = itm.label.substring(itm.label.indexOf('(') + 2, itm.label.indexOf(')') - 1);
	            // In case, translations are available for the selected language then we can directly translate label and titles
	            if (fisI18nService.isTranslationReady()) {
	              itm.label = fisI18nService.translate(itm.label);
	              updatePath2Item(itm, path);
	              updateId2Item(itm);
	            } else {
	              // In case, translations are loading asynchronously, we need to use promise api to update
	              // labels and titles on receiving data for translation
	              fisI18nService.translateAsync(itm.label).then(function (resolvedLabel) {
	                itm.label = resolvedLabel;
	                updatePath2Item(itm, path);
	                updateId2Item(itm);
	              });
	            }
	          }
	          if (itm.title && itm.title.indexOf('i18n(') === 0) {
	            itm.title = itm.title.substring(itm.title.indexOf('(') + 2, itm.title.indexOf(')') - 1);
	            // In case, translations are available for the selected language then we can directly translate label and titles
	            if (fisI18nService.isTranslationReady()) {
	              itm.title = fisI18nService.translate(itm.title);
	              updatePath2Item(itm, path);
	              updateId2Item(itm);
	            } else {
	              // In case, translations are loading asynchronously, we need to use promise api to update
	              // labels and titles on receiving data for translation
	              fisI18nService.translateAsync(itm.title).then(function (resolvedTitle) {
	                itm.title = resolvedTitle;
	                updatePath2Item(itm, path);
	                updateId2Item(itm);
	              });
	            }
	          }
	          // support definitions that only contain a template
	          if (itm.template && !itm.partial) {
	            itm.partial = itm.path + '.tpl.html';
	          }
	        });
	      });
	    }
	
	    /**
	     * @name createRoutes
	     * @description Creates angular routes from navigation structure
	     * @param model navigation structure
	     * @methodOf fisViewService
	     * @private
	     */
	    function createRoutes(model) {
	      angular.forEach(model, function (navItems /* , key*/) {
	        traverse(navItems, function (itm /* , path*/) {
	          if (itm.partial) {
	            var opts = {
	              templateUrl: fisUtilService.appendCacheQueryParameter(itm.partial)
	            };
	
	            if (itm.template) {
	              // prefill $templateCache with provided template
	              $templateCache.put(itm.partial, itm.template);
	            }
	
	            if (itm.controller) {
	              // TODO: Controllers need to be loaded on demand
	              opts.controller = itm.controller;
	            }
	            opts.resolve = createResolveProperty(itm);
	            self.$routeProvider.when(itm.path, opts);
	          } else if (!itm.children && !itm.action) {
	            $log.warn('Leaf nav item without a partial: ' + itm.label);
	          }
	        });
	      });
	    }
	
	    function createResolveProperty(itm) {
	      var ret = {};
	
	      // find the constructor in the registry
	      var ctrl = itm.controller && fis.__controllers[itm.controller];
	
	      angular.forEach(ctrl, function (val, key) {
	        if (key.indexOf('$') !== 0) {
	          ret[key] = createResolveValue(val, itm.args);
	        }
	      });
	
	      if (itm.args) {
	        ret.args = function () {
	          return itm.args;
	        };
	      }
	
	      return ret;
	    }
	
	    function createResolveValue(toResolve, args) {
	      if (angular.isFunction(toResolve) || angular.isArray(toResolve) && angular.isFunction(toResolve[toResolve.length - 1])) {
	        return function resolveFunction() {
	          return $injector.invoke(toResolve, this, { args: args });
	        };
	      }
	      return toResolve; // a simple object/array/native we want to pass
	    }
	
	    /**
	     * @name processMenu
	     * @description Process navigation structure for use in shell
	     * @param model navigation structure
	     * @param params filter parameters
	     * @methodOf fisViewService
	     * @private
	     */
	    function processMenu(model, params) {
	      // TODO: execute all into a single traversal for speed.
	      // add the default workspace
	      applyFilters(model, params);
	      normalizeModel(model);
	      createRoutes(model);
	
	      return model;
	    }
	
	    /**
	     * @name fetchNavigation
	     * @description Fetches navigation structure from backend and processes it
	     * @param endpoint Serverside RESTful endpoint that serves navigation structure
	     * @param params filter parameters
	     * @methodOf fisViewService
	     * @private
	     */
	    function fetchNavigation(endpoint, params) {
	      var deferred = $q.defer();
	      $resource(endpoint).get(params, function (results) {
	        var finalResult = {};
	        for (var key in results) {
	          if (results.hasOwnProperty(key)) {
	            var value = results[key];
	            if (key.indexOf('$') !== 0) {
	              finalResult[key] = value;
	            }
	          }
	        }
	        resolveViews(deferred, finalResult, params);
	      }, function () {
	        deferred.reject('Could not load navigation from ' + endpoint);
	      });
	      return deferred.promise;
	    }
	
	    function resolveViews(deferred, views, params) {
	      // assign the processed views to the internal nav var
	      nav = processMenu(views, params);
	
	      // resolve the deferred object to the processed views
	      deferred.resolve(nav);
	
	      // publish it on the 'shell.navReady' topic so that nav widgets can render the views
	      fisPubSubService.publish('shell.navReady', nav);
	      fisNavigationService.setNavigation(nav);
	      return deferred.promise;
	    }
	
	    /**
	     * @name load
	     * @description Loads and initializes navigation
	     * @param params filter parameters
	     * @param model existing navigation structure(optional)
	     * @methodOf fisViewService
	     */
	    serv.load = function (params, model) {
	      // TODO: use fisConfig to get default params and extend with received params
	      params = params || {};
	      path2Item = params.path2Item || {};
	
	      fisPubSubService.publish('shell.navLoading', true);
	      if (model || staticViews) {
	        // views provided as an argument or at config time; make it the new nav structure
	        return resolveViews($q.defer(), angular.copy(model || staticViews), params);
	      } else if (self.endpoint()) {
	        // an endpoint was provided at config time, it takes precedence over config service
	        return fetchNavigation(self.endpoint(), params);
	      }
	      return fetchNavigation(fisConfig.endpoints && fisConfig.endpoints.navigation || defaultEndpoint, params);
	    };
	
	    serv.loadOnNavChange = function (params, model) {
	      // TODO: use fisConfig to get default params and extend with received params
	      params = params || {};
	      path2Item = params.path2Item || {};
	
	      var deferred = $q.defer();
	
	      // assign the processed views to the internal nav var
	      nav = processMenu(angular.copy(model), params);
	
	      // resolve the deferred object to the processed views
	      deferred.resolve(nav);
	
	      fisPubSubService.publish('shell.navChanged', nav);
	
	      fisNavigationService.setNavigation(nav);
	      return deferred.promise;
	    };
	
	    /**
	     * @name findNavItem
	     * @description Retrieves item at specified path.
	     * @param navPath Navigation Path for required item
	     * @param fromPath Path to search from if navPath is relative (doesn't start with '/').
	     *          If not provided and navPath is relative, the function will return undefined.
	     * @methodOf fisViewService
	     */
	    /* serv.findNavItem = function (navPath, fromPath) {
	     console.log('Processing for navPath...', navPath);
	     console.log('fromPath...', fromPath);
	     fromPath = fromPath || '';
	     if( navPath && navPath.indexOf('/') !== 0 ) {
	     // navPath is relative, search from fromPath
	     var item, idx = fromPath.lastIndexOf('/') + 1;
	     console.log('index...', idx);
	     console.log('path2Item...', path2Item);
	     while(idx > 1) {
	     console.log('path...', fromPath.substring(0, idx) + navPath);
	     item = path2Item[fromPath.substring(0, idx) + navPath];
	     console.log('item...', item);
	     if( item ) {
	     return item;
	     }
	     idx = fromPath.lastIndexOf('/', idx - 2) + 1;
	     console.log('index after...', idx);
	     }
	     }
	     return path2Item[navPath];
	     };*/
	
	    serv.findNavItem = function (navPath, fromPath) {
	      var item = null;
	      fromPath = fromPath || '';
	
	      if (navPath && navPath.indexOf('/') !== 0) {
	        // navPath is relative, search from fromPath
	        // var idx = fromPath.lastIndexOf('/') + 1;
	        // console.log('index...', idx);
	        // console.log('path2Item...', path2Item);
	        // console.log('path...', fromPath.substring(0, idx) + navPath);
	        item = path2Item[fromPath + '/' + navPath];
	        // console.log('item...', item);
	        if (item) {
	          return item;
	        }
	        // item not found relative to fromPath.
	        item = serv.getItemFromPath2Item(navPath);
	        // item still not found. Try to find if the path is just id. check with ids that contain '/' character
	        if (!item) {
	          item = getItemFromId2Item(navPath);
	        }
	        return item;
	      }
	
	      item = path2Item[navPath];
	
	      return item;
	    };
	
	    function getItemFromId2Item(navPath) {
	      var item = null;
	
	      for (var id in id2Item) {
	        // eslint-disable-line
	        var idArr = id.split('/');
	        var navPathArr = navPath.split('/');
	        if (idArr.length === navPathArr.length) {
	          var paramArr = matchTokens(idArr, navPathArr);
	          if (paramArr) {
	            item = id2Item[id];
	            item.params = paramArr;
	            break;
	          }
	        }
	      }
	      return item;
	    }
	
	    function matchTokens(idArr, navPathArr) {
	      var paramArr = {};
	
	      for (var i = 0; i < idArr.length; i++) {
	        if (idArr[i] !== navPathArr[i] && idArr[i].indexOf(':') !== 0) {
	          paramArr = null;
	          return false;
	        } else if (idArr[i] !== navPathArr[i] && idArr[i].indexOf(':') === 0) {
	          var paramName = idArr[i].substring(1);
	          var paramValue = navPathArr[i];
	          paramArr[paramName] = paramValue;
	        }
	      }
	
	      return paramArr;
	    }
	
	    // returns the last part of the navItem, excluding those those which include a ':', in which case the second last part will be returned
	    function getNavPathEnd(navItem) {
	      var parts = navItem.split('/');
	      var size = parts.length;
	
	      if (size < 2) {
	        return navItem;
	      }
	
	      if (parts[size - 1].indexOf(':') === -1) {
	        return parts[size - 1];
	      } else if (parts[size - 2].indexOf(':') === -1) {
	        return parts[size - 2];
	      }
	
	      // more than one parameters in id
	      for (var i = size - 1; i > 0; i--) {
	        if (parts[i].indexOf(':') === -1) {
	          return parts[i];
	        }
	      }
	    }
	
	    serv.getItemFromPath2Item = function (navPath) {
	      var navItem = null;
	
	      for (var path in path2Item) {
	        if (path2Item.hasOwnProperty(path)) {
	          var item = path2Item[path];
	
	          var pathTokenLength = path.split('/').length;
	          var navPathTokenLength = navPath.split('/').length;
	
	          if ((pathTokenLength > 2 && navPathTokenLength > 2 && pathTokenLength === navPathTokenLength || pathTokenLength <= 2 || navPathTokenLength <= 2) && getNavPathEnd(path) === getNavPathEnd(navPath)) {
	            navItem = item;
	            return navItem;
	          }
	        }
	      }
	      return navItem;
	    };
	
	    serv.addDynamicItem = function (item, opts) {
	      path2Item[item.path] = item;
	      self.$routeProvider.when(item.path, opts);
	    };
	
	    /**
	     * @name addItemToMenu
	     * @description Add a node to existing navigation structure dynamically
	     * @param parentItemId id or path of the node to which the new node needs to be appended
	     * @param itemToAdd new node to be added
	     * @methodOf fisViewService
	     */
	    serv.addNavItem = function (parentItemId, itemToAdd, openItemAfterAdd, openParams, addAfterItemId) {
	      if (itemToAdd && itemToAdd.id) {
	        var deferred = $q.defer();
	        openItemAfterAdd = openItemAfterAdd === 'true' || openItemAfterAdd === true;
	        openParams = jQuery.isEmptyObject(openParams) ? undefined : openParams;
	        fisPubSubService.publish('fisBeforeNavItemAdd', true);
	        var parentItem = serv.findNavItem(parentItemId);
	        if (parentItem) {
	          itemToAdd.path = parentItem.path + '/' + itemToAdd.id;
	          path2Item[itemToAdd.path] = itemToAdd;
	          if (!parentItem.children) {
	            parentItem.children = [];
	          }
	
	          if (isItemAlreadyPresentInParent(parentItem.children, itemToAdd)) {
	            deferred.reject();
	          } else {
	            // add item after the specified sibling - if this item is not found, the new item will be added at the end
	            if (addAfterItemId) {
	              var siblingItem = serv.findNavItem(addAfterItemId);
	              if (siblingItem) {
	                var siblingIndex = -1;
	                for (var i = 0; i < parentItem.children.length; i++) {
	                  if (parentItem.children[i].path === siblingItem.path) {
	                    siblingIndex = i;
	                    break;
	                  }
	                }
	                if (siblingIndex > -1) {
	                  parentItem.children.splice(siblingIndex + 1, 0, itemToAdd);
	                }
	              }
	            } else {
	              parentItem.children.push(itemToAdd);
	            }
	            updateModel(parentItem, function (navItems, matchedItem) {
	              matchedItem.children = parentItem.children;
	            });
	
	            serv.loadOnNavChange({ path2Item: path2Item }, nav).then(function () {
	              fisPubSubService.publish('fisAfterNavItemAdd', { nav: nav, itemToAdd: itemToAdd, parentItem: parentItem, openItemAfterAdd: openItemAfterAdd, openParams: openParams });
	              deferred.resolve(nav);
	            });
	          }
	        } else if (!parentItem && nav[parentItemId]) {
	          // if item needs to be added directly at root level (for ex. directly under main, footer etc.)
	          itemToAdd.path = '/' + itemToAdd.id;
	          path2Item[itemToAdd.path] = itemToAdd;
	          if (isItemAlreadyPresentInParent(nav[parentItemId], itemToAdd)) {
	            deferred.reject();
	          } else {
	            nav[parentItemId].push(itemToAdd);
	            serv.loadOnNavChange({ path2Item: path2Item }, nav).then(function () {
	              var rootNav = parentItemId;
	              fisPubSubService.publish('fisAfterNavItemAdd', { nav: nav, itemToAdd: itemToAdd, parentItem: parentItem, openItemAfterAdd: openItemAfterAdd, openParams: openParams, rootNav: rootNav });
	              deferred.resolve(nav);
	            });
	          }
	        }
	        return deferred.promise;
	      }
	    };
	
	    function isItemAlreadyPresentInParent(children, itemToAdd) {
	      return children.some(function (child) {
	        return child.id === itemToAdd.id;
	      });
	    }
	
	    // TODO: There should not be a need for traversing the nav and updating it separately
	    // However in case when we add an item first and then remove it, the changes are not
	    // getting reflected in the model.
	    // Need to look into the cause of this.
	    function updateModel(itemToLookup, cb) {
	      angular.forEach(nav, function (navItems /* , key*/) {
	        traverse(navItems, function (itm) {
	          if (itm.path === itemToLookup.path) {
	            cb.apply(this, [navItems, itm]);
	          }
	        });
	      });
	    }
	
	    function getIndexOfChild(childItem, parentItem) {
	      var index = -1;
	      if (parentItem && parentItem.children) {
	        for (var i = 0; i < parentItem.children.length; i++) {
	          var child = parentItem.children[i];
	          if (child.id === childItem.id) {
	            index = i;
	            break;
	          }
	        }
	      }
	      return index;
	    }
	
	    serv.removeNavItem = function (itemToRemoveId, openParentNode, openParams) {
	      var deferred = $q.defer();
	      var parentItem;
	
	      openParentNode = openParentNode === 'true' || openParentNode === true;
	      fisPubSubService.publish('fisBeforeNavItemRemove', true);
	      var itemToRemove = serv.findNavItem(itemToRemoveId);
	      if (itemToRemove) {
	        var parentPath = itemToRemove.path.substring(0, itemToRemove.path.lastIndexOf('/'));
	        if (parentPath) {
	          parentItem = serv.findNavItem(parentPath);
	
	          // if parent item not found, tokenize the path and try to find the parent
	          if (!parentItem) {
	            var hasMoreTokens = true;
	            var tempPath = parentPath;
	
	            while (hasMoreTokens) {
	              tempPath = tempPath.substring(0, tempPath.lastIndexOf('/'));
	              if (tempPath && tempPath.length === 0) {
	                hasMoreTokens = false;
	              } else {
	                parentItem = serv.findNavItem(tempPath);
	                if (parentItem) {
	                  hasMoreTokens = false;
	                }
	              }
	            }
	          }
	
	          if (parentItem) {
	            var itmToRemIndex = getIndexOfChild(itemToRemove, parentItem);
	            if (itmToRemIndex > -1) {
	              parentItem.children.splice(itmToRemIndex, 1);
	              path2Item[parentItem.path] = parentItem;
	
	              delete path2Item[itemToRemove.path];
	              delete id2Item[itemToRemove.id];
	
	              updateModel(parentItem, function (navItems, matchedItem) {
	                matchedItem.children = parentItem.children;
	              });
	            }
	          }
	        } else {
	          // no parent path means the node is at root level
	          updateModel(itemToRemove, function (navItems, matchedItem) {
	            navItems.splice(navItems.indexOf(matchedItem), 1);
	          });
	        }
	
	        serv.loadOnNavChange({ path2Item: path2Item }, nav).then(function () {
	          fisPubSubService.publish('fisAfterNavItemRemove', { nav: nav, itemToRemove: itemToRemove, parentItem: parentItem, openParentNode: openParentNode, openParams: openParams });
	          deferred.resolve(nav);
	        });
	      } else {
	        deferred.reject();
	      }
	
	      return deferred.promise;
	    };
	
	    return serv;
	  }];
	};

/***/ }),
/* 65 */
/*!**********************************************!*\
  !*** ./views/navigation-service.provider.js ***!
  \**********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var self = this;
	
	  self.$get = ['fisPubSubService', '$q', function (fisPubSubService, $q) {
	    var service = {};
	    var navigation;
	    var deferred = $q.defer();
	
	    /**
	     * since the 'shell.navReady' is fired before this directive is instantiated,
	     * this method is only used when the navigation is updated.
	     * @param nav
	     */
	    fisPubSubService.subscribe('shell.navReady', function (nav) {
	      if (angular.isDefined(nav)) {
	        navigation = nav;
	        deferred.resolve(navigation);
	      }
	    });
	
	    /**
	     * Setter for the Navigation - used to set navigaiton from the View Service.
	     * @param nav
	     */
	    service.setNavigation = function (nav) {
	      navigation = nav;
	      deferred.resolve(navigation);
	    };
	
	    /**
	     * Accessor for the navigation
	     * @returns {*}
	     */
	    service.getNavigation = function () {
	      return deferred.promise;
	    };
	
	    return service;
	  }];
	};

/***/ })
/******/ ]);
//# sourceMappingURL=fis-core-components.js.map